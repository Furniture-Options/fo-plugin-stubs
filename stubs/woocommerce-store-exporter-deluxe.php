<?php

namespace {
    class WOO_CD_Archives_List_Table extends \WP_List_Table
    {
        function __construct()
        {
        }
        function get_columns()
        {
        }
        function column_cb($item)
        {
        }
        function column_filename($item)
        {
        }
        function column_type($item)
        {
        }
        function column_format($item)
        {
        }
        function column_filesize($item)
        {
        }
        function column_rows($item)
        {
        }
        function column_columns($item)
        {
        }
        function column_author($item)
        {
        }
        function column_process_time($item)
        {
        }
        function column_idle_memory_end($item)
        {
        }
        function column_date($item)
        {
        }
        function get_sortable_columns()
        {
        }
        function get_bulk_actions()
        {
        }
        function process_bulk_action()
        {
        }
        function prepare_items()
        {
        }
    }
    class SED_SimpleXMLElement extends \SimpleXMLElement
    {
        public function addCData($string)
        {
        }
    }
    /**
     * Manage Quick Exports and Scheduled Exports within WooCommerce - Store Exporter Deluxe.
     *
     * @package woo_cd
     * @subpackage commands/community
     * @maintainer Visser Labs
     */
    class Store_Export_Command extends \WP_CLI_Command
    {
        /**
         * List Scheduled Exports.
         *
         * ## OPTIONS
         *
         * [--export_type=<type>]
         * : Accepted values: product, category, tag, order, user, etc. Default: all
         *
         * [--export_format=<format>]
         * : Accepted values: csv, tsv, xls, xlsx, xml, rss, json. Default: all
         *
         * [--export_method=<method>]
         * : Accepted values: archive, save, email, post, ftp, raw. Default: all
         *
         * ## EXAMPLES
         *
         *     wp store-export list --export_format=csv
         *     wp store-export list --export_format=csv --export_type=product
         *     wp store-export list --export_format=csv --export_type=product --export_method=email
         *
         * @subcommand list
         */
        function _list($args, $assoc_args)
        {
        }
        /**
         * Manually execute a Scheduled Export.
         *
         * ## OPTIONS
         *
         * [--scheduled_id=<post_id>]
         * : Accepted values: post_id. Default: empty
         *
         * ## EXAMPLES
         *
         *     wp store-export scheduled_export --scheduled_id=1000
         *
         * @subcommand scheduled_export
         */
        function scheduled_export($args, $assoc_args)
        {
        }
        /**
         * Manually execute a Quick Export.
         *
         * ## OPTIONS
         *
         * [--export_type=<type>]
         * : Accepted values: product, category, tag, order, user, etc. Default: all
         *
         * [--export_format=<type>]
         * : Accepted values: csv, tsv, xls, xlsx, xml, rss, json. Default: csv
         *
         * ## EXAMPLES
         *
         *     wp store-export quick_export
         *     wp store-export quick_export --export_type=product
         *
         * @subcommand quick_export
         */
        function quick_export($args, $assoc_args)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category	PHPExcel
     * @package		PHPExcel_Chart
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license		http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version		1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Chart
     *
     * @category	PHPExcel
     * @package		PHPExcel_Chart
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Chart
    {
        /**
         * Chart Name
         *
         * @var string
         */
        private $_name = '';
        /**
         * Worksheet
         *
         * @var PHPExcel_Worksheet
         */
        private $_worksheet = \null;
        /**
         * Chart Title
         *
         * @var PHPExcel_Chart_Title
         */
        private $_title = \null;
        /**
         * Chart Legend
         *
         * @var PHPExcel_Chart_Legend
         */
        private $_legend = \null;
        /**
         * X-Axis Label
         *
         * @var PHPExcel_Chart_Title
         */
        private $_xAxisLabel = \null;
        /**
         * Y-Axis Label
         *
         * @var PHPExcel_Chart_Title
         */
        private $_yAxisLabel = \null;
        /**
         * Chart Plot Area
         *
         * @var PHPExcel_Chart_PlotArea
         */
        private $_plotArea = \null;
        /**
         * Plot Visible Only
         *
         * @var boolean
         */
        private $_plotVisibleOnly = \true;
        /**
         * Display Blanks as
         *
         * @var string
         */
        private $_displayBlanksAs = '0';
        /**
         * Top-Left Cell Position
         *
         * @var string
         */
        private $_topLeftCellRef = 'A1';
        /**
         * Top-Left X-Offset
         *
         * @var integer
         */
        private $_topLeftXOffset = 0;
        /**
         * Top-Left Y-Offset
         *
         * @var integer
         */
        private $_topLeftYOffset = 0;
        /**
         * Bottom-Right Cell Position
         *
         * @var string
         */
        private $_bottomRightCellRef = 'A1';
        /**
         * Bottom-Right X-Offset
         *
         * @var integer
         */
        private $_bottomRightXOffset = 10;
        /**
         * Bottom-Right Y-Offset
         *
         * @var integer
         */
        private $_bottomRightYOffset = 10;
        /**
         * Create a new PHPExcel_Chart
         */
        public function __construct($name, \PHPExcel_Chart_Title $title = \null, \PHPExcel_Chart_Legend $legend = \null, \PHPExcel_Chart_PlotArea $plotArea = \null, $plotVisibleOnly = \true, $displayBlanksAs = '0', \PHPExcel_Chart_Title $xAxisLabel = \null, \PHPExcel_Chart_Title $yAxisLabel = \null)
        {
        }
        /**
         * Get Name
         *
         * @return string
         */
        public function getName()
        {
        }
        /**
         * Get Worksheet
         *
         * @return PHPExcel_Worksheet
         */
        public function getWorksheet()
        {
        }
        /**
         * Set Worksheet
         *
         * @param	PHPExcel_Worksheet	$pValue
         * @throws	PHPExcel_Chart_Exception
         * @return PHPExcel_Chart
         */
        public function setWorksheet(\PHPExcel_Worksheet $pValue = \null)
        {
        }
        /**
         * Get Title
         *
         * @return PHPExcel_Chart_Title
         */
        public function getTitle()
        {
        }
        /**
         * Set Title
         *
         * @param	PHPExcel_Chart_Title $title
         * @return	PHPExcel_Chart
         */
        public function setTitle(\PHPExcel_Chart_Title $title)
        {
        }
        /**
         * Get Legend
         *
         * @return PHPExcel_Chart_Legend
         */
        public function getLegend()
        {
        }
        /**
         * Set Legend
         *
         * @param	PHPExcel_Chart_Legend $legend
         * @return	PHPExcel_Chart
         */
        public function setLegend(\PHPExcel_Chart_Legend $legend)
        {
        }
        /**
         * Get X-Axis Label
         *
         * @return PHPExcel_Chart_Title
         */
        public function getXAxisLabel()
        {
        }
        /**
         * Set X-Axis Label
         *
         * @param	PHPExcel_Chart_Title $label
         * @return	PHPExcel_Chart
         */
        public function setXAxisLabel(\PHPExcel_Chart_Title $label)
        {
        }
        /**
         * Get Y-Axis Label
         *
         * @return PHPExcel_Chart_Title
         */
        public function getYAxisLabel()
        {
        }
        /**
         * Set Y-Axis Label
         *
         * @param	PHPExcel_Chart_Title $label
         * @return	PHPExcel_Chart
         */
        public function setYAxisLabel(\PHPExcel_Chart_Title $label)
        {
        }
        /**
         * Get Plot Area
         *
         * @return PHPExcel_Chart_PlotArea
         */
        public function getPlotArea()
        {
        }
        /**
         * Get Plot Visible Only
         *
         * @return boolean
         */
        public function getPlotVisibleOnly()
        {
        }
        /**
         * Set Plot Visible Only
         *
         * @param boolean $plotVisibleOnly
         * @return PHPExcel_Chart
         */
        public function setPlotVisibleOnly($plotVisibleOnly = \true)
        {
        }
        /**
         * Get Display Blanks as
         *
         * @return string
         */
        public function getDisplayBlanksAs()
        {
        }
        /**
         * Set Display Blanks as
         *
         * @param string $displayBlanksAs
         * @return PHPExcel_Chart
         */
        public function setDisplayBlanksAs($displayBlanksAs = '0')
        {
        }
        /**
         * Set the Top Left position for the chart
         *
         * @param	string	$cell
         * @param	integer	$xOffset
         * @param	integer	$yOffset
         * @return PHPExcel_Chart
         */
        public function setTopLeftPosition($cell, $xOffset = \null, $yOffset = \null)
        {
        }
        /**
         * Get the top left position of the chart
         *
         * @return array	an associative array containing the cell address, X-Offset and Y-Offset from the top left of that cell
         */
        public function getTopLeftPosition()
        {
        }
        /**
         * Get the cell address where the top left of the chart is fixed
         *
         * @return string
         */
        public function getTopLeftCell()
        {
        }
        /**
         * Set the Top Left cell position for the chart
         *
         * @param	string	$cell
         * @return PHPExcel_Chart
         */
        public function setTopLeftCell($cell)
        {
        }
        /**
         * Set the offset position within the Top Left cell for the chart
         *
         * @param	integer	$xOffset
         * @param	integer	$yOffset
         * @return PHPExcel_Chart
         */
        public function setTopLeftOffset($xOffset = \null, $yOffset = \null)
        {
        }
        /**
         * Get the offset position within the Top Left cell for the chart
         *
         * @return integer[]
         */
        public function getTopLeftOffset()
        {
        }
        public function setTopLeftXOffset($xOffset)
        {
        }
        public function getTopLeftXOffset()
        {
        }
        public function setTopLeftYOffset($yOffset)
        {
        }
        public function getTopLeftYOffset()
        {
        }
        /**
         * Set the Bottom Right position of the chart
         *
         * @param	string	$cell
         * @param	integer	$xOffset
         * @param	integer	$yOffset
         * @return PHPExcel_Chart
         */
        public function setBottomRightPosition($cell, $xOffset = \null, $yOffset = \null)
        {
        }
        /**
         * Get the bottom right position of the chart
         *
         * @return array	an associative array containing the cell address, X-Offset and Y-Offset from the top left of that cell
         */
        public function getBottomRightPosition()
        {
        }
        public function setBottomRightCell($cell)
        {
        }
        /**
         * Get the cell address where the bottom right of the chart is fixed
         *
         * @return string
         */
        public function getBottomRightCell()
        {
        }
        /**
         * Set the offset position within the Bottom Right cell for the chart
         *
         * @param	integer	$xOffset
         * @param	integer	$yOffset
         * @return PHPExcel_Chart
         */
        public function setBottomRightOffset($xOffset = \null, $yOffset = \null)
        {
        }
        /**
         * Get the offset position within the Bottom Right cell for the chart
         *
         * @return integer[]
         */
        public function getBottomRightOffset()
        {
        }
        public function setBottomRightXOffset($xOffset)
        {
        }
        public function getBottomRightXOffset()
        {
        }
        public function setBottomRightYOffset($yOffset)
        {
        }
        public function getBottomRightYOffset()
        {
        }
        public function refresh()
        {
        }
        public function render($outputDestination = \null)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_CachedObjectStorage
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_CachedObjectStorage_ICache
     *
     * @category   PHPExcel
     * @package    PHPExcel_CachedObjectStorage
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    interface PHPExcel_CachedObjectStorage_ICache
    {
        /**
         * Add or Update a cell in cache identified by coordinate address
         *
         * @param	string			$pCoord		Coordinate address of the cell to update
         * @param	PHPExcel_Cell	$cell		Cell to update
         * @return	void
         * @throws	PHPExcel_Exception
         */
        public function addCacheData($pCoord, \PHPExcel_Cell $cell);
        /**
         * Add or Update a cell in cache
         *
         * @param	PHPExcel_Cell	$cell		Cell to update
         * @return	void
         * @throws	PHPExcel_Exception
         */
        public function updateCacheData(\PHPExcel_Cell $cell);
        /**
         * Fetch a cell from cache identified by coordinate address
         *
         * @param	string			$pCoord		Coordinate address of the cell to retrieve
         * @return PHPExcel_Cell 	Cell that was found, or null if not found
         * @throws	PHPExcel_Exception
         */
        public function getCacheData($pCoord);
        /**
         * Delete a cell in cache identified by coordinate address
         *
         * @param	string			$pCoord		Coordinate address of the cell to delete
         * @throws	PHPExcel_Exception
         */
        public function deleteCacheData($pCoord);
        /**
         * Is a value set in the current PHPExcel_CachedObjectStorage_ICache for an indexed cell?
         *
         * @param	string		$pCoord		Coordinate address of the cell to check
         * @return	boolean
         */
        public function isDataSet($pCoord);
        /**
         * Get a list of all cell addresses currently held in cache
         *
         * @return	array of string
         */
        public function getCellList();
        /**
         * Get the list of all cell addresses currently held in cache sorted by column and row
         *
         * @return	void
         */
        public function getSortedCellList();
        /**
         * Clone the cell collection
         *
         * @param	PHPExcel_Worksheet	$parent		The new worksheet
         * @return	void
         */
        public function copyCellCollection(\PHPExcel_Worksheet $parent);
        /**
         * Identify whether the caching method is currently available
         * Some methods are dependent on the availability of certain extensions being enabled in the PHP build
         *
         * @return	boolean
         */
        public static function cacheMethodIsAvailable();
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_CachedObjectStorage
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_CachedObjectStorage_CacheBase
     *
     * @category   PHPExcel
     * @package    PHPExcel_CachedObjectStorage
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    abstract class PHPExcel_CachedObjectStorage_CacheBase
    {
        /**
         * Parent worksheet
         *
         * @var PHPExcel_Worksheet
         */
        protected $_parent;
        /**
         * The currently active Cell
         *
         * @var PHPExcel_Cell
         */
        protected $_currentObject = \null;
        /**
         * Coordinate address of the currently active Cell
         *
         * @var string
         */
        protected $_currentObjectID = \null;
        /**
         * Flag indicating whether the currently active Cell requires saving
         *
         * @var boolean
         */
        protected $_currentCellIsDirty = \true;
        /**
         * An array of cells or cell pointers for the worksheet cells held in this cache,
         *		and indexed by their coordinate address within the worksheet
         *
         * @var array of mixed
         */
        protected $_cellCache = array();
        /**
         * Initialise this new cell collection
         *
         * @param	PHPExcel_Worksheet	$parent		The worksheet for this cell collection
         */
        public function __construct(\PHPExcel_Worksheet $parent)
        {
        }
        //	function __construct()
        /**
         * Return the parent worksheet for this cell collection
         *
         * @return	PHPExcel_Worksheet
         */
        public function getParent()
        {
        }
        /**
         * Is a value set in the current PHPExcel_CachedObjectStorage_ICache for an indexed cell?
         *
         * @param	string		$pCoord		Coordinate address of the cell to check
         * @return	boolean
         */
        public function isDataSet($pCoord)
        {
        }
        //	function isDataSet()
        /**
         * Move a cell object from one address to another
         *
         * @param	string		$fromAddress	Current address of the cell to move
         * @param	string		$toAddress		Destination address of the cell to move
         * @return	boolean
         */
        public function moveCell($fromAddress, $toAddress)
        {
        }
        //	function moveCell()
        /**
         * Add or Update a cell in cache
         *
         * @param	PHPExcel_Cell	$cell		Cell to update
         * @return	void
         * @throws	PHPExcel_Exception
         */
        public function updateCacheData(\PHPExcel_Cell $cell)
        {
        }
        //	function updateCacheData()
        /**
         * Delete a cell in cache identified by coordinate address
         *
         * @param	string			$pCoord		Coordinate address of the cell to delete
         * @throws	PHPExcel_Exception
         */
        public function deleteCacheData($pCoord)
        {
        }
        //	function deleteCacheData()
        /**
         * Get a list of all cell addresses currently held in cache
         *
         * @return	array of string
         */
        public function getCellList()
        {
        }
        //	function getCellList()
        /**
         * Sort the list of all cell addresses currently held in cache by row and column
         *
         * @return	void
         */
        public function getSortedCellList()
        {
        }
        //	function sortCellList()
        /**
         * Get highest worksheet column and highest row that have cell records
         *
         * @return array Highest column name and highest row number
         */
        public function getHighestRowAndColumn()
        {
        }
        /**
         * Return the cell address of the currently active cell object
         *
         * @return	string
         */
        public function getCurrentAddress()
        {
        }
        /**
         * Return the column address of the currently active cell object
         *
         * @return	string
         */
        public function getCurrentColumn()
        {
        }
        /**
         * Return the row address of the currently active cell object
         *
         * @return	string
         */
        public function getCurrentRow()
        {
        }
        /**
         * Get highest worksheet column
         *
         * @param   string     $row        Return the highest column for the specified row,
         *                                     or the highest column of any row if no row number is passed
         * @return  string     Highest column name
         */
        public function getHighestColumn($row = \null)
        {
        }
        /**
         * Get highest worksheet row
         *
         * @param   string     $column     Return the highest row for the specified column,
         *                                     or the highest row of any column if no column letter is passed
         * @return  int        Highest row number
         */
        public function getHighestRow($column = \null)
        {
        }
        /**
         * Generate a unique ID for cache referencing
         *
         * @return string Unique Reference
         */
        protected function _getUniqueID()
        {
        }
        /**
         * Clone the cell collection
         *
         * @param	PHPExcel_Worksheet	$parent		The new worksheet
         * @return	void
         */
        public function copyCellCollection(\PHPExcel_Worksheet $parent)
        {
        }
        //	function copyCellCollection()
        /**
         * Identify whether the caching method is currently available
         * Some methods are dependent on the availability of certain extensions being enabled in the PHP build
         *
         * @return	boolean
         */
        public static function cacheMethodIsAvailable()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_CachedObjectStorage
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_CachedObjectStorage_Memory
     *
     * @category   PHPExcel
     * @package    PHPExcel_CachedObjectStorage
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_CachedObjectStorage_Memory extends \PHPExcel_CachedObjectStorage_CacheBase implements \PHPExcel_CachedObjectStorage_ICache
    {
        /**
         * Dummy method callable from CacheBase, but unused by Memory cache
         *
         * @return	void
         */
        protected function _storeData()
        {
        }
        //	function _storeData()
        /**
         * Add or Update a cell in cache identified by coordinate address
         *
         * @param	string			$pCoord		Coordinate address of the cell to update
         * @param	PHPExcel_Cell	$cell		Cell to update
         * @return	PHPExcel_Cell
         * @throws	PHPExcel_Exception
         */
        public function addCacheData($pCoord, \PHPExcel_Cell $cell)
        {
        }
        //	function addCacheData()
        /**
         * Get cell at a specific coordinate
         *
         * @param 	string 			$pCoord		Coordinate of the cell
         * @throws 	PHPExcel_Exception
         * @return 	PHPExcel_Cell 	Cell that was found, or null if not found
         */
        public function getCacheData($pCoord)
        {
        }
        //	function getCacheData()
        /**
         * Clone the cell collection
         *
         * @param	PHPExcel_Worksheet	$parent		The new worksheet
         * @return	void
         */
        public function copyCellCollection(\PHPExcel_Worksheet $parent)
        {
        }
        /**
         * Clear the cell collection and disconnect from our parent
         *
         * @return	void
         */
        public function unsetWorksheetCells()
        {
        }
        //	function unsetWorksheetCells()
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_CachedObjectStorage
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_CachedObjectStorage_SQLite
     *
     * @category   PHPExcel
     * @package    PHPExcel_CachedObjectStorage
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_CachedObjectStorage_SQLite extends \PHPExcel_CachedObjectStorage_CacheBase implements \PHPExcel_CachedObjectStorage_ICache
    {
        /**
         * Database table name
         *
         * @var string
         */
        private $_TableName = \null;
        /**
         * Database handle
         *
         * @var resource
         */
        private $_DBHandle = \null;
        /**
         * Store cell data in cache for the current cell object if it's "dirty",
         *     and the 'nullify' the current cell object
         *
         * @return	void
         * @throws	PHPExcel_Exception
         */
        protected function _storeData()
        {
        }
        //	function _storeData()
        /**
         * Add or Update a cell in cache identified by coordinate address
         *
         * @param	string			$pCoord		Coordinate address of the cell to update
         * @param	PHPExcel_Cell	$cell		Cell to update
         * @return	void
         * @throws	PHPExcel_Exception
         */
        public function addCacheData($pCoord, \PHPExcel_Cell $cell)
        {
        }
        //	function addCacheData()
        /**
         * Get cell at a specific coordinate
         *
         * @param 	string 			$pCoord		Coordinate of the cell
         * @throws 	PHPExcel_Exception
         * @return 	PHPExcel_Cell 	Cell that was found, or null if not found
         */
        public function getCacheData($pCoord)
        {
        }
        //	function getCacheData()
        /**
         * Is a value set for an indexed cell?
         *
         * @param	string		$pCoord		Coordinate address of the cell to check
         * @return	boolean
         */
        public function isDataSet($pCoord)
        {
        }
        //	function isDataSet()
        /**
         * Delete a cell in cache identified by coordinate address
         *
         * @param	string			$pCoord		Coordinate address of the cell to delete
         * @throws	PHPExcel_Exception
         */
        public function deleteCacheData($pCoord)
        {
        }
        //	function deleteCacheData()
        /**
         * Move a cell object from one address to another
         *
         * @param	string		$fromAddress	Current address of the cell to move
         * @param	string		$toAddress		Destination address of the cell to move
         * @return	boolean
         */
        public function moveCell($fromAddress, $toAddress)
        {
        }
        //	function moveCell()
        /**
         * Get a list of all cell addresses currently held in cache
         *
         * @return	array of string
         */
        public function getCellList()
        {
        }
        //	function getCellList()
        /**
         * Clone the cell collection
         *
         * @param	PHPExcel_Worksheet	$parent		The new worksheet
         * @return	void
         */
        public function copyCellCollection(\PHPExcel_Worksheet $parent)
        {
        }
        //	function copyCellCollection()
        /**
         * Clear the cell collection and disconnect from our parent
         *
         * @return	void
         */
        public function unsetWorksheetCells()
        {
        }
        //	function unsetWorksheetCells()
        /**
         * Initialise this new cell collection
         *
         * @param	PHPExcel_Worksheet	$parent		The worksheet for this cell collection
         */
        public function __construct(\PHPExcel_Worksheet $parent)
        {
        }
        //	function __construct()
        /**
         * Destroy this cell collection
         */
        public function __destruct()
        {
        }
        //	function __destruct()
        /**
         * Identify whether the caching method is currently available
         * Some methods are dependent on the availability of certain extensions being enabled in the PHP build
         *
         * @return	boolean
         */
        public static function cacheMethodIsAvailable()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package	PHPExcel_CachedObjectStorage
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license	http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version	1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_CachedObjectStorage_Wincache
     *
     * @category   PHPExcel
     * @package	PHPExcel_CachedObjectStorage
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_CachedObjectStorage_Wincache extends \PHPExcel_CachedObjectStorage_CacheBase implements \PHPExcel_CachedObjectStorage_ICache
    {
        /**
         * Prefix used to uniquely identify cache data for this worksheet
         *
         * @var string
         */
        private $_cachePrefix = \null;
        /**
         * Cache timeout
         *
         * @var integer
         */
        private $_cacheTime = 600;
        /**
         * Store cell data in cache for the current cell object if it's "dirty",
         *     and the 'nullify' the current cell object
         *
         * @return	void
         * @throws	PHPExcel_Exception
         */
        protected function _storeData()
        {
        }
        //	function _storeData()
        /**
         * Add or Update a cell in cache identified by coordinate address
         *
         * @param	string			$pCoord		Coordinate address of the cell to update
         * @param	PHPExcel_Cell	$cell		Cell to update
         * @return	void
         * @throws	PHPExcel_Exception
         */
        public function addCacheData($pCoord, \PHPExcel_Cell $cell)
        {
        }
        //	function addCacheData()
        /**
         * Is a value set in the current PHPExcel_CachedObjectStorage_ICache for an indexed cell?
         *
         * @param	string		$pCoord		Coordinate address of the cell to check
         * @return	boolean
         */
        public function isDataSet($pCoord)
        {
        }
        //	function isDataSet()
        /**
         * Get cell at a specific coordinate
         *
         * @param	string			$pCoord		Coordinate of the cell
         * @throws	PHPExcel_Exception
         * @return	PHPExcel_Cell	Cell that was found, or null if not found
         */
        public function getCacheData($pCoord)
        {
        }
        //	function getCacheData()
        /**
         * Get a list of all cell addresses currently held in cache
         *
         * @return  array of string
         */
        public function getCellList()
        {
        }
        /**
         * Delete a cell in cache identified by coordinate address
         *
         * @param	string			$pCoord		Coordinate address of the cell to delete
         * @throws	PHPExcel_Exception
         */
        public function deleteCacheData($pCoord)
        {
        }
        //	function deleteCacheData()
        /**
         * Clone the cell collection
         *
         * @param	PHPExcel_Worksheet	$parent		The new worksheet
         * @return	void
         */
        public function copyCellCollection(\PHPExcel_Worksheet $parent)
        {
        }
        //	function copyCellCollection()
        /**
         * Clear the cell collection and disconnect from our parent
         *
         * @return	void
         */
        public function unsetWorksheetCells()
        {
        }
        //	function unsetWorksheetCells()
        /**
         * Initialise this new cell collection
         *
         * @param	PHPExcel_Worksheet	$parent		The worksheet for this cell collection
         * @param	array of mixed		$arguments	Additional initialisation arguments
         */
        public function __construct(\PHPExcel_Worksheet $parent, $arguments)
        {
        }
        //	function __construct()
        /**
         * Destroy this cell collection
         */
        public function __destruct()
        {
        }
        //	function __destruct()
        /**
         * Identify whether the caching method is currently available
         * Some methods are dependent on the availability of certain extensions being enabled in the PHP build
         *
         * @return	boolean
         */
        public static function cacheMethodIsAvailable()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_CachedObjectStorage
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_CachedObjectStorage_MemorySerialized
     *
     * @category   PHPExcel
     * @package    PHPExcel_CachedObjectStorage
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_CachedObjectStorage_MemorySerialized extends \PHPExcel_CachedObjectStorage_CacheBase implements \PHPExcel_CachedObjectStorage_ICache
    {
        /**
         * Store cell data in cache for the current cell object if it's "dirty",
         *     and the 'nullify' the current cell object
         *
         * @return	void
         * @throws	PHPExcel_Exception
         */
        protected function _storeData()
        {
        }
        //	function _storeData()
        /**
         * Add or Update a cell in cache identified by coordinate address
         *
         * @param	string			$pCoord		Coordinate address of the cell to update
         * @param	PHPExcel_Cell	$cell		Cell to update
         * @return	void
         * @throws	PHPExcel_Exception
         */
        public function addCacheData($pCoord, \PHPExcel_Cell $cell)
        {
        }
        //	function addCacheData()
        /**
         * Get cell at a specific coordinate
         *
         * @param 	string 			$pCoord		Coordinate of the cell
         * @throws 	PHPExcel_Exception
         * @return 	PHPExcel_Cell 	Cell that was found, or null if not found
         */
        public function getCacheData($pCoord)
        {
        }
        //	function getCacheData()
        /**
         * Get a list of all cell addresses currently held in cache
         *
         * @return  array of string
         */
        public function getCellList()
        {
        }
        /**
         * Clear the cell collection and disconnect from our parent
         *
         * @return	void
         */
        public function unsetWorksheetCells()
        {
        }
        //	function unsetWorksheetCells()
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_CachedObjectStorage
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_CachedObjectStorage_SQLite3
     *
     * @category   PHPExcel
     * @package    PHPExcel_CachedObjectStorage
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_CachedObjectStorage_SQLite3 extends \PHPExcel_CachedObjectStorage_CacheBase implements \PHPExcel_CachedObjectStorage_ICache
    {
        /**
         * Database table name
         *
         * @var string
         */
        private $_TableName = \null;
        /**
         * Database handle
         *
         * @var resource
         */
        private $_DBHandle = \null;
        /**
         * Prepared statement for a SQLite3 select query
         *
         * @var SQLite3Stmt
         */
        private $_selectQuery;
        /**
         * Prepared statement for a SQLite3 insert query
         *
         * @var SQLite3Stmt
         */
        private $_insertQuery;
        /**
         * Prepared statement for a SQLite3 update query
         *
         * @var SQLite3Stmt
         */
        private $_updateQuery;
        /**
         * Prepared statement for a SQLite3 delete query
         *
         * @var SQLite3Stmt
         */
        private $_deleteQuery;
        /**
         * Store cell data in cache for the current cell object if it's "dirty",
         *     and the 'nullify' the current cell object
         *
         * @return	void
         * @throws	PHPExcel_Exception
         */
        protected function _storeData()
        {
        }
        //	function _storeData()
        /**
         * Add or Update a cell in cache identified by coordinate address
         *
         * @param	string			$pCoord		Coordinate address of the cell to update
         * @param	PHPExcel_Cell	$cell		Cell to update
         * @return	void
         * @throws	PHPExcel_Exception
         */
        public function addCacheData($pCoord, \PHPExcel_Cell $cell)
        {
        }
        //	function addCacheData()
        /**
         * Get cell at a specific coordinate
         *
         * @param 	string 			$pCoord		Coordinate of the cell
         * @throws 	PHPExcel_Exception
         * @return 	PHPExcel_Cell 	Cell that was found, or null if not found
         */
        public function getCacheData($pCoord)
        {
        }
        //	function getCacheData()
        /**
         *	Is a value set for an indexed cell?
         *
         * @param	string		$pCoord		Coordinate address of the cell to check
         * @return	boolean
         */
        public function isDataSet($pCoord)
        {
        }
        //	function isDataSet()
        /**
         *	Delete a cell in cache identified by coordinate address
         *
         * @param	string			$pCoord		Coordinate address of the cell to delete
         * @throws	PHPExcel_Exception
         */
        public function deleteCacheData($pCoord)
        {
        }
        //	function deleteCacheData()
        /**
         * Move a cell object from one address to another
         *
         * @param	string		$fromAddress	Current address of the cell to move
         * @param	string		$toAddress		Destination address of the cell to move
         * @return	boolean
         */
        public function moveCell($fromAddress, $toAddress)
        {
        }
        //	function moveCell()
        /**
         * Get a list of all cell addresses currently held in cache
         *
         * @return	array of string
         */
        public function getCellList()
        {
        }
        //	function getCellList()
        /**
         * Clone the cell collection
         *
         * @param	PHPExcel_Worksheet	$parent		The new worksheet
         * @return	void
         */
        public function copyCellCollection(\PHPExcel_Worksheet $parent)
        {
        }
        //	function copyCellCollection()
        /**
         * Clear the cell collection and disconnect from our parent
         *
         * @return	void
         */
        public function unsetWorksheetCells()
        {
        }
        //	function unsetWorksheetCells()
        /**
         * Initialise this new cell collection
         *
         * @param	PHPExcel_Worksheet	$parent		The worksheet for this cell collection
         */
        public function __construct(\PHPExcel_Worksheet $parent)
        {
        }
        //	function __construct()
        /**
         * Destroy this cell collection
         */
        public function __destruct()
        {
        }
        //	function __destruct()
        /**
         * Identify whether the caching method is currently available
         * Some methods are dependent on the availability of certain extensions being enabled in the PHP build
         *
         * @return	boolean
         */
        public static function cacheMethodIsAvailable()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_CachedObjectStorage
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_CachedObjectStorage_DiscISAM
     *
     * @category   PHPExcel
     * @package    PHPExcel_CachedObjectStorage
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_CachedObjectStorage_DiscISAM extends \PHPExcel_CachedObjectStorage_CacheBase implements \PHPExcel_CachedObjectStorage_ICache
    {
        /**
         * Name of the file for this cache
         *
         * @var string
         */
        private $_fileName = \NULL;
        /**
         * File handle for this cache file
         *
         * @var resource
         */
        private $_fileHandle = \NULL;
        /**
         * Directory/Folder where the cache file is located
         *
         * @var string
         */
        private $_cacheDirectory = \NULL;
        /**
         * Store cell data in cache for the current cell object if it's "dirty",
         *     and the 'nullify' the current cell object
         *
         * @return	void
         * @throws	PHPExcel_Exception
         */
        protected function _storeData()
        {
        }
        //	function _storeData()
        /**
         * Add or Update a cell in cache identified by coordinate address
         *
         * @param	string			$pCoord		Coordinate address of the cell to update
         * @param	PHPExcel_Cell	$cell		Cell to update
         * @return	void
         * @throws	PHPExcel_Exception
         */
        public function addCacheData($pCoord, \PHPExcel_Cell $cell)
        {
        }
        //	function addCacheData()
        /**
         * Get cell at a specific coordinate
         *
         * @param 	string 			$pCoord		Coordinate of the cell
         * @throws 	PHPExcel_Exception
         * @return 	PHPExcel_Cell 	Cell that was found, or null if not found
         */
        public function getCacheData($pCoord)
        {
        }
        //	function getCacheData()
        /**
         * Get a list of all cell addresses currently held in cache
         *
         * @return  array of string
         */
        public function getCellList()
        {
        }
        /**
         * Clone the cell collection
         *
         * @param	PHPExcel_Worksheet	$parent		The new worksheet
         * @return	void
         */
        public function copyCellCollection(\PHPExcel_Worksheet $parent)
        {
        }
        //	function copyCellCollection()
        /**
         * Clear the cell collection and disconnect from our parent
         *
         * @return	void
         */
        public function unsetWorksheetCells()
        {
        }
        //	function unsetWorksheetCells()
        /**
         * Initialise this new cell collection
         *
         * @param	PHPExcel_Worksheet	$parent		The worksheet for this cell collection
         * @param	array of mixed		$arguments	Additional initialisation arguments
         */
        public function __construct(\PHPExcel_Worksheet $parent, $arguments)
        {
        }
        //	function __construct()
        /**
         * Destroy this cell collection
         */
        public function __destruct()
        {
        }
        //	function __destruct()
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_CachedObjectStorage
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_CachedObjectStorage_MemoryGZip
     *
     * @category   PHPExcel
     * @package    PHPExcel_CachedObjectStorage
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_CachedObjectStorage_MemoryGZip extends \PHPExcel_CachedObjectStorage_CacheBase implements \PHPExcel_CachedObjectStorage_ICache
    {
        /**
         * Store cell data in cache for the current cell object if it's "dirty",
         *     and the 'nullify' the current cell object
         *
         * @return	void
         * @throws	PHPExcel_Exception
         */
        protected function _storeData()
        {
        }
        //	function _storeData()
        /**
         * Add or Update a cell in cache identified by coordinate address
         *
         * @param	string			$pCoord		Coordinate address of the cell to update
         * @param	PHPExcel_Cell	$cell		Cell to update
         * @return	void
         * @throws	PHPExcel_Exception
         */
        public function addCacheData($pCoord, \PHPExcel_Cell $cell)
        {
        }
        //	function addCacheData()
        /**
         * Get cell at a specific coordinate
         *
         * @param 	string 			$pCoord		Coordinate of the cell
         * @throws 	PHPExcel_Exception
         * @return 	PHPExcel_Cell 	Cell that was found, or null if not found
         */
        public function getCacheData($pCoord)
        {
        }
        //	function getCacheData()
        /**
         * Get a list of all cell addresses currently held in cache
         *
         * @return  array of string
         */
        public function getCellList()
        {
        }
        /**
         * Clear the cell collection and disconnect from our parent
         *
         * @return	void
         */
        public function unsetWorksheetCells()
        {
        }
        //	function unsetWorksheetCells()
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_CachedObjectStorage
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_CachedObjectStorage_Memcache
     *
     * @category   PHPExcel
     * @package    PHPExcel_CachedObjectStorage
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_CachedObjectStorage_Memcache extends \PHPExcel_CachedObjectStorage_CacheBase implements \PHPExcel_CachedObjectStorage_ICache
    {
        /**
         * Prefix used to uniquely identify cache data for this worksheet
         *
         * @var string
         */
        private $_cachePrefix = \null;
        /**
         * Cache timeout
         *
         * @var integer
         */
        private $_cacheTime = 600;
        /**
         * Memcache interface
         *
         * @var resource
         */
        private $_memcache = \null;
        /**
         * Store cell data in cache for the current cell object if it's "dirty",
         *     and the 'nullify' the current cell object
         *
         * @return	void
         * @throws	PHPExcel_Exception
         */
        protected function _storeData()
        {
        }
        //	function _storeData()
        /**
         * Add or Update a cell in cache identified by coordinate address
         *
         * @param	string			$pCoord		Coordinate address of the cell to update
         * @param	PHPExcel_Cell	$cell		Cell to update
         * @return	void
         * @throws	PHPExcel_Exception
         */
        public function addCacheData($pCoord, \PHPExcel_Cell $cell)
        {
        }
        //	function addCacheData()
        /**
         * Is a value set in the current PHPExcel_CachedObjectStorage_ICache for an indexed cell?
         *
         * @param	string		$pCoord		Coordinate address of the cell to check
         * @return	void
         * @return	boolean
         */
        public function isDataSet($pCoord)
        {
        }
        //	function isDataSet()
        /**
         * Get cell at a specific coordinate
         *
         * @param 	string 			$pCoord		Coordinate of the cell
         * @throws 	PHPExcel_Exception
         * @return 	PHPExcel_Cell 	Cell that was found, or null if not found
         */
        public function getCacheData($pCoord)
        {
        }
        //	function getCacheData()
        /**
         * Get a list of all cell addresses currently held in cache
         *
         * @return  array of string
         */
        public function getCellList()
        {
        }
        /**
         * Delete a cell in cache identified by coordinate address
         *
         * @param	string			$pCoord		Coordinate address of the cell to delete
         * @throws	PHPExcel_Exception
         */
        public function deleteCacheData($pCoord)
        {
        }
        //	function deleteCacheData()
        /**
         * Clone the cell collection
         *
         * @param	PHPExcel_Worksheet	$parent		The new worksheet
         * @return	void
         */
        public function copyCellCollection(\PHPExcel_Worksheet $parent)
        {
        }
        //	function copyCellCollection()
        /**
         * Clear the cell collection and disconnect from our parent
         *
         * @return	void
         */
        public function unsetWorksheetCells()
        {
        }
        //	function unsetWorksheetCells()
        /**
         * Initialise this new cell collection
         *
         * @param	PHPExcel_Worksheet	$parent		The worksheet for this cell collection
         * @param	array of mixed		$arguments	Additional initialisation arguments
         */
        public function __construct(\PHPExcel_Worksheet $parent, $arguments)
        {
        }
        //	function __construct()
        /**
         * Memcache error handler
         *
         * @param	string	$host		Memcache server
         * @param	integer	$port		Memcache port
         * @throws	PHPExcel_Exception
         */
        public function failureCallback($host, $port)
        {
        }
        /**
         * Destroy this cell collection
         */
        public function __destruct()
        {
        }
        //	function __destruct()
        /**
         * Identify whether the caching method is currently available
         * Some methods are dependent on the availability of certain extensions being enabled in the PHP build
         *
         * @return	boolean
         */
        public static function cacheMethodIsAvailable()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_CachedObjectStorage
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_CachedObjectStorage_PHPTemp
     *
     * @category   PHPExcel
     * @package    PHPExcel_CachedObjectStorage
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_CachedObjectStorage_PHPTemp extends \PHPExcel_CachedObjectStorage_CacheBase implements \PHPExcel_CachedObjectStorage_ICache
    {
        /**
         * Name of the file for this cache
         *
         * @var string
         */
        private $_fileHandle = \null;
        /**
         * Memory limit to use before reverting to file cache
         *
         * @var integer
         */
        private $_memoryCacheSize = \null;
        /**
         * Store cell data in cache for the current cell object if it's "dirty",
         *     and the 'nullify' the current cell object
         *
         * @return	void
         * @throws	PHPExcel_Exception
         */
        protected function _storeData()
        {
        }
        //	function _storeData()
        /**
         * Add or Update a cell in cache identified by coordinate address
         *
         * @param	string			$pCoord		Coordinate address of the cell to update
         * @param	PHPExcel_Cell	$cell		Cell to update
         * @return	void
         * @throws	PHPExcel_Exception
         */
        public function addCacheData($pCoord, \PHPExcel_Cell $cell)
        {
        }
        //	function addCacheData()
        /**
         * Get cell at a specific coordinate
         *
         * @param 	string 			$pCoord		Coordinate of the cell
         * @throws 	PHPExcel_Exception
         * @return 	PHPExcel_Cell 	Cell that was found, or null if not found
         */
        public function getCacheData($pCoord)
        {
        }
        //	function getCacheData()
        /**
         * Get a list of all cell addresses currently held in cache
         *
         * @return  array of string
         */
        public function getCellList()
        {
        }
        /**
         * Clone the cell collection
         *
         * @param	PHPExcel_Worksheet	$parent		The new worksheet
         * @return	void
         */
        public function copyCellCollection(\PHPExcel_Worksheet $parent)
        {
        }
        //	function copyCellCollection()
        /**
         * Clear the cell collection and disconnect from our parent
         *
         * @return	void
         */
        public function unsetWorksheetCells()
        {
        }
        //	function unsetWorksheetCells()
        /**
         * Initialise this new cell collection
         *
         * @param	PHPExcel_Worksheet	$parent		The worksheet for this cell collection
         * @param	array of mixed		$arguments	Additional initialisation arguments
         */
        public function __construct(\PHPExcel_Worksheet $parent, $arguments)
        {
        }
        //	function __construct()
        /**
         * Destroy this cell collection
         */
        public function __destruct()
        {
        }
        //	function __destruct()
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_CachedObjectStorage
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt    LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_CachedObjectStorage_APC
     *
     * @category   PHPExcel
     * @package    PHPExcel_CachedObjectStorage
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_CachedObjectStorage_APC extends \PHPExcel_CachedObjectStorage_CacheBase implements \PHPExcel_CachedObjectStorage_ICache
    {
        /**
         * Prefix used to uniquely identify cache data for this worksheet
         *
         * @access    private
         * @var string
         */
        private $_cachePrefix = \null;
        /**
         * Cache timeout
         *
         * @access    private
         * @var integer
         */
        private $_cacheTime = 600;
        /**
         * Store cell data in cache for the current cell object if it's "dirty",
         *     and the 'nullify' the current cell object
         *
         * @access  private
         * @return  void
         * @throws  PHPExcel_Exception
         */
        protected function _storeData()
        {
        }
        //    function _storeData()
        /**
         * Add or Update a cell in cache identified by coordinate address
         *
         * @access  public
         * @param   string         $pCoord  Coordinate address of the cell to update
         * @param   PHPExcel_Cell  $cell    Cell to update
         * @return  void
         * @throws  PHPExcel_Exception
         */
        public function addCacheData($pCoord, \PHPExcel_Cell $cell)
        {
        }
        //    function addCacheData()
        /**
         * Is a value set in the current PHPExcel_CachedObjectStorage_ICache for an indexed cell?
         *
         * @access  public
         * @param   string  $pCoord  Coordinate address of the cell to check
         * @return  void
         * @return  boolean
         */
        public function isDataSet($pCoord)
        {
        }
        //    function isDataSet()
        /**
         * Get cell at a specific coordinate
         *
         * @access  public
         * @param   string         $pCoord  Coordinate of the cell
         * @throws  PHPExcel_Exception
         * @return  PHPExcel_Cell  Cell that was found, or null if not found
         */
        public function getCacheData($pCoord)
        {
        }
        //    function getCacheData()
        /**
         * Get a list of all cell addresses currently held in cache
         *
         * @return  array of string
         */
        public function getCellList()
        {
        }
        /**
         * Delete a cell in cache identified by coordinate address
         *
         * @access  public
         * @param   string  $pCoord  Coordinate address of the cell to delete
         * @throws  PHPExcel_Exception
         */
        public function deleteCacheData($pCoord)
        {
        }
        //    function deleteCacheData()
        /**
         * Clone the cell collection
         *
         * @access  public
         * @param   PHPExcel_Worksheet  $parent  The new worksheet
         * @throws  PHPExcel_Exception
         * @return  void
         */
        public function copyCellCollection(\PHPExcel_Worksheet $parent)
        {
        }
        //    function copyCellCollection()
        /**
         * Clear the cell collection and disconnect from our parent
         *
         * @return  void
         */
        public function unsetWorksheetCells()
        {
        }
        //    function unsetWorksheetCells()
        /**
         * Initialise this new cell collection
         *
         * @param  PHPExcel_Worksheet  $parent     The worksheet for this cell collection
         * @param  array of mixed      $arguments  Additional initialisation arguments
         */
        public function __construct(\PHPExcel_Worksheet $parent, $arguments)
        {
        }
        //    function __construct()
        /**
         * Destroy this cell collection
         */
        public function __destruct()
        {
        }
        //    function __destruct()
        /**
         * Identify whether the caching method is currently available
         * Some methods are dependent on the availability of certain extensions being enabled in the PHP build
         *
         * @return  boolean
         */
        public static function cacheMethodIsAvailable()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_CachedObjectStorage
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_CachedObjectStorage_Igbinary
     *
     * @category   PHPExcel
     * @package    PHPExcel_CachedObjectStorage
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_CachedObjectStorage_Igbinary extends \PHPExcel_CachedObjectStorage_CacheBase implements \PHPExcel_CachedObjectStorage_ICache
    {
        /**
         * Store cell data in cache for the current cell object if it's "dirty",
         *     and the 'nullify' the current cell object
         *
         * @return	void
         * @throws	PHPExcel_Exception
         */
        protected function _storeData()
        {
        }
        //	function _storeData()
        /**
         * Add or Update a cell in cache identified by coordinate address
         *
         * @param	string			$pCoord		Coordinate address of the cell to update
         * @param	PHPExcel_Cell	$cell		Cell to update
         * @return	void
         * @throws	PHPExcel_Exception
         */
        public function addCacheData($pCoord, \PHPExcel_Cell $cell)
        {
        }
        //	function addCacheData()
        /**
         * Get cell at a specific coordinate
         *
         * @param 	string 			$pCoord		Coordinate of the cell
         * @throws 	PHPExcel_Exception
         * @return 	PHPExcel_Cell 	Cell that was found, or null if not found
         */
        public function getCacheData($pCoord)
        {
        }
        //	function getCacheData()
        /**
         * Get a list of all cell addresses currently held in cache
         *
         * @return  array of string
         */
        public function getCellList()
        {
        }
        /**
         * Clear the cell collection and disconnect from our parent
         *
         * @return	void
         */
        public function unsetWorksheetCells()
        {
        }
        //	function unsetWorksheetCells()
        /**
         * Identify whether the caching method is currently available
         * Some methods are dependent on the availability of certain extensions being enabled in the PHP build
         *
         * @return	boolean
         */
        public static function cacheMethodIsAvailable()
        {
        }
    }
    /**
     * PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_IComparable
     *
     * @category   PHPExcel
     * @package    PHPExcel
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    interface PHPExcel_IComparable
    {
        /**
         * Get hash code
         *
         * @return string	Hash code
         */
        public function getHashCode();
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package	PHPExcel_Style
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license	http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version	1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Style_Supervisor
     *
     * @category   PHPExcel
     * @package	PHPExcel_Style
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    abstract class PHPExcel_Style_Supervisor
    {
        /**
         * Supervisor?
         *
         * @var boolean
         */
        protected $_isSupervisor;
        /**
         * Parent. Only used for supervisor
         *
         * @var PHPExcel_Style
         */
        protected $_parent;
        /**
         * Create a new PHPExcel_Style_Alignment
         *
         * @param	boolean	$isSupervisor	Flag indicating if this is a supervisor or not
         *									Leave this value at default unless you understand exactly what
         *										its ramifications are
         */
        public function __construct($isSupervisor = \FALSE)
        {
        }
        /**
         * Bind parent. Only used for supervisor
         *
         * @param PHPExcel $parent
         * @return PHPExcel_Style_Supervisor
         */
        public function bindParent($parent, $parentPropertyName = \NULL)
        {
        }
        /**
         * Is this a supervisor or a cell style component?
         *
         * @return boolean
         */
        public function getIsSupervisor()
        {
        }
        /**
         * Get the currently active sheet. Only used for supervisor
         *
         * @return PHPExcel_Worksheet
         */
        public function getActiveSheet()
        {
        }
        /**
         * Get the currently active cell coordinate in currently active sheet.
         * Only used for supervisor
         *
         * @return string E.g. 'A1'
         */
        public function getSelectedCells()
        {
        }
        /**
         * Get the currently active cell coordinate in currently active sheet.
         * Only used for supervisor
         *
         * @return string E.g. 'A1'
         */
        public function getActiveCell()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Style
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt    LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Style
     *
     * @category   PHPExcel
     * @package    PHPExcel_Style
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Style extends \PHPExcel_Style_Supervisor implements \PHPExcel_IComparable
    {
        /**
         * Font
         *
         * @var PHPExcel_Style_Font
         */
        protected $_font;
        /**
         * Fill
         *
         * @var PHPExcel_Style_Fill
         */
        protected $_fill;
        /**
         * Borders
         *
         * @var PHPExcel_Style_Borders
         */
        protected $_borders;
        /**
         * Alignment
         *
         * @var PHPExcel_Style_Alignment
         */
        protected $_alignment;
        /**
         * Number Format
         *
         * @var PHPExcel_Style_NumberFormat
         */
        protected $_numberFormat;
        /**
         * Conditional styles
         *
         * @var PHPExcel_Style_Conditional[]
         */
        protected $_conditionalStyles;
        /**
         * Protection
         *
         * @var PHPExcel_Style_Protection
         */
        protected $_protection;
        /**
         * Index of style in collection. Only used for real style.
         *
         * @var int
         */
        protected $_index;
        /**
         * Use Quote Prefix when displaying in cell editor. Only used for real style.
         *
         * @var boolean
         */
        protected $_quotePrefix = \false;
        /**
         * Create a new PHPExcel_Style
         *
         * @param boolean $isSupervisor Flag indicating if this is a supervisor or not
         * 		Leave this value at default unless you understand exactly what
         *    its ramifications are
         * @param boolean $isConditional Flag indicating if this is a conditional style or not
         *   	Leave this value at default unless you understand exactly what
         *    its ramifications are
         */
        public function __construct($isSupervisor = \false, $isConditional = \false)
        {
        }
        /**
         * Get the shared style component for the currently active cell in currently active sheet.
         * Only used for style supervisor
         *
         * @return PHPExcel_Style
         */
        public function getSharedComponent()
        {
        }
        /**
         * Get parent. Only used for style supervisor
         *
         * @return PHPExcel
         */
        public function getParent()
        {
        }
        /**
         * Build style array from subcomponents
         *
         * @param array $array
         * @return array
         */
        public function getStyleArray($array)
        {
        }
        /**
         * Apply styles from array
         *
         * <code>
         * $objPHPExcel->getActiveSheet()->getStyle('B2')->applyFromArray(
         *         array(
         *             'font'    => array(
         *                 'name'      => 'Arial',
         *                 'bold'      => true,
         *                 'italic'    => false,
         *                 'underline' => PHPExcel_Style_Font::UNDERLINE_DOUBLE,
         *                 'strike'    => false,
         *                 'color'     => array(
         *                     'rgb' => '808080'
         *                 )
         *             ),
         *             'borders' => array(
         *                 'bottom'     => array(
         *                     'style' => PHPExcel_Style_Border::BORDER_DASHDOT,
         *                     'color' => array(
         *                         'rgb' => '808080'
         *                     )
         *                 ),
         *                 'top'     => array(
         *                     'style' => PHPExcel_Style_Border::BORDER_DASHDOT,
         *                     'color' => array(
         *                         'rgb' => '808080'
         *                     )
         *                 )
         *             ),
         *             'quotePrefix'    => true
         *         )
         * );
         * </code>
         *
         * @param    array    $pStyles    Array containing style information
         * @param     boolean        $pAdvanced    Advanced mode for setting borders.
         * @throws    PHPExcel_Exception
         * @return PHPExcel_Style
         */
        public function applyFromArray($pStyles = \null, $pAdvanced = \true)
        {
        }
        /**
         * Get Fill
         *
         * @return PHPExcel_Style_Fill
         */
        public function getFill()
        {
        }
        /**
         * Get Font
         *
         * @return PHPExcel_Style_Font
         */
        public function getFont()
        {
        }
        /**
         * Set font
         *
         * @param PHPExcel_Style_Font $font
         * @return PHPExcel_Style
         */
        public function setFont(\PHPExcel_Style_Font $font)
        {
        }
        /**
         * Get Borders
         *
         * @return PHPExcel_Style_Borders
         */
        public function getBorders()
        {
        }
        /**
         * Get Alignment
         *
         * @return PHPExcel_Style_Alignment
         */
        public function getAlignment()
        {
        }
        /**
         * Get Number Format
         *
         * @return PHPExcel_Style_NumberFormat
         */
        public function getNumberFormat()
        {
        }
        /**
         * Get Conditional Styles. Only used on supervisor.
         *
         * @return PHPExcel_Style_Conditional[]
         */
        public function getConditionalStyles()
        {
        }
        /**
         * Set Conditional Styles. Only used on supervisor.
         *
         * @param PHPExcel_Style_Conditional[] $pValue Array of condtional styles
         * @return PHPExcel_Style
         */
        public function setConditionalStyles($pValue = \null)
        {
        }
        /**
         * Get Protection
         *
         * @return PHPExcel_Style_Protection
         */
        public function getProtection()
        {
        }
        /**
         * Get quote prefix
         *
         * @return boolean
         */
        public function getQuotePrefix()
        {
        }
        /**
         * Set quote prefix
         *
         * @param boolean $pValue
         */
        public function setQuotePrefix($pValue)
        {
        }
        /**
         * Get hash code
         *
         * @return string Hash code
         */
        public function getHashCode()
        {
        }
        /**
         * Get own index in style collection
         *
         * @return int
         */
        public function getIndex()
        {
        }
        /**
         * Set own index in style collection
         *
         * @param int $pValue
         */
        public function setIndex($pValue)
        {
        }
    }
    /**
     * PHPExcel_Calculation (Multiton)
     *
     * @category	PHPExcel
     * @package		PHPExcel_Calculation
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Calculation
    {
        /** Constants				*/
        /** Regular Expressions		*/
        //	Numeric operand
        const CALCULATION_REGEXP_NUMBER = '[-+]?\\d*\\.?\\d+(e[-+]?\\d+)?';
        //	String operand
        const CALCULATION_REGEXP_STRING = '"(?:[^"]|"")*"';
        //	Opening bracket
        const CALCULATION_REGEXP_OPENBRACE = '\\(';
        //	Function (allow for the old @ symbol that could be used to prefix a function, but we'll ignore it)
        const CALCULATION_REGEXP_FUNCTION = '@?([A-Z][A-Z0-9\\.]*)[\\s]*\\(';
        //	Cell reference (cell or range of cells, with or without a sheet reference)
        const CALCULATION_REGEXP_CELLREF = \CALCULATION_REGEXP_CELLREF;
        //	Named Range of cells
        const CALCULATION_REGEXP_NAMEDRANGE = \CALCULATION_REGEXP_NAMEDRANGE;
        //	Error
        const CALCULATION_REGEXP_ERROR = '\\#[A-Z][A-Z0_\\/]*[!\\?]?';
        /** constants */
        const RETURN_ARRAY_AS_ERROR = 'error';
        const RETURN_ARRAY_AS_VALUE = 'value';
        const RETURN_ARRAY_AS_ARRAY = 'array';
        private static $returnArrayAsType = self::RETURN_ARRAY_AS_VALUE;
        /**
         * Instance of this class
         *
         * @access	private
         * @var PHPExcel_Calculation
         */
        private static $_instance;
        /**
         * Instance of the workbook this Calculation Engine is using
         *
         * @access	private
         * @var PHPExcel
         */
        private $_workbook;
        /**
         * List of instances of the calculation engine that we've instantiated for individual workbooks
         *
         * @access	private
         * @var PHPExcel_Calculation[]
         */
        private static $_workbookSets;
        /**
         * Calculation cache
         *
         * @access	private
         * @var array
         */
        private $_calculationCache = array();
        /**
         * Calculation cache enabled
         *
         * @access	private
         * @var boolean
         */
        private $_calculationCacheEnabled = \TRUE;
        /**
         * List of operators that can be used within formulae
         * The true/false value indicates whether it is a binary operator or a unary operator
         *
         * @access	private
         * @var array
         */
        private static $_operators = array('+' => \TRUE, '-' => \TRUE, '*' => \TRUE, '/' => \TRUE, '^' => \TRUE, '&' => \TRUE, '%' => \FALSE, '~' => \FALSE, '>' => \TRUE, '<' => \TRUE, '=' => \TRUE, '>=' => \TRUE, '<=' => \TRUE, '<>' => \TRUE, '|' => \TRUE, ':' => \TRUE);
        /**
         * List of binary operators (those that expect two operands)
         *
         * @access	private
         * @var array
         */
        private static $_binaryOperators = array('+' => \TRUE, '-' => \TRUE, '*' => \TRUE, '/' => \TRUE, '^' => \TRUE, '&' => \TRUE, '>' => \TRUE, '<' => \TRUE, '=' => \TRUE, '>=' => \TRUE, '<=' => \TRUE, '<>' => \TRUE, '|' => \TRUE, ':' => \TRUE);
        /**
         * The debug log generated by the calculation engine
         *
         * @access	private
         * @var PHPExcel_CalcEngine_Logger
         *
         */
        private $debugLog;
        /**
         * Flag to determine how formula errors should be handled
         *		If true, then a user error will be triggered
         *		If false, then an exception will be thrown
         *
         * @access	public
         * @var boolean
         *
         */
        public $suppressFormulaErrors = \FALSE;
        /**
         * Error message for any error that was raised/thrown by the calculation engine
         *
         * @access	public
         * @var string
         *
         */
        public $formulaError = \NULL;
        /**
         * An array of the nested cell references accessed by the calculation engine, used for the debug log
         *
         * @access	private
         * @var array of string
         *
         */
        private $_cyclicReferenceStack;
        /**
         * Current iteration counter for cyclic formulae
         * If the value is 0 (or less) then cyclic formulae will throw an exception,
         *    otherwise they will iterate to the limit defined here before returning a result
         *
         * @var integer
         *
         */
        private $_cyclicFormulaCount = 0;
        private $_cyclicFormulaCell = '';
        /**
         * Number of iterations for cyclic formulae
         *
         * @var integer
         *
         */
        public $cyclicFormulaCount = 0;
        /**
         * Precision used for calculations
         *
         * @var integer
         *
         */
        private $_savedPrecision = 14;
        /**
         * The current locale setting
         *
         * @var string
         *
         */
        private static $_localeLanguage = 'en_us';
        //	US English	(default locale)
        /**
         * List of available locale settings
         * Note that this is read for the locale subdirectory only when requested
         *
         * @var string[]
         *
         */
        private static $_validLocaleLanguages = array('en');
        /**
         * Locale-specific argument separator for function arguments
         *
         * @var string
         *
         */
        private static $_localeArgumentSeparator = ',';
        private static $_localeFunctions = array();
        /**
         * Locale-specific translations for Excel constants (True, False and Null)
         *
         * @var string[]
         *
         */
        public static $_localeBoolean = array('TRUE' => 'TRUE', 'FALSE' => 'FALSE', 'NULL' => 'NULL');
        /**
         * Excel constant string translations to their PHP equivalents
         * Constant conversion from text name/value to actual (datatyped) value
         *
         * @var string[]
         *
         */
        private static $_ExcelConstants = array('TRUE' => \TRUE, 'FALSE' => \FALSE, 'NULL' => \NULL);
        //	PHPExcel functions
        private static $_PHPExcelFunctions = array(
            // PHPExcel functions
            'ABS' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'abs', 'argumentCount' => '1'),
            'ACCRINT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::ACCRINT', 'argumentCount' => '4-7'),
            'ACCRINTM' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::ACCRINTM', 'argumentCount' => '3-5'),
            'ACOS' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'acos', 'argumentCount' => '1'),
            'ACOSH' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'acosh', 'argumentCount' => '1'),
            'ADDRESS' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => 'PHPExcel_Calculation_LookupRef::CELL_ADDRESS', 'argumentCount' => '2-5'),
            'AMORDEGRC' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::AMORDEGRC', 'argumentCount' => '6,7'),
            'AMORLINC' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::AMORLINC', 'argumentCount' => '6,7'),
            'AND' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_LOGICAL, 'functionCall' => 'PHPExcel_Calculation_Logical::LOGICAL_AND', 'argumentCount' => '1+'),
            'AREAS' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '1'),
            'ASC' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '1'),
            'ASIN' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'asin', 'argumentCount' => '1'),
            'ASINH' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'asinh', 'argumentCount' => '1'),
            'ATAN' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'atan', 'argumentCount' => '1'),
            'ATAN2' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::ATAN2', 'argumentCount' => '2'),
            'ATANH' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'atanh', 'argumentCount' => '1'),
            'AVEDEV' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::AVEDEV', 'argumentCount' => '1+'),
            'AVERAGE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::AVERAGE', 'argumentCount' => '1+'),
            'AVERAGEA' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::AVERAGEA', 'argumentCount' => '1+'),
            'AVERAGEIF' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::AVERAGEIF', 'argumentCount' => '2,3'),
            'AVERAGEIFS' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '3+'),
            'BAHTTEXT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '1'),
            'BESSELI' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::BESSELI', 'argumentCount' => '2'),
            'BESSELJ' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::BESSELJ', 'argumentCount' => '2'),
            'BESSELK' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::BESSELK', 'argumentCount' => '2'),
            'BESSELY' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::BESSELY', 'argumentCount' => '2'),
            'BETADIST' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::BETADIST', 'argumentCount' => '3-5'),
            'BETAINV' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::BETAINV', 'argumentCount' => '3-5'),
            'BIN2DEC' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::BINTODEC', 'argumentCount' => '1'),
            'BIN2HEX' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::BINTOHEX', 'argumentCount' => '1,2'),
            'BIN2OCT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::BINTOOCT', 'argumentCount' => '1,2'),
            'BINOMDIST' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::BINOMDIST', 'argumentCount' => '4'),
            'CEILING' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::CEILING', 'argumentCount' => '2'),
            'CELL' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_INFORMATION, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '1,2'),
            'CHAR' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_TextData::CHARACTER', 'argumentCount' => '1'),
            'CHIDIST' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::CHIDIST', 'argumentCount' => '2'),
            'CHIINV' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::CHIINV', 'argumentCount' => '2'),
            'CHITEST' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '2'),
            'CHOOSE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => 'PHPExcel_Calculation_LookupRef::CHOOSE', 'argumentCount' => '2+'),
            'CLEAN' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_TextData::TRIMNONPRINTABLE', 'argumentCount' => '1'),
            'CODE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_TextData::ASCIICODE', 'argumentCount' => '1'),
            'COLUMN' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => 'PHPExcel_Calculation_LookupRef::COLUMN', 'argumentCount' => '-1', 'passByReference' => array(\TRUE)),
            'COLUMNS' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => 'PHPExcel_Calculation_LookupRef::COLUMNS', 'argumentCount' => '1'),
            'COMBIN' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::COMBIN', 'argumentCount' => '2'),
            'COMPLEX' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::COMPLEX', 'argumentCount' => '2,3'),
            'CONCATENATE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_TextData::CONCATENATE', 'argumentCount' => '1+'),
            'CONFIDENCE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::CONFIDENCE', 'argumentCount' => '3'),
            'CONVERT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::CONVERTUOM', 'argumentCount' => '3'),
            'CORREL' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::CORREL', 'argumentCount' => '2'),
            'COS' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'cos', 'argumentCount' => '1'),
            'COSH' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'cosh', 'argumentCount' => '1'),
            'COUNT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::COUNT', 'argumentCount' => '1+'),
            'COUNTA' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::COUNTA', 'argumentCount' => '1+'),
            'COUNTBLANK' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::COUNTBLANK', 'argumentCount' => '1'),
            'COUNTIF' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::COUNTIF', 'argumentCount' => '2'),
            'COUNTIFS' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '2'),
            'COUPDAYBS' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::COUPDAYBS', 'argumentCount' => '3,4'),
            'COUPDAYS' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::COUPDAYS', 'argumentCount' => '3,4'),
            'COUPDAYSNC' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::COUPDAYSNC', 'argumentCount' => '3,4'),
            'COUPNCD' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::COUPNCD', 'argumentCount' => '3,4'),
            'COUPNUM' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::COUPNUM', 'argumentCount' => '3,4'),
            'COUPPCD' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::COUPPCD', 'argumentCount' => '3,4'),
            'COVAR' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::COVAR', 'argumentCount' => '2'),
            'CRITBINOM' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::CRITBINOM', 'argumentCount' => '3'),
            'CUBEKPIMEMBER' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_CUBE, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '?'),
            'CUBEMEMBER' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_CUBE, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '?'),
            'CUBEMEMBERPROPERTY' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_CUBE, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '?'),
            'CUBERANKEDMEMBER' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_CUBE, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '?'),
            'CUBESET' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_CUBE, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '?'),
            'CUBESETCOUNT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_CUBE, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '?'),
            'CUBEVALUE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_CUBE, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '?'),
            'CUMIPMT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::CUMIPMT', 'argumentCount' => '6'),
            'CUMPRINC' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::CUMPRINC', 'argumentCount' => '6'),
            'DATE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATE_AND_TIME, 'functionCall' => 'PHPExcel_Calculation_DateTime::DATE', 'argumentCount' => '3'),
            'DATEDIF' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATE_AND_TIME, 'functionCall' => 'PHPExcel_Calculation_DateTime::DATEDIF', 'argumentCount' => '2,3'),
            'DATEVALUE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATE_AND_TIME, 'functionCall' => 'PHPExcel_Calculation_DateTime::DATEVALUE', 'argumentCount' => '1'),
            'DAVERAGE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATABASE, 'functionCall' => 'PHPExcel_Calculation_Database::DAVERAGE', 'argumentCount' => '3'),
            'DAY' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATE_AND_TIME, 'functionCall' => 'PHPExcel_Calculation_DateTime::DAYOFMONTH', 'argumentCount' => '1'),
            'DAYS360' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATE_AND_TIME, 'functionCall' => 'PHPExcel_Calculation_DateTime::DAYS360', 'argumentCount' => '2,3'),
            'DB' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::DB', 'argumentCount' => '4,5'),
            'DCOUNT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATABASE, 'functionCall' => 'PHPExcel_Calculation_Database::DCOUNT', 'argumentCount' => '3'),
            'DCOUNTA' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATABASE, 'functionCall' => 'PHPExcel_Calculation_Database::DCOUNTA', 'argumentCount' => '3'),
            'DDB' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::DDB', 'argumentCount' => '4,5'),
            'DEC2BIN' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::DECTOBIN', 'argumentCount' => '1,2'),
            'DEC2HEX' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::DECTOHEX', 'argumentCount' => '1,2'),
            'DEC2OCT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::DECTOOCT', 'argumentCount' => '1,2'),
            'DEGREES' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'rad2deg', 'argumentCount' => '1'),
            'DELTA' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::DELTA', 'argumentCount' => '1,2'),
            'DEVSQ' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::DEVSQ', 'argumentCount' => '1+'),
            'DGET' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATABASE, 'functionCall' => 'PHPExcel_Calculation_Database::DGET', 'argumentCount' => '3'),
            'DISC' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::DISC', 'argumentCount' => '4,5'),
            'DMAX' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATABASE, 'functionCall' => 'PHPExcel_Calculation_Database::DMAX', 'argumentCount' => '3'),
            'DMIN' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATABASE, 'functionCall' => 'PHPExcel_Calculation_Database::DMIN', 'argumentCount' => '3'),
            'DOLLAR' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_TextData::DOLLAR', 'argumentCount' => '1,2'),
            'DOLLARDE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::DOLLARDE', 'argumentCount' => '2'),
            'DOLLARFR' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::DOLLARFR', 'argumentCount' => '2'),
            'DPRODUCT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATABASE, 'functionCall' => 'PHPExcel_Calculation_Database::DPRODUCT', 'argumentCount' => '3'),
            'DSTDEV' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATABASE, 'functionCall' => 'PHPExcel_Calculation_Database::DSTDEV', 'argumentCount' => '3'),
            'DSTDEVP' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATABASE, 'functionCall' => 'PHPExcel_Calculation_Database::DSTDEVP', 'argumentCount' => '3'),
            'DSUM' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATABASE, 'functionCall' => 'PHPExcel_Calculation_Database::DSUM', 'argumentCount' => '3'),
            'DURATION' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '5,6'),
            'DVAR' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATABASE, 'functionCall' => 'PHPExcel_Calculation_Database::DVAR', 'argumentCount' => '3'),
            'DVARP' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATABASE, 'functionCall' => 'PHPExcel_Calculation_Database::DVARP', 'argumentCount' => '3'),
            'EDATE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATE_AND_TIME, 'functionCall' => 'PHPExcel_Calculation_DateTime::EDATE', 'argumentCount' => '2'),
            'EFFECT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::EFFECT', 'argumentCount' => '2'),
            'EOMONTH' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATE_AND_TIME, 'functionCall' => 'PHPExcel_Calculation_DateTime::EOMONTH', 'argumentCount' => '2'),
            'ERF' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::ERF', 'argumentCount' => '1,2'),
            'ERFC' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::ERFC', 'argumentCount' => '1'),
            'ERROR.TYPE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_INFORMATION, 'functionCall' => 'PHPExcel_Calculation_Functions::ERROR_TYPE', 'argumentCount' => '1'),
            'EVEN' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::EVEN', 'argumentCount' => '1'),
            'EXACT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '2'),
            'EXP' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'exp', 'argumentCount' => '1'),
            'EXPONDIST' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::EXPONDIST', 'argumentCount' => '3'),
            'FACT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::FACT', 'argumentCount' => '1'),
            'FACTDOUBLE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::FACTDOUBLE', 'argumentCount' => '1'),
            'FALSE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_LOGICAL, 'functionCall' => 'PHPExcel_Calculation_Logical::FALSE', 'argumentCount' => '0'),
            'FDIST' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '3'),
            'FIND' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_TextData::SEARCHSENSITIVE', 'argumentCount' => '2,3'),
            'FINDB' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_TextData::SEARCHSENSITIVE', 'argumentCount' => '2,3'),
            'FINV' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '3'),
            'FISHER' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::FISHER', 'argumentCount' => '1'),
            'FISHERINV' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::FISHERINV', 'argumentCount' => '1'),
            'FIXED' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_TextData::FIXEDFORMAT', 'argumentCount' => '1-3'),
            'FLOOR' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::FLOOR', 'argumentCount' => '2'),
            'FORECAST' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::FORECAST', 'argumentCount' => '3'),
            'FREQUENCY' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '2'),
            'FTEST' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '2'),
            'FV' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::FV', 'argumentCount' => '3-5'),
            'FVSCHEDULE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::FVSCHEDULE', 'argumentCount' => '2'),
            'GAMMADIST' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::GAMMADIST', 'argumentCount' => '4'),
            'GAMMAINV' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::GAMMAINV', 'argumentCount' => '3'),
            'GAMMALN' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::GAMMALN', 'argumentCount' => '1'),
            'GCD' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::GCD', 'argumentCount' => '1+'),
            'GEOMEAN' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::GEOMEAN', 'argumentCount' => '1+'),
            'GESTEP' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::GESTEP', 'argumentCount' => '1,2'),
            'GETPIVOTDATA' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '2+'),
            'GROWTH' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::GROWTH', 'argumentCount' => '1-4'),
            'HARMEAN' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::HARMEAN', 'argumentCount' => '1+'),
            'HEX2BIN' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::HEXTOBIN', 'argumentCount' => '1,2'),
            'HEX2DEC' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::HEXTODEC', 'argumentCount' => '1'),
            'HEX2OCT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::HEXTOOCT', 'argumentCount' => '1,2'),
            'HLOOKUP' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => 'PHPExcel_Calculation_LookupRef::HLOOKUP', 'argumentCount' => '3,4'),
            'HOUR' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATE_AND_TIME, 'functionCall' => 'PHPExcel_Calculation_DateTime::HOUROFDAY', 'argumentCount' => '1'),
            'HYPERLINK' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => 'PHPExcel_Calculation_LookupRef::HYPERLINK', 'argumentCount' => '1,2', 'passCellReference' => \TRUE),
            'HYPGEOMDIST' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::HYPGEOMDIST', 'argumentCount' => '4'),
            'IF' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_LOGICAL, 'functionCall' => 'PHPExcel_Calculation_Logical::STATEMENT_IF', 'argumentCount' => '1-3'),
            'IFERROR' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_LOGICAL, 'functionCall' => 'PHPExcel_Calculation_Logical::IFERROR', 'argumentCount' => '2'),
            'IMABS' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::IMABS', 'argumentCount' => '1'),
            'IMAGINARY' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::IMAGINARY', 'argumentCount' => '1'),
            'IMARGUMENT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::IMARGUMENT', 'argumentCount' => '1'),
            'IMCONJUGATE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::IMCONJUGATE', 'argumentCount' => '1'),
            'IMCOS' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::IMCOS', 'argumentCount' => '1'),
            'IMDIV' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::IMDIV', 'argumentCount' => '2'),
            'IMEXP' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::IMEXP', 'argumentCount' => '1'),
            'IMLN' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::IMLN', 'argumentCount' => '1'),
            'IMLOG10' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::IMLOG10', 'argumentCount' => '1'),
            'IMLOG2' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::IMLOG2', 'argumentCount' => '1'),
            'IMPOWER' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::IMPOWER', 'argumentCount' => '2'),
            'IMPRODUCT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::IMPRODUCT', 'argumentCount' => '1+'),
            'IMREAL' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::IMREAL', 'argumentCount' => '1'),
            'IMSIN' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::IMSIN', 'argumentCount' => '1'),
            'IMSQRT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::IMSQRT', 'argumentCount' => '1'),
            'IMSUB' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::IMSUB', 'argumentCount' => '2'),
            'IMSUM' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::IMSUM', 'argumentCount' => '1+'),
            'INDEX' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => 'PHPExcel_Calculation_LookupRef::INDEX', 'argumentCount' => '1-4'),
            'INDIRECT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => 'PHPExcel_Calculation_LookupRef::INDIRECT', 'argumentCount' => '1,2', 'passCellReference' => \TRUE),
            'INFO' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_INFORMATION, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '1'),
            'INT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::INT', 'argumentCount' => '1'),
            'INTERCEPT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::INTERCEPT', 'argumentCount' => '2'),
            'INTRATE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::INTRATE', 'argumentCount' => '4,5'),
            'IPMT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::IPMT', 'argumentCount' => '4-6'),
            'IRR' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::IRR', 'argumentCount' => '1,2'),
            'ISBLANK' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_INFORMATION, 'functionCall' => 'PHPExcel_Calculation_Functions::IS_BLANK', 'argumentCount' => '1'),
            'ISERR' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_INFORMATION, 'functionCall' => 'PHPExcel_Calculation_Functions::IS_ERR', 'argumentCount' => '1'),
            'ISERROR' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_INFORMATION, 'functionCall' => 'PHPExcel_Calculation_Functions::IS_ERROR', 'argumentCount' => '1'),
            'ISEVEN' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_INFORMATION, 'functionCall' => 'PHPExcel_Calculation_Functions::IS_EVEN', 'argumentCount' => '1'),
            'ISLOGICAL' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_INFORMATION, 'functionCall' => 'PHPExcel_Calculation_Functions::IS_LOGICAL', 'argumentCount' => '1'),
            'ISNA' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_INFORMATION, 'functionCall' => 'PHPExcel_Calculation_Functions::IS_NA', 'argumentCount' => '1'),
            'ISNONTEXT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_INFORMATION, 'functionCall' => 'PHPExcel_Calculation_Functions::IS_NONTEXT', 'argumentCount' => '1'),
            'ISNUMBER' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_INFORMATION, 'functionCall' => 'PHPExcel_Calculation_Functions::IS_NUMBER', 'argumentCount' => '1'),
            'ISODD' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_INFORMATION, 'functionCall' => 'PHPExcel_Calculation_Functions::IS_ODD', 'argumentCount' => '1'),
            'ISPMT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::ISPMT', 'argumentCount' => '4'),
            'ISREF' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_INFORMATION, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '1'),
            'ISTEXT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_INFORMATION, 'functionCall' => 'PHPExcel_Calculation_Functions::IS_TEXT', 'argumentCount' => '1'),
            'JIS' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '1'),
            'KURT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::KURT', 'argumentCount' => '1+'),
            'LARGE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::LARGE', 'argumentCount' => '2'),
            'LCM' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::LCM', 'argumentCount' => '1+'),
            'LEFT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_TextData::LEFT', 'argumentCount' => '1,2'),
            'LEFTB' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_TextData::LEFT', 'argumentCount' => '1,2'),
            'LEN' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_TextData::STRINGLENGTH', 'argumentCount' => '1'),
            'LENB' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_TextData::STRINGLENGTH', 'argumentCount' => '1'),
            'LINEST' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::LINEST', 'argumentCount' => '1-4'),
            'LN' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'log', 'argumentCount' => '1'),
            'LOG' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::LOG_BASE', 'argumentCount' => '1,2'),
            'LOG10' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'log10', 'argumentCount' => '1'),
            'LOGEST' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::LOGEST', 'argumentCount' => '1-4'),
            'LOGINV' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::LOGINV', 'argumentCount' => '3'),
            'LOGNORMDIST' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::LOGNORMDIST', 'argumentCount' => '3'),
            'LOOKUP' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => 'PHPExcel_Calculation_LookupRef::LOOKUP', 'argumentCount' => '2,3'),
            'LOWER' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_TextData::LOWERCASE', 'argumentCount' => '1'),
            'MATCH' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => 'PHPExcel_Calculation_LookupRef::MATCH', 'argumentCount' => '2,3'),
            'MAX' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::MAX', 'argumentCount' => '1+'),
            'MAXA' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::MAXA', 'argumentCount' => '1+'),
            'MAXIF' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::MAXIF', 'argumentCount' => '2+'),
            'MDETERM' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::MDETERM', 'argumentCount' => '1'),
            'MDURATION' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '5,6'),
            'MEDIAN' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::MEDIAN', 'argumentCount' => '1+'),
            'MEDIANIF' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '2+'),
            'MID' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_TextData::MID', 'argumentCount' => '3'),
            'MIDB' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_TextData::MID', 'argumentCount' => '3'),
            'MIN' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::MIN', 'argumentCount' => '1+'),
            'MINA' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::MINA', 'argumentCount' => '1+'),
            'MINIF' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::MINIF', 'argumentCount' => '2+'),
            'MINUTE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATE_AND_TIME, 'functionCall' => 'PHPExcel_Calculation_DateTime::MINUTEOFHOUR', 'argumentCount' => '1'),
            'MINVERSE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::MINVERSE', 'argumentCount' => '1'),
            'MIRR' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::MIRR', 'argumentCount' => '3'),
            'MMULT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::MMULT', 'argumentCount' => '2'),
            'MOD' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::MOD', 'argumentCount' => '2'),
            'MODE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::MODE', 'argumentCount' => '1+'),
            'MONTH' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATE_AND_TIME, 'functionCall' => 'PHPExcel_Calculation_DateTime::MONTHOFYEAR', 'argumentCount' => '1'),
            'MROUND' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::MROUND', 'argumentCount' => '2'),
            'MULTINOMIAL' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::MULTINOMIAL', 'argumentCount' => '1+'),
            'N' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_INFORMATION, 'functionCall' => 'PHPExcel_Calculation_Functions::N', 'argumentCount' => '1'),
            'NA' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_INFORMATION, 'functionCall' => 'PHPExcel_Calculation_Functions::NA', 'argumentCount' => '0'),
            'NEGBINOMDIST' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::NEGBINOMDIST', 'argumentCount' => '3'),
            'NETWORKDAYS' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATE_AND_TIME, 'functionCall' => 'PHPExcel_Calculation_DateTime::NETWORKDAYS', 'argumentCount' => '2+'),
            'NOMINAL' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::NOMINAL', 'argumentCount' => '2'),
            'NORMDIST' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::NORMDIST', 'argumentCount' => '4'),
            'NORMINV' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::NORMINV', 'argumentCount' => '3'),
            'NORMSDIST' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::NORMSDIST', 'argumentCount' => '1'),
            'NORMSINV' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::NORMSINV', 'argumentCount' => '1'),
            'NOT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_LOGICAL, 'functionCall' => 'PHPExcel_Calculation_Logical::NOT', 'argumentCount' => '1'),
            'NOW' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATE_AND_TIME, 'functionCall' => 'PHPExcel_Calculation_DateTime::DATETIMENOW', 'argumentCount' => '0'),
            'NPER' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::NPER', 'argumentCount' => '3-5'),
            'NPV' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::NPV', 'argumentCount' => '2+'),
            'OCT2BIN' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::OCTTOBIN', 'argumentCount' => '1,2'),
            'OCT2DEC' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::OCTTODEC', 'argumentCount' => '1'),
            'OCT2HEX' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_ENGINEERING, 'functionCall' => 'PHPExcel_Calculation_Engineering::OCTTOHEX', 'argumentCount' => '1,2'),
            'ODD' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::ODD', 'argumentCount' => '1'),
            'ODDFPRICE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '8,9'),
            'ODDFYIELD' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '8,9'),
            'ODDLPRICE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '7,8'),
            'ODDLYIELD' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '7,8'),
            'OFFSET' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => 'PHPExcel_Calculation_LookupRef::OFFSET', 'argumentCount' => '3,5', 'passCellReference' => \TRUE, 'passByReference' => array(\TRUE)),
            'OR' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_LOGICAL, 'functionCall' => 'PHPExcel_Calculation_Logical::LOGICAL_OR', 'argumentCount' => '1+'),
            'PEARSON' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::CORREL', 'argumentCount' => '2'),
            'PERCENTILE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::PERCENTILE', 'argumentCount' => '2'),
            'PERCENTRANK' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::PERCENTRANK', 'argumentCount' => '2,3'),
            'PERMUT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::PERMUT', 'argumentCount' => '2'),
            'PHONETIC' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '1'),
            'PI' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'pi', 'argumentCount' => '0'),
            'PMT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::PMT', 'argumentCount' => '3-5'),
            'POISSON' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::POISSON', 'argumentCount' => '3'),
            'POWER' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::POWER', 'argumentCount' => '2'),
            'PPMT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::PPMT', 'argumentCount' => '4-6'),
            'PRICE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::PRICE', 'argumentCount' => '6,7'),
            'PRICEDISC' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::PRICEDISC', 'argumentCount' => '4,5'),
            'PRICEMAT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::PRICEMAT', 'argumentCount' => '5,6'),
            'PROB' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '3,4'),
            'PRODUCT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::PRODUCT', 'argumentCount' => '1+'),
            'PROPER' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_TextData::PROPERCASE', 'argumentCount' => '1'),
            'PV' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::PV', 'argumentCount' => '3-5'),
            'QUARTILE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::QUARTILE', 'argumentCount' => '2'),
            'QUOTIENT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::QUOTIENT', 'argumentCount' => '2'),
            'RADIANS' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'deg2rad', 'argumentCount' => '1'),
            'RAND' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::RAND', 'argumentCount' => '0'),
            'RANDBETWEEN' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::RAND', 'argumentCount' => '2'),
            'RANK' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::RANK', 'argumentCount' => '2,3'),
            'RATE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::RATE', 'argumentCount' => '3-6'),
            'RECEIVED' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::RECEIVED', 'argumentCount' => '4-5'),
            'REPLACE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_TextData::REPLACE', 'argumentCount' => '4'),
            'REPLACEB' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_TextData::REPLACE', 'argumentCount' => '4'),
            'REPT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'str_repeat', 'argumentCount' => '2'),
            'RIGHT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_TextData::RIGHT', 'argumentCount' => '1,2'),
            'RIGHTB' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_TextData::RIGHT', 'argumentCount' => '1,2'),
            'ROMAN' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::ROMAN', 'argumentCount' => '1,2'),
            'ROUND' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'round', 'argumentCount' => '2'),
            'ROUNDDOWN' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::ROUNDDOWN', 'argumentCount' => '2'),
            'ROUNDUP' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::ROUNDUP', 'argumentCount' => '2'),
            'ROW' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => 'PHPExcel_Calculation_LookupRef::ROW', 'argumentCount' => '-1', 'passByReference' => array(\TRUE)),
            'ROWS' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => 'PHPExcel_Calculation_LookupRef::ROWS', 'argumentCount' => '1'),
            'RSQ' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::RSQ', 'argumentCount' => '2'),
            'RTD' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '1+'),
            'SEARCH' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_TextData::SEARCHINSENSITIVE', 'argumentCount' => '2,3'),
            'SEARCHB' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_TextData::SEARCHINSENSITIVE', 'argumentCount' => '2,3'),
            'SECOND' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATE_AND_TIME, 'functionCall' => 'PHPExcel_Calculation_DateTime::SECONDOFMINUTE', 'argumentCount' => '1'),
            'SERIESSUM' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::SERIESSUM', 'argumentCount' => '4'),
            'SIGN' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::SIGN', 'argumentCount' => '1'),
            'SIN' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'sin', 'argumentCount' => '1'),
            'SINH' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'sinh', 'argumentCount' => '1'),
            'SKEW' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::SKEW', 'argumentCount' => '1+'),
            'SLN' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::SLN', 'argumentCount' => '3'),
            'SLOPE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::SLOPE', 'argumentCount' => '2'),
            'SMALL' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::SMALL', 'argumentCount' => '2'),
            'SQRT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'sqrt', 'argumentCount' => '1'),
            'SQRTPI' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::SQRTPI', 'argumentCount' => '1'),
            'STANDARDIZE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::STANDARDIZE', 'argumentCount' => '3'),
            'STDEV' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::STDEV', 'argumentCount' => '1+'),
            'STDEVA' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::STDEVA', 'argumentCount' => '1+'),
            'STDEVP' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::STDEVP', 'argumentCount' => '1+'),
            'STDEVPA' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::STDEVPA', 'argumentCount' => '1+'),
            'STEYX' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::STEYX', 'argumentCount' => '2'),
            'SUBSTITUTE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_TextData::SUBSTITUTE', 'argumentCount' => '3,4'),
            'SUBTOTAL' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::SUBTOTAL', 'argumentCount' => '2+'),
            'SUM' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::SUM', 'argumentCount' => '1+'),
            'SUMIF' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::SUMIF', 'argumentCount' => '2,3'),
            'SUMIFS' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '?'),
            'SUMPRODUCT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::SUMPRODUCT', 'argumentCount' => '1+'),
            'SUMSQ' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::SUMSQ', 'argumentCount' => '1+'),
            'SUMX2MY2' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::SUMX2MY2', 'argumentCount' => '2'),
            'SUMX2PY2' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::SUMX2PY2', 'argumentCount' => '2'),
            'SUMXMY2' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::SUMXMY2', 'argumentCount' => '2'),
            'SYD' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::SYD', 'argumentCount' => '4'),
            'T' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_TextData::RETURNSTRING', 'argumentCount' => '1'),
            'TAN' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'tan', 'argumentCount' => '1'),
            'TANH' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'tanh', 'argumentCount' => '1'),
            'TBILLEQ' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::TBILLEQ', 'argumentCount' => '3'),
            'TBILLPRICE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::TBILLPRICE', 'argumentCount' => '3'),
            'TBILLYIELD' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::TBILLYIELD', 'argumentCount' => '3'),
            'TDIST' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::TDIST', 'argumentCount' => '3'),
            'TEXT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_TextData::TEXTFORMAT', 'argumentCount' => '2'),
            'TIME' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATE_AND_TIME, 'functionCall' => 'PHPExcel_Calculation_DateTime::TIME', 'argumentCount' => '3'),
            'TIMEVALUE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATE_AND_TIME, 'functionCall' => 'PHPExcel_Calculation_DateTime::TIMEVALUE', 'argumentCount' => '1'),
            'TINV' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::TINV', 'argumentCount' => '2'),
            'TODAY' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATE_AND_TIME, 'functionCall' => 'PHPExcel_Calculation_DateTime::DATENOW', 'argumentCount' => '0'),
            'TRANSPOSE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => 'PHPExcel_Calculation_LookupRef::TRANSPOSE', 'argumentCount' => '1'),
            'TREND' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::TREND', 'argumentCount' => '1-4'),
            'TRIM' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_TextData::TRIMSPACES', 'argumentCount' => '1'),
            'TRIMMEAN' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::TRIMMEAN', 'argumentCount' => '2'),
            'TRUE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_LOGICAL, 'functionCall' => 'PHPExcel_Calculation_Logical::TRUE', 'argumentCount' => '0'),
            'TRUNC' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'PHPExcel_Calculation_MathTrig::TRUNC', 'argumentCount' => '1,2'),
            'TTEST' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '4'),
            'TYPE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_INFORMATION, 'functionCall' => 'PHPExcel_Calculation_Functions::TYPE', 'argumentCount' => '1'),
            'UPPER' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_TextData::UPPERCASE', 'argumentCount' => '1'),
            'USDOLLAR' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '2'),
            'VALUE' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '1'),
            'VAR' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::VARFunc', 'argumentCount' => '1+'),
            'VARA' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::VARA', 'argumentCount' => '1+'),
            'VARP' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::VARP', 'argumentCount' => '1+'),
            'VARPA' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::VARPA', 'argumentCount' => '1+'),
            'VDB' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '5-7'),
            'VERSION' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_INFORMATION, 'functionCall' => 'PHPExcel_Calculation_Functions::VERSION', 'argumentCount' => '0'),
            'VLOOKUP' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => 'PHPExcel_Calculation_LookupRef::VLOOKUP', 'argumentCount' => '3,4'),
            'WEEKDAY' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATE_AND_TIME, 'functionCall' => 'PHPExcel_Calculation_DateTime::DAYOFWEEK', 'argumentCount' => '1,2'),
            'WEEKNUM' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATE_AND_TIME, 'functionCall' => 'PHPExcel_Calculation_DateTime::WEEKOFYEAR', 'argumentCount' => '1,2'),
            'WEIBULL' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::WEIBULL', 'argumentCount' => '4'),
            'WORKDAY' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATE_AND_TIME, 'functionCall' => 'PHPExcel_Calculation_DateTime::WORKDAY', 'argumentCount' => '2+'),
            'XIRR' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::XIRR', 'argumentCount' => '2,3'),
            'XNPV' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::XNPV', 'argumentCount' => '3'),
            'YEAR' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATE_AND_TIME, 'functionCall' => 'PHPExcel_Calculation_DateTime::YEAR', 'argumentCount' => '1'),
            'YEARFRAC' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_DATE_AND_TIME, 'functionCall' => 'PHPExcel_Calculation_DateTime::YEARFRAC', 'argumentCount' => '2,3'),
            'YIELD' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY', 'argumentCount' => '6,7'),
            'YIELDDISC' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::YIELDDISC', 'argumentCount' => '4,5'),
            'YIELDMAT' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_FINANCIAL, 'functionCall' => 'PHPExcel_Calculation_Financial::YIELDMAT', 'argumentCount' => '5,6'),
            'ZTEST' => array('category' => \PHPExcel_Calculation_Function::CATEGORY_STATISTICAL, 'functionCall' => 'PHPExcel_Calculation_Statistical::ZTEST', 'argumentCount' => '2-3'),
        );
        //	Internal functions used for special control purposes
        private static $_controlFunctions = array('MKMATRIX' => array('argumentCount' => '*', 'functionCall' => 'self::_mkMatrix'));
        private function __construct(\PHPExcel $workbook = \NULL)
        {
        }
        //	function __construct()
        public function __destruct()
        {
        }
        private static function _loadLocales()
        {
        }
        /**
         * Get an instance of this class
         *
         * @access	public
         * @param   PHPExcel $workbook  Injected workbook for working with a PHPExcel object,
         *									or NULL to create a standalone claculation engine
         * @return PHPExcel_Calculation
         */
        public static function getInstance(\PHPExcel $workbook = \NULL)
        {
        }
        //	function getInstance()
        /**
         * Unset an instance of this class
         *
         * @access	public
         * @param   PHPExcel $workbook  Injected workbook identifying the instance to unset
         */
        public static function unsetInstance(\PHPExcel $workbook = \NULL)
        {
        }
        /**
         * Flush the calculation cache for any existing instance of this class
         *		but only if a PHPExcel_Calculation instance exists
         *
         * @access	public
         * @return null
         */
        public function flushInstance()
        {
        }
        //	function flushInstance()
        /**
         * Get the debuglog for this claculation engine instance
         *
         * @access	public
         * @return PHPExcel_CalcEngine_Logger
         */
        public function getDebugLog()
        {
        }
        /**
         * __clone implementation. Cloning should not be allowed in a Singleton!
         *
         * @access	public
         * @throws	PHPExcel_Calculation_Exception
         */
        public final function __clone()
        {
        }
        //	function __clone()
        /**
         * Return the locale-specific translation of TRUE
         *
         * @access	public
         * @return	 string		locale-specific translation of TRUE
         */
        public static function getTRUE()
        {
        }
        /**
         * Return the locale-specific translation of FALSE
         *
         * @access	public
         * @return	 string		locale-specific translation of FALSE
         */
        public static function getFALSE()
        {
        }
        /**
         * Set the Array Return Type (Array or Value of first element in the array)
         *
         * @access	public
         * @param	 string	$returnType			Array return type
         * @return	 boolean					Success or failure
         */
        public static function setArrayReturnType($returnType)
        {
        }
        //	function setArrayReturnType()
        /**
         * Return the Array Return Type (Array or Value of first element in the array)
         *
         * @access	public
         * @return	 string		$returnType			Array return type
         */
        public static function getArrayReturnType()
        {
        }
        //	function getArrayReturnType()
        /**
         * Is calculation caching enabled?
         *
         * @access	public
         * @return boolean
         */
        public function getCalculationCacheEnabled()
        {
        }
        //	function getCalculationCacheEnabled()
        /**
         * Enable/disable calculation cache
         *
         * @access	public
         * @param boolean $pValue
         */
        public function setCalculationCacheEnabled($pValue = \TRUE)
        {
        }
        //	function setCalculationCacheEnabled()
        /**
         * Enable calculation cache
         */
        public function enableCalculationCache()
        {
        }
        //	function enableCalculationCache()
        /**
         * Disable calculation cache
         */
        public function disableCalculationCache()
        {
        }
        //	function disableCalculationCache()
        /**
         * Clear calculation cache
         */
        public function clearCalculationCache()
        {
        }
        //	function clearCalculationCache()
        /**
         * Clear calculation cache for a specified worksheet
         *
         * @param string $worksheetName
         */
        public function clearCalculationCacheForWorksheet($worksheetName)
        {
        }
        //	function clearCalculationCacheForWorksheet()
        /**
         * Rename calculation cache for a specified worksheet
         *
         * @param string $fromWorksheetName
         * @param string $toWorksheetName
         */
        public function renameCalculationCacheForWorksheet($fromWorksheetName, $toWorksheetName)
        {
        }
        //	function renameCalculationCacheForWorksheet()
        /**
         * Get the currently defined locale code
         *
         * @return string
         */
        public function getLocale()
        {
        }
        //	function getLocale()
        /**
         * Set the locale code
         *
         * @param string $locale  The locale to use for formula translation
         * @return boolean
         */
        public function setLocale($locale = 'en_us')
        {
        }
        //	function setLocale()
        public static function _translateSeparator($fromSeparator, $toSeparator, $formula, &$inBraces)
        {
        }
        private static function _translateFormula($from, $to, $formula, $fromSeparator, $toSeparator)
        {
        }
        private static $functionReplaceFromExcel = \NULL;
        private static $functionReplaceToLocale = \NULL;
        public function _translateFormulaToLocale($formula)
        {
        }
        //	function _translateFormulaToLocale()
        private static $functionReplaceFromLocale = \NULL;
        private static $functionReplaceToExcel = \NULL;
        public function _translateFormulaToEnglish($formula)
        {
        }
        //	function _translateFormulaToEnglish()
        public static function _localeFunc($function)
        {
        }
        /**
         * Wrap string values in quotes
         *
         * @param mixed $value
         * @return mixed
         */
        public static function _wrapResult($value)
        {
        }
        //	function _wrapResult()
        /**
         * Remove quotes used as a wrapper to identify string values
         *
         * @param mixed $value
         * @return mixed
         */
        public static function _unwrapResult($value)
        {
        }
        //	function _unwrapResult()
        /**
         * Calculate cell value (using formula from a cell ID)
         * Retained for backward compatibility
         *
         * @access	public
         * @param	PHPExcel_Cell	$pCell	Cell to calculate
         * @return	mixed
         * @throws	PHPExcel_Calculation_Exception
         */
        public function calculate(\PHPExcel_Cell $pCell = \NULL)
        {
        }
        //	function calculate()
        /**
         * Calculate the value of a cell formula
         *
         * @access	public
         * @param	PHPExcel_Cell	$pCell		Cell to calculate
         * @param	Boolean			$resetLog	Flag indicating whether the debug log should be reset or not
         * @return	mixed
         * @throws	PHPExcel_Calculation_Exception
         */
        public function calculateCellValue(\PHPExcel_Cell $pCell = \NULL, $resetLog = \TRUE)
        {
        }
        //	function calculateCellValue(
        /**
         * Validate and parse a formula string
         *
         * @param	string		$formula		Formula to parse
         * @return	array
         * @throws	PHPExcel_Calculation_Exception
         */
        public function parseFormula($formula)
        {
        }
        //	function parseFormula()
        /**
         * Calculate the value of a formula
         *
         * @param	string			$formula	Formula to parse
         * @param	string			$cellID		Address of the cell to calculate
         * @param	PHPExcel_Cell	$pCell		Cell to calculate
         * @return	mixed
         * @throws	PHPExcel_Calculation_Exception
         */
        public function calculateFormula($formula, $cellID = \NULL, \PHPExcel_Cell $pCell = \NULL)
        {
        }
        //	function calculateFormula()
        public function getValueFromCache($worksheetName, $cellID, &$cellValue)
        {
        }
        public function saveValueToCache($worksheetName, $cellID, $cellValue)
        {
        }
        /**
         * Parse a cell formula and calculate its value
         *
         * @param	string			$formula	The formula to parse and calculate
         * @param	string			$cellID		The ID (e.g. A3) of the cell that we are calculating
         * @param	PHPExcel_Cell	$pCell		Cell to calculate
         * @return	mixed
         * @throws	PHPExcel_Calculation_Exception
         */
        public function _calculateFormulaValue($formula, $cellID = \null, \PHPExcel_Cell $pCell = \null)
        {
        }
        //	function _calculateFormulaValue()
        /**
         * Ensure that paired matrix operands are both matrices and of the same size
         *
         * @param	mixed		&$operand1	First matrix operand
         * @param	mixed		&$operand2	Second matrix operand
         * @param	integer		$resize		Flag indicating whether the matrices should be resized to match
         *										and (if so), whether the smaller dimension should grow or the
         *										larger should shrink.
         *											0 = no resize
         *											1 = shrink to fit
         *											2 = extend to fit
         */
        private static function _checkMatrixOperands(&$operand1, &$operand2, $resize = 1)
        {
        }
        //	function _checkMatrixOperands()
        /**
         * Read the dimensions of a matrix, and re-index it with straight numeric keys starting from row 0, column 0
         *
         * @param	mixed		&$matrix		matrix operand
         * @return	array		An array comprising the number of rows, and number of columns
         */
        public static function _getMatrixDimensions(&$matrix)
        {
        }
        //	function _getMatrixDimensions()
        /**
         * Ensure that paired matrix operands are both matrices of the same size
         *
         * @param	mixed		&$matrix1		First matrix operand
         * @param	mixed		&$matrix2		Second matrix operand
         * @param	integer		$matrix1Rows	Row size of first matrix operand
         * @param	integer		$matrix1Columns	Column size of first matrix operand
         * @param	integer		$matrix2Rows	Row size of second matrix operand
         * @param	integer		$matrix2Columns	Column size of second matrix operand
         */
        private static function _resizeMatricesShrink(&$matrix1, &$matrix2, $matrix1Rows, $matrix1Columns, $matrix2Rows, $matrix2Columns)
        {
        }
        //	function _resizeMatricesShrink()
        /**
         * Ensure that paired matrix operands are both matrices of the same size
         *
         * @param	mixed		&$matrix1	First matrix operand
         * @param	mixed		&$matrix2	Second matrix operand
         * @param	integer		$matrix1Rows	Row size of first matrix operand
         * @param	integer		$matrix1Columns	Column size of first matrix operand
         * @param	integer		$matrix2Rows	Row size of second matrix operand
         * @param	integer		$matrix2Columns	Column size of second matrix operand
         */
        private static function _resizeMatricesExtend(&$matrix1, &$matrix2, $matrix1Rows, $matrix1Columns, $matrix2Rows, $matrix2Columns)
        {
        }
        //	function _resizeMatricesExtend()
        /**
         * Format details of an operand for display in the log (based on operand type)
         *
         * @param	mixed		$value	First matrix operand
         * @return	mixed
         */
        private function _showValue($value)
        {
        }
        //	function _showValue()
        /**
         * Format type and details of an operand for display in the log (based on operand type)
         *
         * @param	mixed		$value	First matrix operand
         * @return	mixed
         */
        private function _showTypeDetails($value)
        {
        }
        //	function _showTypeDetails()
        private static function _convertMatrixReferences($formula)
        {
        }
        //	function _convertMatrixReferences()
        private static function _mkMatrix()
        {
        }
        //	function _mkMatrix()
        //	Binary Operators
        //	These operators always work on two values
        //	Array key is the operator, the value indicates whether this is a left or right associative operator
        private static $_operatorAssociativity = array(
            '^' => 0,
            //	Exponentiation
            '*' => 0,
            '/' => 0,
            //	Multiplication and Division
            '+' => 0,
            '-' => 0,
            //	Addition and Subtraction
            '&' => 0,
            //	Concatenation
            '|' => 0,
            ':' => 0,
            //	Intersect and Range
            '>' => 0,
            '<' => 0,
            '=' => 0,
            '>=' => 0,
            '<=' => 0,
            '<>' => 0,
        );
        //	Comparison (Boolean) Operators
        //	These operators work on two values, but always return a boolean result
        private static $_comparisonOperators = array('>' => \TRUE, '<' => \TRUE, '=' => \TRUE, '>=' => \TRUE, '<=' => \TRUE, '<>' => \TRUE);
        //	Operator Precedence
        //	This list includes all valid operators, whether binary (including boolean) or unary (such as %)
        //	Array key is the operator, the value is its precedence
        private static $_operatorPrecedence = array(
            ':' => 8,
            //	Range
            '|' => 7,
            //	Intersect
            '~' => 6,
            //	Negation
            '%' => 5,
            //	Percentage
            '^' => 4,
            //	Exponentiation
            '*' => 3,
            '/' => 3,
            //	Multiplication and Division
            '+' => 2,
            '-' => 2,
            //	Addition and Subtraction
            '&' => 1,
            //	Concatenation
            '>' => 0,
            '<' => 0,
            '=' => 0,
            '>=' => 0,
            '<=' => 0,
            '<>' => 0,
        );
        // Convert infix to postfix notation
        private function _parseFormula($formula, \PHPExcel_Cell $pCell = \NULL)
        {
        }
        //	function _parseFormula()
        private static function _dataTestReference(&$operandData)
        {
        }
        // evaluate postfix notation
        private function _processTokenStack($tokens, $cellID = \NULL, \PHPExcel_Cell $pCell = \NULL)
        {
        }
        //	function _processTokenStack()
        private function _validateBinaryOperand($cellID, &$operand, &$stack)
        {
        }
        //	function _validateBinaryOperand()
        private function _executeBinaryComparisonOperation($cellID, $operand1, $operand2, $operation, &$stack, $recursingArrays = \FALSE)
        {
        }
        //	function _executeBinaryComparisonOperation()
        /**
         * Compare two strings in the same way as strcmp() except that lowercase come before uppercase letters
         * @param string $str1
         * @param string $str2
         * @return integer
         */
        private function strcmpLowercaseFirst($str1, $str2)
        {
        }
        private function _executeNumericBinaryOperation($cellID, $operand1, $operand2, $operation, $matrixFunction, &$stack)
        {
        }
        //	function _executeNumericBinaryOperation()
        // trigger an error, but nicely, if need be
        protected function _raiseFormulaError($errorMessage)
        {
        }
        //	function _raiseFormulaError()
        /**
         * Extract range values
         *
         * @param	string				&$pRange	String based range representation
         * @param	PHPExcel_Worksheet	$pSheet		Worksheet
         * @param	boolean				$resetLog	Flag indicating whether calculation log should be reset or not
         * @return  mixed				Array of values in range if range contains more than one element. Otherwise, a single value is returned.
         * @throws	PHPExcel_Calculation_Exception
         */
        public function extractCellRange(&$pRange = 'A1', \PHPExcel_Worksheet $pSheet = \NULL, $resetLog = \TRUE)
        {
        }
        //	function extractCellRange()
        /**
         * Extract range values
         *
         * @param	string				&$pRange	String based range representation
         * @param	PHPExcel_Worksheet	$pSheet		Worksheet
         * @return  mixed				Array of values in range if range contains more than one element. Otherwise, a single value is returned.
         * @param	boolean				$resetLog	Flag indicating whether calculation log should be reset or not
         * @throws	PHPExcel_Calculation_Exception
         */
        public function extractNamedRange(&$pRange = 'A1', \PHPExcel_Worksheet $pSheet = \NULL, $resetLog = \TRUE)
        {
        }
        //	function extractNamedRange()
        /**
         * Is a specific function implemented?
         *
         * @param	string	$pFunction	Function Name
         * @return	boolean
         */
        public function isImplemented($pFunction = '')
        {
        }
        //	function isImplemented()
        /**
         * Get a list of all implemented functions as an array of function objects
         *
         * @return	array of PHPExcel_Calculation_Function
         */
        public function listFunctions()
        {
        }
        //	function listFunctions()
        /**
         * Get a list of all Excel function names
         *
         * @return	array
         */
        public function listAllFunctionNames()
        {
        }
        //	function listAllFunctionNames()
        /**
         * Get a list of implemented Excel function names
         *
         * @return	array
         */
        public function listFunctionNames()
        {
        }
        //	function listFunctionNames()
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt    LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Exception
     *
     * @category   PHPExcel
     * @package    PHPExcel
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Exception extends \Exception
    {
        /**
         * Error handler callback
         *
         * @param mixed $code
         * @param mixed $string
         * @param mixed $file
         * @param mixed $line
         * @param mixed $context
         */
        public static function errorHandlerCallback($code, $string, $file, $line, $context)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Reader
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license	http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version	1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Reader_Exception
     *
     * @category   PHPExcel
     * @package    PHPExcel_Reader
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Reader_Exception extends \PHPExcel_Exception
    {
        /**
         * Error handler callback
         *
         * @param mixed $code
         * @param mixed $string
         * @param mixed $file
         * @param mixed $line
         * @param mixed $context
         */
        public static function errorHandlerCallback($code, $string, $file, $line, $context)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Reader_Excel5
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt        LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Reader_Excel5_MD5
     *
     * @category        PHPExcel
     * @package                PHPExcel_Reader_Excel5
     * @copyright        Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Reader_Excel5_MD5
    {
        // Context
        private $a;
        private $b;
        private $c;
        private $d;
        /**
         * MD5 stream constructor
         */
        public function __construct()
        {
        }
        /**
         * Reset the MD5 stream context
         */
        public function reset()
        {
        }
        /**
         * Get MD5 stream context
         * 
         * @return string
         */
        public function getContext()
        {
        }
        /**
         * Add data to context
         * 
         * @param string $data Data to add
         */
        public function add($data)
        {
        }
        private static function F($X, $Y, $Z)
        {
        }
        private static function G($X, $Y, $Z)
        {
        }
        private static function H($X, $Y, $Z)
        {
        }
        private static function I($X, $Y, $Z)
        {
        }
        private static function step($func, &$A, $B, $C, $D, $M, $s, $t)
        {
        }
        private static function rotate($decimal, $bits)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Reader_Excel5
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Reader_Excel5_RC4
     *
     * @category	PHPExcel
     * @package		PHPExcel_Reader_Excel5
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Reader_Excel5_RC4
    {
        // Context
        var $s = array();
        var $i = 0;
        var $j = 0;
        /**
         * RC4 stream decryption/encryption constrcutor
         * 
         * @param string $key Encryption key/passphrase
         */
        public function __construct($key)
        {
        }
        /**
         * Symmetric decryption/encryption function
         * 
         * @param string $data Data to encrypt/decrypt
         * 
         * @return string
         */
        public function RC4($data)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Reader_Excel5
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Reader_Excel5_Escher
     *
     * @category   PHPExcel
     * @package    PHPExcel_Reader_Excel5
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Reader_Excel5_Escher
    {
        const DGGCONTAINER = 0xf000;
        const BSTORECONTAINER = 0xf001;
        const DGCONTAINER = 0xf002;
        const SPGRCONTAINER = 0xf003;
        const SPCONTAINER = 0xf004;
        const DGG = 0xf006;
        const BSE = 0xf007;
        const DG = 0xf008;
        const SPGR = 0xf009;
        const SP = 0xf00a;
        const OPT = 0xf00b;
        const CLIENTTEXTBOX = 0xf00d;
        const CLIENTANCHOR = 0xf010;
        const CLIENTDATA = 0xf011;
        const BLIPJPEG = 0xf01d;
        const BLIPPNG = 0xf01e;
        const SPLITMENUCOLORS = 0xf11e;
        const TERTIARYOPT = 0xf122;
        /**
         * Escher stream data (binary)
         *
         * @var string
         */
        private $_data;
        /**
         * Size in bytes of the Escher stream data
         *
         * @var int
         */
        private $_dataSize;
        /**
         * Current position of stream pointer in Escher stream data
         *
         * @var int
         */
        private $_pos;
        /**
         * The object to be returned by the reader. Modified during load.
         *
         * @var mixed
         */
        private $_object;
        /**
         * Create a new PHPExcel_Reader_Excel5_Escher instance
         *
         * @param mixed $object
         */
        public function __construct($object)
        {
        }
        /**
         * Load Escher stream data. May be a partial Escher stream.
         *
         * @param string $data
         */
        public function load($data)
        {
        }
        /**
         * Read a generic record
         */
        private function _readDefault()
        {
        }
        /**
         * Read DggContainer record (Drawing Group Container)
         */
        private function _readDggContainer()
        {
        }
        /**
         * Read Dgg record (Drawing Group)
         */
        private function _readDgg()
        {
        }
        /**
         * Read BstoreContainer record (Blip Store Container)
         */
        private function _readBstoreContainer()
        {
        }
        /**
         * Read BSE record
         */
        private function _readBSE()
        {
        }
        /**
         * Read BlipJPEG record. Holds raw JPEG image data
         */
        private function _readBlipJPEG()
        {
        }
        /**
         * Read BlipPNG record. Holds raw PNG image data
         */
        private function _readBlipPNG()
        {
        }
        /**
         * Read OPT record. This record may occur within DggContainer record or SpContainer
         */
        private function _readOPT()
        {
        }
        /**
         * Read TertiaryOPT record
         */
        private function _readTertiaryOPT()
        {
        }
        /**
         * Read SplitMenuColors record
         */
        private function _readSplitMenuColors()
        {
        }
        /**
         * Read DgContainer record (Drawing Container)
         */
        private function _readDgContainer()
        {
        }
        /**
         * Read Dg record (Drawing)
         */
        private function _readDg()
        {
        }
        /**
         * Read SpgrContainer record (Shape Group Container)
         */
        private function _readSpgrContainer()
        {
        }
        /**
         * Read SpContainer record (Shape Container)
         */
        private function _readSpContainer()
        {
        }
        /**
         * Read Spgr record (Shape Group)
         */
        private function _readSpgr()
        {
        }
        /**
         * Read Sp record (Shape)
         */
        private function _readSp()
        {
        }
        /**
         * Read ClientTextbox record
         */
        private function _readClientTextbox()
        {
        }
        /**
         * Read ClientAnchor record. This record holds information about where the shape is anchored in worksheet
         */
        private function _readClientAnchor()
        {
        }
        /**
         * Read ClientData record
         */
        private function _readClientData()
        {
        }
        /**
         * Read OfficeArtRGFOPTE table of property-value pairs
         *
         * @param string $data Binary data
         * @param int $n Number of properties
         */
        private function _readOfficeArtRGFOPTE($data, $n)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Reader
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Reader_IReadFilter
     *
     * @category   PHPExcel
     * @package    PHPExcel_Reader
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    interface PHPExcel_Reader_IReadFilter
    {
        /**
         * Should this cell be read?
         *
         * @param 	$column		String column index
         * @param 	$row			Row index
         * @param	$worksheetName	Optional worksheet name
         * @return	boolean
         */
        public function readCell($column, $row, $worksheetName = '');
    }
    /**
     * PHPExcel_Reader_DefaultReadFilter
     *
     * @category   PHPExcel
     * @package    PHPExcel_Reader
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Reader_DefaultReadFilter implements \PHPExcel_Reader_IReadFilter
    {
        /**
         * Should this cell be read?
         *
         * @param 	$column		String column index
         * @param 	$row			Row index
         * @param	$worksheetName	Optional worksheet name
         * @return	boolean
         */
        public function readCell($column, $row, $worksheetName = '')
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Reader
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Reader_IReader
     *
     * @category   PHPExcel
     * @package    PHPExcel_Reader
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    interface PHPExcel_Reader_IReader
    {
        /**
         * Can the current PHPExcel_Reader_IReader read the file?
         *
         * @param 	string 		$pFilename
         * @return 	boolean
         */
        public function canRead($pFilename);
        /**
         * Loads PHPExcel from file
         *
         * @param 	string 		$pFilename
         * @throws 	PHPExcel_Reader_Exception
         */
        public function load($pFilename);
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Reader
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Reader_Abstract
     *
     * @category	PHPExcel
     * @package	PHPExcel_Reader
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    abstract class PHPExcel_Reader_Abstract implements \PHPExcel_Reader_IReader
    {
        /**
         * Read data only?
         * Identifies whether the Reader should only read data values for cells, and ignore any formatting information;
         *		or whether it should read both data and formatting
         *
         * @var	boolean
         */
        protected $_readDataOnly = \FALSE;
        /**
         * Read charts that are defined in the workbook?
         * Identifies whether the Reader should read the definitions for any charts that exist in the workbook;
         *
         * @var	boolean
         */
        protected $_includeCharts = \FALSE;
        /**
         * Restrict which sheets should be loaded?
         * This property holds an array of worksheet names to be loaded. If null, then all worksheets will be loaded.
         *
         * @var array of string
         */
        protected $_loadSheetsOnly = \NULL;
        /**
         * PHPExcel_Reader_IReadFilter instance
         *
         * @var PHPExcel_Reader_IReadFilter
         */
        protected $_readFilter = \NULL;
        protected $_fileHandle = \NULL;
        /**
         * Read data only?
         *		If this is true, then the Reader will only read data values for cells, it will not read any formatting information.
         *		If false (the default) it will read data and formatting.
         *
         * @return	boolean
         */
        public function getReadDataOnly()
        {
        }
        /**
         * Set read data only
         *		Set to true, to advise the Reader only to read data values for cells, and to ignore any formatting information.
         *		Set to false (the default) to advise the Reader to read both data and formatting for cells.
         *
         * @param	boolean	$pValue
         *
         * @return	PHPExcel_Reader_IReader
         */
        public function setReadDataOnly($pValue = \FALSE)
        {
        }
        /**
         * Read charts in workbook?
         *		If this is true, then the Reader will include any charts that exist in the workbook.
         *      Note that a ReadDataOnly value of false overrides, and charts won't be read regardless of the IncludeCharts value.
         *		If false (the default) it will ignore any charts defined in the workbook file.
         *
         * @return	boolean
         */
        public function getIncludeCharts()
        {
        }
        /**
         * Set read charts in workbook
         *		Set to true, to advise the Reader to include any charts that exist in the workbook.
         *      Note that a ReadDataOnly value of false overrides, and charts won't be read regardless of the IncludeCharts value.
         *		Set to false (the default) to discard charts.
         *
         * @param	boolean	$pValue
         *
         * @return	PHPExcel_Reader_IReader
         */
        public function setIncludeCharts($pValue = \FALSE)
        {
        }
        /**
         * Get which sheets to load
         * Returns either an array of worksheet names (the list of worksheets that should be loaded), or a null
         *		indicating that all worksheets in the workbook should be loaded.
         *
         * @return mixed
         */
        public function getLoadSheetsOnly()
        {
        }
        /**
         * Set which sheets to load
         *
         * @param mixed $value
         *		This should be either an array of worksheet names to be loaded, or a string containing a single worksheet name.
         *		If NULL, then it tells the Reader to read all worksheets in the workbook
         *
         * @return PHPExcel_Reader_IReader
         */
        public function setLoadSheetsOnly($value = \NULL)
        {
        }
        /**
         * Set all sheets to load
         *		Tells the Reader to load all worksheets from the workbook.
         *
         * @return PHPExcel_Reader_IReader
         */
        public function setLoadAllSheets()
        {
        }
        /**
         * Read filter
         *
         * @return PHPExcel_Reader_IReadFilter
         */
        public function getReadFilter()
        {
        }
        /**
         * Set read filter
         *
         * @param PHPExcel_Reader_IReadFilter $pValue
         * @return PHPExcel_Reader_IReader
         */
        public function setReadFilter(\PHPExcel_Reader_IReadFilter $pValue)
        {
        }
        /**
         * Open file for reading
         *
         * @param string $pFilename
         * @throws	PHPExcel_Reader_Exception
         * @return resource
         */
        protected function _openFile($pFilename)
        {
        }
        /**
         * Can the current PHPExcel_Reader_IReader read the file?
         *
         * @param 	string 		$pFilename
         * @return boolean
         * @throws PHPExcel_Reader_Exception
         */
        public function canRead($pFilename)
        {
        }
    }
    /**
     * PHPExcel_Reader_Excel5
     *
     * This class uses {@link http://sourceforge.net/projects/phpexcelreader/parseXL}
     *
     * @category	PHPExcel
     * @package		PHPExcel_Reader_Excel5
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Reader_Excel5 extends \PHPExcel_Reader_Abstract implements \PHPExcel_Reader_IReader
    {
        // ParseXL definitions
        const XLS_BIFF8 = 0x600;
        const XLS_BIFF7 = 0x500;
        const XLS_WorkbookGlobals = 0x5;
        const XLS_Worksheet = 0x10;
        // record identifiers
        const XLS_Type_FORMULA = 0x6;
        const XLS_Type_EOF = 0xa;
        const XLS_Type_PROTECT = 0x12;
        const XLS_Type_OBJECTPROTECT = 0x63;
        const XLS_Type_SCENPROTECT = 0xdd;
        const XLS_Type_PASSWORD = 0x13;
        const XLS_Type_HEADER = 0x14;
        const XLS_Type_FOOTER = 0x15;
        const XLS_Type_EXTERNSHEET = 0x17;
        const XLS_Type_DEFINEDNAME = 0x18;
        const XLS_Type_VERTICALPAGEBREAKS = 0x1a;
        const XLS_Type_HORIZONTALPAGEBREAKS = 0x1b;
        const XLS_Type_NOTE = 0x1c;
        const XLS_Type_SELECTION = 0x1d;
        const XLS_Type_DATEMODE = 0x22;
        const XLS_Type_EXTERNNAME = 0x23;
        const XLS_Type_LEFTMARGIN = 0x26;
        const XLS_Type_RIGHTMARGIN = 0x27;
        const XLS_Type_TOPMARGIN = 0x28;
        const XLS_Type_BOTTOMMARGIN = 0x29;
        const XLS_Type_PRINTGRIDLINES = 0x2b;
        const XLS_Type_FILEPASS = 0x2f;
        const XLS_Type_FONT = 0x31;
        const XLS_Type_CONTINUE = 0x3c;
        const XLS_Type_PANE = 0x41;
        const XLS_Type_CODEPAGE = 0x42;
        const XLS_Type_DEFCOLWIDTH = 0x55;
        const XLS_Type_OBJ = 0x5d;
        const XLS_Type_COLINFO = 0x7d;
        const XLS_Type_IMDATA = 0x7f;
        const XLS_Type_SHEETPR = 0x81;
        const XLS_Type_HCENTER = 0x83;
        const XLS_Type_VCENTER = 0x84;
        const XLS_Type_SHEET = 0x85;
        const XLS_Type_PALETTE = 0x92;
        const XLS_Type_SCL = 0xa0;
        const XLS_Type_PAGESETUP = 0xa1;
        const XLS_Type_MULRK = 0xbd;
        const XLS_Type_MULBLANK = 0xbe;
        const XLS_Type_DBCELL = 0xd7;
        const XLS_Type_XF = 0xe0;
        const XLS_Type_MERGEDCELLS = 0xe5;
        const XLS_Type_MSODRAWINGGROUP = 0xeb;
        const XLS_Type_MSODRAWING = 0xec;
        const XLS_Type_SST = 0xfc;
        const XLS_Type_LABELSST = 0xfd;
        const XLS_Type_EXTSST = 0xff;
        const XLS_Type_EXTERNALBOOK = 0x1ae;
        const XLS_Type_DATAVALIDATIONS = 0x1b2;
        const XLS_Type_TXO = 0x1b6;
        const XLS_Type_HYPERLINK = 0x1b8;
        const XLS_Type_DATAVALIDATION = 0x1be;
        const XLS_Type_DIMENSION = 0x200;
        const XLS_Type_BLANK = 0x201;
        const XLS_Type_NUMBER = 0x203;
        const XLS_Type_LABEL = 0x204;
        const XLS_Type_BOOLERR = 0x205;
        const XLS_Type_STRING = 0x207;
        const XLS_Type_ROW = 0x208;
        const XLS_Type_INDEX = 0x20b;
        const XLS_Type_ARRAY = 0x221;
        const XLS_Type_DEFAULTROWHEIGHT = 0x225;
        const XLS_Type_WINDOW2 = 0x23e;
        const XLS_Type_RK = 0x27e;
        const XLS_Type_STYLE = 0x293;
        const XLS_Type_FORMAT = 0x41e;
        const XLS_Type_SHAREDFMLA = 0x4bc;
        const XLS_Type_BOF = 0x809;
        const XLS_Type_SHEETPROTECTION = 0x867;
        const XLS_Type_RANGEPROTECTION = 0x868;
        const XLS_Type_SHEETLAYOUT = 0x862;
        const XLS_Type_XFEXT = 0x87d;
        const XLS_Type_PAGELAYOUTVIEW = 0x88b;
        const XLS_Type_UNKNOWN = 0xffff;
        // Encryption type
        const MS_BIFF_CRYPTO_NONE = 0;
        const MS_BIFF_CRYPTO_XOR = 1;
        const MS_BIFF_CRYPTO_RC4 = 2;
        // Size of stream blocks when using RC4 encryption
        const REKEY_BLOCK = 0x400;
        /**
         * Summary Information stream data.
         *
         * @var string
         */
        private $_summaryInformation;
        /**
         * Extended Summary Information stream data.
         *
         * @var string
         */
        private $_documentSummaryInformation;
        /**
         * User-Defined Properties stream data.
         *
         * @var string
         */
        private $_userDefinedProperties;
        /**
         * Workbook stream data. (Includes workbook globals substream as well as sheet substreams)
         *
         * @var string
         */
        private $_data;
        /**
         * Size in bytes of $this->_data
         *
         * @var int
         */
        private $_dataSize;
        /**
         * Current position in stream
         *
         * @var integer
         */
        private $_pos;
        /**
         * Workbook to be returned by the reader.
         *
         * @var PHPExcel
         */
        private $_phpExcel;
        /**
         * Worksheet that is currently being built by the reader.
         *
         * @var PHPExcel_Worksheet
         */
        private $_phpSheet;
        /**
         * BIFF version
         *
         * @var int
         */
        private $_version;
        /**
         * Codepage set in the Excel file being read. Only important for BIFF5 (Excel 5.0 - Excel 95)
         * For BIFF8 (Excel 97 - Excel 2003) this will always have the value 'UTF-16LE'
         *
         * @var string
         */
        private $_codepage;
        /**
         * Shared formats
         *
         * @var array
         */
        private $_formats;
        /**
         * Shared fonts
         *
         * @var array
         */
        private $_objFonts;
        /**
         * Color palette
         *
         * @var array
         */
        private $_palette;
        /**
         * Worksheets
         *
         * @var array
         */
        private $_sheets;
        /**
         * External books
         *
         * @var array
         */
        private $_externalBooks;
        /**
         * REF structures. Only applies to BIFF8.
         *
         * @var array
         */
        private $_ref;
        /**
         * External names
         *
         * @var array
         */
        private $_externalNames;
        /**
         * Defined names
         *
         * @var array
         */
        private $_definedname;
        /**
         * Shared strings. Only applies to BIFF8.
         *
         * @var array
         */
        private $_sst;
        /**
         * Panes are frozen? (in sheet currently being read). See WINDOW2 record.
         *
         * @var boolean
         */
        private $_frozen;
        /**
         * Fit printout to number of pages? (in sheet currently being read). See SHEETPR record.
         *
         * @var boolean
         */
        private $_isFitToPages;
        /**
         * Objects. One OBJ record contributes with one entry.
         *
         * @var array
         */
        private $_objs;
        /**
         * Text Objects. One TXO record corresponds with one entry.
         *
         * @var array
         */
        private $_textObjects;
        /**
         * Cell Annotations (BIFF8)
         *
         * @var array
         */
        private $_cellNotes;
        /**
         * The combined MSODRAWINGGROUP data
         *
         * @var string
         */
        private $_drawingGroupData;
        /**
         * The combined MSODRAWING data (per sheet)
         *
         * @var string
         */
        private $_drawingData;
        /**
         * Keep track of XF index
         *
         * @var int
         */
        private $_xfIndex;
        /**
         * Mapping of XF index (that is a cell XF) to final index in cellXf collection
         *
         * @var array
         */
        private $_mapCellXfIndex;
        /**
         * Mapping of XF index (that is a style XF) to final index in cellStyleXf collection
         *
         * @var array
         */
        private $_mapCellStyleXfIndex;
        /**
         * The shared formulas in a sheet. One SHAREDFMLA record contributes with one value.
         *
         * @var array
         */
        private $_sharedFormulas;
        /**
         * The shared formula parts in a sheet. One FORMULA record contributes with one value if it
         * refers to a shared formula.
         *
         * @var array
         */
        private $_sharedFormulaParts;
        /**
         * The type of encryption in use
         *
         * @var int	
         */
        private $_encryption = 0;
        /**
         * The position in the stream after which contents are encrypted
         *
         * @var int
         */
        private $_encryptionStartPos = \false;
        /**
         * The current RC4 decryption object
         *
         * @var PHPExcel_Reader_Excel5_RC4
         */
        private $_rc4Key = \null;
        /**
         * The position in the stream that the RC4 decryption object was left at
         *
         * @var int
         */
        private $_rc4Pos = 0;
        /**
         * The current MD5 context state
         *
         * @var string
         */
        private $_md5Ctxt = \null;
        /**
         * Create a new PHPExcel_Reader_Excel5 instance
         */
        public function __construct()
        {
        }
        /**
         * Can the current PHPExcel_Reader_IReader read the file?
         *
         * @param 	string 		$pFilename
         * @return 	boolean
         * @throws PHPExcel_Reader_Exception
         */
        public function canRead($pFilename)
        {
        }
        /**
         * Reads names of the worksheets from a file, without parsing the whole file to a PHPExcel object
         *
         * @param 	string 		$pFilename
         * @throws 	PHPExcel_Reader_Exception
         */
        public function listWorksheetNames($pFilename)
        {
        }
        /**
         * Return worksheet info (Name, Last Column Letter, Last Column Index, Total Rows, Total Columns)
         *
         * @param   string     $pFilename
         * @throws   PHPExcel_Reader_Exception
         */
        public function listWorksheetInfo($pFilename)
        {
        }
        /**
         * Loads PHPExcel from file
         *
         * @param 	string 		$pFilename
         * @return 	PHPExcel
         * @throws 	PHPExcel_Reader_Exception
         */
        public function load($pFilename)
        {
        }
        /**
         * Read record data from stream, decrypting as required
         * 
         * @param string $data   Data stream to read from
         * @param int    $pos    Position to start reading from
         * @param int    $length Record data length
         * 
         * @return string Record data
         */
        private function _readRecordData($data, $pos, $len)
        {
        }
        /**
         * Use OLE reader to extract the relevant data streams from the OLE file
         *
         * @param string $pFilename
         */
        private function _loadOLE($pFilename)
        {
        }
        /**
         * Read summary information
         */
        private function _readSummaryInformation()
        {
        }
        /**
         * Read additional document summary information
         */
        private function _readDocumentSummaryInformation()
        {
        }
        /**
         * Reads a general type of BIFF record. Does nothing except for moving stream pointer forward to next record.
         */
        private function _readDefault()
        {
        }
        /**
         *	The NOTE record specifies a comment associated with a particular cell. In Excel 95 (BIFF7) and earlier versions,
         *		this record stores a note (cell note). This feature was significantly enhanced in Excel 97.
         */
        private function _readNote()
        {
        }
        /**
         *	The TEXT Object record contains the text associated with a cell annotation.
         */
        private function _readTextObject()
        {
        }
        /**
         * Read BOF
         */
        private function _readBof()
        {
        }
        /**
         * FILEPASS
         *
         * This record is part of the File Protection Block. It
         * contains information about the read/write password of the
         * file. All record contents following this record will be
         * encrypted.
         *
         * --	"OpenOffice.org's Documentation of the Microsoft
         * 		Excel File Format"
         * 
         * The decryption functions and objects used from here on in
         * are based on the source of Spreadsheet-ParseExcel:
         * http://search.cpan.org/~jmcnamara/Spreadsheet-ParseExcel/
         */
        private function _readFilepass()
        {
        }
        /**
         * Make an RC4 decryptor for the given block
         * 
         * @var int    $block      Block for which to create decrypto
         * @var string $valContext MD5 context state
         * 
         * @return PHPExcel_Reader_Excel5_RC4
         */
        private function _makeKey($block, $valContext)
        {
        }
        /**
         * Verify RC4 file password
         * 
         * @var string $password        Password to check
         * @var string $docid           Document id
         * @var string $salt_data       Salt data
         * @var string $hashedsalt_data Hashed salt data
         * @var string &$valContext     Set to the MD5 context of the value
         * 
         * @return bool Success
         */
        private function _verifyPassword($password, $docid, $salt_data, $hashedsalt_data, &$valContext)
        {
        }
        /**
         * CODEPAGE
         *
         * This record stores the text encoding used to write byte
         * strings, stored as MS Windows code page identifier.
         *
         * --	"OpenOffice.org's Documentation of the Microsoft
         * 		Excel File Format"
         */
        private function _readCodepage()
        {
        }
        /**
         * DATEMODE
         *
         * This record specifies the base date for displaying date
         * values. All dates are stored as count of days past this
         * base date. In BIFF2-BIFF4 this record is part of the
         * Calculation Settings Block. In BIFF5-BIFF8 it is
         * stored in the Workbook Globals Substream.
         *
         * --	"OpenOffice.org's Documentation of the Microsoft
         * 		Excel File Format"
         */
        private function _readDateMode()
        {
        }
        /**
         * Read a FONT record
         */
        private function _readFont()
        {
        }
        /**
         * FORMAT
         *
         * This record contains information about a number format.
         * All FORMAT records occur together in a sequential list.
         *
         * In BIFF2-BIFF4 other records referencing a FORMAT record
         * contain a zero-based index into this list. From BIFF5 on
         * the FORMAT record contains the index itself that will be
         * used by other records.
         *
         * --	"OpenOffice.org's Documentation of the Microsoft
         * 		Excel File Format"
         */
        private function _readFormat()
        {
        }
        /**
         * XF - Extended Format
         *
         * This record contains formatting information for cells, rows, columns or styles.
         * According to http://support.microsoft.com/kb/147732 there are always at least 15 cell style XF
         * and 1 cell XF.
         * Inspection of Excel files generated by MS Office Excel shows that XF records 0-14 are cell style XF
         * and XF record 15 is a cell XF
         * We only read the first cell style XF and skip the remaining cell style XF records
         * We read all cell XF records.
         *
         * --	"OpenOffice.org's Documentation of the Microsoft
         * 		Excel File Format"
         */
        private function _readXf()
        {
        }
        /**
         *
         */
        private function _readXfExt()
        {
        }
        /**
         * Read STYLE record
         */
        private function _readStyle()
        {
        }
        /**
         * Read PALETTE record
         */
        private function _readPalette()
        {
        }
        /**
         * SHEET
         *
         * This record is  located in the  Workbook Globals
         * Substream  and represents a sheet inside the workbook.
         * One SHEET record is written for each sheet. It stores the
         * sheet name and a stream offset to the BOF record of the
         * respective Sheet Substream within the Workbook Stream.
         *
         * --	"OpenOffice.org's Documentation of the Microsoft
         * 		Excel File Format"
         */
        private function _readSheet()
        {
        }
        /**
         * Read EXTERNALBOOK record
         */
        private function _readExternalBook()
        {
        }
        /**
         * Read EXTERNNAME record.
         */
        private function _readExternName()
        {
        }
        /**
         * Read EXTERNSHEET record
         */
        private function _readExternSheet()
        {
        }
        /**
         * DEFINEDNAME
         *
         * This record is part of a Link Table. It contains the name
         * and the token array of an internal defined name. Token
         * arrays of defined names contain tokens with aberrant
         * token classes.
         *
         * --	"OpenOffice.org's Documentation of the Microsoft
         * 		Excel File Format"
         */
        private function _readDefinedName()
        {
        }
        /**
         * Read MSODRAWINGGROUP record
         */
        private function _readMsoDrawingGroup()
        {
        }
        /**
         * SST - Shared String Table
         *
         * This record contains a list of all strings used anywhere
         * in the workbook. Each string occurs only once. The
         * workbook uses indexes into the list to reference the
         * strings.
         *
         * --	"OpenOffice.org's Documentation of the Microsoft
         * 		Excel File Format"
         **/
        private function _readSst()
        {
        }
        /**
         * Read PRINTGRIDLINES record
         */
        private function _readPrintGridlines()
        {
        }
        /**
         * Read DEFAULTROWHEIGHT record
         */
        private function _readDefaultRowHeight()
        {
        }
        /**
         * Read SHEETPR record
         */
        private function _readSheetPr()
        {
        }
        /**
         * Read HORIZONTALPAGEBREAKS record
         */
        private function _readHorizontalPageBreaks()
        {
        }
        /**
         * Read VERTICALPAGEBREAKS record
         */
        private function _readVerticalPageBreaks()
        {
        }
        /**
         * Read HEADER record
         */
        private function _readHeader()
        {
        }
        /**
         * Read FOOTER record
         */
        private function _readFooter()
        {
        }
        /**
         * Read HCENTER record
         */
        private function _readHcenter()
        {
        }
        /**
         * Read VCENTER record
         */
        private function _readVcenter()
        {
        }
        /**
         * Read LEFTMARGIN record
         */
        private function _readLeftMargin()
        {
        }
        /**
         * Read RIGHTMARGIN record
         */
        private function _readRightMargin()
        {
        }
        /**
         * Read TOPMARGIN record
         */
        private function _readTopMargin()
        {
        }
        /**
         * Read BOTTOMMARGIN record
         */
        private function _readBottomMargin()
        {
        }
        /**
         * Read PAGESETUP record
         */
        private function _readPageSetup()
        {
        }
        /**
         * PROTECT - Sheet protection (BIFF2 through BIFF8)
         *   if this record is omitted, then it also means no sheet protection
         */
        private function _readProtect()
        {
        }
        /**
         * SCENPROTECT
         */
        private function _readScenProtect()
        {
        }
        /**
         * OBJECTPROTECT
         */
        private function _readObjectProtect()
        {
        }
        /**
         * PASSWORD - Sheet protection (hashed) password (BIFF2 through BIFF8)
         */
        private function _readPassword()
        {
        }
        /**
         * Read DEFCOLWIDTH record
         */
        private function _readDefColWidth()
        {
        }
        /**
         * Read COLINFO record
         */
        private function _readColInfo()
        {
        }
        /**
         * ROW
         *
         * This record contains the properties of a single row in a
         * sheet. Rows and cells in a sheet are divided into blocks
         * of 32 rows.
         *
         * --	"OpenOffice.org's Documentation of the Microsoft
         * 		Excel File Format"
         */
        private function _readRow()
        {
        }
        /**
         * Read RK record
         * This record represents a cell that contains an RK value
         * (encoded integer or floating-point value). If a
         * floating-point value cannot be encoded to an RK value,
         * a NUMBER record will be written. This record replaces the
         * record INTEGER written in BIFF2.
         *
         * --	"OpenOffice.org's Documentation of the Microsoft
         * 		Excel File Format"
         */
        private function _readRk()
        {
        }
        /**
         * Read LABELSST record
         * This record represents a cell that contains a string. It
         * replaces the LABEL record and RSTRING record used in
         * BIFF2-BIFF5.
         *
         * --	"OpenOffice.org's Documentation of the Microsoft
         * 		Excel File Format"
         */
        private function _readLabelSst()
        {
        }
        /**
         * Read MULRK record
         * This record represents a cell range containing RK value
         * cells. All cells are located in the same row.
         *
         * --	"OpenOffice.org's Documentation of the Microsoft
         * 		Excel File Format"
         */
        private function _readMulRk()
        {
        }
        /**
         * Read NUMBER record
         * This record represents a cell that contains a
         * floating-point value.
         *
         * --	"OpenOffice.org's Documentation of the Microsoft
         * 		Excel File Format"
         */
        private function _readNumber()
        {
        }
        /**
         * Read FORMULA record + perhaps a following STRING record if formula result is a string
         * This record contains the token array and the result of a
         * formula cell.
         *
         * --	"OpenOffice.org's Documentation of the Microsoft
         * 		Excel File Format"
         */
        private function _readFormula()
        {
        }
        /**
         * Read a SHAREDFMLA record. This function just stores the binary shared formula in the reader,
         * which usually contains relative references.
         * These will be used to construct the formula in each shared formula part after the sheet is read.
         */
        private function _readSharedFmla()
        {
        }
        /**
         * Read a STRING record from current stream position and advance the stream pointer to next record
         * This record is used for storing result from FORMULA record when it is a string, and
         * it occurs directly after the FORMULA record
         *
         * @return string The string contents as UTF-8
         */
        private function _readString()
        {
        }
        /**
         * Read BOOLERR record
         * This record represents a Boolean value or error value
         * cell.
         *
         * --	"OpenOffice.org's Documentation of the Microsoft
         * 		Excel File Format"
         */
        private function _readBoolErr()
        {
        }
        /**
         * Read MULBLANK record
         * This record represents a cell range of empty cells. All
         * cells are located in the same row
         *
         * --	"OpenOffice.org's Documentation of the Microsoft
         * 		Excel File Format"
         */
        private function _readMulBlank()
        {
        }
        /**
         * Read LABEL record
         * This record represents a cell that contains a string. In
         * BIFF8 it is usually replaced by the LABELSST record.
         * Excel still uses this record, if it copies unformatted
         * text cells to the clipboard.
         *
         * --	"OpenOffice.org's Documentation of the Microsoft
         * 		Excel File Format"
         */
        private function _readLabel()
        {
        }
        /**
         * Read BLANK record
         */
        private function _readBlank()
        {
        }
        /**
         * Read MSODRAWING record
         */
        private function _readMsoDrawing()
        {
        }
        /**
         * Read OBJ record
         */
        private function _readObj()
        {
        }
        /**
         * Read WINDOW2 record
         */
        private function _readWindow2()
        {
        }
        /**
         * Read PLV Record(Created by Excel2007 or upper)
         */
        private function _readPageLayoutView()
        {
        }
        /**
         * Read SCL record
         */
        private function _readScl()
        {
        }
        /**
         * Read PANE record
         */
        private function _readPane()
        {
        }
        /**
         * Read SELECTION record. There is one such record for each pane in the sheet.
         */
        private function _readSelection()
        {
        }
        private function _includeCellRangeFiltered($cellRangeAddress)
        {
        }
        /**
         * MERGEDCELLS
         *
         * This record contains the addresses of merged cell ranges
         * in the current sheet.
         *
         * --	"OpenOffice.org's Documentation of the Microsoft
         * 		Excel File Format"
         */
        private function _readMergedCells()
        {
        }
        /**
         * Read HYPERLINK record
         */
        private function _readHyperLink()
        {
        }
        /**
         * Read DATAVALIDATIONS record
         */
        private function _readDataValidations()
        {
        }
        /**
         * Read DATAVALIDATION record
         */
        private function _readDataValidation()
        {
        }
        /**
         * Read SHEETLAYOUT record. Stores sheet tab color information.
         */
        private function _readSheetLayout()
        {
        }
        /**
         * Read SHEETPROTECTION record (FEATHEADR)
         */
        private function _readSheetProtection()
        {
        }
        /**
         * Read RANGEPROTECTION record
         * Reading of this record is based on Microsoft Office Excel 97-2000 Binary File Format Specification,
         * where it is referred to as FEAT record
         */
        private function _readRangeProtection()
        {
        }
        /**
         * Read IMDATA record
         */
        private function _readImData()
        {
        }
        /**
         * Read a free CONTINUE record. Free CONTINUE record may be a camouflaged MSODRAWING record
         * When MSODRAWING data on a sheet exceeds 8224 bytes, CONTINUE records are used instead. Undocumented.
         * In this case, we must treat the CONTINUE record as a MSODRAWING record
         */
        private function _readContinue()
        {
        }
        /**
         * Reads a record from current position in data stream and continues reading data as long as CONTINUE
         * records are found. Splices the record data pieces and returns the combined string as if record data
         * is in one piece.
         * Moves to next current position in data stream to start of next record different from a CONtINUE record
         *
         * @return array
         */
        private function _getSplicedRecordData()
        {
        }
        /**
         * Convert formula structure into human readable Excel formula like 'A3+A5*5'
         *
         * @param string $formulaStructure The complete binary data for the formula
         * @param string $baseCell Base cell, only needed when formula contains tRefN tokens, e.g. with shared formulas
         * @return string Human readable formula
         */
        private function _getFormulaFromStructure($formulaStructure, $baseCell = 'A1')
        {
        }
        /**
         * Take formula data and additional data for formula and return human readable formula
         *
         * @param string $formulaData The binary data for the formula itself
         * @param string $additionalData Additional binary data going with the formula
         * @param string $baseCell Base cell, only needed when formula contains tRefN tokens, e.g. with shared formulas
         * @return string Human readable formula
         */
        private function _getFormulaFromData($formulaData, $additionalData = '', $baseCell = 'A1')
        {
        }
        /**
         * Take array of tokens together with additional data for formula and return human readable formula
         *
         * @param array $tokens
         * @param array $additionalData Additional binary data going with the formula
         * @param string $baseCell Base cell, only needed when formula contains tRefN tokens, e.g. with shared formulas
         * @return string Human readable formula
         */
        private function _createFormulaFromTokens($tokens, $additionalData)
        {
        }
        /**
         * Fetch next token from binary formula data
         *
         * @param string Formula data
         * @param string $baseCell Base cell, only needed when formula contains tRefN tokens, e.g. with shared formulas
         * @return array
         * @throws PHPExcel_Reader_Exception
         */
        private function _getNextToken($formulaData, $baseCell = 'A1')
        {
        }
        /**
         * Reads a cell address in BIFF8 e.g. 'A2' or '$A$2'
         * section 3.3.4
         *
         * @param string $cellAddressStructure
         * @return string
         */
        private function _readBIFF8CellAddress($cellAddressStructure)
        {
        }
        /**
         * Reads a cell address in BIFF8 for shared formulas. Uses positive and negative values for row and column
         * to indicate offsets from a base cell
         * section 3.3.4
         *
         * @param string $cellAddressStructure
         * @param string $baseCell Base cell, only needed when formula contains tRefN tokens, e.g. with shared formulas
         * @return string
         */
        private function _readBIFF8CellAddressB($cellAddressStructure, $baseCell = 'A1')
        {
        }
        /**
         * Reads a cell range address in BIFF5 e.g. 'A2:B6' or 'A1'
         * always fixed range
         * section 2.5.14
         *
         * @param string $subData
         * @return string
         * @throws PHPExcel_Reader_Exception
         */
        private function _readBIFF5CellRangeAddressFixed($subData)
        {
        }
        /**
         * Reads a cell range address in BIFF8 e.g. 'A2:B6' or 'A1'
         * always fixed range
         * section 2.5.14
         *
         * @param string $subData
         * @return string
         * @throws PHPExcel_Reader_Exception
         */
        private function _readBIFF8CellRangeAddressFixed($subData)
        {
        }
        /**
         * Reads a cell range address in BIFF8 e.g. 'A2:B6' or '$A$2:$B$6'
         * there are flags indicating whether column/row index is relative
         * section 3.3.4
         *
         * @param string $subData
         * @return string
         */
        private function _readBIFF8CellRangeAddress($subData)
        {
        }
        /**
         * Reads a cell range address in BIFF8 for shared formulas. Uses positive and negative values for row and column
         * to indicate offsets from a base cell
         * section 3.3.4
         *
         * @param string $subData
         * @param string $baseCell Base cell
         * @return string Cell range address
         */
        private function _readBIFF8CellRangeAddressB($subData, $baseCell = 'A1')
        {
        }
        /**
         * Read BIFF8 cell range address list
         * section 2.5.15
         *
         * @param string $subData
         * @return array
         */
        private function _readBIFF8CellRangeAddressList($subData)
        {
        }
        /**
         * Read BIFF5 cell range address list
         * section 2.5.15
         *
         * @param string $subData
         * @return array
         */
        private function _readBIFF5CellRangeAddressList($subData)
        {
        }
        /**
         * Get a sheet range like Sheet1:Sheet3 from REF index
         * Note: If there is only one sheet in the range, one gets e.g Sheet1
         * It can also happen that the REF structure uses the -1 (FFFF) code to indicate deleted sheets,
         * in which case an PHPExcel_Reader_Exception is thrown
         *
         * @param int $index
         * @return string|false
         * @throws PHPExcel_Reader_Exception
         */
        private function _readSheetRangeByRefIndex($index)
        {
        }
        /**
         * read BIFF8 constant value array from array data
         * returns e.g. array('value' => '{1,2;3,4}', 'size' => 40}
         * section 2.5.8
         *
         * @param string $arrayData
         * @return array
         */
        private static function _readBIFF8ConstantArray($arrayData)
        {
        }
        /**
         * read BIFF8 constant value which may be 'Empty Value', 'Number', 'String Value', 'Boolean Value', 'Error Value'
         * section 2.5.7
         * returns e.g. array('value' => '5', 'size' => 9)
         *
         * @param string $valueData
         * @return array
         */
        private static function _readBIFF8Constant($valueData)
        {
        }
        /**
         * Extract RGB color
         * OpenOffice.org's Documentation of the Microsoft Excel File Format, section 2.5.4
         *
         * @param string $rgb Encoded RGB value (4 bytes)
         * @return array
         */
        private static function _readRGB($rgb)
        {
        }
        /**
         * Read byte string (8-bit string length)
         * OpenOffice documentation: 2.5.2
         *
         * @param string $subData
         * @return array
         */
        private function _readByteStringShort($subData)
        {
        }
        /**
         * Read byte string (16-bit string length)
         * OpenOffice documentation: 2.5.2
         *
         * @param string $subData
         * @return array
         */
        private function _readByteStringLong($subData)
        {
        }
        /**
         * Extracts an Excel Unicode short string (8-bit string length)
         * OpenOffice documentation: 2.5.3
         * function will automatically find out where the Unicode string ends.
         *
         * @param string $subData
         * @return array
         */
        private static function _readUnicodeStringShort($subData)
        {
        }
        /**
         * Extracts an Excel Unicode long string (16-bit string length)
         * OpenOffice documentation: 2.5.3
         * this function is under construction, needs to support rich text, and Asian phonetic settings
         *
         * @param string $subData
         * @return array
         */
        private static function _readUnicodeStringLong($subData)
        {
        }
        /**
         * Read Unicode string with no string length field, but with known character count
         * this function is under construction, needs to support rich text, and Asian phonetic settings
         * OpenOffice.org's Documentation of the Microsoft Excel File Format, section 2.5.3
         *
         * @param string $subData
         * @param int $characterCount
         * @return array
         */
        private static function _readUnicodeString($subData, $characterCount)
        {
        }
        /**
         * Convert UTF-8 string to string surounded by double quotes. Used for explicit string tokens in formulas.
         * Example:  hello"world  -->  "hello""world"
         *
         * @param string $value UTF-8 encoded string
         * @return string
         */
        private static function _UTF8toExcelDoubleQuoted($value)
        {
        }
        /**
         * Reads first 8 bytes of a string and return IEEE 754 float
         *
         * @param string $data Binary string that is at least 8 bytes long
         * @return float
         */
        private static function _extractNumber($data)
        {
        }
        private static function _GetIEEE754($rknum)
        {
        }
        /**
         * Get UTF-8 string from (compressed or uncompressed) UTF-16 string
         *
         * @param string $string
         * @param bool $compressed
         * @return string
         */
        private static function _encodeUTF16($string, $compressed = '')
        {
        }
        /**
         * Convert UTF-16 string in compressed notation to uncompressed form. Only used for BIFF8.
         *
         * @param string $string
         * @return string
         */
        private static function _uncompressByteString($string)
        {
        }
        /**
         * Convert string to UTF-8. Only used for BIFF5.
         *
         * @param string $string
         * @return string
         */
        private function _decodeCodepage($string)
        {
        }
        /**
         * Read 16-bit unsigned integer
         *
         * @param string $data
         * @param int $pos
         * @return int
         */
        public static function _GetInt2d($data, $pos)
        {
        }
        /**
         * Read 32-bit signed integer
         *
         * @param string $data
         * @param int $pos
         * @return int
         */
        public static function _GetInt4d($data, $pos)
        {
        }
        /**
         * Read color
         *
         * @param int $color Indexed color
         * @param array $palette Color palette
         * @return array RGB color value, example: array('rgb' => 'FF0000')
         */
        private static function _readColor($color, $palette, $version)
        {
        }
        /**
         * Map border style
         * OpenOffice documentation: 2.5.11
         *
         * @param int $index
         * @return string
         */
        private static function _mapBorderStyle($index)
        {
        }
        /**
         * Get fill pattern from index
         * OpenOffice documentation: 2.5.12
         *
         * @param int $index
         * @return string
         */
        private static function _mapFillPattern($index)
        {
        }
        /**
         * Map error code, e.g. '#N/A'
         *
         * @param int $subData
         * @return string
         */
        private static function _mapErrorCode($subData)
        {
        }
        /**
         * Map built-in color to RGB value
         *
         * @param int $color Indexed color
         * @return array
         */
        private static function _mapBuiltInColor($color)
        {
        }
        /**
         * Map color array from BIFF5 built-in color index
         *
         * @param int $subData
         * @return array
         */
        private static function _mapColorBIFF5($subData)
        {
        }
        /**
         * Map color array from BIFF8 built-in color index
         *
         * @param int $subData
         * @return array
         */
        private static function _mapColor($subData)
        {
        }
        private function _parseRichText($is = '')
        {
        }
    }
    /**
     * PHPExcel_Reader_Excel2003XML
     *
     * @category   PHPExcel
     * @package    PHPExcel_Reader
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Reader_Excel2003XML extends \PHPExcel_Reader_Abstract implements \PHPExcel_Reader_IReader
    {
        /**
         * Formats
         *
         * @var array
         */
        private $_styles = array();
        /**
         * Character set used in the file
         *
         * @var string
         */
        private $_charSet = 'UTF-8';
        /**
         * Create a new PHPExcel_Reader_Excel2003XML
         */
        public function __construct()
        {
        }
        /**
         * Can the current PHPExcel_Reader_IReader read the file?
         *
         * @param 	string 		$pFilename
         * @return 	boolean
         * @throws PHPExcel_Reader_Exception
         */
        public function canRead($pFilename)
        {
        }
        /**
         * Reads names of the worksheets from a file, without parsing the whole file to a PHPExcel object
         *
         * @param 	string 		$pFilename
         * @throws 	PHPExcel_Reader_Exception
         */
        public function listWorksheetNames($pFilename)
        {
        }
        /**
         * Return worksheet info (Name, Last Column Letter, Last Column Index, Total Rows, Total Columns)
         *
         * @param   string     $pFilename
         * @throws   PHPExcel_Reader_Exception
         */
        public function listWorksheetInfo($pFilename)
        {
        }
        /**
         * Loads PHPExcel from file
         *
         * @param 	string 		$pFilename
         * @return 	PHPExcel
         * @throws 	PHPExcel_Reader_Exception
         */
        public function load($pFilename)
        {
        }
        private static function identifyFixedStyleValue($styleList, &$styleAttributeValue)
        {
        }
        /**
         * pixel units to excel width units(units of 1/256th of a character width)
         * @param pxs
         * @return
         */
        private static function _pixel2WidthUnits($pxs)
        {
        }
        /**
         * excel width units(units of 1/256th of a character width) to pixel units
         * @param widthUnits
         * @return
         */
        private static function _widthUnits2Pixel($widthUnits)
        {
        }
        private static function _hex2str($hex)
        {
        }
        /**
         * Loads PHPExcel from file into PHPExcel instance
         *
         * @param 	string 		$pFilename
         * @param	PHPExcel	$objPHPExcel
         * @return 	PHPExcel
         * @throws 	PHPExcel_Reader_Exception
         */
        public function loadIntoExisting($pFilename, \PHPExcel $objPHPExcel)
        {
        }
        private static function _convertStringEncoding($string, $charset)
        {
        }
        private function _parseRichText($is = '')
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category	PHPExcel
     * @package		PHPExcel_Reader_Excel2007
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license		http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version		1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Reader_Excel2007_Chart
     *
     * @category	PHPExcel
     * @package		PHPExcel_Reader_Excel2007
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Reader_Excel2007_Chart
    {
        private static function _getAttribute($component, $name, $format)
        {
        }
        //	function _getAttribute()
        private static function _readColor($color, $background = \false)
        {
        }
        public static function readChart($chartElements, $chartName)
        {
        }
        //	function readChart()
        private static function _chartTitle($titleDetails, $namespacesChartMeta, $type)
        {
        }
        //	function _chartTitle()
        private static function _chartLayoutDetails($chartDetail, $namespacesChartMeta)
        {
        }
        //	function _chartLayoutDetails()
        private static function _chartDataSeries($chartDetail, $namespacesChartMeta, $plotType)
        {
        }
        //	function _chartDataSeries()
        private static function _chartDataSeriesValueSet($seriesDetail, $namespacesChartMeta, $marker = \null, $smoothLine = \false)
        {
        }
        //	function _chartDataSeriesValueSet()
        private static function _chartDataSeriesValues($seriesValueSet, $dataType = 'n')
        {
        }
        //	function _chartDataSeriesValues()
        private static function _chartDataSeriesValuesMultiLevel($seriesValueSet, $dataType = 'n')
        {
        }
        //	function _chartDataSeriesValuesMultiLevel()
        private static function _parseRichText($titleDetailPart = \null)
        {
        }
        private static function _readChartAttributes($chartDetail)
        {
        }
        private static function _setChartAttributes($plotArea, $plotAttributes)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Reader_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Reader_Excel2007_Theme
     *
     * @category   PHPExcel
     * @package    PHPExcel_Reader_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Reader_Excel2007_Theme
    {
        /**
         * Theme Name
         *
         * @var string
         */
        private $_themeName;
        /**
         * Colour Scheme Name
         *
         * @var string
         */
        private $_colourSchemeName;
        /**
         * Colour Map indexed by position
         *
         * @var array of string
         */
        private $_colourMapValues;
        /**
         * Colour Map
         *
         * @var array of string
         */
        private $_colourMap;
        /**
         * Create a new PHPExcel_Theme
         *
         */
        public function __construct($themeName, $colourSchemeName, $colourMap)
        {
        }
        /**
         * Get Theme Name
         *
         * @return string
         */
        public function getThemeName()
        {
        }
        /**
         * Get colour Scheme Name
         *
         * @return string
         */
        public function getColourSchemeName()
        {
        }
        /**
         * Get colour Map Value by Position
         *
         * @return string
         */
        public function getColourByIndex($index = 0)
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    /**
     * PHPExcel_Reader_HTML
     *
     * @category   PHPExcel
     * @package    PHPExcel_Reader
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Reader_HTML extends \PHPExcel_Reader_Abstract implements \PHPExcel_Reader_IReader
    {
        /**
         * Input encoding
         *
         * @var string
         */
        private $_inputEncoding = 'ANSI';
        /**
         * Sheet index to read
         *
         * @var int
         */
        private $_sheetIndex = 0;
        /**
         * Formats
         *
         * @var array
         */
        private $_formats = array(
            'h1' => array('font' => array('bold' => \true, 'size' => 24)),
            //	Bold, 24pt
            'h2' => array('font' => array('bold' => \true, 'size' => 18)),
            //	Bold, 18pt
            'h3' => array('font' => array('bold' => \true, 'size' => 13.5)),
            //	Bold, 13.5pt
            'h4' => array('font' => array('bold' => \true, 'size' => 12)),
            //	Bold, 12pt
            'h5' => array('font' => array('bold' => \true, 'size' => 10)),
            //	Bold, 10pt
            'h6' => array('font' => array('bold' => \true, 'size' => 7.5)),
            //	Bold, 7.5pt
            'a' => array('font' => array('underline' => \true, 'color' => array('argb' => \PHPExcel_Style_Color::COLOR_BLUE))),
            //	Blue underlined
            'hr' => array('borders' => array('bottom' => array('style' => \PHPExcel_Style_Border::BORDER_THIN, 'color' => array(\PHPExcel_Style_Color::COLOR_BLACK)))),
        );
        /**
         * Create a new PHPExcel_Reader_HTML
         */
        public function __construct()
        {
        }
        /**
         * Validate that the current file is an HTML file
         *
         * @return boolean
         */
        protected function _isValidFormat()
        {
        }
        /**
         * Loads PHPExcel from file
         *
         * @param 	string 		$pFilename
         * @return 	PHPExcel
         * @throws 	PHPExcel_Reader_Exception
         */
        public function load($pFilename)
        {
        }
        /**
         * Set input encoding
         *
         * @param string $pValue Input encoding
         */
        public function setInputEncoding($pValue = 'ANSI')
        {
        }
        /**
         * Get input encoding
         *
         * @return string
         */
        public function getInputEncoding()
        {
        }
        //	Data Array used for testing only, should write to PHPExcel object on completion of tests
        private $_dataArray = array();
        private $_tableLevel = 0;
        private $_nestedColumn = array('A');
        private function _setTableStartColumn($column)
        {
        }
        private function _getTableStartColumn()
        {
        }
        private function _releaseTableStartColumn()
        {
        }
        private function _flushCell($sheet, $column, $row, &$cellContent)
        {
        }
        private function _processDomElement(\DOMNode $element, $sheet, &$row, &$column, &$cellContent)
        {
        }
        /**
         * Loads PHPExcel from file into PHPExcel instance
         *
         * @param 	string 		$pFilename
         * @param	PHPExcel	$objPHPExcel
         * @return 	PHPExcel
         * @throws 	PHPExcel_Reader_Exception
         */
        public function loadIntoExisting($pFilename, \PHPExcel $objPHPExcel)
        {
        }
        /**
         * Get sheet index
         *
         * @return int
         */
        public function getSheetIndex()
        {
        }
        /**
         * Set sheet index
         *
         * @param	int		$pValue		Sheet index
         * @return PHPExcel_Reader_HTML
         */
        public function setSheetIndex($pValue = 0)
        {
        }
    }
    /**
     * PHPExcel_Reader_CSV
     *
     * @category   PHPExcel
     * @package    PHPExcel_Reader
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Reader_CSV extends \PHPExcel_Reader_Abstract implements \PHPExcel_Reader_IReader
    {
        /**
         * Input encoding
         *
         * @access	private
         * @var	string
         */
        private $_inputEncoding = 'UTF-8';
        /**
         * Delimiter
         *
         * @access	private
         * @var string
         */
        private $_delimiter = ',';
        /**
         * Enclosure
         *
         * @access	private
         * @var	string
         */
        private $_enclosure = '"';
        /**
         * Line ending
         *
         * @access	private
         * @var	string
         */
        private $_lineEnding = \PHP_EOL;
        /**
         * Sheet index to read
         *
         * @access	private
         * @var	int
         */
        private $_sheetIndex = 0;
        /**
         * Load rows contiguously
         *
         * @access	private
         * @var	int
         */
        private $_contiguous = \false;
        /**
         * Row counter for loading rows contiguously
         *
         * @var	int
         */
        private $_contiguousRow = -1;
        /**
         * Create a new PHPExcel_Reader_CSV
         */
        public function __construct()
        {
        }
        /**
         * Validate that the current file is a CSV file
         *
         * @return boolean
         */
        protected function _isValidFormat()
        {
        }
        /**
         * Set input encoding
         *
         * @param string $pValue Input encoding
         */
        public function setInputEncoding($pValue = 'UTF-8')
        {
        }
        /**
         * Get input encoding
         *
         * @return string
         */
        public function getInputEncoding()
        {
        }
        /**
         * Move filepointer past any BOM marker
         *
         */
        protected function _skipBOM()
        {
        }
        /**
         * Return worksheet info (Name, Last Column Letter, Last Column Index, Total Rows, Total Columns)
         *
         * @param 	string 		$pFilename
         * @throws	PHPExcel_Reader_Exception
         */
        public function listWorksheetInfo($pFilename)
        {
        }
        /**
         * Loads PHPExcel from file
         *
         * @param 	string 		$pFilename
         * @return PHPExcel
         * @throws PHPExcel_Reader_Exception
         */
        public function load($pFilename)
        {
        }
        /**
         * Loads PHPExcel from file into PHPExcel instance
         *
         * @param 	string 		$pFilename
         * @param	PHPExcel	$objPHPExcel
         * @return 	PHPExcel
         * @throws 	PHPExcel_Reader_Exception
         */
        public function loadIntoExisting($pFilename, \PHPExcel $objPHPExcel)
        {
        }
        /**
         * Get delimiter
         *
         * @return string
         */
        public function getDelimiter()
        {
        }
        /**
         * Set delimiter
         *
         * @param	string	$pValue		Delimiter, defaults to ,
         * @return	PHPExcel_Reader_CSV
         */
        public function setDelimiter($pValue = ',')
        {
        }
        /**
         * Get enclosure
         *
         * @return string
         */
        public function getEnclosure()
        {
        }
        /**
         * Set enclosure
         *
         * @param	string	$pValue		Enclosure, defaults to "
         * @return PHPExcel_Reader_CSV
         */
        public function setEnclosure($pValue = '"')
        {
        }
        /**
         * Get line ending
         *
         * @return string
         */
        public function getLineEnding()
        {
        }
        /**
         * Set line ending
         *
         * @param	string	$pValue		Line ending, defaults to OS line ending (PHP_EOL)
         * @return PHPExcel_Reader_CSV
         */
        public function setLineEnding($pValue = \PHP_EOL)
        {
        }
        /**
         * Get sheet index
         *
         * @return integer
         */
        public function getSheetIndex()
        {
        }
        /**
         * Set sheet index
         *
         * @param	integer		$pValue		Sheet index
         * @return PHPExcel_Reader_CSV
         */
        public function setSheetIndex($pValue = 0)
        {
        }
        /**
         * Set Contiguous
         *
         * @param boolean $contiguous
         */
        public function setContiguous($contiguous = \FALSE)
        {
        }
        /**
         * Get Contiguous
         *
         * @return boolean
         */
        public function getContiguous()
        {
        }
    }
    /**
     * PHPExcel_Reader_Excel2007
     *
     * @category	PHPExcel
     * @package	PHPExcel_Reader
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Reader_Excel2007 extends \PHPExcel_Reader_Abstract implements \PHPExcel_Reader_IReader
    {
        /**
         * PHPExcel_ReferenceHelper instance
         *
         * @var PHPExcel_ReferenceHelper
         */
        private $_referenceHelper = \NULL;
        /**
         * PHPExcel_Reader_Excel2007_Theme instance
         *
         * @var PHPExcel_Reader_Excel2007_Theme
         */
        private static $_theme = \NULL;
        /**
         * Create a new PHPExcel_Reader_Excel2007 instance
         */
        public function __construct()
        {
        }
        /**
         * Can the current PHPExcel_Reader_IReader read the file?
         *
         * @param 	string 		$pFilename
         * @return 	boolean
         * @throws PHPExcel_Reader_Exception
         */
        public function canRead($pFilename)
        {
        }
        /**
         * Reads names of the worksheets from a file, without parsing the whole file to a PHPExcel object
         *
         * @param 	string 		$pFilename
         * @throws 	PHPExcel_Reader_Exception
         */
        public function listWorksheetNames($pFilename)
        {
        }
        /**
         * Return worksheet info (Name, Last Column Letter, Last Column Index, Total Rows, Total Columns)
         *
         * @param   string     $pFilename
         * @throws   PHPExcel_Reader_Exception
         */
        public function listWorksheetInfo($pFilename)
        {
        }
        private static function _castToBool($c)
        {
        }
        //	function _castToBool()
        private static function _castToError($c)
        {
        }
        //	function _castToError()
        private static function _castToString($c)
        {
        }
        //	function _castToString()
        private function _castToFormula($c, $r, &$cellDataType, &$value, &$calculatedValue, &$sharedFormulas, $castBaseType)
        {
        }
        public function _getFromZipArchive($archive, $fileName = '')
        {
        }
        /**
         * Loads PHPExcel from file
         *
         * @param 	string 		$pFilename
         * @throws 	PHPExcel_Reader_Exception
         */
        public function load($pFilename)
        {
        }
        private static function _readColor($color, $background = \FALSE)
        {
        }
        private static function _readStyle($docStyle, $style)
        {
        }
        private static function _readBorder($docBorder, $eleBorder)
        {
        }
        private function _parseRichText($is = \null)
        {
        }
        private function _readRibbon($excel, $customUITarget, $zip)
        {
        }
        private static function array_item($array, $key = 0)
        {
        }
        private static function dir_add($base, $add)
        {
        }
        private static function toCSSArray($style)
        {
        }
        private static function boolean($value = \NULL)
        {
        }
    }
    /**
     * PHPExcel_Reader_Gnumeric
     *
     * @category	PHPExcel
     * @package		PHPExcel_Reader
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Reader_Gnumeric extends \PHPExcel_Reader_Abstract implements \PHPExcel_Reader_IReader
    {
        /**
         * Formats
         *
         * @var array
         */
        private $_styles = array();
        /**
         * Shared Expressions
         *
         * @var array
         */
        private $_expressions = array();
        private $_referenceHelper = \null;
        /**
         * Create a new PHPExcel_Reader_Gnumeric
         */
        public function __construct()
        {
        }
        /**
         * Can the current PHPExcel_Reader_IReader read the file?
         *
         * @param 	string 		$pFilename
         * @return 	boolean
         * @throws PHPExcel_Reader_Exception
         */
        public function canRead($pFilename)
        {
        }
        /**
         * Reads names of the worksheets from a file, without parsing the whole file to a PHPExcel object
         *
         * @param 	string 		$pFilename
         * @throws 	PHPExcel_Reader_Exception
         */
        public function listWorksheetNames($pFilename)
        {
        }
        /**
         * Return worksheet info (Name, Last Column Letter, Last Column Index, Total Rows, Total Columns)
         *
         * @param   string     $pFilename
         * @throws   PHPExcel_Reader_Exception
         */
        public function listWorksheetInfo($pFilename)
        {
        }
        private function _gzfileGetContents($filename)
        {
        }
        /**
         * Loads PHPExcel from file
         *
         * @param 	string 		$pFilename
         * @return 	PHPExcel
         * @throws 	PHPExcel_Reader_Exception
         */
        public function load($pFilename)
        {
        }
        /**
         * Loads PHPExcel from file into PHPExcel instance
         *
         * @param 	string 		$pFilename
         * @param	PHPExcel	$objPHPExcel
         * @return 	PHPExcel
         * @throws 	PHPExcel_Reader_Exception
         */
        public function loadIntoExisting($pFilename, \PHPExcel $objPHPExcel)
        {
        }
        private static function _parseBorderAttributes($borderAttributes)
        {
        }
        private function _parseRichText($is = '')
        {
        }
        private static function _parseGnumericColour($gnmColour)
        {
        }
    }
    /**
     * PHPExcel_Reader_SYLK
     *
     * @category   PHPExcel
     * @package    PHPExcel_Reader
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Reader_SYLK extends \PHPExcel_Reader_Abstract implements \PHPExcel_Reader_IReader
    {
        /**
         * Input encoding
         *
         * @var string
         */
        private $_inputEncoding = 'ANSI';
        /**
         * Sheet index to read
         *
         * @var int
         */
        private $_sheetIndex = 0;
        /**
         * Formats
         *
         * @var array
         */
        private $_formats = array();
        /**
         * Format Count
         *
         * @var int
         */
        private $_format = 0;
        /**
         * Create a new PHPExcel_Reader_SYLK
         */
        public function __construct()
        {
        }
        /**
         * Validate that the current file is a SYLK file
         *
         * @return boolean
         */
        protected function _isValidFormat()
        {
        }
        /**
         * Set input encoding
         *
         * @param string $pValue Input encoding
         */
        public function setInputEncoding($pValue = 'ANSI')
        {
        }
        /**
         * Get input encoding
         *
         * @return string
         */
        public function getInputEncoding()
        {
        }
        /**
         * Return worksheet info (Name, Last Column Letter, Last Column Index, Total Rows, Total Columns)
         *
         * @param   string     $pFilename
         * @throws   PHPExcel_Reader_Exception
         */
        public function listWorksheetInfo($pFilename)
        {
        }
        /**
         * Loads PHPExcel from file
         *
         * @param 	string 		$pFilename
         * @return 	PHPExcel
         * @throws 	PHPExcel_Reader_Exception
         */
        public function load($pFilename)
        {
        }
        /**
         * Loads PHPExcel from file into PHPExcel instance
         *
         * @param 	string 		$pFilename
         * @param	PHPExcel	$objPHPExcel
         * @return 	PHPExcel
         * @throws 	PHPExcel_Reader_Exception
         */
        public function loadIntoExisting($pFilename, \PHPExcel $objPHPExcel)
        {
        }
        /**
         * Get sheet index
         *
         * @return int
         */
        public function getSheetIndex()
        {
        }
        /**
         * Set sheet index
         *
         * @param	int		$pValue		Sheet index
         * @return PHPExcel_Reader_SYLK
         */
        public function setSheetIndex($pValue = 0)
        {
        }
    }
    /**
     * PHPExcel_Reader_OOCalc
     *
     * @category	PHPExcel
     * @package		PHPExcel_Reader
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Reader_OOCalc extends \PHPExcel_Reader_Abstract implements \PHPExcel_Reader_IReader
    {
        /**
         * Formats
         *
         * @var array
         */
        private $_styles = array();
        /**
         * Create a new PHPExcel_Reader_OOCalc
         */
        public function __construct()
        {
        }
        /**
         * Can the current PHPExcel_Reader_IReader read the file?
         *
         * @param 	string 		$pFilename
         * @return 	boolean
         * @throws PHPExcel_Reader_Exception
         */
        public function canRead($pFilename)
        {
        }
        /**
         * Reads names of the worksheets from a file, without parsing the whole file to a PHPExcel object
         *
         * @param 	string 		$pFilename
         * @throws 	PHPExcel_Reader_Exception
         */
        public function listWorksheetNames($pFilename)
        {
        }
        /**
         * Return worksheet info (Name, Last Column Letter, Last Column Index, Total Rows, Total Columns)
         *
         * @param   string     $pFilename
         * @throws   PHPExcel_Reader_Exception
         */
        public function listWorksheetInfo($pFilename)
        {
        }
        /**
         * Loads PHPExcel from file
         *
         * @param 	string 		$pFilename
         * @return 	PHPExcel
         * @throws 	PHPExcel_Reader_Exception
         */
        public function load($pFilename)
        {
        }
        private static function identifyFixedStyleValue($styleList, &$styleAttributeValue)
        {
        }
        /**
         * Loads PHPExcel from file into PHPExcel instance
         *
         * @param 	string 		$pFilename
         * @param	PHPExcel	$objPHPExcel
         * @return 	PHPExcel
         * @throws 	PHPExcel_Reader_Exception
         */
        public function loadIntoExisting($pFilename, \PHPExcel $objPHPExcel)
        {
        }
        private function _parseRichText($is = '')
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Chart
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license	http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version	1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Chart_Exception
     *
     * @category   PHPExcel
     * @package    PHPExcel_Chart
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Chart_Exception extends \PHPExcel_Exception
    {
        /**
         * Error handler callback
         *
         * @param mixed $code
         * @param mixed $string
         * @param mixed $file
         * @param mixed $line
         * @param mixed $context
         */
        public static function errorHandlerCallback($code, $string, $file, $line, $context)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category	PHPExcel
     * @package		PHPExcel_Chart
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license		http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version		1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Chart_Layout
     *
     * @category	PHPExcel
     * @package		PHPExcel_Chart
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Chart_Layout
    {
        /**
         * layoutTarget
         *
         * @var string
         */
        private $_layoutTarget = \NULL;
        /**
         * X Mode
         *
         * @var string
         */
        private $_xMode = \NULL;
        /**
         * Y Mode
         *
         * @var string
         */
        private $_yMode = \NULL;
        /**
         * X-Position
         *
         * @var float
         */
        private $_xPos = \NULL;
        /**
         * Y-Position
         *
         * @var float
         */
        private $_yPos = \NULL;
        /**
         * width
         *
         * @var float
         */
        private $_width = \NULL;
        /**
         * height
         *
         * @var float
         */
        private $_height = \NULL;
        /**
         * show legend key
         * Specifies that legend keys should be shown in data labels
         *
         * @var boolean
         */
        private $_showLegendKey = \NULL;
        /**
         * show value
         * Specifies that the value should be shown in a data label.
         *
         * @var boolean
         */
        private $_showVal = \NULL;
        /**
         * show category name
         * Specifies that the category name should be shown in the data label.
         *
         * @var boolean
         */
        private $_showCatName = \NULL;
        /**
         * show data series name
         * Specifies that the series name should be shown in the data label.
         *
         * @var boolean
         */
        private $_showSerName = \NULL;
        /**
         * show percentage
         * Specifies that the percentage should be shown in the data label.
         *
         * @var boolean
         */
        private $_showPercent = \NULL;
        /**
         * show bubble size
         *
         * @var boolean
         */
        private $_showBubbleSize = \NULL;
        /**
         * show leader lines
         * Specifies that leader lines should be shown for the data label.
         *
         * @var boolean
         */
        private $_showLeaderLines = \NULL;
        /**
         * Create a new PHPExcel_Chart_Layout
         */
        public function __construct($layout = array())
        {
        }
        /**
         * Get Layout Target
         *
         * @return string
         */
        public function getLayoutTarget()
        {
        }
        /**
         * Set Layout Target
         *
         * @param Layout Target $value
         * @return PHPExcel_Chart_Layout
         */
        public function setLayoutTarget($value)
        {
        }
        /**
         * Get X-Mode
         *
         * @return string
         */
        public function getXMode()
        {
        }
        /**
         * Set X-Mode
         *
         * @param X-Mode $value
         * @return PHPExcel_Chart_Layout
         */
        public function setXMode($value)
        {
        }
        /**
         * Get Y-Mode
         *
         * @return string
         */
        public function getYMode()
        {
        }
        /**
         * Set Y-Mode
         *
         * @param Y-Mode $value
         * @return PHPExcel_Chart_Layout
         */
        public function setYMode($value)
        {
        }
        /**
         * Get X-Position
         *
         * @return number
         */
        public function getXPosition()
        {
        }
        /**
         * Set X-Position
         *
         * @param X-Position $value
         * @return PHPExcel_Chart_Layout
         */
        public function setXPosition($value)
        {
        }
        /**
         * Get Y-Position
         *
         * @return number
         */
        public function getYPosition()
        {
        }
        /**
         * Set Y-Position
         *
         * @param Y-Position $value
         * @return PHPExcel_Chart_Layout
         */
        public function setYPosition($value)
        {
        }
        /**
         * Get Width
         *
         * @return number
         */
        public function getWidth()
        {
        }
        /**
         * Set Width
         *
         * @param Width $value
         * @return PHPExcel_Chart_Layout
         */
        public function setWidth($value)
        {
        }
        /**
         * Get Height
         *
         * @return number
         */
        public function getHeight()
        {
        }
        /**
         * Set Height
         *
         * @param Height $value
         * @return PHPExcel_Chart_Layout
         */
        public function setHeight($value)
        {
        }
        /**
         * Get show legend key
         *
         * @return boolean
         */
        public function getShowLegendKey()
        {
        }
        /**
         * Set show legend key
         * Specifies that legend keys should be shown in data labels.
         *
         * @param boolean $value		Show legend key
         * @return PHPExcel_Chart_Layout
         */
        public function setShowLegendKey($value)
        {
        }
        /**
         * Get show value
         *
         * @return boolean
         */
        public function getShowVal()
        {
        }
        /**
         * Set show val
         * Specifies that the value should be shown in data labels.
         *
         * @param boolean $value		Show val
         * @return PHPExcel_Chart_Layout
         */
        public function setShowVal($value)
        {
        }
        /**
         * Get show category name
         *
         * @return boolean
         */
        public function getShowCatName()
        {
        }
        /**
         * Set show cat name
         * Specifies that the category name should be shown in data labels.
         *
         * @param boolean $value		Show cat name
         * @return PHPExcel_Chart_Layout
         */
        public function setShowCatName($value)
        {
        }
        /**
         * Get show data series name
         *
         * @return boolean
         */
        public function getShowSerName()
        {
        }
        /**
         * Set show ser name
         * Specifies that the series name should be shown in data labels.
         *
         * @param boolean $value		Show series name
         * @return PHPExcel_Chart_Layout
         */
        public function setShowSerName($value)
        {
        }
        /**
         * Get show percentage
         *
         * @return boolean
         */
        public function getShowPercent()
        {
        }
        /**
         * Set show percentage
         * Specifies that the percentage should be shown in data labels.
         *
         * @param boolean $value		Show percentage
         * @return PHPExcel_Chart_Layout
         */
        public function setShowPercent($value)
        {
        }
        /**
         * Get show bubble size
         *
         * @return boolean
         */
        public function getShowBubbleSize()
        {
        }
        /**
         * Set show bubble size
         * Specifies that the bubble size should be shown in data labels.
         *
         * @param boolean $value		Show bubble size
         * @return PHPExcel_Chart_Layout
         */
        public function setShowBubbleSize($value)
        {
        }
        /**
         * Get show leader lines
         *
         * @return boolean
         */
        public function getShowLeaderLines()
        {
        }
        /**
         * Set show leader lines
         * Specifies that leader lines should be shown in data labels.
         *
         * @param boolean $value		Show leader lines
         * @return PHPExcel_Chart_Layout
         */
        public function setShowLeaderLines($value)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category	PHPExcel
     * @package		PHPExcel_Chart
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license		http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version	1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Chart_DataSeries
     *
     * @category	PHPExcel
     * @package		PHPExcel_Chart
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Chart_DataSeries
    {
        const TYPE_BARCHART = 'barChart';
        const TYPE_BARCHART_3D = 'bar3DChart';
        const TYPE_LINECHART = 'lineChart';
        const TYPE_LINECHART_3D = 'line3DChart';
        const TYPE_AREACHART = 'areaChart';
        const TYPE_AREACHART_3D = 'area3DChart';
        const TYPE_PIECHART = 'pieChart';
        const TYPE_PIECHART_3D = 'pie3DChart';
        const TYPE_DOUGHTNUTCHART = 'doughnutChart';
        const TYPE_DONUTCHART = self::TYPE_DOUGHTNUTCHART;
        //	Synonym
        const TYPE_SCATTERCHART = 'scatterChart';
        const TYPE_SURFACECHART = 'surfaceChart';
        const TYPE_SURFACECHART_3D = 'surface3DChart';
        const TYPE_RADARCHART = 'radarChart';
        const TYPE_BUBBLECHART = 'bubbleChart';
        const TYPE_STOCKCHART = 'stockChart';
        const TYPE_CANDLECHART = self::TYPE_STOCKCHART;
        //	Synonym
        const GROUPING_CLUSTERED = 'clustered';
        const GROUPING_STACKED = 'stacked';
        const GROUPING_PERCENT_STACKED = 'percentStacked';
        const GROUPING_STANDARD = 'standard';
        const DIRECTION_BAR = 'bar';
        const DIRECTION_HORIZONTAL = self::DIRECTION_BAR;
        const DIRECTION_COL = 'col';
        const DIRECTION_COLUMN = self::DIRECTION_COL;
        const DIRECTION_VERTICAL = self::DIRECTION_COL;
        const STYLE_LINEMARKER = 'lineMarker';
        const STYLE_SMOOTHMARKER = 'smoothMarker';
        const STYLE_MARKER = 'marker';
        const STYLE_FILLED = 'filled';
        /**
         * Series Plot Type
         *
         * @var string
         */
        private $_plotType = \null;
        /**
         * Plot Grouping Type
         *
         * @var boolean
         */
        private $_plotGrouping = \null;
        /**
         * Plot Direction
         *
         * @var boolean
         */
        private $_plotDirection = \null;
        /**
         * Plot Style
         *
         * @var string
         */
        private $_plotStyle = \null;
        /**
         * Order of plots in Series
         *
         * @var array of integer
         */
        private $_plotOrder = array();
        /**
         * Plot Label
         *
         * @var array of PHPExcel_Chart_DataSeriesValues
         */
        private $_plotLabel = array();
        /**
         * Plot Category
         *
         * @var array of PHPExcel_Chart_DataSeriesValues
         */
        private $_plotCategory = array();
        /**
         * Smooth Line
         *
         * @var string
         */
        private $_smoothLine = \null;
        /**
         * Plot Values
         *
         * @var array of PHPExcel_Chart_DataSeriesValues
         */
        private $_plotValues = array();
        /**
         * Create a new PHPExcel_Chart_DataSeries
         */
        public function __construct($plotType = \null, $plotGrouping = \null, $plotOrder = array(), $plotLabel = array(), $plotCategory = array(), $plotValues = array(), $smoothLine = \null, $plotStyle = \null)
        {
        }
        /**
         * Get Plot Type
         *
         * @return string
         */
        public function getPlotType()
        {
        }
        /**
         * Set Plot Type
         *
         * @param string $plotType
         * @return PHPExcel_Chart_DataSeries
         */
        public function setPlotType($plotType = '')
        {
        }
        /**
         * Get Plot Grouping Type
         *
         * @return string
         */
        public function getPlotGrouping()
        {
        }
        /**
         * Set Plot Grouping Type
         *
         * @param string $groupingType
         * @return PHPExcel_Chart_DataSeries
         */
        public function setPlotGrouping($groupingType = \null)
        {
        }
        /**
         * Get Plot Direction
         *
         * @return string
         */
        public function getPlotDirection()
        {
        }
        /**
         * Set Plot Direction
         *
         * @param string $plotDirection
         * @return PHPExcel_Chart_DataSeries
         */
        public function setPlotDirection($plotDirection = \null)
        {
        }
        /**
         * Get Plot Order
         *
         * @return string
         */
        public function getPlotOrder()
        {
        }
        /**
         * Get Plot Labels
         *
         * @return array of PHPExcel_Chart_DataSeriesValues
         */
        public function getPlotLabels()
        {
        }
        /**
         * Get Plot Label by Index
         *
         * @return PHPExcel_Chart_DataSeriesValues
         */
        public function getPlotLabelByIndex($index)
        {
        }
        /**
         * Get Plot Categories
         *
         * @return array of PHPExcel_Chart_DataSeriesValues
         */
        public function getPlotCategories()
        {
        }
        /**
         * Get Plot Category by Index
         *
         * @return PHPExcel_Chart_DataSeriesValues
         */
        public function getPlotCategoryByIndex($index)
        {
        }
        /**
         * Get Plot Style
         *
         * @return string
         */
        public function getPlotStyle()
        {
        }
        /**
         * Set Plot Style
         *
         * @param string $plotStyle
         * @return PHPExcel_Chart_DataSeries
         */
        public function setPlotStyle($plotStyle = \null)
        {
        }
        /**
         * Get Plot Values
         *
         * @return array of PHPExcel_Chart_DataSeriesValues
         */
        public function getPlotValues()
        {
        }
        /**
         * Get Plot Values by Index
         *
         * @return PHPExcel_Chart_DataSeriesValues
         */
        public function getPlotValuesByIndex($index)
        {
        }
        /**
         * Get Number of Plot Series
         *
         * @return integer
         */
        public function getPlotSeriesCount()
        {
        }
        /**
         * Get Smooth Line
         *
         * @return boolean
         */
        public function getSmoothLine()
        {
        }
        /**
         * Set Smooth Line
         *
         * @param boolean $smoothLine
         * @return PHPExcel_Chart_DataSeries
         */
        public function setSmoothLine($smoothLine = \TRUE)
        {
        }
        public function refresh(\PHPExcel_Worksheet $worksheet)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category	PHPExcel
     * @package		PHPExcel_Chart
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license		http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version		1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Chart_DataSeriesValues
     *
     * @category	PHPExcel
     * @package		PHPExcel_Chart
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Chart_DataSeriesValues
    {
        const DATASERIES_TYPE_STRING = 'String';
        const DATASERIES_TYPE_NUMBER = 'Number';
        private static $_dataTypeValues = array(self::DATASERIES_TYPE_STRING, self::DATASERIES_TYPE_NUMBER);
        /**
         * Series Data Type
         *
         * @var	string
         */
        private $_dataType = \null;
        /**
         * Series Data Source
         *
         * @var	string
         */
        private $_dataSource = \null;
        /**
         * Format Code
         *
         * @var	string
         */
        private $_formatCode = \null;
        /**
         * Series Point Marker
         *
         * @var	string
         */
        private $_marker = \null;
        /**
         * Point Count (The number of datapoints in the dataseries)
         *
         * @var	integer
         */
        private $_pointCount = 0;
        /**
         * Data Values
         *
         * @var	array of mixed
         */
        private $_dataValues = array();
        /**
         * Create a new PHPExcel_Chart_DataSeriesValues object
         */
        public function __construct($dataType = self::DATASERIES_TYPE_NUMBER, $dataSource = \null, $formatCode = \null, $pointCount = 0, $dataValues = array(), $marker = \null)
        {
        }
        /**
         * Get Series Data Type
         *
         * @return	string
         */
        public function getDataType()
        {
        }
        /**
         * Set Series Data Type
         *
         * @param	string	$dataType	Datatype of this data series
         *								Typical values are:
         *									PHPExcel_Chart_DataSeriesValues::DATASERIES_TYPE_STRING
         *										Normally used for axis point values
         *									PHPExcel_Chart_DataSeriesValues::DATASERIES_TYPE_NUMBER
         *										Normally used for chart data values
         * @return	PHPExcel_Chart_DataSeriesValues
         */
        public function setDataType($dataType = self::DATASERIES_TYPE_NUMBER)
        {
        }
        /**
         * Get Series Data Source (formula)
         *
         * @return	string
         */
        public function getDataSource()
        {
        }
        /**
         * Set Series Data Source (formula)
         *
         * @param	string	$dataSource
         * @return	PHPExcel_Chart_DataSeriesValues
         */
        public function setDataSource($dataSource = \null, $refreshDataValues = \true)
        {
        }
        /**
         * Get Point Marker
         *
         * @return string
         */
        public function getPointMarker()
        {
        }
        /**
         * Set Point Marker
         *
         * @param	string	$marker
         * @return	PHPExcel_Chart_DataSeriesValues
         */
        public function setPointMarker($marker = \null)
        {
        }
        /**
         * Get Series Format Code
         *
         * @return	string
         */
        public function getFormatCode()
        {
        }
        /**
         * Set Series Format Code
         *
         * @param	string	$formatCode
         * @return	PHPExcel_Chart_DataSeriesValues
         */
        public function setFormatCode($formatCode = \null)
        {
        }
        /**
         * Get Series Point Count
         *
         * @return	integer
         */
        public function getPointCount()
        {
        }
        /**
         * Identify if the Data Series is a multi-level or a simple series
         *
         * @return	boolean
         */
        public function isMultiLevelSeries()
        {
        }
        /**
         * Return the level count of a multi-level Data Series
         *
         * @return	boolean
         */
        public function multiLevelCount()
        {
        }
        /**
         * Get Series Data Values
         *
         * @return	array of mixed
         */
        public function getDataValues()
        {
        }
        /**
         * Get the first Series Data value
         *
         * @return	mixed
         */
        public function getDataValue()
        {
        }
        /**
         * Set Series Data Values
         *
         * @param	array	$dataValues
         * @param	boolean	$refreshDataSource
         *					TRUE - refresh the value of _dataSource based on the values of $dataValues
         *					FALSE - don't change the value of _dataSource
         * @return	PHPExcel_Chart_DataSeriesValues
         */
        public function setDataValues($dataValues = array(), $refreshDataSource = \TRUE)
        {
        }
        private function _stripNulls($var)
        {
        }
        public function refresh(\PHPExcel_Worksheet $worksheet, $flatten = \TRUE)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category	PHPExcel
     * @package		PHPExcel_Chart
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license		http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version		1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Chart_Title
     *
     * @category	PHPExcel
     * @package		PHPExcel_Chart
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Chart_Title
    {
        /**
         * Title Caption
         *
         * @var string
         */
        private $_caption = \null;
        /**
         * Title Layout
         *
         * @var PHPExcel_Chart_Layout
         */
        private $_layout = \null;
        /**
         * Create a new PHPExcel_Chart_Title
         */
        public function __construct($caption = \null, \PHPExcel_Chart_Layout $layout = \null)
        {
        }
        /**
         * Get caption
         *
         * @return string
         */
        public function getCaption()
        {
        }
        /**
         * Set caption
         *
         * @param string $caption
         * @return PHPExcel_Chart_Title
         */
        public function setCaption($caption = \null)
        {
        }
        /**
         * Get Layout
         *
         * @return PHPExcel_Chart_Layout
         */
        public function getLayout()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category	PHPExcel
     * @package		PHPExcel_Chart
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license		http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version		1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Chart_PlotArea
     *
     * @category	PHPExcel
     * @package		PHPExcel_Chart
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Chart_PlotArea
    {
        /**
         * PlotArea Layout
         *
         * @var PHPExcel_Chart_Layout
         */
        private $_layout = \null;
        /**
         * Plot Series
         *
         * @var array of PHPExcel_Chart_DataSeries
         */
        private $_plotSeries = array();
        /**
         * Create a new PHPExcel_Chart_PlotArea
         */
        public function __construct(\PHPExcel_Chart_Layout $layout = \null, $plotSeries = array())
        {
        }
        /**
         * Get Layout
         *
         * @return PHPExcel_Chart_Layout
         */
        public function getLayout()
        {
        }
        /**
         * Get Number of Plot Groups
         *
         * @return array of PHPExcel_Chart_DataSeries
         */
        public function getPlotGroupCount()
        {
        }
        /**
         * Get Number of Plot Series
         *
         * @return integer
         */
        public function getPlotSeriesCount()
        {
        }
        /**
         * Get Plot Series
         *
         * @return array of PHPExcel_Chart_DataSeries
         */
        public function getPlotGroup()
        {
        }
        /**
         * Get Plot Series by Index
         *
         * @return PHPExcel_Chart_DataSeries
         */
        public function getPlotGroupByIndex($index)
        {
        }
        /**
         * Set Plot Series
         *
         * @param [PHPExcel_Chart_DataSeries]
         * @return PHPExcel_Chart_PlotArea
         */
        public function setPlotSeries($plotSeries = array())
        {
        }
        public function refresh(\PHPExcel_Worksheet $worksheet)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category	PHPExcel
     * @package		PHPExcel_Chart
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license		http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version		1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Chart_Legend
     *
     * @category	PHPExcel
     * @package		PHPExcel_Chart
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Chart_Legend
    {
        /** Legend positions */
        const xlLegendPositionBottom = -4107;
        //	Below the chart.
        const xlLegendPositionCorner = 2;
        //	In the upper right-hand corner of the chart border.
        const xlLegendPositionCustom = -4161;
        //	A custom position.
        const xlLegendPositionLeft = -4131;
        //	Left of the chart.
        const xlLegendPositionRight = -4152;
        //	Right of the chart.
        const xlLegendPositionTop = -4160;
        //	Above the chart.
        const POSITION_RIGHT = 'r';
        const POSITION_LEFT = 'l';
        const POSITION_BOTTOM = 'b';
        const POSITION_TOP = 't';
        const POSITION_TOPRIGHT = 'tr';
        private static $_positionXLref = array(self::xlLegendPositionBottom => self::POSITION_BOTTOM, self::xlLegendPositionCorner => self::POSITION_TOPRIGHT, self::xlLegendPositionCustom => '??', self::xlLegendPositionLeft => self::POSITION_LEFT, self::xlLegendPositionRight => self::POSITION_RIGHT, self::xlLegendPositionTop => self::POSITION_TOP);
        /**
         * Legend position
         *
         * @var	string
         */
        private $_position = self::POSITION_RIGHT;
        /**
         * Allow overlay of other elements?
         *
         * @var	boolean
         */
        private $_overlay = \TRUE;
        /**
         * Legend Layout
         *
         * @var	PHPExcel_Chart_Layout
         */
        private $_layout = \NULL;
        /**
         *	Create a new PHPExcel_Chart_Legend
         */
        public function __construct($position = self::POSITION_RIGHT, \PHPExcel_Chart_Layout $layout = \NULL, $overlay = \FALSE)
        {
        }
        /**
         * Get legend position as an excel string value
         *
         * @return	string
         */
        public function getPosition()
        {
        }
        /**
         * Get legend position using an excel string value
         *
         * @param	string	$position
         */
        public function setPosition($position = self::POSITION_RIGHT)
        {
        }
        /**
         * Get legend position as an Excel internal numeric value
         *
         * @return	number
         */
        public function getPositionXL()
        {
        }
        /**
         * Set legend position using an Excel internal numeric value
         *
         * @param	number	$positionXL
         */
        public function setPositionXL($positionXL = self::xlLegendPositionRight)
        {
        }
        /**
         * Get allow overlay of other elements?
         *
         * @return	boolean
         */
        public function getOverlay()
        {
        }
        /**
         * Set allow overlay of other elements?
         *
         * @param	boolean	$overlay
         * @return	boolean
         */
        public function setOverlay($overlay = \FALSE)
        {
        }
        /**
         * Get Layout
         *
         * @return PHPExcel_Chart_Layout
         */
        public function getLayout()
        {
        }
    }
    /**
     * PHPExcel_Chart_Renderer_jpgraph
     *
     * @category	PHPExcel
     * @package		PHPExcel_Chart_Renderer
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Chart_Renderer_jpgraph
    {
        private static $_width = 640;
        private static $_height = 480;
        private static $_colourSet = array('mediumpurple1', 'palegreen3', 'gold1', 'cadetblue1', 'darkmagenta', 'coral', 'dodgerblue3', 'eggplant', 'mediumblue', 'magenta', 'sandybrown', 'cyan', 'firebrick1', 'forestgreen', 'deeppink4', 'darkolivegreen', 'goldenrod2');
        private static $_markSet = array('diamond' => \MARK_DIAMOND, 'square' => \MARK_SQUARE, 'triangle' => \MARK_UTRIANGLE, 'x' => \MARK_X, 'star' => \MARK_STAR, 'dot' => \MARK_FILLEDCIRCLE, 'dash' => \MARK_DTRIANGLE, 'circle' => \MARK_CIRCLE, 'plus' => \MARK_CROSS);
        private $_chart = \null;
        private $_graph = \null;
        private static $_plotColour = 0;
        private static $_plotMark = 0;
        private function _formatPointMarker($seriesPlot, $markerID)
        {
        }
        //	function _formatPointMarker()
        private function _formatDataSetLabels($groupID, $datasetLabels, $labelCount, $rotation = '')
        {
        }
        //	function _formatDataSetLabels()
        private function _percentageSumCalculation($groupID, $seriesCount)
        {
        }
        //	function _percentageSumCalculation()
        private function _percentageAdjustValues($dataValues, $sumValues)
        {
        }
        //	function _percentageAdjustValues()
        private function _getCaption($captionElement)
        {
        }
        //	function _getCaption()
        private function _renderTitle()
        {
        }
        //	function _renderTitle()
        private function _renderLegend()
        {
        }
        //	function _renderLegend()
        private function _renderCartesianPlotArea($type = 'textlin')
        {
        }
        //	function _renderCartesianPlotArea()
        private function _renderPiePlotArea($doughnut = \False)
        {
        }
        //	function _renderPiePlotArea()
        private function _renderRadarPlotArea()
        {
        }
        //	function _renderRadarPlotArea()
        private function _renderPlotLine($groupID, $filled = \false, $combination = \false, $dimensions = '2d')
        {
        }
        //	function _renderPlotLine()
        private function _renderPlotBar($groupID, $dimensions = '2d')
        {
        }
        //	function _renderPlotBar()
        private function _renderPlotScatter($groupID, $bubble)
        {
        }
        //	function _renderPlotScatter()
        private function _renderPlotRadar($groupID)
        {
        }
        //	function _renderPlotRadar()
        private function _renderPlotContour($groupID)
        {
        }
        //	function _renderPlotContour()
        private function _renderPlotStock($groupID)
        {
        }
        //	function _renderPlotStock()
        private function _renderAreaChart($groupCount, $dimensions = '2d')
        {
        }
        //	function _renderAreaChart()
        private function _renderLineChart($groupCount, $dimensions = '2d')
        {
        }
        //	function _renderLineChart()
        private function _renderBarChart($groupCount, $dimensions = '2d')
        {
        }
        //	function _renderBarChart()
        private function _renderScatterChart($groupCount)
        {
        }
        //	function _renderScatterChart()
        private function _renderBubbleChart($groupCount)
        {
        }
        //	function _renderBubbleChart()
        private function _renderPieChart($groupCount, $dimensions = '2d', $doughnut = \False, $multiplePlots = \False)
        {
        }
        //	function _renderPieChart()
        private function _renderRadarChart($groupCount)
        {
        }
        //	function _renderRadarChart()
        private function _renderStockChart($groupCount)
        {
        }
        //	function _renderStockChart()
        private function _renderContourChart($groupCount, $dimensions)
        {
        }
        //	function _renderContourChart()
        private function _renderCombinationChart($groupCount, $dimensions, $outputDestination)
        {
        }
        //	function _renderCombinationChart()
        public function render($outputDestination)
        {
        }
        //	function render()
        /**
         * Create a new PHPExcel_Chart_Renderer_jpgraph
         */
        public function __construct(\PHPExcel_Chart $chart)
        {
        }
        //	function __construct()
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Worksheet_Protection
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Worksheet_Protection
    {
        /**
         * Sheet
         *
         * @var boolean
         */
        private $_sheet = \false;
        /**
         * Objects
         *
         * @var boolean
         */
        private $_objects = \false;
        /**
         * Scenarios
         *
         * @var boolean
         */
        private $_scenarios = \false;
        /**
         * Format cells
         *
         * @var boolean
         */
        private $_formatCells = \false;
        /**
         * Format columns
         *
         * @var boolean
         */
        private $_formatColumns = \false;
        /**
         * Format rows
         *
         * @var boolean
         */
        private $_formatRows = \false;
        /**
         * Insert columns
         *
         * @var boolean
         */
        private $_insertColumns = \false;
        /**
         * Insert rows
         *
         * @var boolean
         */
        private $_insertRows = \false;
        /**
         * Insert hyperlinks
         *
         * @var boolean
         */
        private $_insertHyperlinks = \false;
        /**
         * Delete columns
         *
         * @var boolean
         */
        private $_deleteColumns = \false;
        /**
         * Delete rows
         *
         * @var boolean
         */
        private $_deleteRows = \false;
        /**
         * Select locked cells
         *
         * @var boolean
         */
        private $_selectLockedCells = \false;
        /**
         * Sort
         *
         * @var boolean
         */
        private $_sort = \false;
        /**
         * AutoFilter
         *
         * @var boolean
         */
        private $_autoFilter = \false;
        /**
         * Pivot tables
         *
         * @var boolean
         */
        private $_pivotTables = \false;
        /**
         * Select unlocked cells
         *
         * @var boolean
         */
        private $_selectUnlockedCells = \false;
        /**
         * Password
         *
         * @var string
         */
        private $_password = '';
        /**
         * Create a new PHPExcel_Worksheet_Protection
         */
        public function __construct()
        {
        }
        /**
         * Is some sort of protection enabled?
         *
         * @return boolean
         */
        function isProtectionEnabled()
        {
        }
        /**
         * Get Sheet
         *
         * @return boolean
         */
        function getSheet()
        {
        }
        /**
         * Set Sheet
         *
         * @param boolean $pValue
         * @return PHPExcel_Worksheet_Protection
         */
        function setSheet($pValue = \false)
        {
        }
        /**
         * Get Objects
         *
         * @return boolean
         */
        function getObjects()
        {
        }
        /**
         * Set Objects
         *
         * @param boolean $pValue
         * @return PHPExcel_Worksheet_Protection
         */
        function setObjects($pValue = \false)
        {
        }
        /**
         * Get Scenarios
         *
         * @return boolean
         */
        function getScenarios()
        {
        }
        /**
         * Set Scenarios
         *
         * @param boolean $pValue
         * @return PHPExcel_Worksheet_Protection
         */
        function setScenarios($pValue = \false)
        {
        }
        /**
         * Get FormatCells
         *
         * @return boolean
         */
        function getFormatCells()
        {
        }
        /**
         * Set FormatCells
         *
         * @param boolean $pValue
         * @return PHPExcel_Worksheet_Protection
         */
        function setFormatCells($pValue = \false)
        {
        }
        /**
         * Get FormatColumns
         *
         * @return boolean
         */
        function getFormatColumns()
        {
        }
        /**
         * Set FormatColumns
         *
         * @param boolean $pValue
         * @return PHPExcel_Worksheet_Protection
         */
        function setFormatColumns($pValue = \false)
        {
        }
        /**
         * Get FormatRows
         *
         * @return boolean
         */
        function getFormatRows()
        {
        }
        /**
         * Set FormatRows
         *
         * @param boolean $pValue
         * @return PHPExcel_Worksheet_Protection
         */
        function setFormatRows($pValue = \false)
        {
        }
        /**
         * Get InsertColumns
         *
         * @return boolean
         */
        function getInsertColumns()
        {
        }
        /**
         * Set InsertColumns
         *
         * @param boolean $pValue
         * @return PHPExcel_Worksheet_Protection
         */
        function setInsertColumns($pValue = \false)
        {
        }
        /**
         * Get InsertRows
         *
         * @return boolean
         */
        function getInsertRows()
        {
        }
        /**
         * Set InsertRows
         *
         * @param boolean $pValue
         * @return PHPExcel_Worksheet_Protection
         */
        function setInsertRows($pValue = \false)
        {
        }
        /**
         * Get InsertHyperlinks
         *
         * @return boolean
         */
        function getInsertHyperlinks()
        {
        }
        /**
         * Set InsertHyperlinks
         *
         * @param boolean $pValue
         * @return PHPExcel_Worksheet_Protection
         */
        function setInsertHyperlinks($pValue = \false)
        {
        }
        /**
         * Get DeleteColumns
         *
         * @return boolean
         */
        function getDeleteColumns()
        {
        }
        /**
         * Set DeleteColumns
         *
         * @param boolean $pValue
         * @return PHPExcel_Worksheet_Protection
         */
        function setDeleteColumns($pValue = \false)
        {
        }
        /**
         * Get DeleteRows
         *
         * @return boolean
         */
        function getDeleteRows()
        {
        }
        /**
         * Set DeleteRows
         *
         * @param boolean $pValue
         * @return PHPExcel_Worksheet_Protection
         */
        function setDeleteRows($pValue = \false)
        {
        }
        /**
         * Get SelectLockedCells
         *
         * @return boolean
         */
        function getSelectLockedCells()
        {
        }
        /**
         * Set SelectLockedCells
         *
         * @param boolean $pValue
         * @return PHPExcel_Worksheet_Protection
         */
        function setSelectLockedCells($pValue = \false)
        {
        }
        /**
         * Get Sort
         *
         * @return boolean
         */
        function getSort()
        {
        }
        /**
         * Set Sort
         *
         * @param boolean $pValue
         * @return PHPExcel_Worksheet_Protection
         */
        function setSort($pValue = \false)
        {
        }
        /**
         * Get AutoFilter
         *
         * @return boolean
         */
        function getAutoFilter()
        {
        }
        /**
         * Set AutoFilter
         *
         * @param boolean $pValue
         * @return PHPExcel_Worksheet_Protection
         */
        function setAutoFilter($pValue = \false)
        {
        }
        /**
         * Get PivotTables
         *
         * @return boolean
         */
        function getPivotTables()
        {
        }
        /**
         * Set PivotTables
         *
         * @param boolean $pValue
         * @return PHPExcel_Worksheet_Protection
         */
        function setPivotTables($pValue = \false)
        {
        }
        /**
         * Get SelectUnlockedCells
         *
         * @return boolean
         */
        function getSelectUnlockedCells()
        {
        }
        /**
         * Set SelectUnlockedCells
         *
         * @param boolean $pValue
         * @return PHPExcel_Worksheet_Protection
         */
        function setSelectUnlockedCells($pValue = \false)
        {
        }
        /**
         * Get Password (hashed)
         *
         * @return string
         */
        function getPassword()
        {
        }
        /**
         * Set Password
         *
         * @param string 	$pValue
         * @param boolean 	$pAlreadyHashed If the password has already been hashed, set this to true
         * @return PHPExcel_Worksheet_Protection
         */
        function setPassword($pValue = '', $pAlreadyHashed = \false)
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Worksheet_Row
     *
     * Represents a row in PHPExcel_Worksheet, used by PHPExcel_Worksheet_RowIterator
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Worksheet_Row
    {
        /**
         * PHPExcel_Worksheet
         *
         * @var PHPExcel_Worksheet
         */
        private $_parent;
        /**
         * Row index
         *
         * @var int
         */
        private $_rowIndex = 0;
        /**
         * Create a new row
         *
         * @param PHPExcel_Worksheet 		$parent
         * @param int						$rowIndex
         */
        public function __construct(\PHPExcel_Worksheet $parent = \null, $rowIndex = 1)
        {
        }
        /**
         * Destructor
         */
        public function __destruct()
        {
        }
        /**
         * Get row index
         *
         * @return int
         */
        public function getRowIndex()
        {
        }
        /**
         * Get cell iterator
         *
         * @return PHPExcel_Worksheet_CellIterator
         */
        public function getCellIterator()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Worksheet_PageMargins
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Worksheet_PageMargins
    {
        /**
         * Left
         *
         * @var double
         */
        private $_left = 0.7;
        /**
         * Right
         *
         * @var double
         */
        private $_right = 0.7;
        /**
         * Top
         *
         * @var double
         */
        private $_top = 0.75;
        /**
         * Bottom
         *
         * @var double
         */
        private $_bottom = 0.75;
        /**
         * Header
         *
         * @var double
         */
        private $_header = 0.3;
        /**
         * Footer
         *
         * @var double
         */
        private $_footer = 0.3;
        /**
         * Create a new PHPExcel_Worksheet_PageMargins
         */
        public function __construct()
        {
        }
        /**
         * Get Left
         *
         * @return double
         */
        public function getLeft()
        {
        }
        /**
         * Set Left
         *
         * @param double $pValue
         * @return PHPExcel_Worksheet_PageMargins
         */
        public function setLeft($pValue)
        {
        }
        /**
         * Get Right
         *
         * @return double
         */
        public function getRight()
        {
        }
        /**
         * Set Right
         *
         * @param double $pValue
         * @return PHPExcel_Worksheet_PageMargins
         */
        public function setRight($pValue)
        {
        }
        /**
         * Get Top
         *
         * @return double
         */
        public function getTop()
        {
        }
        /**
         * Set Top
         *
         * @param double $pValue
         * @return PHPExcel_Worksheet_PageMargins
         */
        public function setTop($pValue)
        {
        }
        /**
         * Get Bottom
         *
         * @return double
         */
        public function getBottom()
        {
        }
        /**
         * Set Bottom
         *
         * @param double $pValue
         * @return PHPExcel_Worksheet_PageMargins
         */
        public function setBottom($pValue)
        {
        }
        /**
         * Get Header
         *
         * @return double
         */
        public function getHeader()
        {
        }
        /**
         * Set Header
         *
         * @param double $pValue
         * @return PHPExcel_Worksheet_PageMargins
         */
        public function setHeader($pValue)
        {
        }
        /**
         * Get Footer
         *
         * @return double
         */
        public function getFooter()
        {
        }
        /**
         * Set Footer
         *
         * @param double $pValue
         * @return PHPExcel_Worksheet_PageMargins
         */
        public function setFooter($pValue)
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Worksheet_AutoFilter
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Worksheet_AutoFilter
    {
        /**
         * Autofilter Worksheet
         *
         * @var PHPExcel_Worksheet
         */
        private $_workSheet = \NULL;
        /**
         * Autofilter Range
         *
         * @var string
         */
        private $_range = '';
        /**
         * Autofilter Column Ruleset
         *
         * @var array of PHPExcel_Worksheet_AutoFilter_Column
         */
        private $_columns = array();
        /**
         * Create a new PHPExcel_Worksheet_AutoFilter
         *
         *	@param	string		$pRange		Cell range (i.e. A1:E10)
         * @param PHPExcel_Worksheet $pSheet
         */
        public function __construct($pRange = '', \PHPExcel_Worksheet $pSheet = \NULL)
        {
        }
        /**
         * Get AutoFilter Parent Worksheet
         *
         * @return PHPExcel_Worksheet
         */
        public function getParent()
        {
        }
        /**
         * Set AutoFilter Parent Worksheet
         *
         * @param PHPExcel_Worksheet $pSheet
         * @return PHPExcel_Worksheet_AutoFilter
         */
        public function setParent(\PHPExcel_Worksheet $pSheet = \NULL)
        {
        }
        /**
         * Get AutoFilter Range
         *
         * @return string
         */
        public function getRange()
        {
        }
        /**
         *	Set AutoFilter Range
         *
         *	@param	string		$pRange		Cell range (i.e. A1:E10)
         *	@throws	PHPExcel_Exception
         *	@return PHPExcel_Worksheet_AutoFilter
         */
        public function setRange($pRange = '')
        {
        }
        /**
         * Get all AutoFilter Columns
         *
         * @throws	PHPExcel_Exception
         * @return array of PHPExcel_Worksheet_AutoFilter_Column
         */
        public function getColumns()
        {
        }
        /**
         * Validate that the specified column is in the AutoFilter range
         *
         * @param	string	$column			Column name (e.g. A)
         * @throws	PHPExcel_Exception
         * @return	integer	The column offset within the autofilter range
         */
        public function testColumnInRange($column)
        {
        }
        /**
         * Get a specified AutoFilter Column Offset within the defined AutoFilter range
         *
         * @param	string	$pColumn		Column name (e.g. A)
         * @throws	PHPExcel_Exception
         * @return integer	The offset of the specified column within the autofilter range
         */
        public function getColumnOffset($pColumn)
        {
        }
        /**
         * Get a specified AutoFilter Column
         *
         * @param	string	$pColumn		Column name (e.g. A)
         * @throws	PHPExcel_Exception
         * @return PHPExcel_Worksheet_AutoFilter_Column
         */
        public function getColumn($pColumn)
        {
        }
        /**
         * Get a specified AutoFilter Column by it's offset
         *
         * @param	integer	$pColumnOffset		Column offset within range (starting from 0)
         * @throws	PHPExcel_Exception
         * @return PHPExcel_Worksheet_AutoFilter_Column
         */
        public function getColumnByOffset($pColumnOffset = 0)
        {
        }
        /**
         *	Set AutoFilter
         *
         *	@param	PHPExcel_Worksheet_AutoFilter_Column|string		$pColumn
         *			A simple string containing a Column ID like 'A' is permitted
         *	@throws	PHPExcel_Exception
         *	@return PHPExcel_Worksheet_AutoFilter
         */
        public function setColumn($pColumn)
        {
        }
        /**
         * Clear a specified AutoFilter Column
         *
         * @param	string  $pColumn    Column name (e.g. A)
         * @throws	PHPExcel_Exception
         * @return PHPExcel_Worksheet_AutoFilter
         */
        public function clearColumn($pColumn)
        {
        }
        /**
         *	Shift an AutoFilter Column Rule to a different column
         *
         *	Note: This method bypasses validation of the destination column to ensure it is within this AutoFilter range.
         *		Nor does it verify whether any column rule already exists at $toColumn, but will simply overrideany existing value.
         *		Use with caution.
         *
         *	@param	string	$fromColumn		Column name (e.g. A)
         *	@param	string	$toColumn		Column name (e.g. B)
         *	@return PHPExcel_Worksheet_AutoFilter
         */
        public function shiftColumn($fromColumn = \NULL, $toColumn = \NULL)
        {
        }
        /**
         *	Test if cell value is in the defined set of values
         *
         *	@param	mixed		$cellValue
         *	@param	mixed[]		$dataSet
         *	@return boolean
         */
        private static function _filterTestInSimpleDataSet($cellValue, $dataSet)
        {
        }
        /**
         *	Test if cell value is in the defined set of Excel date values
         *
         *	@param	mixed		$cellValue
         *	@param	mixed[]		$dataSet
         *	@return boolean
         */
        private static function _filterTestInDateGroupSet($cellValue, $dataSet)
        {
        }
        /**
         *	Test if cell value is within a set of values defined by a ruleset
         *
         *	@param	mixed		$cellValue
         *	@param	mixed[]		$ruleSet
         *	@return boolean
         */
        private static function _filterTestInCustomDataSet($cellValue, $ruleSet)
        {
        }
        /**
         *	Test if cell date value is matches a set of values defined by a set of months
         *
         *	@param	mixed		$cellValue
         *	@param	mixed[]		$monthSet
         *	@return boolean
         */
        private static function _filterTestInPeriodDateSet($cellValue, $monthSet)
        {
        }
        /**
         *	Search/Replace arrays to convert Excel wildcard syntax to a regexp syntax for preg_matching
         *
         *	@var	array
         */
        private static $_fromReplace = array('\\*', '\\?', '~~', '~.*', '~.?');
        private static $_toReplace = array('.*', '.', '~', '\\*', '\\?');
        /**
         *	Convert a dynamic rule daterange to a custom filter range expression for ease of calculation
         *
         *	@param	string										$dynamicRuleType
         *	@param	PHPExcel_Worksheet_AutoFilter_Column		&$filterColumn
         *	@return mixed[]
         */
        private function _dynamicFilterDateRange($dynamicRuleType, &$filterColumn)
        {
        }
        private function _calculateTopTenValue($columnID, $startRow, $endRow, $ruleType, $ruleValue)
        {
        }
        /**
         *	Apply the AutoFilter rules to the AutoFilter Range
         *
         *	@throws	PHPExcel_Exception
         *	@return PHPExcel_Worksheet_AutoFilter
         */
        public function showHideRows()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
        /**
         * toString method replicates previous behavior by returning the range if object is
         *    referenced as a property of its parent.
         */
        public function __toString()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category	PHPExcel
     * @package		PHPExcel_Worksheet
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license		http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version		1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Worksheet_AutoFilter_Column_Rule
     *
     * @category	PHPExcel
     * @package		PHPExcel_Worksheet
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Worksheet_AutoFilter_Column_Rule
    {
        const AUTOFILTER_RULETYPE_FILTER = 'filter';
        const AUTOFILTER_RULETYPE_DATEGROUP = 'dateGroupItem';
        const AUTOFILTER_RULETYPE_CUSTOMFILTER = 'customFilter';
        const AUTOFILTER_RULETYPE_DYNAMICFILTER = 'dynamicFilter';
        const AUTOFILTER_RULETYPE_TOPTENFILTER = 'top10Filter';
        private static $_ruleTypes = array(
            //	Currently we're not handling
            //		colorFilter
            //		extLst
            //		iconFilter
            self::AUTOFILTER_RULETYPE_FILTER,
            self::AUTOFILTER_RULETYPE_DATEGROUP,
            self::AUTOFILTER_RULETYPE_CUSTOMFILTER,
            self::AUTOFILTER_RULETYPE_DYNAMICFILTER,
            self::AUTOFILTER_RULETYPE_TOPTENFILTER,
        );
        const AUTOFILTER_RULETYPE_DATEGROUP_YEAR = 'year';
        const AUTOFILTER_RULETYPE_DATEGROUP_MONTH = 'month';
        const AUTOFILTER_RULETYPE_DATEGROUP_DAY = 'day';
        const AUTOFILTER_RULETYPE_DATEGROUP_HOUR = 'hour';
        const AUTOFILTER_RULETYPE_DATEGROUP_MINUTE = 'minute';
        const AUTOFILTER_RULETYPE_DATEGROUP_SECOND = 'second';
        private static $_dateTimeGroups = array(self::AUTOFILTER_RULETYPE_DATEGROUP_YEAR, self::AUTOFILTER_RULETYPE_DATEGROUP_MONTH, self::AUTOFILTER_RULETYPE_DATEGROUP_DAY, self::AUTOFILTER_RULETYPE_DATEGROUP_HOUR, self::AUTOFILTER_RULETYPE_DATEGROUP_MINUTE, self::AUTOFILTER_RULETYPE_DATEGROUP_SECOND);
        const AUTOFILTER_RULETYPE_DYNAMIC_YESTERDAY = 'yesterday';
        const AUTOFILTER_RULETYPE_DYNAMIC_TODAY = 'today';
        const AUTOFILTER_RULETYPE_DYNAMIC_TOMORROW = 'tomorrow';
        const AUTOFILTER_RULETYPE_DYNAMIC_YEARTODATE = 'yearToDate';
        const AUTOFILTER_RULETYPE_DYNAMIC_THISYEAR = 'thisYear';
        const AUTOFILTER_RULETYPE_DYNAMIC_THISQUARTER = 'thisQuarter';
        const AUTOFILTER_RULETYPE_DYNAMIC_THISMONTH = 'thisMonth';
        const AUTOFILTER_RULETYPE_DYNAMIC_THISWEEK = 'thisWeek';
        const AUTOFILTER_RULETYPE_DYNAMIC_LASTYEAR = 'lastYear';
        const AUTOFILTER_RULETYPE_DYNAMIC_LASTQUARTER = 'lastQuarter';
        const AUTOFILTER_RULETYPE_DYNAMIC_LASTMONTH = 'lastMonth';
        const AUTOFILTER_RULETYPE_DYNAMIC_LASTWEEK = 'lastWeek';
        const AUTOFILTER_RULETYPE_DYNAMIC_NEXTYEAR = 'nextYear';
        const AUTOFILTER_RULETYPE_DYNAMIC_NEXTQUARTER = 'nextQuarter';
        const AUTOFILTER_RULETYPE_DYNAMIC_NEXTMONTH = 'nextMonth';
        const AUTOFILTER_RULETYPE_DYNAMIC_NEXTWEEK = 'nextWeek';
        const AUTOFILTER_RULETYPE_DYNAMIC_MONTH_1 = 'M1';
        const AUTOFILTER_RULETYPE_DYNAMIC_JANUARY = self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_1;
        const AUTOFILTER_RULETYPE_DYNAMIC_MONTH_2 = 'M2';
        const AUTOFILTER_RULETYPE_DYNAMIC_FEBRUARY = self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_2;
        const AUTOFILTER_RULETYPE_DYNAMIC_MONTH_3 = 'M3';
        const AUTOFILTER_RULETYPE_DYNAMIC_MARCH = self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_3;
        const AUTOFILTER_RULETYPE_DYNAMIC_MONTH_4 = 'M4';
        const AUTOFILTER_RULETYPE_DYNAMIC_APRIL = self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_4;
        const AUTOFILTER_RULETYPE_DYNAMIC_MONTH_5 = 'M5';
        const AUTOFILTER_RULETYPE_DYNAMIC_MAY = self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_5;
        const AUTOFILTER_RULETYPE_DYNAMIC_MONTH_6 = 'M6';
        const AUTOFILTER_RULETYPE_DYNAMIC_JUNE = self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_6;
        const AUTOFILTER_RULETYPE_DYNAMIC_MONTH_7 = 'M7';
        const AUTOFILTER_RULETYPE_DYNAMIC_JULY = self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_7;
        const AUTOFILTER_RULETYPE_DYNAMIC_MONTH_8 = 'M8';
        const AUTOFILTER_RULETYPE_DYNAMIC_AUGUST = self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_8;
        const AUTOFILTER_RULETYPE_DYNAMIC_MONTH_9 = 'M9';
        const AUTOFILTER_RULETYPE_DYNAMIC_SEPTEMBER = self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_9;
        const AUTOFILTER_RULETYPE_DYNAMIC_MONTH_10 = 'M10';
        const AUTOFILTER_RULETYPE_DYNAMIC_OCTOBER = self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_10;
        const AUTOFILTER_RULETYPE_DYNAMIC_MONTH_11 = 'M11';
        const AUTOFILTER_RULETYPE_DYNAMIC_NOVEMBER = self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_11;
        const AUTOFILTER_RULETYPE_DYNAMIC_MONTH_12 = 'M12';
        const AUTOFILTER_RULETYPE_DYNAMIC_DECEMBER = self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_12;
        const AUTOFILTER_RULETYPE_DYNAMIC_QUARTER_1 = 'Q1';
        const AUTOFILTER_RULETYPE_DYNAMIC_QUARTER_2 = 'Q2';
        const AUTOFILTER_RULETYPE_DYNAMIC_QUARTER_3 = 'Q3';
        const AUTOFILTER_RULETYPE_DYNAMIC_QUARTER_4 = 'Q4';
        const AUTOFILTER_RULETYPE_DYNAMIC_ABOVEAVERAGE = 'aboveAverage';
        const AUTOFILTER_RULETYPE_DYNAMIC_BELOWAVERAGE = 'belowAverage';
        private static $_dynamicTypes = array(self::AUTOFILTER_RULETYPE_DYNAMIC_YESTERDAY, self::AUTOFILTER_RULETYPE_DYNAMIC_TODAY, self::AUTOFILTER_RULETYPE_DYNAMIC_TOMORROW, self::AUTOFILTER_RULETYPE_DYNAMIC_YEARTODATE, self::AUTOFILTER_RULETYPE_DYNAMIC_THISYEAR, self::AUTOFILTER_RULETYPE_DYNAMIC_THISQUARTER, self::AUTOFILTER_RULETYPE_DYNAMIC_THISMONTH, self::AUTOFILTER_RULETYPE_DYNAMIC_THISWEEK, self::AUTOFILTER_RULETYPE_DYNAMIC_LASTYEAR, self::AUTOFILTER_RULETYPE_DYNAMIC_LASTQUARTER, self::AUTOFILTER_RULETYPE_DYNAMIC_LASTMONTH, self::AUTOFILTER_RULETYPE_DYNAMIC_LASTWEEK, self::AUTOFILTER_RULETYPE_DYNAMIC_NEXTYEAR, self::AUTOFILTER_RULETYPE_DYNAMIC_NEXTQUARTER, self::AUTOFILTER_RULETYPE_DYNAMIC_NEXTMONTH, self::AUTOFILTER_RULETYPE_DYNAMIC_NEXTWEEK, self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_1, self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_2, self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_3, self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_4, self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_5, self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_6, self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_7, self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_8, self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_9, self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_10, self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_11, self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_12, self::AUTOFILTER_RULETYPE_DYNAMIC_QUARTER_1, self::AUTOFILTER_RULETYPE_DYNAMIC_QUARTER_2, self::AUTOFILTER_RULETYPE_DYNAMIC_QUARTER_3, self::AUTOFILTER_RULETYPE_DYNAMIC_QUARTER_4, self::AUTOFILTER_RULETYPE_DYNAMIC_ABOVEAVERAGE, self::AUTOFILTER_RULETYPE_DYNAMIC_BELOWAVERAGE);
        /*
         *	The only valid filter rule operators for filter and customFilter types are:
         *		<xsd:enumeration value="equal"/>
         *		<xsd:enumeration value="lessThan"/>
         *		<xsd:enumeration value="lessThanOrEqual"/>
         *		<xsd:enumeration value="notEqual"/>
         *		<xsd:enumeration value="greaterThanOrEqual"/>
         *		<xsd:enumeration value="greaterThan"/>
         */
        const AUTOFILTER_COLUMN_RULE_EQUAL = 'equal';
        const AUTOFILTER_COLUMN_RULE_NOTEQUAL = 'notEqual';
        const AUTOFILTER_COLUMN_RULE_GREATERTHAN = 'greaterThan';
        const AUTOFILTER_COLUMN_RULE_GREATERTHANOREQUAL = 'greaterThanOrEqual';
        const AUTOFILTER_COLUMN_RULE_LESSTHAN = 'lessThan';
        const AUTOFILTER_COLUMN_RULE_LESSTHANOREQUAL = 'lessThanOrEqual';
        private static $_operators = array(self::AUTOFILTER_COLUMN_RULE_EQUAL, self::AUTOFILTER_COLUMN_RULE_NOTEQUAL, self::AUTOFILTER_COLUMN_RULE_GREATERTHAN, self::AUTOFILTER_COLUMN_RULE_GREATERTHANOREQUAL, self::AUTOFILTER_COLUMN_RULE_LESSTHAN, self::AUTOFILTER_COLUMN_RULE_LESSTHANOREQUAL);
        const AUTOFILTER_COLUMN_RULE_TOPTEN_BY_VALUE = 'byValue';
        const AUTOFILTER_COLUMN_RULE_TOPTEN_PERCENT = 'byPercent';
        private static $_topTenValue = array(self::AUTOFILTER_COLUMN_RULE_TOPTEN_BY_VALUE, self::AUTOFILTER_COLUMN_RULE_TOPTEN_PERCENT);
        const AUTOFILTER_COLUMN_RULE_TOPTEN_TOP = 'top';
        const AUTOFILTER_COLUMN_RULE_TOPTEN_BOTTOM = 'bottom';
        private static $_topTenType = array(self::AUTOFILTER_COLUMN_RULE_TOPTEN_TOP, self::AUTOFILTER_COLUMN_RULE_TOPTEN_BOTTOM);
        /* Rule Operators (Numeric, Boolean etc) */
        //	const AUTOFILTER_COLUMN_RULE_BETWEEN			= 'between';		//	greaterThanOrEqual 1 && lessThanOrEqual 2
        /* Rule Operators (Numeric Special) which are translated to standard numeric operators with calculated values */
        //	const AUTOFILTER_COLUMN_RULE_TOPTEN				= 'topTen';			//	greaterThan calculated value
        //	const AUTOFILTER_COLUMN_RULE_TOPTENPERCENT		= 'topTenPercent';	//	greaterThan calculated value
        //	const AUTOFILTER_COLUMN_RULE_ABOVEAVERAGE		= 'aboveAverage';	//	Value is calculated as the average
        //	const AUTOFILTER_COLUMN_RULE_BELOWAVERAGE		= 'belowAverage';	//	Value is calculated as the average
        /* Rule Operators (String) which are set as wild-carded values */
        //	const AUTOFILTER_COLUMN_RULE_BEGINSWITH			= 'beginsWith';			// A*
        //	const AUTOFILTER_COLUMN_RULE_ENDSWITH			= 'endsWith';			// *Z
        //	const AUTOFILTER_COLUMN_RULE_CONTAINS			= 'contains';			// *B*
        //	const AUTOFILTER_COLUMN_RULE_DOESNTCONTAIN		= 'notEqual';			//	notEqual *B*
        /* Rule Operators (Date Special) which are translated to standard numeric operators with calculated values */
        //	const AUTOFILTER_COLUMN_RULE_BEFORE				= 'lessThan';
        //	const AUTOFILTER_COLUMN_RULE_AFTER				= 'greaterThan';
        //	const AUTOFILTER_COLUMN_RULE_YESTERDAY			= 'yesterday';
        //	const AUTOFILTER_COLUMN_RULE_TODAY				= 'today';
        //	const AUTOFILTER_COLUMN_RULE_TOMORROW			= 'tomorrow';
        //	const AUTOFILTER_COLUMN_RULE_LASTWEEK			= 'lastWeek';
        //	const AUTOFILTER_COLUMN_RULE_THISWEEK			= 'thisWeek';
        //	const AUTOFILTER_COLUMN_RULE_NEXTWEEK			= 'nextWeek';
        //	const AUTOFILTER_COLUMN_RULE_LASTMONTH			= 'lastMonth';
        //	const AUTOFILTER_COLUMN_RULE_THISMONTH			= 'thisMonth';
        //	const AUTOFILTER_COLUMN_RULE_NEXTMONTH			= 'nextMonth';
        //	const AUTOFILTER_COLUMN_RULE_LASTQUARTER		= 'lastQuarter';
        //	const AUTOFILTER_COLUMN_RULE_THISQUARTER		= 'thisQuarter';
        //	const AUTOFILTER_COLUMN_RULE_NEXTQUARTER		= 'nextQuarter';
        //	const AUTOFILTER_COLUMN_RULE_LASTYEAR			= 'lastYear';
        //	const AUTOFILTER_COLUMN_RULE_THISYEAR			= 'thisYear';
        //	const AUTOFILTER_COLUMN_RULE_NEXTYEAR			= 'nextYear';
        //	const AUTOFILTER_COLUMN_RULE_YEARTODATE			= 'yearToDate';			//	<dynamicFilter val="40909" type="yearToDate" maxVal="41113"/>
        //	const AUTOFILTER_COLUMN_RULE_ALLDATESINMONTH	= 'allDatesInMonth';	//	<dynamicFilter type="M2"/> for Month/February
        //	const AUTOFILTER_COLUMN_RULE_ALLDATESINQUARTER	= 'allDatesInQuarter';	//	<dynamicFilter type="Q2"/> for Quarter 2
        /**
         * Autofilter Column
         *
         * @var PHPExcel_Worksheet_AutoFilter_Column
         */
        private $_parent = \NULL;
        /**
         * Autofilter Rule Type
         *
         * @var string
         */
        private $_ruleType = self::AUTOFILTER_RULETYPE_FILTER;
        /**
         * Autofilter Rule Value
         *
         * @var string
         */
        private $_value = '';
        /**
         * Autofilter Rule Operator
         *
         * @var string
         */
        private $_operator = '';
        /**
         * DateTimeGrouping Group Value
         *
         * @var string
         */
        private $_grouping = '';
        /**
         * Create a new PHPExcel_Worksheet_AutoFilter_Column_Rule
         *
         * @param PHPExcel_Worksheet_AutoFilter_Column $pParent
         */
        public function __construct(\PHPExcel_Worksheet_AutoFilter_Column $pParent = \NULL)
        {
        }
        /**
         * Get AutoFilter Rule Type
         *
         * @return string
         */
        public function getRuleType()
        {
        }
        /**
         *	Set AutoFilter Rule Type
         *
         *	@param	string		$pRuleType
         *	@throws	PHPExcel_Exception
         *	@return PHPExcel_Worksheet_AutoFilter_Column
         */
        public function setRuleType($pRuleType = self::AUTOFILTER_RULETYPE_FILTER)
        {
        }
        /**
         * Get AutoFilter Rule Value
         *
         * @return string
         */
        public function getValue()
        {
        }
        /**
         *	Set AutoFilter Rule Value
         *
         *	@param	string|string[]		$pValue
         *	@throws	PHPExcel_Exception
         *	@return PHPExcel_Worksheet_AutoFilter_Column_Rule
         */
        public function setValue($pValue = '')
        {
        }
        /**
         * Get AutoFilter Rule Operator
         *
         * @return string
         */
        public function getOperator()
        {
        }
        /**
         *	Set AutoFilter Rule Operator
         *
         *	@param	string		$pOperator
         *	@throws	PHPExcel_Exception
         *	@return PHPExcel_Worksheet_AutoFilter_Column_Rule
         */
        public function setOperator($pOperator = self::AUTOFILTER_COLUMN_RULE_EQUAL)
        {
        }
        /**
         * Get AutoFilter Rule Grouping
         *
         * @return string
         */
        public function getGrouping()
        {
        }
        /**
         *	Set AutoFilter Rule Grouping
         *
         *	@param	string		$pGrouping
         *	@throws	PHPExcel_Exception
         *	@return PHPExcel_Worksheet_AutoFilter_Column_Rule
         */
        public function setGrouping($pGrouping = \NULL)
        {
        }
        /**
         *	Set AutoFilter Rule
         *
         *	@param	string				$pOperator
         *	@param	string|string[]		$pValue
         *	@param	string				$pGrouping
         *	@throws	PHPExcel_Exception
         *	@return PHPExcel_Worksheet_AutoFilter_Column_Rule
         */
        public function setRule($pOperator = self::AUTOFILTER_COLUMN_RULE_EQUAL, $pValue = '', $pGrouping = \NULL)
        {
        }
        /**
         * Get this Rule's AutoFilter Column Parent
         *
         * @return PHPExcel_Worksheet_AutoFilter_Column
         */
        public function getParent()
        {
        }
        /**
         * Set this Rule's AutoFilter Column Parent
         *
         * @param PHPExcel_Worksheet_AutoFilter_Column
         * @return PHPExcel_Worksheet_AutoFilter_Column_Rule
         */
        public function setParent(\PHPExcel_Worksheet_AutoFilter_Column $pParent = \NULL)
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category	PHPExcel
     * @package		PHPExcel_Worksheet
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license		http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version		1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Worksheet_AutoFilter_Column
     *
     * @category	PHPExcel
     * @package		PHPExcel_Worksheet
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Worksheet_AutoFilter_Column
    {
        const AUTOFILTER_FILTERTYPE_FILTER = 'filters';
        const AUTOFILTER_FILTERTYPE_CUSTOMFILTER = 'customFilters';
        //	Supports no more than 2 rules, with an And/Or join criteria
        //		if more than 1 rule is defined
        const AUTOFILTER_FILTERTYPE_DYNAMICFILTER = 'dynamicFilter';
        //	Even though the filter rule is constant, the filtered data can vary
        //		e.g. filtered by date = TODAY
        const AUTOFILTER_FILTERTYPE_TOPTENFILTER = 'top10';
        /**
         * Types of autofilter rules
         *
         * @var string[]
         */
        private static $_filterTypes = array(
            //	Currently we're not handling
            //		colorFilter
            //		extLst
            //		iconFilter
            self::AUTOFILTER_FILTERTYPE_FILTER,
            self::AUTOFILTER_FILTERTYPE_CUSTOMFILTER,
            self::AUTOFILTER_FILTERTYPE_DYNAMICFILTER,
            self::AUTOFILTER_FILTERTYPE_TOPTENFILTER,
        );
        /* Multiple Rule Connections */
        const AUTOFILTER_COLUMN_JOIN_AND = 'and';
        const AUTOFILTER_COLUMN_JOIN_OR = 'or';
        /**
         * Join options for autofilter rules
         *
         * @var string[]
         */
        private static $_ruleJoins = array(self::AUTOFILTER_COLUMN_JOIN_AND, self::AUTOFILTER_COLUMN_JOIN_OR);
        /**
         * Autofilter
         *
         * @var PHPExcel_Worksheet_AutoFilter
         */
        private $_parent = \NULL;
        /**
         * Autofilter Column Index
         *
         * @var string
         */
        private $_columnIndex = '';
        /**
         * Autofilter Column Filter Type
         *
         * @var string
         */
        private $_filterType = self::AUTOFILTER_FILTERTYPE_FILTER;
        /**
         * Autofilter Multiple Rules And/Or
         *
         * @var string
         */
        private $_join = self::AUTOFILTER_COLUMN_JOIN_OR;
        /**
         * Autofilter Column Rules
         *
         * @var array of PHPExcel_Worksheet_AutoFilter_Column_Rule
         */
        private $_ruleset = array();
        /**
         * Autofilter Column Dynamic Attributes
         *
         * @var array of mixed
         */
        private $_attributes = array();
        /**
         * Create a new PHPExcel_Worksheet_AutoFilter_Column
         *
         *	@param	string		                   $pColumn		Column (e.g. A)
         *	@param	PHPExcel_Worksheet_AutoFilter  $pParent		Autofilter for this column
         */
        public function __construct($pColumn, \PHPExcel_Worksheet_AutoFilter $pParent = \NULL)
        {
        }
        /**
         * Get AutoFilter Column Index
         *
         * @return string
         */
        public function getColumnIndex()
        {
        }
        /**
         *	Set AutoFilter Column Index
         *
         *	@param	string		$pColumn		Column (e.g. A)
         *	@throws	PHPExcel_Exception
         *	@return PHPExcel_Worksheet_AutoFilter_Column
         */
        public function setColumnIndex($pColumn)
        {
        }
        /**
         * Get this Column's AutoFilter Parent
         *
         * @return PHPExcel_Worksheet_AutoFilter
         */
        public function getParent()
        {
        }
        /**
         * Set this Column's AutoFilter Parent
         *
         * @param PHPExcel_Worksheet_AutoFilter
         * @return PHPExcel_Worksheet_AutoFilter_Column
         */
        public function setParent(\PHPExcel_Worksheet_AutoFilter $pParent = \NULL)
        {
        }
        /**
         * Get AutoFilter Type
         *
         * @return string
         */
        public function getFilterType()
        {
        }
        /**
         *	Set AutoFilter Type
         *
         *	@param	string		$pFilterType
         *	@throws	PHPExcel_Exception
         *	@return PHPExcel_Worksheet_AutoFilter_Column
         */
        public function setFilterType($pFilterType = self::AUTOFILTER_FILTERTYPE_FILTER)
        {
        }
        /**
         * Get AutoFilter Multiple Rules And/Or Join
         *
         * @return string
         */
        public function getJoin()
        {
        }
        /**
         *	Set AutoFilter Multiple Rules And/Or
         *
         *	@param	string		$pJoin		And/Or
         *	@throws	PHPExcel_Exception
         *	@return PHPExcel_Worksheet_AutoFilter_Column
         */
        public function setJoin($pJoin = self::AUTOFILTER_COLUMN_JOIN_OR)
        {
        }
        /**
         *	Set AutoFilter Attributes
         *
         *	@param	string[]		$pAttributes
         *	@throws	PHPExcel_Exception
         *	@return PHPExcel_Worksheet_AutoFilter_Column
         */
        public function setAttributes($pAttributes = array())
        {
        }
        /**
         *	Set An AutoFilter Attribute
         *
         *	@param	string		$pName		Attribute Name
         *	@param	string		$pValue		Attribute Value
         *	@throws	PHPExcel_Exception
         *	@return PHPExcel_Worksheet_AutoFilter_Column
         */
        public function setAttribute($pName, $pValue)
        {
        }
        /**
         * Get AutoFilter Column Attributes
         *
         * @return string
         */
        public function getAttributes()
        {
        }
        /**
         * Get specific AutoFilter Column Attribute
         *
         *	@param	string		$pName		Attribute Name
         * @return string
         */
        public function getAttribute($pName)
        {
        }
        /**
         * Get all AutoFilter Column Rules
         *
         * @throws	PHPExcel_Exception
         * @return array of PHPExcel_Worksheet_AutoFilter_Column_Rule
         */
        public function getRules()
        {
        }
        /**
         * Get a specified AutoFilter Column Rule
         *
         * @param	integer	$pIndex		Rule index in the ruleset array
         * @return	PHPExcel_Worksheet_AutoFilter_Column_Rule
         */
        public function getRule($pIndex)
        {
        }
        /**
         * Create a new AutoFilter Column Rule in the ruleset
         *
         * @return	PHPExcel_Worksheet_AutoFilter_Column_Rule
         */
        public function createRule()
        {
        }
        /**
         * Add a new AutoFilter Column Rule to the ruleset
         *
         * @param	PHPExcel_Worksheet_AutoFilter_Column_Rule	$pRule
         * @param	boolean	$returnRule 	Flag indicating whether the rule object or the column object should be returned
         * @return	PHPExcel_Worksheet_AutoFilter_Column|PHPExcel_Worksheet_AutoFilter_Column_Rule
         */
        public function addRule(\PHPExcel_Worksheet_AutoFilter_Column_Rule $pRule, $returnRule = \TRUE)
        {
        }
        /**
         * Delete a specified AutoFilter Column Rule
         *	If the number of rules is reduced to 1, then we reset And/Or logic to Or
         *
         * @param	integer	$pIndex		Rule index in the ruleset array
         * @return	PHPExcel_Worksheet_AutoFilter_Column
         */
        public function deleteRule($pIndex)
        {
        }
        /**
         * Delete all AutoFilter Column Rules
         *
         * @return	PHPExcel_Worksheet_AutoFilter_Column
         */
        public function clearRules()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Worksheet_CellIterator
     *
     * Used to iterate rows in a PHPExcel_Worksheet
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Worksheet_CellIterator implements \Iterator
    {
        /**
         * PHPExcel_Worksheet to iterate
         *
         * @var PHPExcel_Worksheet
         */
        private $_subject;
        /**
         * Row index
         *
         * @var int
         */
        private $_rowIndex;
        /**
         * Current iterator position
         *
         * @var int
         */
        private $_position = 0;
        /**
         * Loop only existing cells
         *
         * @var boolean
         */
        private $_onlyExistingCells = \true;
        /**
         * Create a new cell iterator
         *
         * @param PHPExcel_Worksheet 		$subject
         * @param int						$rowIndex
         */
        public function __construct(\PHPExcel_Worksheet $subject = \null, $rowIndex = 1)
        {
        }
        /**
         * Destructor
         */
        public function __destruct()
        {
        }
        /**
         * Rewind iterator
         */
        public function rewind()
        {
        }
        /**
         * Current PHPExcel_Cell
         *
         * @return PHPExcel_Cell
         */
        public function current()
        {
        }
        /**
         * Current key
         *
         * @return int
         */
        public function key()
        {
        }
        /**
         * Next value
         */
        public function next()
        {
        }
        /**
         * Are there any more PHPExcel_Cell instances available?
         *
         * @return boolean
         */
        public function valid()
        {
        }
        /**
         * Get loop only existing cells
         *
         * @return boolean
         */
        public function getIterateOnlyExistingCells()
        {
        }
        /**
         * Set the iterator to loop only existing cells
         *
         * @param	boolean		$value
         */
        public function setIterateOnlyExistingCells($value = \true)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet_Drawing
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Worksheet_Drawing_Shadow
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet_Drawing
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Worksheet_Drawing_Shadow implements \PHPExcel_IComparable
    {
        /* Shadow alignment */
        const SHADOW_BOTTOM = 'b';
        const SHADOW_BOTTOM_LEFT = 'bl';
        const SHADOW_BOTTOM_RIGHT = 'br';
        const SHADOW_CENTER = 'ctr';
        const SHADOW_LEFT = 'l';
        const SHADOW_TOP = 't';
        const SHADOW_TOP_LEFT = 'tl';
        const SHADOW_TOP_RIGHT = 'tr';
        /**
         * Visible
         *
         * @var boolean
         */
        private $_visible;
        /**
         * Blur radius
         *
         * Defaults to 6
         *
         * @var int
         */
        private $_blurRadius;
        /**
         * Shadow distance
         *
         * Defaults to 2
         *
         * @var int
         */
        private $_distance;
        /**
         * Shadow direction (in degrees)
         *
         * @var int
         */
        private $_direction;
        /**
         * Shadow alignment
         *
         * @var int
         */
        private $_alignment;
        /**
         * Color
         *
         * @var PHPExcel_Style_Color
         */
        private $_color;
        /**
         * Alpha
         *
         * @var int
         */
        private $_alpha;
        /**
         * Create a new PHPExcel_Worksheet_Drawing_Shadow
         */
        public function __construct()
        {
        }
        /**
         * Get Visible
         *
         * @return boolean
         */
        public function getVisible()
        {
        }
        /**
         * Set Visible
         *
         * @param boolean $pValue
         * @return PHPExcel_Worksheet_Drawing_Shadow
         */
        public function setVisible($pValue = \false)
        {
        }
        /**
         * Get Blur radius
         *
         * @return int
         */
        public function getBlurRadius()
        {
        }
        /**
         * Set Blur radius
         *
         * @param int $pValue
         * @return PHPExcel_Worksheet_Drawing_Shadow
         */
        public function setBlurRadius($pValue = 6)
        {
        }
        /**
         * Get Shadow distance
         *
         * @return int
         */
        public function getDistance()
        {
        }
        /**
         * Set Shadow distance
         *
         * @param int $pValue
         * @return PHPExcel_Worksheet_Drawing_Shadow
         */
        public function setDistance($pValue = 2)
        {
        }
        /**
         * Get Shadow direction (in degrees)
         *
         * @return int
         */
        public function getDirection()
        {
        }
        /**
         * Set Shadow direction (in degrees)
         *
         * @param int $pValue
         * @return PHPExcel_Worksheet_Drawing_Shadow
         */
        public function setDirection($pValue = 0)
        {
        }
        /**
         * Get Shadow alignment
         *
         * @return int
         */
        public function getAlignment()
        {
        }
        /**
         * Set Shadow alignment
         *
         * @param int $pValue
         * @return PHPExcel_Worksheet_Drawing_Shadow
         */
        public function setAlignment($pValue = 0)
        {
        }
        /**
         * Get Color
         *
         * @return PHPExcel_Style_Color
         */
        public function getColor()
        {
        }
        /**
         * Set Color
         *
         * @param 	PHPExcel_Style_Color $pValue
         * @throws 	PHPExcel_Exception
         * @return PHPExcel_Worksheet_Drawing_Shadow
         */
        public function setColor(\PHPExcel_Style_Color $pValue = \null)
        {
        }
        /**
         * Get Alpha
         *
         * @return int
         */
        public function getAlpha()
        {
        }
        /**
         * Set Alpha
         *
         * @param int $pValue
         * @return PHPExcel_Worksheet_Drawing_Shadow
         */
        public function setAlpha($pValue = 0)
        {
        }
        /**
         * Get hash code
         *
         * @return string	Hash code
         */
        public function getHashCode()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Worksheet_ColumnDimension
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Worksheet_ColumnDimension
    {
        /**
         * Column index
         *
         * @var int
         */
        private $_columnIndex;
        /**
         * Column width
         *
         * When this is set to a negative value, the column width should be ignored by IWriter
         *
         * @var double
         */
        private $_width = -1;
        /**
         * Auto size?
         *
         * @var bool
         */
        private $_autoSize = \false;
        /**
         * Visible?
         *
         * @var bool
         */
        private $_visible = \true;
        /**
         * Outline level
         *
         * @var int
         */
        private $_outlineLevel = 0;
        /**
         * Collapsed
         *
         * @var bool
         */
        private $_collapsed = \false;
        /**
         * Index to cellXf
         *
         * @var int
         */
        private $_xfIndex;
        /**
         * Create a new PHPExcel_Worksheet_ColumnDimension
         *
         * @param string $pIndex Character column index
         */
        public function __construct($pIndex = 'A')
        {
        }
        /**
         * Get ColumnIndex
         *
         * @return string
         */
        public function getColumnIndex()
        {
        }
        /**
         * Set ColumnIndex
         *
         * @param string $pValue
         * @return PHPExcel_Worksheet_ColumnDimension
         */
        public function setColumnIndex($pValue)
        {
        }
        /**
         * Get Width
         *
         * @return double
         */
        public function getWidth()
        {
        }
        /**
         * Set Width
         *
         * @param double $pValue
         * @return PHPExcel_Worksheet_ColumnDimension
         */
        public function setWidth($pValue = -1)
        {
        }
        /**
         * Get Auto Size
         *
         * @return bool
         */
        public function getAutoSize()
        {
        }
        /**
         * Set Auto Size
         *
         * @param bool $pValue
         * @return PHPExcel_Worksheet_ColumnDimension
         */
        public function setAutoSize($pValue = \false)
        {
        }
        /**
         * Get Visible
         *
         * @return bool
         */
        public function getVisible()
        {
        }
        /**
         * Set Visible
         *
         * @param bool $pValue
         * @return PHPExcel_Worksheet_ColumnDimension
         */
        public function setVisible($pValue = \true)
        {
        }
        /**
         * Get Outline Level
         *
         * @return int
         */
        public function getOutlineLevel()
        {
        }
        /**
         * Set Outline Level
         *
         * Value must be between 0 and 7
         *
         * @param int $pValue
         * @throws PHPExcel_Exception
         * @return PHPExcel_Worksheet_ColumnDimension
         */
        public function setOutlineLevel($pValue)
        {
        }
        /**
         * Get Collapsed
         *
         * @return bool
         */
        public function getCollapsed()
        {
        }
        /**
         * Set Collapsed
         *
         * @param bool $pValue
         * @return PHPExcel_Worksheet_ColumnDimension
         */
        public function setCollapsed($pValue = \true)
        {
        }
        /**
         * Get index to cellXf
         *
         * @return int
         */
        public function getXfIndex()
        {
        }
        /**
         * Set index to cellXf
         *
         * @param int $pValue
         * @return PHPExcel_Worksheet_ColumnDimension
         */
        public function setXfIndex($pValue = 0)
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Worksheet_BaseDrawing
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Worksheet_BaseDrawing implements \PHPExcel_IComparable
    {
        /**
         * Image counter
         *
         * @var int
         */
        private static $_imageCounter = 0;
        /**
         * Image index
         *
         * @var int
         */
        private $_imageIndex = 0;
        /**
         * Name
         *
         * @var string
         */
        protected $_name;
        /**
         * Description
         *
         * @var string
         */
        protected $_description;
        /**
         * Worksheet
         *
         * @var PHPExcel_Worksheet
         */
        protected $_worksheet;
        /**
         * Coordinates
         *
         * @var string
         */
        protected $_coordinates;
        /**
         * Offset X
         *
         * @var int
         */
        protected $_offsetX;
        /**
         * Offset Y
         *
         * @var int
         */
        protected $_offsetY;
        /**
         * Width
         *
         * @var int
         */
        protected $_width;
        /**
         * Height
         *
         * @var int
         */
        protected $_height;
        /**
         * Proportional resize
         *
         * @var boolean
         */
        protected $_resizeProportional;
        /**
         * Rotation
         *
         * @var int
         */
        protected $_rotation;
        /**
         * Shadow
         *
         * @var PHPExcel_Worksheet_Drawing_Shadow
         */
        protected $_shadow;
        /**
         * Create a new PHPExcel_Worksheet_BaseDrawing
         */
        public function __construct()
        {
        }
        /**
         * Get image index
         *
         * @return int
         */
        public function getImageIndex()
        {
        }
        /**
         * Get Name
         *
         * @return string
         */
        public function getName()
        {
        }
        /**
         * Set Name
         *
         * @param string $pValue
         * @return PHPExcel_Worksheet_BaseDrawing
         */
        public function setName($pValue = '')
        {
        }
        /**
         * Get Description
         *
         * @return string
         */
        public function getDescription()
        {
        }
        /**
         * Set Description
         *
         * @param string $pValue
         * @return PHPExcel_Worksheet_BaseDrawing
         */
        public function setDescription($pValue = '')
        {
        }
        /**
         * Get Worksheet
         *
         * @return PHPExcel_Worksheet
         */
        public function getWorksheet()
        {
        }
        /**
         * Set Worksheet
         *
         * @param 	PHPExcel_Worksheet 	$pValue
         * @param 	bool				$pOverrideOld	If a Worksheet has already been assigned, overwrite it and remove image from old Worksheet?
         * @throws 	PHPExcel_Exception
         * @return PHPExcel_Worksheet_BaseDrawing
         */
        public function setWorksheet(\PHPExcel_Worksheet $pValue = \null, $pOverrideOld = \false)
        {
        }
        /**
         * Get Coordinates
         *
         * @return string
         */
        public function getCoordinates()
        {
        }
        /**
         * Set Coordinates
         *
         * @param string $pValue
         * @return PHPExcel_Worksheet_BaseDrawing
         */
        public function setCoordinates($pValue = 'A1')
        {
        }
        /**
         * Get OffsetX
         *
         * @return int
         */
        public function getOffsetX()
        {
        }
        /**
         * Set OffsetX
         *
         * @param int $pValue
         * @return PHPExcel_Worksheet_BaseDrawing
         */
        public function setOffsetX($pValue = 0)
        {
        }
        /**
         * Get OffsetY
         *
         * @return int
         */
        public function getOffsetY()
        {
        }
        /**
         * Set OffsetY
         *
         * @param int $pValue
         * @return PHPExcel_Worksheet_BaseDrawing
         */
        public function setOffsetY($pValue = 0)
        {
        }
        /**
         * Get Width
         *
         * @return int
         */
        public function getWidth()
        {
        }
        /**
         * Set Width
         *
         * @param int $pValue
         * @return PHPExcel_Worksheet_BaseDrawing
         */
        public function setWidth($pValue = 0)
        {
        }
        /**
         * Get Height
         *
         * @return int
         */
        public function getHeight()
        {
        }
        /**
         * Set Height
         *
         * @param int $pValue
         * @return PHPExcel_Worksheet_BaseDrawing
         */
        public function setHeight($pValue = 0)
        {
        }
        /**
         * Set width and height with proportional resize
         * Example:
         * <code>
         * $objDrawing->setResizeProportional(true);
         * $objDrawing->setWidthAndHeight(160,120);
         * </code>
         *
         * @author Vincent@luo MSN:kele_100@hotmail.com
         * @param int $width
         * @param int $height
         * @return PHPExcel_Worksheet_BaseDrawing
         */
        public function setWidthAndHeight($width = 0, $height = 0)
        {
        }
        /**
         * Get ResizeProportional
         *
         * @return boolean
         */
        public function getResizeProportional()
        {
        }
        /**
         * Set ResizeProportional
         *
         * @param boolean $pValue
         * @return PHPExcel_Worksheet_BaseDrawing
         */
        public function setResizeProportional($pValue = \true)
        {
        }
        /**
         * Get Rotation
         *
         * @return int
         */
        public function getRotation()
        {
        }
        /**
         * Set Rotation
         *
         * @param int $pValue
         * @return PHPExcel_Worksheet_BaseDrawing
         */
        public function setRotation($pValue = 0)
        {
        }
        /**
         * Get Shadow
         *
         * @return PHPExcel_Worksheet_Drawing_Shadow
         */
        public function getShadow()
        {
        }
        /**
         * Set Shadow
         *
         * @param 	PHPExcel_Worksheet_Drawing_Shadow $pValue
         * @throws 	PHPExcel_Exception
         * @return PHPExcel_Worksheet_BaseDrawing
         */
        public function setShadow(\PHPExcel_Worksheet_Drawing_Shadow $pValue = \null)
        {
        }
        /**
         * Get hash code
         *
         * @return string	Hash code
         */
        public function getHashCode()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet_Drawing
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Worksheet_Drawing
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet_Drawing
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Worksheet_Drawing extends \PHPExcel_Worksheet_BaseDrawing implements \PHPExcel_IComparable
    {
        /**
         * Path
         *
         * @var string
         */
        private $_path;
        /**
         * Create a new PHPExcel_Worksheet_Drawing
         */
        public function __construct()
        {
        }
        /**
         * Get Filename
         *
         * @return string
         */
        public function getFilename()
        {
        }
        /**
         * Get indexed filename (using image index)
         *
         * @return string
         */
        public function getIndexedFilename()
        {
        }
        /**
         * Get Extension
         *
         * @return string
         */
        public function getExtension()
        {
        }
        /**
         * Get Path
         *
         * @return string
         */
        public function getPath()
        {
        }
        /**
         * Set Path
         *
         * @param 	string 		$pValue			File path
         * @param 	boolean		$pVerifyFile	Verify file
         * @throws 	PHPExcel_Exception
         * @return PHPExcel_Worksheet_Drawing
         */
        public function setPath($pValue = '', $pVerifyFile = \true)
        {
        }
        /**
         * Get hash code
         *
         * @return string	Hash code
         */
        public function getHashCode()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Worksheet_HeaderFooter
     *
     * <code>
     * Header/Footer Formatting Syntax taken from Office Open XML Part 4 - Markup Language Reference, page 1970:
     *
     * There are a number of formatting codes that can be written inline with the actual header / footer text, which
     * affect the formatting in the header or footer.
     *
     * Example: This example shows the text "Center Bold Header" on the first line (center section), and the date on
     * the second line (center section).
     * 		&CCenter &"-,Bold"Bold&"-,Regular"Header_x000A_&D
     *
     * General Rules:
     * There is no required order in which these codes must appear.
     *
     * The first occurrence of the following codes turns the formatting ON, the second occurrence turns it OFF again:
     * - strikethrough
     * - superscript
     * - subscript
     * Superscript and subscript cannot both be ON at same time. Whichever comes first wins and the other is ignored,
     * while the first is ON.
     * &L - code for "left section" (there are three header / footer locations, "left", "center", and "right"). When
     * two or more occurrences of this section marker exist, the contents from all markers are concatenated, in the
     * order of appearance, and placed into the left section.
     * &P - code for "current page #"
     * &N - code for "total pages"
     * &font size - code for "text font size", where font size is a font size in points.
     * &K - code for "text font color"
     * RGB Color is specified as RRGGBB
     * Theme Color is specifed as TTSNN where TT is the theme color Id, S is either "+" or "-" of the tint/shade
     * value, NN is the tint/shade value.
     * &S - code for "text strikethrough" on / off
     * &X - code for "text super script" on / off
     * &Y - code for "text subscript" on / off
     * &C - code for "center section". When two or more occurrences of this section marker exist, the contents
     * from all markers are concatenated, in the order of appearance, and placed into the center section.
     *
     * &D - code for "date"
     * &T - code for "time"
     * &G - code for "picture as background"
     * &U - code for "text single underline"
     * &E - code for "double underline"
     * &R - code for "right section". When two or more occurrences of this section marker exist, the contents
     * from all markers are concatenated, in the order of appearance, and placed into the right section.
     * &Z - code for "this workbook's file path"
     * &F - code for "this workbook's file name"
     * &A - code for "sheet tab name"
     * &+ - code for add to page #.
     * &- - code for subtract from page #.
     * &"font name,font type" - code for "text font name" and "text font type", where font name and font type
     * are strings specifying the name and type of the font, separated by a comma. When a hyphen appears in font
     * name, it means "none specified". Both of font name and font type can be localized values.
     * &"-,Bold" - code for "bold font style"
     * &B - also means "bold font style".
     * &"-,Regular" - code for "regular font style"
     * &"-,Italic" - code for "italic font style"
     * &I - also means "italic font style"
     * &"-,Bold Italic" code for "bold italic font style"
     * &O - code for "outline style"
     * &H - code for "shadow style"
     * </code>
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Worksheet_HeaderFooter
    {
        /* Header/footer image location */
        const IMAGE_HEADER_LEFT = 'LH';
        const IMAGE_HEADER_CENTER = 'CH';
        const IMAGE_HEADER_RIGHT = 'RH';
        const IMAGE_FOOTER_LEFT = 'LF';
        const IMAGE_FOOTER_CENTER = 'CF';
        const IMAGE_FOOTER_RIGHT = 'RF';
        /**
         * OddHeader
         *
         * @var string
         */
        private $_oddHeader = '';
        /**
         * OddFooter
         *
         * @var string
         */
        private $_oddFooter = '';
        /**
         * EvenHeader
         *
         * @var string
         */
        private $_evenHeader = '';
        /**
         * EvenFooter
         *
         * @var string
         */
        private $_evenFooter = '';
        /**
         * FirstHeader
         *
         * @var string
         */
        private $_firstHeader = '';
        /**
         * FirstFooter
         *
         * @var string
         */
        private $_firstFooter = '';
        /**
         * Different header for Odd/Even, defaults to false
         *
         * @var boolean
         */
        private $_differentOddEven = \false;
        /**
         * Different header for first page, defaults to false
         *
         * @var boolean
         */
        private $_differentFirst = \false;
        /**
         * Scale with document, defaults to true
         *
         * @var boolean
         */
        private $_scaleWithDocument = \true;
        /**
         * Align with margins, defaults to true
         *
         * @var boolean
         */
        private $_alignWithMargins = \true;
        /**
         * Header/footer images
         *
         * @var PHPExcel_Worksheet_HeaderFooterDrawing[]
         */
        private $_headerFooterImages = array();
        /**
         * Create a new PHPExcel_Worksheet_HeaderFooter
         */
        public function __construct()
        {
        }
        /**
         * Get OddHeader
         *
         * @return string
         */
        public function getOddHeader()
        {
        }
        /**
         * Set OddHeader
         *
         * @param string $pValue
         * @return PHPExcel_Worksheet_HeaderFooter
         */
        public function setOddHeader($pValue)
        {
        }
        /**
         * Get OddFooter
         *
         * @return string
         */
        public function getOddFooter()
        {
        }
        /**
         * Set OddFooter
         *
         * @param string $pValue
         * @return PHPExcel_Worksheet_HeaderFooter
         */
        public function setOddFooter($pValue)
        {
        }
        /**
         * Get EvenHeader
         *
         * @return string
         */
        public function getEvenHeader()
        {
        }
        /**
         * Set EvenHeader
         *
         * @param string $pValue
         * @return PHPExcel_Worksheet_HeaderFooter
         */
        public function setEvenHeader($pValue)
        {
        }
        /**
         * Get EvenFooter
         *
         * @return string
         */
        public function getEvenFooter()
        {
        }
        /**
         * Set EvenFooter
         *
         * @param string $pValue
         * @return PHPExcel_Worksheet_HeaderFooter
         */
        public function setEvenFooter($pValue)
        {
        }
        /**
         * Get FirstHeader
         *
         * @return string
         */
        public function getFirstHeader()
        {
        }
        /**
         * Set FirstHeader
         *
         * @param string $pValue
         * @return PHPExcel_Worksheet_HeaderFooter
         */
        public function setFirstHeader($pValue)
        {
        }
        /**
         * Get FirstFooter
         *
         * @return string
         */
        public function getFirstFooter()
        {
        }
        /**
         * Set FirstFooter
         *
         * @param string $pValue
         * @return PHPExcel_Worksheet_HeaderFooter
         */
        public function setFirstFooter($pValue)
        {
        }
        /**
         * Get DifferentOddEven
         *
         * @return boolean
         */
        public function getDifferentOddEven()
        {
        }
        /**
         * Set DifferentOddEven
         *
         * @param boolean $pValue
         * @return PHPExcel_Worksheet_HeaderFooter
         */
        public function setDifferentOddEven($pValue = \false)
        {
        }
        /**
         * Get DifferentFirst
         *
         * @return boolean
         */
        public function getDifferentFirst()
        {
        }
        /**
         * Set DifferentFirst
         *
         * @param boolean $pValue
         * @return PHPExcel_Worksheet_HeaderFooter
         */
        public function setDifferentFirst($pValue = \false)
        {
        }
        /**
         * Get ScaleWithDocument
         *
         * @return boolean
         */
        public function getScaleWithDocument()
        {
        }
        /**
         * Set ScaleWithDocument
         *
         * @param boolean $pValue
         * @return PHPExcel_Worksheet_HeaderFooter
         */
        public function setScaleWithDocument($pValue = \true)
        {
        }
        /**
         * Get AlignWithMargins
         *
         * @return boolean
         */
        public function getAlignWithMargins()
        {
        }
        /**
         * Set AlignWithMargins
         *
         * @param boolean $pValue
         * @return PHPExcel_Worksheet_HeaderFooter
         */
        public function setAlignWithMargins($pValue = \true)
        {
        }
        /**
         * Add header/footer image
         *
         * @param PHPExcel_Worksheet_HeaderFooterDrawing $image
         * @param string $location
         * @throws PHPExcel_Exception
         * @return PHPExcel_Worksheet_HeaderFooter
         */
        public function addImage(\PHPExcel_Worksheet_HeaderFooterDrawing $image = \null, $location = self::IMAGE_HEADER_LEFT)
        {
        }
        /**
         * Remove header/footer image
         *
         * @param string $location
         * @throws PHPExcel_Exception
         * @return PHPExcel_Worksheet_HeaderFooter
         */
        public function removeImage($location = self::IMAGE_HEADER_LEFT)
        {
        }
        /**
         * Set header/footer images
         *
         * @param PHPExcel_Worksheet_HeaderFooterDrawing[] $images
         * @throws PHPExcel_Exception
         * @return PHPExcel_Worksheet_HeaderFooter
         */
        public function setImages($images)
        {
        }
        /**
         * Get header/footer images
         *
         * @return PHPExcel_Worksheet_HeaderFooterDrawing[]
         */
        public function getImages()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Worksheet_HeaderFooterDrawing
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Worksheet_HeaderFooterDrawing extends \PHPExcel_Worksheet_Drawing implements \PHPExcel_IComparable
    {
        /**
         * Path
         *
         * @var string
         */
        private $_path;
        /**
         * Name
         *
         * @var string
         */
        protected $_name;
        /**
         * Offset X
         *
         * @var int
         */
        protected $_offsetX;
        /**
         * Offset Y
         *
         * @var int
         */
        protected $_offsetY;
        /**
         * Width
         *
         * @var int
         */
        protected $_width;
        /**
         * Height
         *
         * @var int
         */
        protected $_height;
        /**
         * Proportional resize
         *
         * @var boolean
         */
        protected $_resizeProportional;
        /**
         * Create a new PHPExcel_Worksheet_HeaderFooterDrawing
         */
        public function __construct()
        {
        }
        /**
         * Get Name
         *
         * @return string
         */
        public function getName()
        {
        }
        /**
         * Set Name
         *
         * @param string $pValue
         * @return PHPExcel_Worksheet_HeaderFooterDrawing
         */
        public function setName($pValue = '')
        {
        }
        /**
         * Get OffsetX
         *
         * @return int
         */
        public function getOffsetX()
        {
        }
        /**
         * Set OffsetX
         *
         * @param int $pValue
         * @return PHPExcel_Worksheet_HeaderFooterDrawing
         */
        public function setOffsetX($pValue = 0)
        {
        }
        /**
         * Get OffsetY
         *
         * @return int
         */
        public function getOffsetY()
        {
        }
        /**
         * Set OffsetY
         *
         * @param int $pValue
         * @return PHPExcel_Worksheet_HeaderFooterDrawing
         */
        public function setOffsetY($pValue = 0)
        {
        }
        /**
         * Get Width
         *
         * @return int
         */
        public function getWidth()
        {
        }
        /**
         * Set Width
         *
         * @param int $pValue
         * @return PHPExcel_Worksheet_HeaderFooterDrawing
         */
        public function setWidth($pValue = 0)
        {
        }
        /**
         * Get Height
         *
         * @return int
         */
        public function getHeight()
        {
        }
        /**
         * Set Height
         *
         * @param int $pValue
         * @return PHPExcel_Worksheet_HeaderFooterDrawing
         */
        public function setHeight($pValue = 0)
        {
        }
        /**
         * Set width and height with proportional resize
         * Example:
         * <code>
         * $objDrawing->setResizeProportional(true);
         * $objDrawing->setWidthAndHeight(160,120);
         * </code>
         *
         * @author Vincent@luo MSN:kele_100@hotmail.com
         * @param int $width
         * @param int $height
         * @return PHPExcel_Worksheet_HeaderFooterDrawing
         */
        public function setWidthAndHeight($width = 0, $height = 0)
        {
        }
        /**
         * Get ResizeProportional
         *
         * @return boolean
         */
        public function getResizeProportional()
        {
        }
        /**
         * Set ResizeProportional
         *
         * @param boolean $pValue
         * @return PHPExcel_Worksheet_HeaderFooterDrawing
         */
        public function setResizeProportional($pValue = \true)
        {
        }
        /**
         * Get Filename
         *
         * @return string
         */
        public function getFilename()
        {
        }
        /**
         * Get Extension
         *
         * @return string
         */
        public function getExtension()
        {
        }
        /**
         * Get Path
         *
         * @return string
         */
        public function getPath()
        {
        }
        /**
         * Set Path
         *
         * @param 	string 		$pValue			File path
         * @param 	boolean		$pVerifyFile	Verify file
         * @throws 	PHPExcel_Exception
         * @return PHPExcel_Worksheet_HeaderFooterDrawing
         */
        public function setPath($pValue = '', $pVerifyFile = \true)
        {
        }
        /**
         * Get hash code
         *
         * @return string	Hash code
         */
        public function getHashCode()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package	PHPExcel_Worksheet
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license	http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version	1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Worksheet_RowIterator
     *
     * Used to iterate rows in a PHPExcel_Worksheet
     *
     * @category   PHPExcel
     * @package	PHPExcel_Worksheet
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Worksheet_RowIterator implements \Iterator
    {
        /**
         * PHPExcel_Worksheet to iterate
         *
         * @var PHPExcel_Worksheet
         */
        private $_subject;
        /**
         * Current iterator position
         *
         * @var int
         */
        private $_position = 1;
        /**
         * Start position
         *
         * @var int
         */
        private $_startRow = 1;
        /**
         * Create a new row iterator
         *
         * @param	PHPExcel_Worksheet	$subject	The worksheet to iterate over
         * @param	integer				$startRow	The row number at which to start iterating
         */
        public function __construct(\PHPExcel_Worksheet $subject = \null, $startRow = 1)
        {
        }
        /**
         * Destructor
         */
        public function __destruct()
        {
        }
        /**
         * (Re)Set the start row and the current row pointer
         *
         * @param integer	$startRow	The row number at which to start iterating
         */
        public function resetStart($startRow = 1)
        {
        }
        /**
         * Set the row pointer to the selected row
         *
         * @param integer	$row	The row number to set the current pointer at
         */
        public function seek($row = 1)
        {
        }
        /**
         * Rewind the iterator to the starting row
         */
        public function rewind()
        {
        }
        /**
         * Return the current row in this worksheet
         *
         * @return PHPExcel_Worksheet_Row
         */
        public function current()
        {
        }
        /**
         * Return the current iterator key
         *
         * @return int
         */
        public function key()
        {
        }
        /**
         * Set the iterator to its next value
         */
        public function next()
        {
        }
        /**
         * Set the iterator to its previous value
         */
        public function prev()
        {
        }
        /**
         * Indicate if more rows exist in the worksheet
         *
         * @return boolean
         */
        public function valid()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Worksheet_RowDimension
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Worksheet_RowDimension
    {
        /**
         * Row index
         *
         * @var int
         */
        private $_rowIndex;
        /**
         * Row height (in pt)
         *
         * When this is set to a negative value, the row height should be ignored by IWriter
         *
         * @var double
         */
        private $_rowHeight = -1;
        /**
         * ZeroHeight for Row?
         *
         * @var bool
         */
        private $_zeroHeight = \false;
        /**
         * Visible?
         *
         * @var bool
         */
        private $_visible = \true;
        /**
         * Outline level
         *
         * @var int
         */
        private $_outlineLevel = 0;
        /**
         * Collapsed
         *
         * @var bool
         */
        private $_collapsed = \false;
        /**
         * Index to cellXf. Null value means row has no explicit cellXf format.
         *
         * @var int|null
         */
        private $_xfIndex;
        /**
         * Create a new PHPExcel_Worksheet_RowDimension
         *
         * @param int $pIndex Numeric row index
         */
        public function __construct($pIndex = 0)
        {
        }
        /**
         * Get Row Index
         *
         * @return int
         */
        public function getRowIndex()
        {
        }
        /**
         * Set Row Index
         *
         * @param int $pValue
         * @return PHPExcel_Worksheet_RowDimension
         */
        public function setRowIndex($pValue)
        {
        }
        /**
         * Get Row Height
         *
         * @return double
         */
        public function getRowHeight()
        {
        }
        /**
         * Set Row Height
         *
         * @param double $pValue
         * @return PHPExcel_Worksheet_RowDimension
         */
        public function setRowHeight($pValue = -1)
        {
        }
        /**
         * Get ZeroHeight
         *
         * @return bool
         */
        public function getzeroHeight()
        {
        }
        /**
         * Set ZeroHeight
         *
         * @param bool $pValue
         * @return PHPExcel_Worksheet_RowDimension
         */
        public function setzeroHeight($pValue = \false)
        {
        }
        /**
         * Get Visible
         *
         * @return bool
         */
        public function getVisible()
        {
        }
        /**
         * Set Visible
         *
         * @param bool $pValue
         * @return PHPExcel_Worksheet_RowDimension
         */
        public function setVisible($pValue = \true)
        {
        }
        /**
         * Get Outline Level
         *
         * @return int
         */
        public function getOutlineLevel()
        {
        }
        /**
         * Set Outline Level
         *
         * Value must be between 0 and 7
         *
         * @param int $pValue
         * @throws PHPExcel_Exception
         * @return PHPExcel_Worksheet_RowDimension
         */
        public function setOutlineLevel($pValue)
        {
        }
        /**
         * Get Collapsed
         *
         * @return bool
         */
        public function getCollapsed()
        {
        }
        /**
         * Set Collapsed
         *
         * @param bool $pValue
         * @return PHPExcel_Worksheet_RowDimension
         */
        public function setCollapsed($pValue = \true)
        {
        }
        /**
         * Get index to cellXf
         *
         * @return int
         */
        public function getXfIndex()
        {
        }
        /**
         * Set index to cellXf
         *
         * @param int $pValue
         * @return PHPExcel_Worksheet_RowDimension
         */
        public function setXfIndex($pValue = 0)
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Worksheet_SheetView
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Worksheet_SheetView
    {
        /* Sheet View types */
        const SHEETVIEW_NORMAL = 'normal';
        const SHEETVIEW_PAGE_LAYOUT = 'pageLayout';
        const SHEETVIEW_PAGE_BREAK_PREVIEW = 'pageBreakPreview';
        private static $_sheetViewTypes = array(self::SHEETVIEW_NORMAL, self::SHEETVIEW_PAGE_LAYOUT, self::SHEETVIEW_PAGE_BREAK_PREVIEW);
        /**
         * ZoomScale
         *
         * Valid values range from 10 to 400.
         *
         * @var int
         */
        private $_zoomScale = 100;
        /**
         * ZoomScaleNormal
         *
         * Valid values range from 10 to 400.
         *
         * @var int
         */
        private $_zoomScaleNormal = 100;
        /**
         * View
         *
         * Valid values range from 10 to 400.
         *
         * @var string
         */
        private $_sheetviewType = self::SHEETVIEW_NORMAL;
        /**
         * Create a new PHPExcel_Worksheet_SheetView
         */
        public function __construct()
        {
        }
        /**
         * Get ZoomScale
         *
         * @return int
         */
        public function getZoomScale()
        {
        }
        /**
         * Set ZoomScale
         *
         * Valid values range from 10 to 400.
         *
         * @param 	int 	$pValue
         * @throws 	PHPExcel_Exception
         * @return PHPExcel_Worksheet_SheetView
         */
        public function setZoomScale($pValue = 100)
        {
        }
        /**
         * Get ZoomScaleNormal
         *
         * @return int
         */
        public function getZoomScaleNormal()
        {
        }
        /**
         * Set ZoomScale
         *
         * Valid values range from 10 to 400.
         *
         * @param 	int 	$pValue
         * @throws 	PHPExcel_Exception
         * @return PHPExcel_Worksheet_SheetView
         */
        public function setZoomScaleNormal($pValue = 100)
        {
        }
        /**
         * Get View
         *
         * @return string
         */
        public function getView()
        {
        }
        /**
         * Set View
         *
         * Valid values are
         *		'normal'			self::SHEETVIEW_NORMAL
         *		'pageLayout'		self::SHEETVIEW_PAGE_LAYOUT
         *		'pageBreakPreview'	self::SHEETVIEW_PAGE_BREAK_PREVIEW
         *
         * @param 	string 	$pValue
         * @throws 	PHPExcel_Exception
         * @return PHPExcel_Worksheet_SheetView
         */
        public function setView($pValue = \NULL)
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Worksheet_PageSetup
     *
     * <code>
     * Paper size taken from Office Open XML Part 4 - Markup Language Reference, page 1988:
     *
     * 1 = Letter paper (8.5 in. by 11 in.)
     * 2 = Letter small paper (8.5 in. by 11 in.)
     * 3 = Tabloid paper (11 in. by 17 in.)
     * 4 = Ledger paper (17 in. by 11 in.)
     * 5 = Legal paper (8.5 in. by 14 in.)
     * 6 = Statement paper (5.5 in. by 8.5 in.)
     * 7 = Executive paper (7.25 in. by 10.5 in.)
     * 8 = A3 paper (297 mm by 420 mm)
     * 9 = A4 paper (210 mm by 297 mm)
     * 10 = A4 small paper (210 mm by 297 mm)
     * 11 = A5 paper (148 mm by 210 mm)
     * 12 = B4 paper (250 mm by 353 mm)
     * 13 = B5 paper (176 mm by 250 mm)
     * 14 = Folio paper (8.5 in. by 13 in.)
     * 15 = Quarto paper (215 mm by 275 mm)
     * 16 = Standard paper (10 in. by 14 in.)
     * 17 = Standard paper (11 in. by 17 in.)
     * 18 = Note paper (8.5 in. by 11 in.)
     * 19 = #9 envelope (3.875 in. by 8.875 in.)
     * 20 = #10 envelope (4.125 in. by 9.5 in.)
     * 21 = #11 envelope (4.5 in. by 10.375 in.)
     * 22 = #12 envelope (4.75 in. by 11 in.)
     * 23 = #14 envelope (5 in. by 11.5 in.)
     * 24 = C paper (17 in. by 22 in.)
     * 25 = D paper (22 in. by 34 in.)
     * 26 = E paper (34 in. by 44 in.)
     * 27 = DL envelope (110 mm by 220 mm)
     * 28 = C5 envelope (162 mm by 229 mm)
     * 29 = C3 envelope (324 mm by 458 mm)
     * 30 = C4 envelope (229 mm by 324 mm)
     * 31 = C6 envelope (114 mm by 162 mm)
     * 32 = C65 envelope (114 mm by 229 mm)
     * 33 = B4 envelope (250 mm by 353 mm)
     * 34 = B5 envelope (176 mm by 250 mm)
     * 35 = B6 envelope (176 mm by 125 mm)
     * 36 = Italy envelope (110 mm by 230 mm)
     * 37 = Monarch envelope (3.875 in. by 7.5 in.).
     * 38 = 6 3/4 envelope (3.625 in. by 6.5 in.)
     * 39 = US standard fanfold (14.875 in. by 11 in.)
     * 40 = German standard fanfold (8.5 in. by 12 in.)
     * 41 = German legal fanfold (8.5 in. by 13 in.)
     * 42 = ISO B4 (250 mm by 353 mm)
     * 43 = Japanese double postcard (200 mm by 148 mm)
     * 44 = Standard paper (9 in. by 11 in.)
     * 45 = Standard paper (10 in. by 11 in.)
     * 46 = Standard paper (15 in. by 11 in.)
     * 47 = Invite envelope (220 mm by 220 mm)
     * 50 = Letter extra paper (9.275 in. by 12 in.)
     * 51 = Legal extra paper (9.275 in. by 15 in.)
     * 52 = Tabloid extra paper (11.69 in. by 18 in.)
     * 53 = A4 extra paper (236 mm by 322 mm)
     * 54 = Letter transverse paper (8.275 in. by 11 in.)
     * 55 = A4 transverse paper (210 mm by 297 mm)
     * 56 = Letter extra transverse paper (9.275 in. by 12 in.)
     * 57 = SuperA/SuperA/A4 paper (227 mm by 356 mm)
     * 58 = SuperB/SuperB/A3 paper (305 mm by 487 mm)
     * 59 = Letter plus paper (8.5 in. by 12.69 in.)
     * 60 = A4 plus paper (210 mm by 330 mm)
     * 61 = A5 transverse paper (148 mm by 210 mm)
     * 62 = JIS B5 transverse paper (182 mm by 257 mm)
     * 63 = A3 extra paper (322 mm by 445 mm)
     * 64 = A5 extra paper (174 mm by 235 mm)
     * 65 = ISO B5 extra paper (201 mm by 276 mm)
     * 66 = A2 paper (420 mm by 594 mm)
     * 67 = A3 transverse paper (297 mm by 420 mm)
     * 68 = A3 extra transverse paper (322 mm by 445 mm)
     * </code>
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Worksheet_PageSetup
    {
        /* Paper size */
        const PAPERSIZE_LETTER = 1;
        const PAPERSIZE_LETTER_SMALL = 2;
        const PAPERSIZE_TABLOID = 3;
        const PAPERSIZE_LEDGER = 4;
        const PAPERSIZE_LEGAL = 5;
        const PAPERSIZE_STATEMENT = 6;
        const PAPERSIZE_EXECUTIVE = 7;
        const PAPERSIZE_A3 = 8;
        const PAPERSIZE_A4 = 9;
        const PAPERSIZE_A4_SMALL = 10;
        const PAPERSIZE_A5 = 11;
        const PAPERSIZE_B4 = 12;
        const PAPERSIZE_B5 = 13;
        const PAPERSIZE_FOLIO = 14;
        const PAPERSIZE_QUARTO = 15;
        const PAPERSIZE_STANDARD_1 = 16;
        const PAPERSIZE_STANDARD_2 = 17;
        const PAPERSIZE_NOTE = 18;
        const PAPERSIZE_NO9_ENVELOPE = 19;
        const PAPERSIZE_NO10_ENVELOPE = 20;
        const PAPERSIZE_NO11_ENVELOPE = 21;
        const PAPERSIZE_NO12_ENVELOPE = 22;
        const PAPERSIZE_NO14_ENVELOPE = 23;
        const PAPERSIZE_C = 24;
        const PAPERSIZE_D = 25;
        const PAPERSIZE_E = 26;
        const PAPERSIZE_DL_ENVELOPE = 27;
        const PAPERSIZE_C5_ENVELOPE = 28;
        const PAPERSIZE_C3_ENVELOPE = 29;
        const PAPERSIZE_C4_ENVELOPE = 30;
        const PAPERSIZE_C6_ENVELOPE = 31;
        const PAPERSIZE_C65_ENVELOPE = 32;
        const PAPERSIZE_B4_ENVELOPE = 33;
        const PAPERSIZE_B5_ENVELOPE = 34;
        const PAPERSIZE_B6_ENVELOPE = 35;
        const PAPERSIZE_ITALY_ENVELOPE = 36;
        const PAPERSIZE_MONARCH_ENVELOPE = 37;
        const PAPERSIZE_6_3_4_ENVELOPE = 38;
        const PAPERSIZE_US_STANDARD_FANFOLD = 39;
        const PAPERSIZE_GERMAN_STANDARD_FANFOLD = 40;
        const PAPERSIZE_GERMAN_LEGAL_FANFOLD = 41;
        const PAPERSIZE_ISO_B4 = 42;
        const PAPERSIZE_JAPANESE_DOUBLE_POSTCARD = 43;
        const PAPERSIZE_STANDARD_PAPER_1 = 44;
        const PAPERSIZE_STANDARD_PAPER_2 = 45;
        const PAPERSIZE_STANDARD_PAPER_3 = 46;
        const PAPERSIZE_INVITE_ENVELOPE = 47;
        const PAPERSIZE_LETTER_EXTRA_PAPER = 48;
        const PAPERSIZE_LEGAL_EXTRA_PAPER = 49;
        const PAPERSIZE_TABLOID_EXTRA_PAPER = 50;
        const PAPERSIZE_A4_EXTRA_PAPER = 51;
        const PAPERSIZE_LETTER_TRANSVERSE_PAPER = 52;
        const PAPERSIZE_A4_TRANSVERSE_PAPER = 53;
        const PAPERSIZE_LETTER_EXTRA_TRANSVERSE_PAPER = 54;
        const PAPERSIZE_SUPERA_SUPERA_A4_PAPER = 55;
        const PAPERSIZE_SUPERB_SUPERB_A3_PAPER = 56;
        const PAPERSIZE_LETTER_PLUS_PAPER = 57;
        const PAPERSIZE_A4_PLUS_PAPER = 58;
        const PAPERSIZE_A5_TRANSVERSE_PAPER = 59;
        const PAPERSIZE_JIS_B5_TRANSVERSE_PAPER = 60;
        const PAPERSIZE_A3_EXTRA_PAPER = 61;
        const PAPERSIZE_A5_EXTRA_PAPER = 62;
        const PAPERSIZE_ISO_B5_EXTRA_PAPER = 63;
        const PAPERSIZE_A2_PAPER = 64;
        const PAPERSIZE_A3_TRANSVERSE_PAPER = 65;
        const PAPERSIZE_A3_EXTRA_TRANSVERSE_PAPER = 66;
        /* Page orientation */
        const ORIENTATION_DEFAULT = 'default';
        const ORIENTATION_LANDSCAPE = 'landscape';
        const ORIENTATION_PORTRAIT = 'portrait';
        /* Print Range Set Method */
        const SETPRINTRANGE_OVERWRITE = 'O';
        const SETPRINTRANGE_INSERT = 'I';
        /**
         * Paper size
         *
         * @var int
         */
        private $_paperSize = \PHPExcel_Worksheet_PageSetup::PAPERSIZE_LETTER;
        /**
         * Orientation
         *
         * @var string
         */
        private $_orientation = \PHPExcel_Worksheet_PageSetup::ORIENTATION_DEFAULT;
        /**
         * Scale (Print Scale)
         *
         * Print scaling. Valid values range from 10 to 400
         * This setting is overridden when fitToWidth and/or fitToHeight are in use
         *
         * @var int?
         */
        private $_scale = 100;
        /**
         * Fit To Page
         * Whether scale or fitToWith / fitToHeight applies
         *
         * @var boolean
         */
        private $_fitToPage = \FALSE;
        /**
         * Fit To Height
         * Number of vertical pages to fit on
         *
         * @var int?
         */
        private $_fitToHeight = 1;
        /**
         * Fit To Width
         * Number of horizontal pages to fit on
         *
         * @var int?
         */
        private $_fitToWidth = 1;
        /**
         * Columns to repeat at left
         *
         * @var array Containing start column and end column, empty array if option unset
         */
        private $_columnsToRepeatAtLeft = array('', '');
        /**
         * Rows to repeat at top
         *
         * @var array Containing start row number and end row number, empty array if option unset
         */
        private $_rowsToRepeatAtTop = array(0, 0);
        /**
         * Center page horizontally
         *
         * @var boolean
         */
        private $_horizontalCentered = \FALSE;
        /**
         * Center page vertically
         *
         * @var boolean
         */
        private $_verticalCentered = \FALSE;
        /**
         * Print area
         *
         * @var string
         */
        private $_printArea = \NULL;
        /**
         * First page number
         *
         * @var int
         */
        private $_firstPageNumber = \NULL;
        /**
         * Create a new PHPExcel_Worksheet_PageSetup
         */
        public function __construct()
        {
        }
        /**
         * Get Paper Size
         *
         * @return int
         */
        public function getPaperSize()
        {
        }
        /**
         * Set Paper Size
         *
         * @param int $pValue
         * @return PHPExcel_Worksheet_PageSetup
         */
        public function setPaperSize($pValue = \PHPExcel_Worksheet_PageSetup::PAPERSIZE_LETTER)
        {
        }
        /**
         * Get Orientation
         *
         * @return string
         */
        public function getOrientation()
        {
        }
        /**
         * Set Orientation
         *
         * @param string $pValue
         * @return PHPExcel_Worksheet_PageSetup
         */
        public function setOrientation($pValue = \PHPExcel_Worksheet_PageSetup::ORIENTATION_DEFAULT)
        {
        }
        /**
         * Get Scale
         *
         * @return int?
         */
        public function getScale()
        {
        }
        /**
         * Set Scale
         *
         * Print scaling. Valid values range from 10 to 400
         * This setting is overridden when fitToWidth and/or fitToHeight are in use
         *
         * @param 	int?	$pValue
         * @param boolean	$pUpdate	Update fitToPage so scaling applies rather than fitToHeight / fitToWidth
         * @return PHPExcel_Worksheet_PageSetup
         * @throws 	PHPExcel_Exception
         */
        public function setScale($pValue = 100, $pUpdate = \true)
        {
        }
        /**
         * Get Fit To Page
         *
         * @return boolean
         */
        public function getFitToPage()
        {
        }
        /**
         * Set Fit To Page
         *
         * @param boolean $pValue
         * @return PHPExcel_Worksheet_PageSetup
         */
        public function setFitToPage($pValue = \TRUE)
        {
        }
        /**
         * Get Fit To Height
         *
         * @return int?
         */
        public function getFitToHeight()
        {
        }
        /**
         * Set Fit To Height
         *
         * @param int? $pValue
         * @param boolean $pUpdate Update fitToPage so it applies rather than scaling
         * @return PHPExcel_Worksheet_PageSetup
         */
        public function setFitToHeight($pValue = 1, $pUpdate = \TRUE)
        {
        }
        /**
         * Get Fit To Width
         *
         * @return int?
         */
        public function getFitToWidth()
        {
        }
        /**
         * Set Fit To Width
         *
         * @param int? $pValue
         * @param boolean $pUpdate Update fitToPage so it applies rather than scaling
         * @return PHPExcel_Worksheet_PageSetup
         */
        public function setFitToWidth($pValue = 1, $pUpdate = \TRUE)
        {
        }
        /**
         * Is Columns to repeat at left set?
         *
         * @return boolean
         */
        public function isColumnsToRepeatAtLeftSet()
        {
        }
        /**
         * Get Columns to repeat at left
         *
         * @return array Containing start column and end column, empty array if option unset
         */
        public function getColumnsToRepeatAtLeft()
        {
        }
        /**
         * Set Columns to repeat at left
         *
         * @param array $pValue Containing start column and end column, empty array if option unset
         * @return PHPExcel_Worksheet_PageSetup
         */
        public function setColumnsToRepeatAtLeft($pValue = \null)
        {
        }
        /**
         * Set Columns to repeat at left by start and end
         *
         * @param string $pStart
         * @param string $pEnd
         * @return PHPExcel_Worksheet_PageSetup
         */
        public function setColumnsToRepeatAtLeftByStartAndEnd($pStart = 'A', $pEnd = 'A')
        {
        }
        /**
         * Is Rows to repeat at top set?
         *
         * @return boolean
         */
        public function isRowsToRepeatAtTopSet()
        {
        }
        /**
         * Get Rows to repeat at top
         *
         * @return array Containing start column and end column, empty array if option unset
         */
        public function getRowsToRepeatAtTop()
        {
        }
        /**
         * Set Rows to repeat at top
         *
         * @param array	$pValue	Containing start column and end column, empty array if option unset
         * @return PHPExcel_Worksheet_PageSetup
         */
        public function setRowsToRepeatAtTop($pValue = \null)
        {
        }
        /**
         * Set Rows to repeat at top by start and end
         *
         * @param int $pStart
         * @param int $pEnd
         * @return PHPExcel_Worksheet_PageSetup
         */
        public function setRowsToRepeatAtTopByStartAndEnd($pStart = 1, $pEnd = 1)
        {
        }
        /**
         * Get center page horizontally
         *
         * @return bool
         */
        public function getHorizontalCentered()
        {
        }
        /**
         * Set center page horizontally
         *
         * @param bool $value
         * @return PHPExcel_Worksheet_PageSetup
         */
        public function setHorizontalCentered($value = \false)
        {
        }
        /**
         * Get center page vertically
         *
         * @return bool
         */
        public function getVerticalCentered()
        {
        }
        /**
         * Set center page vertically
         *
         * @param bool $value
         * @return PHPExcel_Worksheet_PageSetup
         */
        public function setVerticalCentered($value = \false)
        {
        }
        /**
         *	Get print area
         *
         * @param	int		$index	Identifier for a specific print area range if several ranges have been set
         *							Default behaviour, or a index value of 0, will return all ranges as a comma-separated string
         *							Otherwise, the specific range identified by the value of $index will be returned
         *							Print areas are numbered from 1
         * @throws	PHPExcel_Exception
         * @return	string
         */
        public function getPrintArea($index = 0)
        {
        }
        /**
         * Is print area set?
         *
         * @param	int		$index	Identifier for a specific print area range if several ranges have been set
         *							Default behaviour, or an index value of 0, will identify whether any print range is set
         *							Otherwise, existence of the range identified by the value of $index will be returned
         *							Print areas are numbered from 1
         * @return	boolean
         */
        public function isPrintAreaSet($index = 0)
        {
        }
        /**
         * Clear a print area
         *
         * @param	int		$index	Identifier for a specific print area range if several ranges have been set
         *							Default behaviour, or an index value of 0, will clear all print ranges that are set
         *							Otherwise, the range identified by the value of $index will be removed from the series
         *							Print areas are numbered from 1
         * @return	PHPExcel_Worksheet_PageSetup
         */
        public function clearPrintArea($index = 0)
        {
        }
        /**
         * Set print area. e.g. 'A1:D10' or 'A1:D10,G5:M20'
         *
         * @param	string	$value
         * @param	int		$index	Identifier for a specific print area range allowing several ranges to be set
         *							When the method is "O"verwrite, then a positive integer index will overwrite that indexed
         *								entry in the print areas list; a negative index value will identify which entry to
         *								overwrite working bacward through the print area to the list, with the last entry as -1.
         *								Specifying an index value of 0, will overwrite <b>all</b> existing print ranges.
         *							When the method is "I"nsert, then a positive index will insert after that indexed entry in
         *								the print areas list, while a negative index will insert before the indexed entry.
         *								Specifying an index value of 0, will always append the new print range at the end of the
         *								list.
         *							Print areas are numbered from 1
         * @param	string	$method	Determines the method used when setting multiple print areas
         *							Default behaviour, or the "O" method, overwrites existing print area
         *							The "I" method, inserts the new print area before any specified index, or at the end of the list
         * @return	PHPExcel_Worksheet_PageSetup
         * @throws	PHPExcel_Exception
         */
        public function setPrintArea($value, $index = 0, $method = self::SETPRINTRANGE_OVERWRITE)
        {
        }
        /**
         * Add a new print area (e.g. 'A1:D10' or 'A1:D10,G5:M20') to the list of print areas
         *
         * @param	string	$value
         * @param	int		$index	Identifier for a specific print area range allowing several ranges to be set
         *							A positive index will insert after that indexed entry in the print areas list, while a
         *								negative index will insert before the indexed entry.
         *								Specifying an index value of 0, will always append the new print range at the end of the
         *								list.
         *							Print areas are numbered from 1
         * @return	PHPExcel_Worksheet_PageSetup
         * @throws	PHPExcel_Exception
         */
        public function addPrintArea($value, $index = -1)
        {
        }
        /**
         * Set print area
         *
         * @param	int		$column1	Column 1
         * @param	int		$row1		Row 1
         * @param	int		$column2	Column 2
         * @param	int		$row2		Row 2
         * @param	int		$index		Identifier for a specific print area range allowing several ranges to be set
         *								When the method is "O"verwrite, then a positive integer index will overwrite that indexed
         *									entry in the print areas list; a negative index value will identify which entry to
         *									overwrite working bacward through the print area to the list, with the last entry as -1.
         *									Specifying an index value of 0, will overwrite <b>all</b> existing print ranges.
         *								When the method is "I"nsert, then a positive index will insert after that indexed entry in
         *									the print areas list, while a negative index will insert before the indexed entry.
         *									Specifying an index value of 0, will always append the new print range at the end of the
         *									list.
         *								Print areas are numbered from 1
         * @param	string	$method		Determines the method used when setting multiple print areas
         *								Default behaviour, or the "O" method, overwrites existing print area
         *								The "I" method, inserts the new print area before any specified index, or at the end of the list
         * @return	PHPExcel_Worksheet_PageSetup
         * @throws	PHPExcel_Exception
         */
        public function setPrintAreaByColumnAndRow($column1, $row1, $column2, $row2, $index = 0, $method = self::SETPRINTRANGE_OVERWRITE)
        {
        }
        /**
         * Add a new print area to the list of print areas
         *
         * @param	int		$column1	Start Column for the print area
         * @param	int		$row1		Start Row for the print area
         * @param	int		$column2	End Column for the print area
         * @param	int		$row2		End Row for the print area
         * @param	int		$index		Identifier for a specific print area range allowing several ranges to be set
         *								A positive index will insert after that indexed entry in the print areas list, while a
         *									negative index will insert before the indexed entry.
         *									Specifying an index value of 0, will always append the new print range at the end of the
         *									list.
         *								Print areas are numbered from 1
         * @return	PHPExcel_Worksheet_PageSetup
         * @throws	PHPExcel_Exception
         */
        public function addPrintAreaByColumnAndRow($column1, $row1, $column2, $row2, $index = -1)
        {
        }
        /**
         * Get first page number
         *
         * @return int
         */
        public function getFirstPageNumber()
        {
        }
        /**
         * Set first page number
         *
         * @param int $value
         * @return PHPExcel_Worksheet_HeaderFooter
         */
        public function setFirstPageNumber($value = \null)
        {
        }
        /**
         * Reset first page number
         *
         * @return PHPExcel_Worksheet_HeaderFooter
         */
        public function resetFirstPageNumber()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Worksheet_MemoryDrawing
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Worksheet_MemoryDrawing extends \PHPExcel_Worksheet_BaseDrawing implements \PHPExcel_IComparable
    {
        /* Rendering functions */
        const RENDERING_DEFAULT = 'imagepng';
        const RENDERING_PNG = 'imagepng';
        const RENDERING_GIF = 'imagegif';
        const RENDERING_JPEG = 'imagejpeg';
        /* MIME types */
        const MIMETYPE_DEFAULT = 'image/png';
        const MIMETYPE_PNG = 'image/png';
        const MIMETYPE_GIF = 'image/gif';
        const MIMETYPE_JPEG = 'image/jpeg';
        /**
         * Image resource
         *
         * @var resource
         */
        private $_imageResource;
        /**
         * Rendering function
         *
         * @var string
         */
        private $_renderingFunction;
        /**
         * Mime type
         *
         * @var string
         */
        private $_mimeType;
        /**
         * Unique name
         *
         * @var string
         */
        private $_uniqueName;
        /**
         * Create a new PHPExcel_Worksheet_MemoryDrawing
         */
        public function __construct()
        {
        }
        /**
         * Get image resource
         *
         * @return resource
         */
        public function getImageResource()
        {
        }
        /**
         * Set image resource
         *
         * @param	$value resource
         * @return PHPExcel_Worksheet_MemoryDrawing
         */
        public function setImageResource($value = \null)
        {
        }
        /**
         * Get rendering function
         *
         * @return string
         */
        public function getRenderingFunction()
        {
        }
        /**
         * Set rendering function
         *
         * @param string $value
         * @return PHPExcel_Worksheet_MemoryDrawing
         */
        public function setRenderingFunction($value = \PHPExcel_Worksheet_MemoryDrawing::RENDERING_DEFAULT)
        {
        }
        /**
         * Get mime type
         *
         * @return string
         */
        public function getMimeType()
        {
        }
        /**
         * Set mime type
         *
         * @param string $value
         * @return PHPExcel_Worksheet_MemoryDrawing
         */
        public function setMimeType($value = \PHPExcel_Worksheet_MemoryDrawing::MIMETYPE_DEFAULT)
        {
        }
        /**
         * Get indexed filename (using image index)
         *
         * @return string
         */
        public function getIndexedFilename()
        {
        }
        /**
         * Get hash code
         *
         * @return string	Hash code
         */
        public function getHashCode()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_CachedObjectStorage
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt    LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_CachedObjectStorageFactory
     *
     * @category    PHPExcel
     * @package        PHPExcel_CachedObjectStorage
     * @copyright    Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_CachedObjectStorageFactory
    {
        const cache_in_memory = 'Memory';
        const cache_in_memory_gzip = 'MemoryGZip';
        const cache_in_memory_serialized = 'MemorySerialized';
        const cache_igbinary = 'Igbinary';
        const cache_to_discISAM = 'DiscISAM';
        const cache_to_apc = 'APC';
        const cache_to_memcache = 'Memcache';
        const cache_to_phpTemp = 'PHPTemp';
        const cache_to_wincache = 'Wincache';
        const cache_to_sqlite = 'SQLite';
        const cache_to_sqlite3 = 'SQLite3';
        /**
         * Name of the method used for cell cacheing
         *
         * @var string
         */
        private static $_cacheStorageMethod = \NULL;
        /**
         * Name of the class used for cell cacheing
         *
         * @var string
         */
        private static $_cacheStorageClass = \NULL;
        /**
         * List of all possible cache storage methods
         *
         * @var string[]
         */
        private static $_storageMethods = array(self::cache_in_memory, self::cache_in_memory_gzip, self::cache_in_memory_serialized, self::cache_igbinary, self::cache_to_phpTemp, self::cache_to_discISAM, self::cache_to_apc, self::cache_to_memcache, self::cache_to_wincache, self::cache_to_sqlite, self::cache_to_sqlite3);
        /**
         * Default arguments for each cache storage method
         *
         * @var array of mixed array
         */
        private static $_storageMethodDefaultParameters = array(self::cache_in_memory => array(), self::cache_in_memory_gzip => array(), self::cache_in_memory_serialized => array(), self::cache_igbinary => array(), self::cache_to_phpTemp => array('memoryCacheSize' => '1MB'), self::cache_to_discISAM => array('dir' => \NULL), self::cache_to_apc => array('cacheTime' => 600), self::cache_to_memcache => array('memcacheServer' => 'localhost', 'memcachePort' => 11211, 'cacheTime' => 600), self::cache_to_wincache => array('cacheTime' => 600), self::cache_to_sqlite => array(), self::cache_to_sqlite3 => array());
        /**
         * Arguments for the active cache storage method
         *
         * @var array of mixed array
         */
        private static $_storageMethodParameters = array();
        /**
         * Return the current cache storage method
         *
         * @return string|NULL
         **/
        public static function getCacheStorageMethod()
        {
        }
        //    function getCacheStorageMethod()
        /**
         * Return the current cache storage class
         *
         * @return PHPExcel_CachedObjectStorage_ICache|NULL
         **/
        public static function getCacheStorageClass()
        {
        }
        //    function getCacheStorageClass()
        /**
         * Return the list of all possible cache storage methods
         *
         * @return string[]
         **/
        public static function getAllCacheStorageMethods()
        {
        }
        //    function getCacheStorageMethods()
        /**
         * Return the list of all available cache storage methods
         *
         * @return string[]
         **/
        public static function getCacheStorageMethods()
        {
        }
        //    function getCacheStorageMethods()
        /**
         * Identify the cache storage method to use
         *
         * @param    string            $method        Name of the method to use for cell cacheing
         * @param    array of mixed    $arguments    Additional arguments to pass to the cell caching class
         *                                        when instantiating
         * @return boolean
         **/
        public static function initialize($method = self::cache_in_memory, $arguments = array())
        {
        }
        //    function initialize()
        /**
         * Initialise the cache storage
         *
         * @param    PHPExcel_Worksheet     $parent        Enable cell caching for this worksheet
         * @return    PHPExcel_CachedObjectStorage_ICache
         **/
        public static function getInstance(\PHPExcel_Worksheet $parent)
        {
        }
        //    function getInstance()
        /**
         * Clear the cache storage
         *
         **/
        public static function finalize()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package	PHPExcel
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license	http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version	1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_HashTable
     *
     * @category   PHPExcel
     * @package	PHPExcel
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_HashTable
    {
        /**
         * HashTable elements
         *
         * @var array
         */
        public $_items = array();
        /**
         * HashTable key map
         *
         * @var array
         */
        public $_keyMap = array();
        /**
         * Create a new PHPExcel_HashTable
         *
         * @param	PHPExcel_IComparable[] $pSource	Optional source array to create HashTable from
         * @throws	PHPExcel_Exception
         */
        public function __construct($pSource = \null)
        {
        }
        /**
         * Add HashTable items from source
         *
         * @param	PHPExcel_IComparable[] $pSource	Source array to create HashTable from
         * @throws	PHPExcel_Exception
         */
        public function addFromSource($pSource = \null)
        {
        }
        /**
         * Add HashTable item
         *
         * @param	PHPExcel_IComparable $pSource	Item to add
         * @throws	PHPExcel_Exception
         */
        public function add(\PHPExcel_IComparable $pSource = \null)
        {
        }
        /**
         * Remove HashTable item
         *
         * @param	PHPExcel_IComparable $pSource	Item to remove
         * @throws	PHPExcel_Exception
         */
        public function remove(\PHPExcel_IComparable $pSource = \null)
        {
        }
        /**
         * Clear HashTable
         *
         */
        public function clear()
        {
        }
        /**
         * Count
         *
         * @return int
         */
        public function count()
        {
        }
        /**
         * Get index for hash code
         *
         * @param	string	$pHashCode
         * @return	int	Index
         */
        public function getIndexForHashCode($pHashCode = '')
        {
        }
        /**
         * Get by index
         *
         * @param	int	$pIndex
         * @return	PHPExcel_IComparable
         *
         */
        public function getByIndex($pIndex = 0)
        {
        }
        /**
         * Get by hashcode
         *
         * @param	string	$pHashCode
         * @return	PHPExcel_IComparable
         *
         */
        public function getByHashCode($pHashCode = '')
        {
        }
        /**
         * HashTable to array
         *
         * @return PHPExcel_IComparable[]
         */
        public function toArray()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package	PHPExcel
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license	http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version	1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_ReferenceHelper (Singleton)
     *
     * @category   PHPExcel
     * @package	PHPExcel
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_ReferenceHelper
    {
        /**	Constants				*/
        /**	Regular Expressions		*/
        const REFHELPER_REGEXP_CELLREF = '((\\w*|\'[^!]*\')!)?(?<![:a-z\\$])(\\$?[a-z]{1,3}\\$?\\d+)(?=[^:!\\d\'])';
        const REFHELPER_REGEXP_CELLRANGE = '((\\w*|\'[^!]*\')!)?(\\$?[a-z]{1,3}\\$?\\d+):(\\$?[a-z]{1,3}\\$?\\d+)';
        const REFHELPER_REGEXP_ROWRANGE = '((\\w*|\'[^!]*\')!)?(\\$?\\d+):(\\$?\\d+)';
        const REFHELPER_REGEXP_COLRANGE = '((\\w*|\'[^!]*\')!)?(\\$?[a-z]{1,3}):(\\$?[a-z]{1,3})';
        /**
         * Instance of this class
         *
         * @var PHPExcel_ReferenceHelper
         */
        private static $_instance;
        /**
         * Get an instance of this class
         *
         * @return PHPExcel_ReferenceHelper
         */
        public static function getInstance()
        {
        }
        /**
         * Create a new PHPExcel_ReferenceHelper
         */
        protected function __construct()
        {
        }
        /**
         * Compare two column addresses
         * Intended for use as a Callback function for sorting column addresses by column
         *
         * @param   string   $a  First column to test (e.g. 'AA')
         * @param   string   $b  Second column to test (e.g. 'Z')
         * @return  integer
         */
        public static function columnSort($a, $b)
        {
        }
        /**
         * Compare two column addresses
         * Intended for use as a Callback function for reverse sorting column addresses by column
         *
         * @param   string   $a  First column to test (e.g. 'AA')
         * @param   string   $b  Second column to test (e.g. 'Z')
         * @return  integer
         */
        public static function columnReverseSort($a, $b)
        {
        }
        /**
         * Compare two cell addresses
         * Intended for use as a Callback function for sorting cell addresses by column and row
         *
         * @param   string   $a  First cell to test (e.g. 'AA1')
         * @param   string   $b  Second cell to test (e.g. 'Z1')
         * @return  integer
         */
        public static function cellSort($a, $b)
        {
        }
        /**
         * Compare two cell addresses
         * Intended for use as a Callback function for sorting cell addresses by column and row
         *
         * @param   string   $a  First cell to test (e.g. 'AA1')
         * @param   string   $b  Second cell to test (e.g. 'Z1')
         * @return  integer
         */
        public static function cellReverseSort($a, $b)
        {
        }
        /**
         * Test whether a cell address falls within a defined range of cells
         *
         * @param   string     $cellAddress        Address of the cell we're testing
         * @param   integer    $beforeRow          Number of the row we're inserting/deleting before
         * @param   integer    $pNumRows           Number of rows to insert/delete (negative values indicate deletion)
         * @param   integer    $beforeColumnIndex  Index number of the column we're inserting/deleting before
         * @param   integer    $pNumCols           Number of columns to insert/delete (negative values indicate deletion)
         * @return  boolean
         */
        private static function cellAddressInDeleteRange($cellAddress, $beforeRow, $pNumRows, $beforeColumnIndex, $pNumCols)
        {
        }
        /**
         * Update page breaks when inserting/deleting rows/columns
         *
         * @param   PHPExcel_Worksheet  $pSheet             The worksheet that we're editing
         * @param   string              $pBefore            Insert/Delete before this cell address (e.g. 'A1')
         * @param   integer             $beforeColumnIndex  Index number of the column we're inserting/deleting before
         * @param   integer             $pNumCols           Number of columns to insert/delete (negative values indicate deletion)
         * @param   integer             $beforeRow          Number of the row we're inserting/deleting before
         * @param   integer             $pNumRows           Number of rows to insert/delete (negative values indicate deletion)
         */
        protected function _adjustPageBreaks(\PHPExcel_Worksheet $pSheet, $pBefore, $beforeColumnIndex, $pNumCols, $beforeRow, $pNumRows)
        {
        }
        /**
         * Update cell comments when inserting/deleting rows/columns
         *
         * @param   PHPExcel_Worksheet  $pSheet             The worksheet that we're editing
         * @param   string              $pBefore            Insert/Delete before this cell address (e.g. 'A1')
         * @param   integer             $beforeColumnIndex  Index number of the column we're inserting/deleting before
         * @param   integer             $pNumCols           Number of columns to insert/delete (negative values indicate deletion)
         * @param   integer             $beforeRow          Number of the row we're inserting/deleting before
         * @param   integer             $pNumRows           Number of rows to insert/delete (negative values indicate deletion)
         */
        protected function _adjustComments($pSheet, $pBefore, $beforeColumnIndex, $pNumCols, $beforeRow, $pNumRows)
        {
        }
        /**
         * Update hyperlinks when inserting/deleting rows/columns
         *
         * @param   PHPExcel_Worksheet  $pSheet             The worksheet that we're editing
         * @param   string              $pBefore            Insert/Delete before this cell address (e.g. 'A1')
         * @param   integer             $beforeColumnIndex  Index number of the column we're inserting/deleting before
         * @param   integer             $pNumCols           Number of columns to insert/delete (negative values indicate deletion)
         * @param   integer             $beforeRow          Number of the row we're inserting/deleting before
         * @param   integer             $pNumRows           Number of rows to insert/delete (negative values indicate deletion)
         */
        protected function _adjustHyperlinks($pSheet, $pBefore, $beforeColumnIndex, $pNumCols, $beforeRow, $pNumRows)
        {
        }
        /**
         * Update data validations when inserting/deleting rows/columns
         *
         * @param   PHPExcel_Worksheet  $pSheet             The worksheet that we're editing
         * @param   string              $pBefore            Insert/Delete before this cell address (e.g. 'A1')
         * @param   integer             $beforeColumnIndex  Index number of the column we're inserting/deleting before
         * @param   integer             $pNumCols           Number of columns to insert/delete (negative values indicate deletion)
         * @param   integer             $beforeRow          Number of the row we're inserting/deleting before
         * @param   integer             $pNumRows           Number of rows to insert/delete (negative values indicate deletion)
         */
        protected function _adjustDataValidations($pSheet, $pBefore, $beforeColumnIndex, $pNumCols, $beforeRow, $pNumRows)
        {
        }
        /**
         * Update merged cells when inserting/deleting rows/columns
         *
         * @param   PHPExcel_Worksheet  $pSheet             The worksheet that we're editing
         * @param   string              $pBefore            Insert/Delete before this cell address (e.g. 'A1')
         * @param   integer             $beforeColumnIndex  Index number of the column we're inserting/deleting before
         * @param   integer             $pNumCols           Number of columns to insert/delete (negative values indicate deletion)
         * @param   integer             $beforeRow          Number of the row we're inserting/deleting before
         * @param   integer             $pNumRows           Number of rows to insert/delete (negative values indicate deletion)
         */
        protected function _adjustMergeCells($pSheet, $pBefore, $beforeColumnIndex, $pNumCols, $beforeRow, $pNumRows)
        {
        }
        /**
         * Update protected cells when inserting/deleting rows/columns
         *
         * @param   PHPExcel_Worksheet  $pSheet             The worksheet that we're editing
         * @param   string              $pBefore            Insert/Delete before this cell address (e.g. 'A1')
         * @param   integer             $beforeColumnIndex  Index number of the column we're inserting/deleting before
         * @param   integer             $pNumCols           Number of columns to insert/delete (negative values indicate deletion)
         * @param   integer             $beforeRow          Number of the row we're inserting/deleting before
         * @param   integer             $pNumRows           Number of rows to insert/delete (negative values indicate deletion)
         */
        protected function _adjustProtectedCells($pSheet, $pBefore, $beforeColumnIndex, $pNumCols, $beforeRow, $pNumRows)
        {
        }
        /**
         * Update column dimensions when inserting/deleting rows/columns
         *
         * @param   PHPExcel_Worksheet  $pSheet             The worksheet that we're editing
         * @param   string              $pBefore            Insert/Delete before this cell address (e.g. 'A1')
         * @param   integer             $beforeColumnIndex  Index number of the column we're inserting/deleting before
         * @param   integer             $pNumCols           Number of columns to insert/delete (negative values indicate deletion)
         * @param   integer             $beforeRow          Number of the row we're inserting/deleting before
         * @param   integer             $pNumRows           Number of rows to insert/delete (negative values indicate deletion)
         */
        protected function _adjustColumnDimensions($pSheet, $pBefore, $beforeColumnIndex, $pNumCols, $beforeRow, $pNumRows)
        {
        }
        /**
         * Update row dimensions when inserting/deleting rows/columns
         *
         * @param   PHPExcel_Worksheet  $pSheet             The worksheet that we're editing
         * @param   string              $pBefore            Insert/Delete before this cell address (e.g. 'A1')
         * @param   integer             $beforeColumnIndex  Index number of the column we're inserting/deleting before
         * @param   integer             $pNumCols           Number of columns to insert/delete (negative values indicate deletion)
         * @param   integer             $beforeRow          Number of the row we're inserting/deleting before
         * @param   integer             $pNumRows           Number of rows to insert/delete (negative values indicate deletion)
         */
        protected function _adjustRowDimensions($pSheet, $pBefore, $beforeColumnIndex, $pNumCols, $beforeRow, $pNumRows)
        {
        }
        /**
         * Insert a new column or row, updating all possible related data
         *
         * @param   string              $pBefore    Insert before this cell address (e.g. 'A1')
         * @param   integer             $pNumCols   Number of columns to insert/delete (negative values indicate deletion)
         * @param   integer             $pNumRows   Number of rows to insert/delete (negative values indicate deletion)
         * @param   PHPExcel_Worksheet  $pSheet     The worksheet that we're editing
         * @throws  PHPExcel_Exception
         */
        public function insertNewBefore($pBefore = 'A1', $pNumCols = 0, $pNumRows = 0, \PHPExcel_Worksheet $pSheet = \NULL)
        {
        }
        /**
         * Update references within formulas
         *
         * @param	string	$pFormula	Formula to update
         * @param	int		$pBefore	Insert before this one
         * @param	int		$pNumCols	Number of columns to insert
         * @param	int		$pNumRows	Number of rows to insert
         * @param   string  $sheetName  Worksheet name/title
         * @return	string	Updated formula
         * @throws	PHPExcel_Exception
         */
        public function updateFormulaReferences($pFormula = '', $pBefore = 'A1', $pNumCols = 0, $pNumRows = 0, $sheetName = '')
        {
        }
        /**
         * Update cell reference
         *
         * @param	string	$pCellRange			Cell range
         * @param	int		$pBefore			Insert before this one
         * @param	int		$pNumCols			Number of columns to increment
         * @param	int		$pNumRows			Number of rows to increment
         * @return	string	Updated cell range
         * @throws	PHPExcel_Exception
         */
        public function updateCellReference($pCellRange = 'A1', $pBefore = 'A1', $pNumCols = 0, $pNumRows = 0)
        {
        }
        /**
         * Update named formulas (i.e. containing worksheet references / named ranges)
         *
         * @param PHPExcel $pPhpExcel	Object to update
         * @param string $oldName		Old name (name to replace)
         * @param string $newName		New name
         */
        public function updateNamedFormulas(\PHPExcel $pPhpExcel, $oldName = '', $newName = '')
        {
        }
        /**
         * Update cell range
         *
         * @param	string	$pCellRange			Cell range	(e.g. 'B2:D4', 'B:C' or '2:3')
         * @param	int		$pBefore			Insert before this one
         * @param	int		$pNumCols			Number of columns to increment
         * @param	int		$pNumRows			Number of rows to increment
         * @return	string	Updated cell range
         * @throws	PHPExcel_Exception
         */
        private function _updateCellRange($pCellRange = 'A1:A1', $pBefore = 'A1', $pNumCols = 0, $pNumRows = 0)
        {
        }
        /**
         * Update single cell reference
         *
         * @param	string	$pCellReference		Single cell reference
         * @param	int		$pBefore			Insert before this one
         * @param	int		$pNumCols			Number of columns to increment
         * @param	int		$pNumRows			Number of rows to increment
         * @return	string	Updated cell reference
         * @throws	PHPExcel_Exception
         */
        private function _updateSingleCellReference($pCellReference = 'A1', $pBefore = 'A1', $pNumCols = 0, $pNumRows = 0)
        {
        }
        /**
         * __clone implementation. Cloning should not be allowed in a Singleton!
         *
         * @throws	PHPExcel_Exception
         */
        public final function __clone()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license	http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version	1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Writer_Exception
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Writer_Exception extends \PHPExcel_Exception
    {
        /**
         * Error handler callback
         *
         * @param mixed $code
         * @param mixed $string
         * @param mixed $file
         * @param mixed $line
         * @param mixed $context
         */
        public static function errorHandlerCallback($code, $string, $file, $line, $context)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel5
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    // Original file header of PEAR::Spreadsheet_Excel_Writer_BIFFwriter (used as the base for this class):
    // -----------------------------------------------------------------------------------------
    // *  Module written/ported by Xavier Noguer <xnoguer@rezebra.com>
    // *
    // *  The majority of this is _NOT_ my code.  I simply ported it from the
    // *  PERL Spreadsheet::WriteExcel module.
    // *
    // *  The author of the Spreadsheet::WriteExcel module is John McNamara
    // *  <jmcnamara@cpan.org>
    // *
    // *  I _DO_ maintain this code, and John McNamara has nothing to do with the
    // *  porting of this code to PHP.  Any questions directly related to this
    // *  class library should be directed to me.
    // *
    // *  License Information:
    // *
    // *    Spreadsheet_Excel_Writer:  A library for generating Excel Spreadsheets
    // *    Copyright (c) 2002-2003 Xavier Noguer xnoguer@rezebra.com
    // *
    // *    This library is free software; you can redistribute it and/or
    // *    modify it under the terms of the GNU Lesser General Public
    // *    License as published by the Free Software Foundation; either
    // *    version 2.1 of the License, or (at your option) any later version.
    // *
    // *    This library is distributed in the hope that it will be useful,
    // *    but WITHOUT ANY WARRANTY; without even the implied warranty of
    // *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    // *    Lesser General Public License for more details.
    // *
    // *    You should have received a copy of the GNU Lesser General Public
    // *    License along with this library; if not, write to the Free Software
    // *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
    // */
    /**
     * PHPExcel_Writer_Excel5_BIFFwriter
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel5
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Writer_Excel5_BIFFwriter
    {
        /**
         * The byte order of this architecture. 0 => little endian, 1 => big endian
         * @var integer
         */
        private static $_byte_order;
        /**
         * The string containing the data of the BIFF stream
         * @var string
         */
        public $_data;
        /**
         * The size of the data in bytes. Should be the same as strlen($this->_data)
         * @var integer
         */
        public $_datasize;
        /**
         * The maximum length for a BIFF record (excluding record header and length field). See _addContinue()
         * @var integer
         * @see _addContinue()
         */
        public $_limit = 8224;
        /**
         * Constructor
         */
        public function __construct()
        {
        }
        /**
         * Determine the byte order and store it as class data to avoid
         * recalculating it for each call to new().
         *
         * @return int
         */
        public static function getByteOrder()
        {
        }
        /**
         * General storage function
         *
         * @param string $data binary data to append
         * @access private
         */
        function _append($data)
        {
        }
        /**
         * General storage function like _append, but returns string instead of modifying $this->_data
         *
         * @param string $data binary data to write
         * @return string
         */
        public function writeData($data)
        {
        }
        /**
         * Writes Excel BOF record to indicate the beginning of a stream or
         * sub-stream in the BIFF file.
         *
         * @param  integer $type Type of BIFF file to write: 0x0005 Workbook,
         *                       0x0010 Worksheet.
         * @access private
         */
        function _storeBof($type)
        {
        }
        /**
         * Writes Excel EOF record to indicate the end of a BIFF stream.
         *
         * @access private
         */
        function _storeEof()
        {
        }
        /**
         * Writes Excel EOF record to indicate the end of a BIFF stream.
         *
         * @access private
         */
        public function writeEof()
        {
        }
        /**
         * Excel limits the size of BIFF records. In Excel 5 the limit is 2084 bytes. In
         * Excel 97 the limit is 8228 bytes. Records that are longer than these limits
         * must be split up into CONTINUE blocks.
         *
         * This function takes a long BIFF record and inserts CONTINUE records as
         * necessary.
         *
         * @param  string  $data The original binary data to be written
         * @return string        A very convenient string of continue blocks
         * @access private
         */
        function _addContinue($data)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel5
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    // Original file header of PEAR::Spreadsheet_Excel_Writer_Workbook (used as the base for this class):
    // -----------------------------------------------------------------------------------------
    // /*
    // *  Module written/ported by Xavier Noguer <xnoguer@rezebra.com>
    // *
    // *  The majority of this is _NOT_ my code.  I simply ported it from the
    // *  PERL Spreadsheet::WriteExcel module.
    // *
    // *  The author of the Spreadsheet::WriteExcel module is John McNamara
    // *  <jmcnamara@cpan.org>
    // *
    // *  I _DO_ maintain this code, and John McNamara has nothing to do with the
    // *  porting of this code to PHP.  Any questions directly related to this
    // *  class library should be directed to me.
    // *
    // *  License Information:
    // *
    // *    Spreadsheet_Excel_Writer:  A library for generating Excel Spreadsheets
    // *    Copyright (c) 2002-2003 Xavier Noguer xnoguer@rezebra.com
    // *
    // *    This library is free software; you can redistribute it and/or
    // *    modify it under the terms of the GNU Lesser General Public
    // *    License as published by the Free Software Foundation; either
    // *    version 2.1 of the License, or (at your option) any later version.
    // *
    // *    This library is distributed in the hope that it will be useful,
    // *    but WITHOUT ANY WARRANTY; without even the implied warranty of
    // *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    // *    Lesser General Public License for more details.
    // *
    // *    You should have received a copy of the GNU Lesser General Public
    // *    License along with this library; if not, write to the Free Software
    // *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
    // */
    /**
     * PHPExcel_Writer_Excel5_Workbook
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel5
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Writer_Excel5_Workbook extends \PHPExcel_Writer_Excel5_BIFFwriter
    {
        /**
         * Formula parser
         *
         * @var PHPExcel_Writer_Excel5_Parser
         */
        private $_parser;
        /**
         * The BIFF file size for the workbook.
         * @var integer
         * @see _calcSheetOffsets()
         */
        public $_biffsize;
        /**
         * XF Writers
         * @var PHPExcel_Writer_Excel5_Xf[]
         */
        private $_xfWriters = array();
        /**
         * Array containing the colour palette
         * @var array
         */
        public $_palette;
        /**
         * The codepage indicates the text encoding used for strings
         * @var integer
         */
        public $_codepage;
        /**
         * The country code used for localization
         * @var integer
         */
        public $_country_code;
        /**
         * Workbook
         * @var PHPExcel
         */
        private $_phpExcel;
        /**
         * Fonts writers
         *
         * @var PHPExcel_Writer_Excel5_Font[]
         */
        private $_fontWriters = array();
        /**
         * Added fonts. Maps from font's hash => index in workbook
         *
         * @var array
         */
        private $_addedFonts = array();
        /**
         * Shared number formats
         *
         * @var array
         */
        private $_numberFormats = array();
        /**
         * Added number formats. Maps from numberFormat's hash => index in workbook
         *
         * @var array
         */
        private $_addedNumberFormats = array();
        /**
         * Sizes of the binary worksheet streams
         *
         * @var array
         */
        private $_worksheetSizes = array();
        /**
         * Offsets of the binary worksheet streams relative to the start of the global workbook stream
         *
         * @var array
         */
        private $_worksheetOffsets = array();
        /**
         * Total number of shared strings in workbook
         *
         * @var int
         */
        private $_str_total;
        /**
         * Number of unique shared strings in workbook
         *
         * @var int
         */
        private $_str_unique;
        /**
         * Array of unique shared strings in workbook
         *
         * @var array
         */
        private $_str_table;
        /**
         * Color cache
         */
        private $_colors;
        /**
         * Escher object corresponding to MSODRAWINGGROUP
         *
         * @var PHPExcel_Shared_Escher
         */
        private $_escher;
        /**
         * Class constructor
         *
         * @param PHPExcel	$phpExcel		The Workbook
         * @param int		&$str_total		Total number of strings
         * @param int		&$str_unique	Total number of unique strings
         * @param array		&$str_table		String Table
         * @param array		&$colors		Colour Table
         * @param mixed		$parser			The formula parser created for the Workbook
         */
        public function __construct(\PHPExcel $phpExcel = \null, &$str_total, &$str_unique, &$str_table, &$colors, $parser)
        {
        }
        /**
         * Add a new XF writer
         *
         * @param PHPExcel_Style
         * @param boolean Is it a style XF?
         * @return int Index to XF record
         */
        public function addXfWriter($style, $isStyleXf = \false)
        {
        }
        /**
         * Add a font to added fonts
         *
         * @param PHPExcel_Style_Font $font
         * @return int Index to FONT record
         */
        public function _addFont(\PHPExcel_Style_Font $font)
        {
        }
        /**
         * Alter color palette adding a custom color
         *
         * @param string $rgb E.g. 'FF00AA'
         * @return int Color index
         */
        private function _addColor($rgb)
        {
        }
        /**
         * Sets the colour palette to the Excel 97+ default.
         *
         * @access private
         */
        function _setPaletteXl97()
        {
        }
        /**
         * Assemble worksheets into a workbook and send the BIFF data to an OLE
         * storage.
         *
         * @param	array	$pWorksheetSizes	The sizes in bytes of the binary worksheet streams
         * @return	string	Binary data for workbook stream
         */
        public function writeWorkbook($pWorksheetSizes = \null)
        {
        }
        /**
         * Calculate offsets for Worksheet BOF records.
         *
         * @access private
         */
        function _calcSheetOffsets()
        {
        }
        /**
         * Store the Excel FONT records.
         */
        private function _writeAllFonts()
        {
        }
        /**
         * Store user defined numerical formats i.e. FORMAT records
         */
        private function _writeAllNumFormats()
        {
        }
        /**
         * Write all XF records.
         */
        private function _writeAllXfs()
        {
        }
        /**
         * Write all STYLE records.
         */
        private function _writeAllStyles()
        {
        }
        /**
         * Write the EXTERNCOUNT and EXTERNSHEET records. These are used as indexes for
         * the NAME records.
         */
        private function _writeExterns()
        {
        }
        /**
         * Write the NAME record to define the print area and the repeat rows and cols.
         */
        private function _writeNames()
        {
        }
        /**
         * Writes all the DEFINEDNAME records (BIFF8).
         * So far this is only used for repeating rows/columns (print titles) and print areas
         */
        private function _writeAllDefinedNamesBiff8()
        {
        }
        /**
         * Write a DEFINEDNAME record for BIFF8 using explicit binary formula data
         *
         * @param	string		$name			The name in UTF-8
         * @param	string		$formulaData	The binary formula data
         * @param	string		$sheetIndex		1-based sheet index the defined name applies to. 0 = global
         * @param	boolean		$isBuiltIn		Built-in name?
         * @return	string	Complete binary record data
         */
        private function _writeDefinedNameBiff8($name, $formulaData, $sheetIndex = 0, $isBuiltIn = \false)
        {
        }
        /**
         * Write a short NAME record
         *
         * @param	string		 $name
         * @param	string		 $sheetIndex		1-based sheet index the defined name applies to. 0 = global
         * @param	integer[][]  $rangeBounds    range boundaries
         * @param	boolean      $isHidden
         * @return	string	Complete binary record data
         * */
        private function _writeShortNameBiff8($name, $sheetIndex = 0, $rangeBounds, $isHidden = \false)
        {
        }
        /**
         * Stores the CODEPAGE biff record.
         */
        private function _writeCodepage()
        {
        }
        /**
         * Write Excel BIFF WINDOW1 record.
         */
        private function _writeWindow1()
        {
        }
        /**
         * Writes Excel BIFF BOUNDSHEET record.
         *
         * @param PHPExcel_Worksheet  $sheet Worksheet name
         * @param integer $offset    Location of worksheet BOF
         */
        private function _writeBoundsheet($sheet, $offset)
        {
        }
        /**
         * Write Internal SUPBOOK record
         */
        private function _writeSupbookInternal()
        {
        }
        /**
         * Writes the Excel BIFF EXTERNSHEET record. These references are used by
         * formulas.
         *
         */
        private function _writeExternsheetBiff8()
        {
        }
        /**
         * Write Excel BIFF STYLE records.
         */
        private function _writeStyle()
        {
        }
        /**
         * Writes Excel FORMAT record for non "built-in" numerical formats.
         *
         * @param string  $format Custom format string
         * @param integer $ifmt   Format index code
         */
        private function _writeNumFormat($format, $ifmt)
        {
        }
        /**
         * Write DATEMODE record to indicate the date system in use (1904 or 1900).
         */
        private function _writeDatemode()
        {
        }
        /**
         * Write BIFF record EXTERNCOUNT to indicate the number of external sheet
         * references in the workbook.
         *
         * Excel only stores references to external sheets that are used in NAME.
         * The workbook NAME record is required to define the print area and the repeat
         * rows and columns.
         *
         * A similar method is used in Worksheet.php for a slightly different purpose.
         *
         * @param integer $cxals Number of external references
         */
        private function _writeExterncount($cxals)
        {
        }
        /**
         * Writes the Excel BIFF EXTERNSHEET record. These references are used by
         * formulas. NAME record is required to define the print area and the repeat
         * rows and columns.
         *
         * A similar method is used in Worksheet.php for a slightly different purpose.
         *
         * @param string $sheetname Worksheet name
         */
        private function _writeExternsheet($sheetname)
        {
        }
        /**
         * Store the NAME record in the short format that is used for storing the print
         * area, repeat rows only and repeat columns only.
         *
         * @param integer $index  Sheet index
         * @param integer $type   Built-in name type
         * @param integer $rowmin Start row
         * @param integer $rowmax End row
         * @param integer $colmin Start colum
         * @param integer $colmax End column
         */
        private function _writeNameShort($index, $type, $rowmin, $rowmax, $colmin, $colmax)
        {
        }
        /**
         * Store the NAME record in the long format that is used for storing the repeat
         * rows and columns when both are specified. This shares a lot of code with
         * _writeNameShort() but we use a separate method to keep the code clean.
         * Code abstraction for reuse can be carried too far, and I should know. ;-)
         *
         * @param integer $index Sheet index
         * @param integer $type  Built-in name type
         * @param integer $rowmin Start row
         * @param integer $rowmax End row
         * @param integer $colmin Start colum
         * @param integer $colmax End column
         */
        private function _writeNameLong($index, $type, $rowmin, $rowmax, $colmin, $colmax)
        {
        }
        /**
         * Stores the COUNTRY record for localization
         *
         * @return string
         */
        private function _writeCountry()
        {
        }
        /**
         * Write the RECALCID record
         *
         * @return string
         */
        private function _writeRecalcId()
        {
        }
        /**
         * Stores the PALETTE biff record.
         */
        private function _writePalette()
        {
        }
        /**
         * Handling of the SST continue blocks is complicated by the need to include an
         * additional continuation byte depending on whether the string is split between
         * blocks or whether it starts at the beginning of the block. (There are also
         * additional complications that will arise later when/if Rich Strings are
         * supported).
         *
         * The Excel documentation says that the SST record should be followed by an
         * EXTSST record. The EXTSST record is a hash table that is used to optimise
         * access to SST. However, despite the documentation it doesn't seem to be
         * required so we will ignore it.
         *
         * @return string Binary data
         */
        private function _writeSharedStringsTable()
        {
        }
        /**
         * Writes the MSODRAWINGGROUP record if needed. Possibly split using CONTINUE records.
         */
        private function _writeMsoDrawingGroup()
        {
        }
        /**
         * Get Escher object
         *
         * @return PHPExcel_Shared_Escher
         */
        public function getEscher()
        {
        }
        /**
         * Set Escher object
         *
         * @param PHPExcel_Shared_Escher $pValue
         */
        public function setEscher(\PHPExcel_Shared_Escher $pValue = \null)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel5
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    // Original file header of PEAR::Spreadsheet_Excel_Writer_Worksheet (used as the base for this class):
    // -----------------------------------------------------------------------------------------
    // /*
    // *  Module written/ported by Xavier Noguer <xnoguer@rezebra.com>
    // *
    // *  The majority of this is _NOT_ my code.  I simply ported it from the
    // *  PERL Spreadsheet::WriteExcel module.
    // *
    // *  The author of the Spreadsheet::WriteExcel module is John McNamara
    // *  <jmcnamara@cpan.org>
    // *
    // *  I _DO_ maintain this code, and John McNamara has nothing to do with the
    // *  porting of this code to PHP.  Any questions directly related to this
    // *  class library should be directed to me.
    // *
    // *  License Information:
    // *
    // *    Spreadsheet_Excel_Writer:  A library for generating Excel Spreadsheets
    // *    Copyright (c) 2002-2003 Xavier Noguer xnoguer@rezebra.com
    // *
    // *    This library is free software; you can redistribute it and/or
    // *    modify it under the terms of the GNU Lesser General Public
    // *    License as published by the Free Software Foundation; either
    // *    version 2.1 of the License, or (at your option) any later version.
    // *
    // *    This library is distributed in the hope that it will be useful,
    // *    but WITHOUT ANY WARRANTY; without even the implied warranty of
    // *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    // *    Lesser General Public License for more details.
    // *
    // *    You should have received a copy of the GNU Lesser General Public
    // *    License along with this library; if not, write to the Free Software
    // *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
    // */
    /**
     * PHPExcel_Writer_Excel5_Worksheet
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel5
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Writer_Excel5_Worksheet extends \PHPExcel_Writer_Excel5_BIFFwriter
    {
        /**
         * Formula parser
         *
         * @var PHPExcel_Writer_Excel5_Parser
         */
        private $_parser;
        /**
         * Maximum number of characters for a string (LABEL record in BIFF5)
         * @var integer
         */
        public $_xls_strmax;
        /**
         * Array containing format information for columns
         * @var array
         */
        public $_colinfo;
        /**
         * Array containing the selected area for the worksheet
         * @var array
         */
        public $_selection;
        /**
         * The active pane for the worksheet
         * @var integer
         */
        public $_active_pane;
        /**
         * Whether to use outline.
         * @var integer
         */
        public $_outline_on;
        /**
         * Auto outline styles.
         * @var bool
         */
        public $_outline_style;
        /**
         * Whether to have outline summary below.
         * @var bool
         */
        public $_outline_below;
        /**
         * Whether to have outline summary at the right.
         * @var bool
         */
        public $_outline_right;
        /**
         * Reference to the total number of strings in the workbook
         * @var integer
         */
        public $_str_total;
        /**
         * Reference to the number of unique strings in the workbook
         * @var integer
         */
        public $_str_unique;
        /**
         * Reference to the array containing all the unique strings in the workbook
         * @var array
         */
        public $_str_table;
        /**
         * Color cache
         */
        private $_colors;
        /**
         * Index of first used row (at least 0)
         * @var int
         */
        private $_firstRowIndex;
        /**
         * Index of last used row. (no used rows means -1)
         * @var int
         */
        private $_lastRowIndex;
        /**
         * Index of first used column (at least 0)
         * @var int
         */
        private $_firstColumnIndex;
        /**
         * Index of last used column (no used columns means -1)
         * @var int
         */
        private $_lastColumnIndex;
        /**
         * Sheet object
         * @var PHPExcel_Worksheet
         */
        public $_phpSheet;
        /**
         * Count cell style Xfs
         *
         * @var int
         */
        private $_countCellStyleXfs;
        /**
         * Escher object corresponding to MSODRAWING
         *
         * @var PHPExcel_Shared_Escher
         */
        private $_escher;
        /**
         * Array of font hashes associated to FONT records index
         *
         * @var array
         */
        public $_fntHashIndex;
        /**
         * Constructor
         *
         * @param int		&$str_total		Total number of strings
         * @param int		&$str_unique	Total number of unique strings
         * @param array		&$str_table		String Table
         * @param array		&$colors		Colour Table
         * @param mixed		$parser			The formula parser created for the Workbook
         * @param boolean	$preCalculateFormulas	Flag indicating whether formulas should be calculated or just written
         * @param string	$phpSheet		The worksheet to write
         * @param PHPExcel_Worksheet $phpSheet
         */
        public function __construct(&$str_total, &$str_unique, &$str_table, &$colors, $parser, $preCalculateFormulas, $phpSheet)
        {
        }
        /**
         * Add data to the beginning of the workbook (note the reverse order)
         * and to the end of the workbook.
         *
         * @access public
         * @see PHPExcel_Writer_Excel5_Workbook::storeWorkbook()
         */
        function close()
        {
        }
        /**
         * Write a cell range address in BIFF8
         * always fixed range
         * See section 2.5.14 in OpenOffice.org's Documentation of the Microsoft Excel File Format
         *
         * @param string $range E.g. 'A1' or 'A1:B6'
         * @return string Binary data
         */
        private function _writeBIFF8CellRangeAddressFixed($range = 'A1')
        {
        }
        /**
         * Retrieves data from memory in one chunk, or from disk in $buffer
         * sized chunks.
         *
         * @return string The data
         */
        function getData()
        {
        }
        /**
         * Set the option to print the row and column headers on the printed page.
         *
         * @access public
         * @param integer $print Whether to print the headers or not. Defaults to 1 (print).
         */
        function printRowColHeaders($print = 1)
        {
        }
        /**
         * This method sets the properties for outlining and grouping. The defaults
         * correspond to Excel's defaults.
         *
         * @param bool $visible
         * @param bool $symbols_below
         * @param bool $symbols_right
         * @param bool $auto_style
         */
        function setOutline($visible = \true, $symbols_below = \true, $symbols_right = \true, $auto_style = \false)
        {
        }
        /**
         * Write a double to the specified row and column (zero indexed).
         * An integer can be written as a double. Excel will display an
         * integer. $format is optional.
         *
         * Returns  0 : normal termination
         *		 -2 : row or column out of range
         *
         * @param integer $row	Zero indexed row
         * @param integer $col	Zero indexed column
         * @param float   $num	The number to write
         * @param mixed   $xfIndex The optional XF format
         * @return integer
         */
        private function _writeNumber($row, $col, $num, $xfIndex)
        {
        }
        /**
         * Write a LABELSST record or a LABEL record. Which one depends on BIFF version
         *
         * @param int $row Row index (0-based)
         * @param int $col Column index (0-based)
         * @param string $str The string
         * @param int $xfIndex Index to XF record
         */
        private function _writeString($row, $col, $str, $xfIndex)
        {
        }
        /**
         * Write a LABELSST record or a LABEL record. Which one depends on BIFF version
         * It differs from _writeString by the writing of rich text strings.
         * @param int $row Row index (0-based)
         * @param int $col Column index (0-based)
         * @param string $str The string
         * @param mixed   $xfIndex The XF format index for the cell
         * @param array $arrcRun Index to Font record and characters beginning
         */
        private function _writeRichTextString($row, $col, $str, $xfIndex, $arrcRun)
        {
        }
        /**
         * Write a string to the specified row and column (zero indexed).
         * NOTE: there is an Excel 5 defined limit of 255 characters.
         * $format is optional.
         * Returns  0 : normal termination
         *		 -2 : row or column out of range
         *		 -3 : long string truncated to 255 chars
         *
         * @access public
         * @param integer $row	Zero indexed row
         * @param integer $col	Zero indexed column
         * @param string  $str	The string to write
         * @param mixed   $xfIndex The XF format index for the cell
         * @return integer
         */
        private function _writeLabel($row, $col, $str, $xfIndex)
        {
        }
        /**
         * Write a string to the specified row and column (zero indexed).
         * This is the BIFF8 version (no 255 chars limit).
         * $format is optional.
         * Returns  0 : normal termination
         *		 -2 : row or column out of range
         *		 -3 : long string truncated to 255 chars
         *
         * @access public
         * @param integer $row	Zero indexed row
         * @param integer $col	Zero indexed column
         * @param string  $str	The string to write
         * @param mixed   $xfIndex The XF format index for the cell
         * @return integer
         */
        private function _writeLabelSst($row, $col, $str, $xfIndex)
        {
        }
        /**
         * Writes a note associated with the cell given by the row and column.
         * NOTE records don't have a length limit.
         *
         * @param integer $row	Zero indexed row
         * @param integer $col	Zero indexed column
         * @param string  $note   The note to write
         */
        private function _writeNote($row, $col, $note)
        {
        }
        /**
         * Write a blank cell to the specified row and column (zero indexed).
         * A blank cell is used to specify formatting without adding a string
         * or a number.
         *
         * A blank cell without a format serves no purpose. Therefore, we don't write
         * a BLANK record unless a format is specified.
         *
         * Returns  0 : normal termination (including no format)
         *		 -1 : insufficient number of arguments
         *		 -2 : row or column out of range
         *
         * @param integer $row	Zero indexed row
         * @param integer $col	Zero indexed column
         * @param mixed   $xfIndex The XF format index
         */
        function _writeBlank($row, $col, $xfIndex)
        {
        }
        /**
         * Write a boolean or an error type to the specified row and column (zero indexed)
         *
         * @param int $row Row index (0-based)
         * @param int $col Column index (0-based)
         * @param int $value
         * @param boolean $isError Error or Boolean?
         * @param int $xfIndex
         */
        private function _writeBoolErr($row, $col, $value, $isError, $xfIndex)
        {
        }
        /**
         * Write a formula to the specified row and column (zero indexed).
         * The textual representation of the formula is passed to the parser in
         * Parser.php which returns a packed binary string.
         *
         * Returns  0 : normal termination
         *		 -1 : formula errors (bad formula)
         *		 -2 : row or column out of range
         *
         * @param integer $row	 Zero indexed row
         * @param integer $col	 Zero indexed column
         * @param string  $formula The formula text string
         * @param mixed   $xfIndex  The XF format index
         * @param mixed   $calculatedValue  Calculated value
         * @return integer
         */
        private function _writeFormula($row, $col, $formula, $xfIndex, $calculatedValue)
        {
        }
        /**
         * Write a STRING record. This
         *
         * @param string $stringValue
         */
        private function _writeStringRecord($stringValue)
        {
        }
        /**
         * Write a hyperlink.
         * This is comprised of two elements: the visible label and
         * the invisible link. The visible label is the same as the link unless an
         * alternative string is specified. The label is written using the
         * _writeString() method. Therefore the 255 characters string limit applies.
         * $string and $format are optional.
         *
         * The hyperlink can be to a http, ftp, mail, internal sheet (not yet), or external
         * directory url.
         *
         * Returns  0 : normal termination
         *		 -2 : row or column out of range
         *		 -3 : long string truncated to 255 chars
         *
         * @param integer $row	Row
         * @param integer $col	Column
         * @param string  $url	URL string
         * @return integer
         */
        private function _writeUrl($row, $col, $url)
        {
        }
        /**
         * This is the more general form of _writeUrl(). It allows a hyperlink to be
         * written to a range of cells. This function also decides the type of hyperlink
         * to be written. These are either, Web (http, ftp, mailto), Internal
         * (Sheet1!A1) or external ('c:\temp\foo.xls#Sheet1!A1').
         *
         * @access private
         * @see _writeUrl()
         * @param integer $row1   Start row
         * @param integer $col1   Start column
         * @param integer $row2   End row
         * @param integer $col2   End column
         * @param string  $url	URL string
         * @return integer
         */
        function _writeUrlRange($row1, $col1, $row2, $col2, $url)
        {
        }
        /**
         * Used to write http, ftp and mailto hyperlinks.
         * The link type ($options) is 0x03 is the same as absolute dir ref without
         * sheet. However it is differentiated by the $unknown2 data stream.
         *
         * @access private
         * @see _writeUrl()
         * @param integer $row1   Start row
         * @param integer $col1   Start column
         * @param integer $row2   End row
         * @param integer $col2   End column
         * @param string  $url	URL string
         * @return integer
         */
        function _writeUrlWeb($row1, $col1, $row2, $col2, $url)
        {
        }
        /**
         * Used to write internal reference hyperlinks such as "Sheet1!A1".
         *
         * @access private
         * @see _writeUrl()
         * @param integer $row1   Start row
         * @param integer $col1   Start column
         * @param integer $row2   End row
         * @param integer $col2   End column
         * @param string  $url	URL string
         * @return integer
         */
        function _writeUrlInternal($row1, $col1, $row2, $col2, $url)
        {
        }
        /**
         * Write links to external directory names such as 'c:\foo.xls',
         * c:\foo.xls#Sheet1!A1', '../../foo.xls'. and '../../foo.xls#Sheet1!A1'.
         *
         * Note: Excel writes some relative links with the $dir_long string. We ignore
         * these cases for the sake of simpler code.
         *
         * @access private
         * @see _writeUrl()
         * @param integer $row1   Start row
         * @param integer $col1   Start column
         * @param integer $row2   End row
         * @param integer $col2   End column
         * @param string  $url	URL string
         * @return integer
         */
        function _writeUrlExternal($row1, $col1, $row2, $col2, $url)
        {
        }
        /**
         * This method is used to set the height and format for a row.
         *
         * @param integer $row	The row to set
         * @param integer $height Height we are giving to the row.
         *						Use null to set XF without setting height
         * @param integer $xfIndex  The optional cell style Xf index to apply to the columns
         * @param bool	$hidden The optional hidden attribute
         * @param integer $level  The optional outline level for row, in range [0,7]
         */
        private function _writeRow($row, $height, $xfIndex, $hidden = \false, $level = 0)
        {
        }
        /**
         * Writes Excel DIMENSIONS to define the area in which there is data.
         */
        private function _writeDimensions()
        {
        }
        /**
         * Write BIFF record Window2.
         */
        private function _writeWindow2()
        {
        }
        /**
         * Write BIFF record DEFAULTROWHEIGHT.
         */
        private function _writeDefaultRowHeight()
        {
        }
        /**
         * Write BIFF record DEFCOLWIDTH if COLINFO records are in use.
         */
        private function _writeDefcol()
        {
        }
        /**
         * Write BIFF record COLINFO to define column widths
         *
         * Note: The SDK says the record length is 0x0B but Excel writes a 0x0C
         * length record.
         *
         * @param array $col_array This is the only parameter received and is composed of the following:
         *				0 => First formatted column,
         *				1 => Last formatted column,
         *				2 => Col width (8.43 is Excel default),
         *				3 => The optional XF format of the column,
         *				4 => Option flags.
         *				5 => Optional outline level
         */
        private function _writeColinfo($col_array)
        {
        }
        /**
         * Write BIFF record SELECTION.
         */
        private function _writeSelection()
        {
        }
        /**
         * Store the MERGEDCELLS records for all ranges of merged cells
         */
        private function _writeMergedCells()
        {
        }
        /**
         * Write SHEETLAYOUT record
         */
        private function _writeSheetLayout()
        {
        }
        /**
         * Write SHEETPROTECTION
         */
        private function _writeSheetProtection()
        {
        }
        /**
         * Write BIFF record RANGEPROTECTION
         *
         * Openoffice.org's Documentaion of the Microsoft Excel File Format uses term RANGEPROTECTION for these records
         * Microsoft Office Excel 97-2007 Binary File Format Specification uses term FEAT for these records
         */
        private function _writeRangeProtection()
        {
        }
        /**
         * Write BIFF record EXTERNCOUNT to indicate the number of external sheet
         * references in a worksheet.
         *
         * Excel only stores references to external sheets that are used in formulas.
         * For simplicity we store references to all the sheets in the workbook
         * regardless of whether they are used or not. This reduces the overall
         * complexity and eliminates the need for a two way dialogue between the formula
         * parser the worksheet objects.
         *
         * @param integer $count The number of external sheet references in this worksheet
         */
        private function _writeExterncount($count)
        {
        }
        /**
         * Writes the Excel BIFF EXTERNSHEET record. These references are used by
         * formulas. A formula references a sheet name via an index. Since we store a
         * reference to all of the external worksheets the EXTERNSHEET index is the same
         * as the worksheet index.
         *
         * @param string $sheetname The name of a external worksheet
         */
        private function _writeExternsheet($sheetname)
        {
        }
        /**
         * Writes the Excel BIFF PANE record.
         * The panes can either be frozen or thawed (unfrozen).
         * Frozen panes are specified in terms of an integer number of rows and columns.
         * Thawed panes are specified in terms of Excel's units for rows and columns.
         */
        private function _writePanes()
        {
        }
        /**
         * Store the page setup SETUP BIFF record.
         */
        private function _writeSetup()
        {
        }
        /**
         * Store the header caption BIFF record.
         */
        private function _writeHeader()
        {
        }
        /**
         * Store the footer caption BIFF record.
         */
        private function _writeFooter()
        {
        }
        /**
         * Store the horizontal centering HCENTER BIFF record.
         *
         * @access private
         */
        private function _writeHcenter()
        {
        }
        /**
         * Store the vertical centering VCENTER BIFF record.
         */
        private function _writeVcenter()
        {
        }
        /**
         * Store the LEFTMARGIN BIFF record.
         */
        private function _writeMarginLeft()
        {
        }
        /**
         * Store the RIGHTMARGIN BIFF record.
         */
        private function _writeMarginRight()
        {
        }
        /**
         * Store the TOPMARGIN BIFF record.
         */
        private function _writeMarginTop()
        {
        }
        /**
         * Store the BOTTOMMARGIN BIFF record.
         */
        private function _writeMarginBottom()
        {
        }
        /**
         * Write the PRINTHEADERS BIFF record.
         */
        private function _writePrintHeaders()
        {
        }
        /**
         * Write the PRINTGRIDLINES BIFF record. Must be used in conjunction with the
         * GRIDSET record.
         */
        private function _writePrintGridlines()
        {
        }
        /**
         * Write the GRIDSET BIFF record. Must be used in conjunction with the
         * PRINTGRIDLINES record.
         */
        private function _writeGridset()
        {
        }
        /**
         * Write the AUTOFILTERINFO BIFF record. This is used to configure the number of autofilter select used in the sheet.
         */
        private function _writeAutoFilterInfo()
        {
        }
        /**
         * Write the GUTS BIFF record. This is used to configure the gutter margins
         * where Excel outline symbols are displayed. The visibility of the gutters is
         * controlled by a flag in WSBOOL.
         *
         * @see _writeWsbool()
         */
        private function _writeGuts()
        {
        }
        /**
         * Write the WSBOOL BIFF record, mainly for fit-to-page. Used in conjunction
         * with the SETUP record.
         */
        private function _writeWsbool()
        {
        }
        /**
         * Write the HORIZONTALPAGEBREAKS and VERTICALPAGEBREAKS BIFF records.
         */
        private function _writeBreaks()
        {
        }
        /**
         * Set the Biff PROTECT record to indicate that the worksheet is protected.
         */
        private function _writeProtect()
        {
        }
        /**
         * Write SCENPROTECT
         */
        private function _writeScenProtect()
        {
        }
        /**
         * Write OBJECTPROTECT
         */
        private function _writeObjectProtect()
        {
        }
        /**
         * Write the worksheet PASSWORD record.
         */
        private function _writePassword()
        {
        }
        /**
         * Insert a 24bit bitmap image in a worksheet.
         *
         * @access public
         * @param integer $row	 The row we are going to insert the bitmap into
         * @param integer $col	 The column we are going to insert the bitmap into
         * @param mixed   $bitmap  The bitmap filename or GD-image resource
         * @param integer $x	   The horizontal position (offset) of the image inside the cell.
         * @param integer $y	   The vertical position (offset) of the image inside the cell.
         * @param float   $scale_x The horizontal scale
         * @param float   $scale_y The vertical scale
         */
        function insertBitmap($row, $col, $bitmap, $x = 0, $y = 0, $scale_x = 1, $scale_y = 1)
        {
        }
        /**
         * Calculate the vertices that define the position of the image as required by
         * the OBJ record.
         *
         *		 +------------+------------+
         *		 |	 A	  |	  B	 |
         *   +-----+------------+------------+
         *   |	 |(x1,y1)	 |			|
         *   |  1  |(A1)._______|______	  |
         *   |	 |	|			  |	 |
         *   |	 |	|			  |	 |
         *   +-----+----|	BITMAP	|-----+
         *   |	 |	|			  |	 |
         *   |  2  |	|______________.	 |
         *   |	 |			|		(B2)|
         *   |	 |			|	 (x2,y2)|
         *   +---- +------------+------------+
         *
         * Example of a bitmap that covers some of the area from cell A1 to cell B2.
         *
         * Based on the width and height of the bitmap we need to calculate 8 vars:
         *	 $col_start, $row_start, $col_end, $row_end, $x1, $y1, $x2, $y2.
         * The width and height of the cells are also variable and have to be taken into
         * account.
         * The values of $col_start and $row_start are passed in from the calling
         * function. The values of $col_end and $row_end are calculated by subtracting
         * the width and height of the bitmap from the width and height of the
         * underlying cells.
         * The vertices are expressed as a percentage of the underlying cell width as
         * follows (rhs values are in pixels):
         *
         *	   x1 = X / W *1024
         *	   y1 = Y / H *256
         *	   x2 = (X-1) / W *1024
         *	   y2 = (Y-1) / H *256
         *
         *	   Where:  X is distance from the left side of the underlying cell
         *			   Y is distance from the top of the underlying cell
         *			   W is the width of the cell
         *			   H is the height of the cell
         * The SDK incorrectly states that the height should be expressed as a
         *		percentage of 1024.
         *
         * @access private
         * @param integer $col_start Col containing upper left corner of object
         * @param integer $row_start Row containing top left corner of object
         * @param integer $x1		Distance to left side of object
         * @param integer $y1		Distance to top of object
         * @param integer $width	 Width of image frame
         * @param integer $height	Height of image frame
         */
        function _positionImage($col_start, $row_start, $x1, $y1, $width, $height)
        {
        }
        /**
         * Store the OBJ record that precedes an IMDATA record. This could be generalise
         * to support other Excel objects.
         *
         * @param integer $colL Column containing upper left corner of object
         * @param integer $dxL  Distance from left side of cell
         * @param integer $rwT  Row containing top left corner of object
         * @param integer $dyT  Distance from top of cell
         * @param integer $colR Column containing lower right corner of object
         * @param integer $dxR  Distance from right of cell
         * @param integer $rwB  Row containing bottom right corner of object
         * @param integer $dyB  Distance from bottom of cell
         */
        private function _writeObjPicture($colL, $dxL, $rwT, $dyT, $colR, $dxR, $rwB, $dyB)
        {
        }
        /**
         * Convert a GD-image into the internal format.
         *
         * @access private
         * @param resource $image The image to process
         * @return array Array with data and properties of the bitmap
         */
        function _processBitmapGd($image)
        {
        }
        /**
         * Convert a 24 bit bitmap into the modified internal format used by Windows.
         * This is described in BITMAPCOREHEADER and BITMAPCOREINFO structures in the
         * MSDN library.
         *
         * @access private
         * @param string $bitmap The bitmap to process
         * @return array Array with data and properties of the bitmap
         */
        function _processBitmap($bitmap)
        {
        }
        /**
         * Store the window zoom factor. This should be a reduced fraction but for
         * simplicity we will store all fractions with a numerator of 100.
         */
        private function _writeZoom()
        {
        }
        /**
         * Get Escher object
         *
         * @return PHPExcel_Shared_Escher
         */
        public function getEscher()
        {
        }
        /**
         * Set Escher object
         *
         * @param PHPExcel_Shared_Escher $pValue
         */
        public function setEscher(\PHPExcel_Shared_Escher $pValue = \null)
        {
        }
        /**
         * Write MSODRAWING record
         */
        private function _writeMsoDrawing()
        {
        }
        /**
         * Store the DATAVALIDATIONS and DATAVALIDATION records.
         */
        private function _writeDataValidity()
        {
        }
        /**
         * Map Error code
         *
         * @param string $errorCode
         * @return int
         */
        private static function _mapErrorCode($errorCode)
        {
        }
        /**
         * Write PLV Record
         */
        private function _writePageLayoutView()
        {
        }
        /**
         * Write CFRule Record
         * @param PHPExcel_Style_Conditional $conditional
         */
        private function _writeCFRule(\PHPExcel_Style_Conditional $conditional)
        {
        }
        /**
         * Write CFHeader record
         */
        private function _writeCFHeader()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel5
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Writer_Excel5_Font
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel5
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Writer_Excel5_Font
    {
        /**
         * Color index
         *
         * @var int
         */
        private $_colorIndex;
        /**
         * Font
         *
         * @var PHPExcel_Style_Font
         */
        private $_font;
        /**
         * Constructor
         *
         * @param PHPExcel_Style_Font $font
         */
        public function __construct(\PHPExcel_Style_Font $font = \null)
        {
        }
        /**
         * Set the color index
         *
         * @param int $colorIndex
         */
        public function setColorIndex($colorIndex)
        {
        }
        /**
         * Get font record data
         *
         * @return string
         */
        public function writeFont()
        {
        }
        /**
         * Map to BIFF5-BIFF8 codes for bold
         *
         * @param boolean $bold
         * @return int
         */
        private static function _mapBold($bold)
        {
        }
        /**
         * Map of BIFF2-BIFF8 codes for underline styles
         * @static	array of int
         *
         */
        private static $_mapUnderline = array(\PHPExcel_Style_Font::UNDERLINE_NONE => 0x0, \PHPExcel_Style_Font::UNDERLINE_SINGLE => 0x1, \PHPExcel_Style_Font::UNDERLINE_DOUBLE => 0x2, \PHPExcel_Style_Font::UNDERLINE_SINGLEACCOUNTING => 0x21, \PHPExcel_Style_Font::UNDERLINE_DOUBLEACCOUNTING => 0x22);
        /**
         * Map underline
         *
         * @param string
         * @return int
         */
        private static function _mapUnderline($underline)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel5
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Shared_Escher_DggContainer_BstoreContainer
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel5
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Writer_Excel5_Escher
    {
        /**
         * The object we are writing
         */
        private $_object;
        /**
         * The written binary data
         */
        private $_data;
        /**
         * Shape offsets. Positions in binary stream where a new shape record begins
         *
         * @var array
         */
        private $_spOffsets;
        /**
         * Shape types.
         *
         * @var array
         */
        private $_spTypes;
        /**
         * Constructor
         *
         * @param mixed
         */
        public function __construct($object)
        {
        }
        /**
         * Process the object to be written
         */
        public function close()
        {
        }
        /**
         * Gets the shape offsets
         *
         * @return array
         */
        public function getSpOffsets()
        {
        }
        /**
         * Gets the shape types
         *
         * @return array
         */
        public function getSpTypes()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel5
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    // Original file header of PEAR::Spreadsheet_Excel_Writer_Format (used as the base for this class):
    // -----------------------------------------------------------------------------------------
    // /*
    // *  Module written/ported by Xavier Noguer <xnoguer@rezebra.com>
    // *
    // *  The majority of this is _NOT_ my code.  I simply ported it from the
    // *  PERL Spreadsheet::WriteExcel module.
    // *
    // *  The author of the Spreadsheet::WriteExcel module is John McNamara
    // *  <jmcnamara@cpan.org>
    // *
    // *  I _DO_ maintain this code, and John McNamara has nothing to do with the
    // *  porting of this code to PHP.  Any questions directly related to this
    // *  class library should be directed to me.
    // *
    // *  License Information:
    // *
    // *    Spreadsheet_Excel_Writer:  A library for generating Excel Spreadsheets
    // *    Copyright (c) 2002-2003 Xavier Noguer xnoguer@rezebra.com
    // *
    // *    This library is free software; you can redistribute it and/or
    // *    modify it under the terms of the GNU Lesser General Public
    // *    License as published by the Free Software Foundation; either
    // *    version 2.1 of the License, or (at your option) any later version.
    // *
    // *    This library is distributed in the hope that it will be useful,
    // *    but WITHOUT ANY WARRANTY; without even the implied warranty of
    // *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    // *    Lesser General Public License for more details.
    // *
    // *    You should have received a copy of the GNU Lesser General Public
    // *    License along with this library; if not, write to the Free Software
    // *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
    // */
    /**
     * PHPExcel_Writer_Excel5_Xf
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel5
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Writer_Excel5_Xf
    {
        /**
         * Style XF or a cell XF ?
         *
         * @var boolean
         */
        private $_isStyleXf;
        /**
         * Index to the FONT record. Index 4 does not exist
         * @var integer
         */
        private $_fontIndex;
        /**
         * An index (2 bytes) to a FORMAT record (number format).
         * @var integer
         */
        public $_numberFormatIndex;
        /**
         * 1 bit, apparently not used.
         * @var integer
         */
        public $_text_justlast;
        /**
         * The cell's foreground color.
         * @var integer
         */
        public $_fg_color;
        /**
         * The cell's background color.
         * @var integer
         */
        public $_bg_color;
        /**
         * Color of the bottom border of the cell.
         * @var integer
         */
        public $_bottom_color;
        /**
         * Color of the top border of the cell.
         * @var integer
         */
        public $_top_color;
        /**
         * Color of the left border of the cell.
         * @var integer
         */
        public $_left_color;
        /**
         * Color of the right border of the cell.
         * @var integer
         */
        public $_right_color;
        /**
         * Constructor
         *
         * @access public
         * @param PHPExcel_Style	The XF format
         */
        public function __construct(\PHPExcel_Style $style = \null)
        {
        }
        /**
         * Generate an Excel BIFF XF record (style or cell).
         *
         * @return string The XF record
         */
        function writeXf()
        {
        }
        /**
         * Is this a style XF ?
         *
         * @param boolean $value
         */
        public function setIsStyleXf($value)
        {
        }
        /**
         * Sets the cell's bottom border color
         *
         * @access public
         * @param int $colorIndex Color index
         */
        function setBottomColor($colorIndex)
        {
        }
        /**
         * Sets the cell's top border color
         *
         * @access public
         * @param int $colorIndex Color index
         */
        function setTopColor($colorIndex)
        {
        }
        /**
         * Sets the cell's left border color
         *
         * @access public
         * @param int $colorIndex Color index
         */
        function setLeftColor($colorIndex)
        {
        }
        /**
         * Sets the cell's right border color
         *
         * @access public
         * @param int $colorIndex Color index
         */
        function setRightColor($colorIndex)
        {
        }
        /**
         * Sets the cell's diagonal border color
         *
         * @access public
         * @param int $colorIndex Color index
         */
        function setDiagColor($colorIndex)
        {
        }
        /**
         * Sets the cell's foreground color
         *
         * @access public
         * @param int $colorIndex Color index
         */
        function setFgColor($colorIndex)
        {
        }
        /**
         * Sets the cell's background color
         *
         * @access public
         * @param int $colorIndex Color index
         */
        function setBgColor($colorIndex)
        {
        }
        /**
         * Sets the index to the number format record
         * It can be date, time, currency, etc...
         *
         * @access public
         * @param integer $numberFormatIndex Index to format record
         */
        function setNumberFormatIndex($numberFormatIndex)
        {
        }
        /**
         * Set the font index.
         *
         * @param int $value Font index, note that value 4 does not exist
         */
        public function setFontIndex($value)
        {
        }
        /**
         * Map of BIFF2-BIFF8 codes for border styles
         * @static	array of int
         *
         */
        private static $_mapBorderStyle = array(\PHPExcel_Style_Border::BORDER_NONE => 0x0, \PHPExcel_Style_Border::BORDER_THIN => 0x1, \PHPExcel_Style_Border::BORDER_MEDIUM => 0x2, \PHPExcel_Style_Border::BORDER_DASHED => 0x3, \PHPExcel_Style_Border::BORDER_DOTTED => 0x4, \PHPExcel_Style_Border::BORDER_THICK => 0x5, \PHPExcel_Style_Border::BORDER_DOUBLE => 0x6, \PHPExcel_Style_Border::BORDER_HAIR => 0x7, \PHPExcel_Style_Border::BORDER_MEDIUMDASHED => 0x8, \PHPExcel_Style_Border::BORDER_DASHDOT => 0x9, \PHPExcel_Style_Border::BORDER_MEDIUMDASHDOT => 0xa, \PHPExcel_Style_Border::BORDER_DASHDOTDOT => 0xb, \PHPExcel_Style_Border::BORDER_MEDIUMDASHDOTDOT => 0xc, \PHPExcel_Style_Border::BORDER_SLANTDASHDOT => 0xd);
        /**
         * Map border style
         *
         * @param string $borderStyle
         * @return int
         */
        private static function _mapBorderStyle($borderStyle)
        {
        }
        /**
         * Map of BIFF2-BIFF8 codes for fill types
         * @static	array of int
         *
         */
        private static $_mapFillType = array(
            \PHPExcel_Style_Fill::FILL_NONE => 0x0,
            \PHPExcel_Style_Fill::FILL_SOLID => 0x1,
            \PHPExcel_Style_Fill::FILL_PATTERN_MEDIUMGRAY => 0x2,
            \PHPExcel_Style_Fill::FILL_PATTERN_DARKGRAY => 0x3,
            \PHPExcel_Style_Fill::FILL_PATTERN_LIGHTGRAY => 0x4,
            \PHPExcel_Style_Fill::FILL_PATTERN_DARKHORIZONTAL => 0x5,
            \PHPExcel_Style_Fill::FILL_PATTERN_DARKVERTICAL => 0x6,
            \PHPExcel_Style_Fill::FILL_PATTERN_DARKDOWN => 0x7,
            \PHPExcel_Style_Fill::FILL_PATTERN_DARKUP => 0x8,
            \PHPExcel_Style_Fill::FILL_PATTERN_DARKGRID => 0x9,
            \PHPExcel_Style_Fill::FILL_PATTERN_DARKTRELLIS => 0xa,
            \PHPExcel_Style_Fill::FILL_PATTERN_LIGHTHORIZONTAL => 0xb,
            \PHPExcel_Style_Fill::FILL_PATTERN_LIGHTVERTICAL => 0xc,
            \PHPExcel_Style_Fill::FILL_PATTERN_LIGHTDOWN => 0xd,
            \PHPExcel_Style_Fill::FILL_PATTERN_LIGHTUP => 0xe,
            \PHPExcel_Style_Fill::FILL_PATTERN_LIGHTGRID => 0xf,
            \PHPExcel_Style_Fill::FILL_PATTERN_LIGHTTRELLIS => 0x10,
            \PHPExcel_Style_Fill::FILL_PATTERN_GRAY125 => 0x11,
            \PHPExcel_Style_Fill::FILL_PATTERN_GRAY0625 => 0x12,
            \PHPExcel_Style_Fill::FILL_GRADIENT_LINEAR => 0x0,
            // does not exist in BIFF8
            \PHPExcel_Style_Fill::FILL_GRADIENT_PATH => 0x0,
        );
        /**
         * Map fill type
         *
         * @param string $fillType
         * @return int
         */
        private static function _mapFillType($fillType)
        {
        }
        /**
         * Map of BIFF2-BIFF8 codes for horizontal alignment
         * @static	array of int
         *
         */
        private static $_mapHAlign = array(\PHPExcel_Style_Alignment::HORIZONTAL_GENERAL => 0, \PHPExcel_Style_Alignment::HORIZONTAL_LEFT => 1, \PHPExcel_Style_Alignment::HORIZONTAL_CENTER => 2, \PHPExcel_Style_Alignment::HORIZONTAL_RIGHT => 3, \PHPExcel_Style_Alignment::HORIZONTAL_FILL => 4, \PHPExcel_Style_Alignment::HORIZONTAL_JUSTIFY => 5, \PHPExcel_Style_Alignment::HORIZONTAL_CENTER_CONTINUOUS => 6);
        /**
         * Map to BIFF2-BIFF8 codes for horizontal alignment
         *
         * @param string $hAlign
         * @return int
         */
        private function _mapHAlign($hAlign)
        {
        }
        /**
         * Map of BIFF2-BIFF8 codes for vertical alignment
         * @static	array of int
         *
         */
        private static $_mapVAlign = array(\PHPExcel_Style_Alignment::VERTICAL_TOP => 0, \PHPExcel_Style_Alignment::VERTICAL_CENTER => 1, \PHPExcel_Style_Alignment::VERTICAL_BOTTOM => 2, \PHPExcel_Style_Alignment::VERTICAL_JUSTIFY => 3);
        /**
         * Map to BIFF2-BIFF8 codes for vertical alignment
         *
         * @param string $vAlign
         * @return int
         */
        private static function _mapVAlign($vAlign)
        {
        }
        /**
         * Map to BIFF8 codes for text rotation angle
         *
         * @param int $textRotation
         * @return int
         */
        private static function _mapTextRotation($textRotation)
        {
        }
        /**
         * Map locked
         *
         * @param string
         * @return int
         */
        private static function _mapLocked($locked)
        {
        }
        /**
         * Map hidden
         *
         * @param string
         * @return int
         */
        private static function _mapHidden($hidden)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel5
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    // Original file header of PEAR::Spreadsheet_Excel_Writer_Parser (used as the base for this class):
    // -----------------------------------------------------------------------------------------
    // *  Class for parsing Excel formulas
    // *
    // *  License Information:
    // *
    // *    Spreadsheet_Excel_Writer:  A library for generating Excel Spreadsheets
    // *    Copyright (c) 2002-2003 Xavier Noguer xnoguer@rezebra.com
    // *
    // *    This library is free software; you can redistribute it and/or
    // *    modify it under the terms of the GNU Lesser General Public
    // *    License as published by the Free Software Foundation; either
    // *    version 2.1 of the License, or (at your option) any later version.
    // *
    // *    This library is distributed in the hope that it will be useful,
    // *    but WITHOUT ANY WARRANTY; without even the implied warranty of
    // *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    // *    Lesser General Public License for more details.
    // *
    // *    You should have received a copy of the GNU Lesser General Public
    // *    License along with this library; if not, write to the Free Software
    // *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
    // */
    /**
     * PHPExcel_Writer_Excel5_Parser
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel5
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Writer_Excel5_Parser
    {
        /**	Constants				*/
        // Sheet title in unquoted form
        // Invalid sheet title characters cannot occur in the sheet title:
        // 		*:/\?[]
        // Moreover, there are valid sheet title characters that cannot occur in unquoted form (there may be more?)
        // +-% '^&<>=,;#()"{}
        const REGEX_SHEET_TITLE_UNQUOTED = '[^\\*\\:\\/\\\\\\?\\[\\]\\+\\-\\% \\\'\\^\\&\\<\\>\\=\\,\\;\\#\\(\\)\\"\\{\\}]+';
        // Sheet title in quoted form (without surrounding quotes)
        // Invalid sheet title characters cannot occur in the sheet title:
        // *:/\?[]					(usual invalid sheet title characters)
        // Single quote is represented as a pair ''
        const REGEX_SHEET_TITLE_QUOTED = '(([^\\*\\:\\/\\\\\\?\\[\\]\\\'])+|(\\\'\\\')+)+';
        /**
         * The index of the character we are currently looking at
         * @var integer
         */
        public $_current_char;
        /**
         * The token we are working on.
         * @var string
         */
        public $_current_token;
        /**
         * The formula to parse
         * @var string
         */
        public $_formula;
        /**
         * The character ahead of the current char
         * @var string
         */
        public $_lookahead;
        /**
         * The parse tree to be generated
         * @var string
         */
        public $_parse_tree;
        /**
         * Array of external sheets
         * @var array
         */
        public $_ext_sheets;
        /**
         * Array of sheet references in the form of REF structures
         * @var array
         */
        public $_references;
        /**
         * The class constructor
         *
         */
        public function __construct()
        {
        }
        /**
         * Initialize the ptg and function hashes.
         *
         * @access private
         */
        function _initializeHashes()
        {
        }
        /**
         * Convert a token to the proper ptg value.
         *
         * @access private
         * @param mixed $token The token to convert.
         * @return mixed the converted token on success
         */
        function _convert($token)
        {
        }
        /**
         * Convert a number token to ptgInt or ptgNum
         *
         * @access private
         * @param mixed $num an integer or double for conversion to its ptg value
         */
        function _convertNumber($num)
        {
        }
        /**
         * Convert a string token to ptgStr
         *
         * @access private
         * @param string $string A string for conversion to its ptg value.
         * @return mixed the converted token on success
         */
        function _convertString($string)
        {
        }
        /**
         * Convert a function to a ptgFunc or ptgFuncVarV depending on the number of
         * args that it takes.
         *
         * @access private
         * @param string  $token    The name of the function for convertion to ptg value.
         * @param integer $num_args The number of arguments the function receives.
         * @return string The packed ptg for the function
         */
        function _convertFunction($token, $num_args)
        {
        }
        /**
         * Convert an Excel range such as A1:D4 to a ptgRefV.
         *
         * @access private
         * @param string	$range	An Excel range in the A1:A2
         * @param int		$class
         */
        function _convertRange2d($range, $class = 0)
        {
        }
        /**
         * Convert an Excel 3d range such as "Sheet1!A1:D4" or "Sheet1:Sheet2!A1:D4" to
         * a ptgArea3d.
         *
         * @access private
         * @param string $token An Excel range in the Sheet1!A1:A2 format.
         * @return mixed The packed ptgArea3d token on success.
         */
        function _convertRange3d($token)
        {
        }
        /**
         * Convert an Excel reference such as A1, $B2, C$3 or $D$4 to a ptgRefV.
         *
         * @access private
         * @param string $cell An Excel cell reference
         * @return string The cell in packed() format with the corresponding ptg
         */
        function _convertRef2d($cell)
        {
        }
        /**
         * Convert an Excel 3d reference such as "Sheet1!A1" or "Sheet1:Sheet2!A1" to a
         * ptgRef3d.
         *
         * @access private
         * @param string $cell An Excel cell reference
         * @return mixed The packed ptgRef3d token on success.
         */
        function _convertRef3d($cell)
        {
        }
        /**
         * Convert an error code to a ptgErr
         *
         * @access	private
         * @param	string	$errorCode	The error code for conversion to its ptg value
         * @return	string				The error code ptgErr
         */
        function _convertError($errorCode)
        {
        }
        /**
         * Convert the sheet name part of an external reference, for example "Sheet1" or
         * "Sheet1:Sheet2", to a packed structure.
         *
         * @access	private
         * @param	string	$ext_ref	The name of the external reference
         * @return	string				The reference index in packed() format
         */
        function _packExtRef($ext_ref)
        {
        }
        /**
         * Look up the REF index that corresponds to an external sheet name
         * (or range). If it doesn't exist yet add it to the workbook's references
         * array. It assumes all sheet names given must exist.
         *
         * @access private
         * @param string $ext_ref The name of the external reference
         * @return mixed The reference index in packed() format on success
         */
        function _getRefIndex($ext_ref)
        {
        }
        /**
         * Look up the index that corresponds to an external sheet name. The hash of
         * sheet names is updated by the addworksheet() method of the
         * PHPExcel_Writer_Excel5_Workbook class.
         *
         * @access	private
         * @param	string	$sheet_name		Sheet name
         * @return	integer					The sheet index, -1 if the sheet was not found
         */
        function _getSheetIndex($sheet_name)
        {
        }
        /**
         * This method is used to update the array of sheet names. It is
         * called by the addWorksheet() method of the
         * PHPExcel_Writer_Excel5_Workbook class.
         *
         * @access public
         * @see PHPExcel_Writer_Excel5_Workbook::addWorksheet()
         * @param string  $name  The name of the worksheet being added
         * @param integer $index The index of the worksheet being added
         */
        function setExtSheet($name, $index)
        {
        }
        /**
         * pack() row and column into the required 3 or 4 byte format.
         *
         * @access private
         * @param string $cell The Excel cell reference to be packed
         * @return array Array containing the row and column in packed() format
         */
        function _cellToPackedRowcol($cell)
        {
        }
        /**
         * pack() row range into the required 3 or 4 byte format.
         * Just using maximum col/rows, which is probably not the correct solution
         *
         * @access private
         * @param string $range The Excel range to be packed
         * @return array Array containing (row1,col1,row2,col2) in packed() format
         */
        function _rangeToPackedRange($range)
        {
        }
        /**
         * Convert an Excel cell reference such as A1 or $B2 or C$3 or $D$4 to a zero
         * indexed row and column number. Also returns two (0,1) values to indicate
         * whether the row or column are relative references.
         *
         * @access private
         * @param string $cell The Excel cell reference in A1 format.
         * @return array
         */
        function _cellToRowcol($cell)
        {
        }
        /**
         * Advance to the next valid token.
         *
         * @access private
         */
        function _advance()
        {
        }
        /**
         * Checks if it's a valid token.
         *
         * @access private
         * @param mixed $token The token to check.
         * @return mixed       The checked token or false on failure
         */
        function _match($token)
        {
        }
        /**
         * The parsing method. It parses a formula.
         *
         * @access public
         * @param string $formula The formula to parse, without the initial equal
         *                        sign (=).
         * @return mixed true on success
         */
        function parse($formula)
        {
        }
        /**
         * It parses a condition. It assumes the following rule:
         * Cond -> Expr [(">" | "<") Expr]
         *
         * @access private
         * @return mixed The parsed ptg'd tree on success
         */
        function _condition()
        {
        }
        /**
         * It parses a expression. It assumes the following rule:
         * Expr -> Term [("+" | "-") Term]
         *      -> "string"
         *      -> "-" Term : Negative value
         *      -> "+" Term : Positive value
         *      -> Error code
         *
         * @access private
         * @return mixed The parsed ptg'd tree on success
         */
        function _expression()
        {
        }
        /**
         * This function just introduces a ptgParen element in the tree, so that Excel
         * doesn't get confused when working with a parenthesized formula afterwards.
         *
         * @access private
         * @see _fact()
         * @return array The parsed ptg'd tree
         */
        function _parenthesizedExpression()
        {
        }
        /**
         * It parses a term. It assumes the following rule:
         * Term -> Fact [("*" | "/") Fact]
         *
         * @access private
         * @return mixed The parsed ptg'd tree on success
         */
        function _term()
        {
        }
        /**
         * It parses a factor. It assumes the following rule:
         * Fact -> ( Expr )
         *       | CellRef
         *       | CellRange
         *       | Number
         *       | Function
         *
         * @access private
         * @return mixed The parsed ptg'd tree on success
         */
        function _fact()
        {
        }
        /**
         * It parses a function call. It assumes the following rule:
         * Func -> ( Expr [,Expr]* )
         *
         * @access private
         * @return mixed The parsed ptg'd tree on success
         */
        function _func()
        {
        }
        /**
         * Creates a tree. In fact an array which may have one or two arrays (sub-trees)
         * as elements.
         *
         * @access private
         * @param mixed $value The value of this node.
         * @param mixed $left  The left array (sub-tree) or a final node.
         * @param mixed $right The right array (sub-tree) or a final node.
         * @return array A tree
         */
        function _createTree($value, $left, $right)
        {
        }
        /**
         * Builds a string containing the tree in reverse polish notation (What you
         * would use in a HP calculator stack).
         * The following tree:
         *
         *    +
         *   / \
         *  2   3
         *
         * produces: "23+"
         *
         * The following tree:
         *
         *    +
         *   / \
         *  3   *
         *     / \
         *    6   A1
         *
         * produces: "36A1*+"
         *
         * In fact all operands, functions, references, etc... are written as ptg's
         *
         * @access public
         * @param array $tree The optional tree to convert.
         * @return string The tree in reverse polish notation
         */
        function toReversePolish($tree = array())
        {
        }
    }
    /**
     *  PHPExcel
     *
     *  Copyright (c) 2006 - 2014 PHPExcel
     *
     *  This library is free software; you can redistribute it and/or
     *  modify it under the terms of the GNU Lesser General Public
     *  License as published by the Free Software Foundation; either
     *  version 2.1 of the License, or (at your option) any later version.
     *
     *  This library is distributed in the hope that it will be useful,
     *  but WITHOUT ANY WARRANTY; without even the implied warranty of
     *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     *  Lesser General Public License for more details.
     *
     *  You should have received a copy of the GNU Lesser General Public
     *  License along with this library; if not, write to the Free Software
     *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     *  @category   PHPExcel
     *  @package    PHPExcel_Writer
     *  @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     *  @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt    LGPL
     *  @version    1.8.0, 2014-03-02
     */
    /**
     *  PHPExcel_Writer_IWriter
     *
     *  @category   PHPExcel
     *  @package    PHPExcel_Writer
     *  @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    interface PHPExcel_Writer_IWriter
    {
        /**
         *  Save PHPExcel to file
         *
         *  @param   string       $pFilename  Name of the file to save
         *  @throws  PHPExcel_Writer_Exception
         */
        public function save($pFilename = \NULL);
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Writer_Abstract
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    abstract class PHPExcel_Writer_Abstract implements \PHPExcel_Writer_IWriter
    {
        /**
         * Write charts that are defined in the workbook?
         * Identifies whether the Writer should write definitions for any charts that exist in the PHPExcel object;
         *
         * @var	boolean
         */
        protected $_includeCharts = \FALSE;
        /**
         * Pre-calculate formulas
         * Forces PHPExcel to recalculate all formulae in a workbook when saving, so that the pre-calculated values are
         *    immediately available to MS Excel or other office spreadsheet viewer when opening the file
         *
         * @var boolean
         */
        protected $_preCalculateFormulas = \TRUE;
        /**
         * Use disk caching where possible?
         *
         * @var boolean
         */
        protected $_useDiskCaching = \FALSE;
        /**
         * Disk caching directory
         *
         * @var string
         */
        protected $_diskCachingDirectory = './';
        /**
         * Write charts in workbook?
         *		If this is true, then the Writer will write definitions for any charts that exist in the PHPExcel object.
         *		If false (the default) it will ignore any charts defined in the PHPExcel object.
         *
         * @return	boolean
         */
        public function getIncludeCharts()
        {
        }
        /**
         * Set write charts in workbook
         *		Set to true, to advise the Writer to include any charts that exist in the PHPExcel object.
         *		Set to false (the default) to ignore charts.
         *
         * @param	boolean	$pValue
         * @return	PHPExcel_Writer_IWriter
         */
        public function setIncludeCharts($pValue = \FALSE)
        {
        }
        /**
         * Get Pre-Calculate Formulas flag
         *     If this is true (the default), then the writer will recalculate all formulae in a workbook when saving,
         *        so that the pre-calculated values are immediately available to MS Excel or other office spreadsheet
         *        viewer when opening the file
         *     If false, then formulae are not calculated on save. This is faster for saving in PHPExcel, but slower
         *        when opening the resulting file in MS Excel, because Excel has to recalculate the formulae itself
         *
         * @return boolean
         */
        public function getPreCalculateFormulas()
        {
        }
        /**
         * Set Pre-Calculate Formulas
         *		Set to true (the default) to advise the Writer to calculate all formulae on save
         *		Set to false to prevent precalculation of formulae on save.
         *
         * @param boolean $pValue	Pre-Calculate Formulas?
         * @return	PHPExcel_Writer_IWriter
         */
        public function setPreCalculateFormulas($pValue = \TRUE)
        {
        }
        /**
         * Get use disk caching where possible?
         *
         * @return boolean
         */
        public function getUseDiskCaching()
        {
        }
        /**
         * Set use disk caching where possible?
         *
         * @param 	boolean 	$pValue
         * @param	string		$pDirectory		Disk caching directory
         * @throws	PHPExcel_Writer_Exception	when directory does not exist
         * @return PHPExcel_Writer_Excel2007
         */
        public function setUseDiskCaching($pValue = \FALSE, $pDirectory = \NULL)
        {
        }
        /**
         * Get disk caching directory
         *
         * @return string
         */
        public function getDiskCachingDirectory()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel5
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license	http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version	1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Writer_Excel5
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel5
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Writer_Excel5 extends \PHPExcel_Writer_Abstract implements \PHPExcel_Writer_IWriter
    {
        /**
         * PHPExcel object
         *
         * @var PHPExcel
         */
        private $_phpExcel;
        /**
         * Total number of shared strings in workbook
         *
         * @var int
         */
        private $_str_total = 0;
        /**
         * Number of unique shared strings in workbook
         *
         * @var int
         */
        private $_str_unique = 0;
        /**
         * Array of unique shared strings in workbook
         *
         * @var array
         */
        private $_str_table = array();
        /**
         * Color cache. Mapping between RGB value and color index.
         *
         * @var array
         */
        private $_colors;
        /**
         * Formula parser
         *
         * @var PHPExcel_Writer_Excel5_Parser
         */
        private $_parser;
        /**
         * Identifier clusters for drawings. Used in MSODRAWINGGROUP record.
         *
         * @var array
         */
        private $_IDCLs;
        /**
         * Basic OLE object summary information
         *
         * @var array
         */
        private $_summaryInformation;
        /**
         * Extended OLE object document summary information
         *
         * @var array
         */
        private $_documentSummaryInformation;
        /**
         * Create a new PHPExcel_Writer_Excel5
         *
         * @param	PHPExcel	$phpExcel	PHPExcel object
         */
        public function __construct(\PHPExcel $phpExcel)
        {
        }
        /**
         * Save PHPExcel to file
         *
         * @param	string		$pFilename
         * @throws	PHPExcel_Writer_Exception
         */
        public function save($pFilename = \null)
        {
        }
        /**
         * Set temporary storage directory
         *
         * @deprecated
         * @param	string	$pValue		Temporary storage directory
         * @throws	PHPExcel_Writer_Exception	when directory does not exist
         * @return PHPExcel_Writer_Excel5
         */
        public function setTempDir($pValue = '')
        {
        }
        /**
         * Build the Worksheet Escher objects
         *
         */
        private function _buildWorksheetEschers()
        {
        }
        /**
         * Build the Escher object corresponding to the MSODRAWINGGROUP record
         */
        private function _buildWorkbookEscher()
        {
        }
        /**
         * Build the OLE Part for DocumentSummary Information
         * @return string
         */
        private function _writeDocumentSummaryInformation()
        {
        }
        /**
         * Build the OLE Part for Summary Information
         * @return string
         */
        private function _writeSummaryInformation()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Writer_Excel2007_WriterPart
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    abstract class PHPExcel_Writer_Excel2007_WriterPart
    {
        /**
         * Parent IWriter object
         *
         * @var PHPExcel_Writer_IWriter
         */
        private $_parentWriter;
        /**
         * Set parent IWriter object
         *
         * @param PHPExcel_Writer_IWriter	$pWriter
         * @throws PHPExcel_Writer_Exception
         */
        public function setParentWriter(\PHPExcel_Writer_IWriter $pWriter = \null)
        {
        }
        /**
         * Get parent IWriter object
         *
         * @return PHPExcel_Writer_IWriter
         * @throws PHPExcel_Writer_Exception
         */
        public function getParentWriter()
        {
        }
        /**
         * Set parent IWriter object
         *
         * @param PHPExcel_Writer_IWriter	$pWriter
         * @throws PHPExcel_Writer_Exception
         */
        public function __construct(\PHPExcel_Writer_IWriter $pWriter = \null)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Writer_Excel2007_Chart
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Writer_Excel2007_Chart extends \PHPExcel_Writer_Excel2007_WriterPart
    {
        /**
         * Write charts to XML format
         *
         * @param 	PHPExcel_Chart				$pChart
         * @return 	string 						XML Output
         * @throws 	PHPExcel_Writer_Exception
         */
        public function writeChart(\PHPExcel_Chart $pChart = \null)
        {
        }
        /**
         * Write Chart Title
         *
         * @param	PHPExcel_Chart_Title		$title
         * @param 	PHPExcel_Shared_XMLWriter 	$objWriter 		XML Writer
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeTitle(\PHPExcel_Chart_Title $title = \null, $objWriter)
        {
        }
        /**
         * Write Chart Legend
         *
         * @param	PHPExcel_Chart_Legend		$legend
         * @param 	PHPExcel_Shared_XMLWriter 	$objWriter 		XML Writer
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeLegend(\PHPExcel_Chart_Legend $legend = \null, $objWriter)
        {
        }
        /**
         * Write Chart Plot Area
         *
         * @param	PHPExcel_Chart_PlotArea		$plotArea
         * @param	PHPExcel_Chart_Title		$xAxisLabel
         * @param	PHPExcel_Chart_Title		$yAxisLabel
         * @param 	PHPExcel_Shared_XMLWriter 	$objWriter 		XML Writer
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writePlotArea(\PHPExcel_Chart_PlotArea $plotArea, \PHPExcel_Chart_Title $xAxisLabel = \NULL, \PHPExcel_Chart_Title $yAxisLabel = \NULL, $objWriter, \PHPExcel_Worksheet $pSheet)
        {
        }
        /**
         * Write Data Labels
         *
         * @param 	PHPExcel_Shared_XMLWriter 	$objWriter 		XML Writer
         * @param 	PHPExcel_Chart_Layout		$chartLayout	Chart layout
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeDataLbls($objWriter, $chartLayout)
        {
        }
        /**
         * Write Category Axis
         *
         * @param 	PHPExcel_Shared_XMLWriter 	$objWriter 		XML Writer
         * @param 	PHPExcel_Chart_PlotArea		$plotArea
         * @param 	PHPExcel_Chart_Title		$xAxisLabel
         * @param 	string						$groupType		Chart type
         * @param 	string						$id1
         * @param 	string						$id2
         * @param 	boolean						$isMultiLevelSeries
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeCatAx($objWriter, \PHPExcel_Chart_PlotArea $plotArea, $xAxisLabel, $groupType, $id1, $id2, $isMultiLevelSeries)
        {
        }
        /**
         * Write Value Axis
         *
         * @param 	PHPExcel_Shared_XMLWriter 	$objWriter 		XML Writer
         * @param 	PHPExcel_Chart_PlotArea		$plotArea
         * @param 	PHPExcel_Chart_Title		$yAxisLabel
         * @param 	string						$groupType		Chart type
         * @param 	string						$id1
         * @param 	string						$id2
         * @param 	boolean						$isMultiLevelSeries
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeValAx($objWriter, \PHPExcel_Chart_PlotArea $plotArea, $yAxisLabel, $groupType, $id1, $id2, $isMultiLevelSeries)
        {
        }
        /**
         * Get the data series type(s) for a chart plot series
         *
         * @param 	PHPExcel_Chart_PlotArea		$plotArea
         * @return	string|array
         * @throws 	PHPExcel_Writer_Exception
         */
        private static function _getChartType($plotArea)
        {
        }
        /**
         * Write Plot Group (series of related plots)
         *
         * @param	PHPExcel_Chart_DataSeries		$plotGroup
         * @param	string							$groupType				Type of plot for dataseries
         * @param 	PHPExcel_Shared_XMLWriter 		$objWriter 				XML Writer
         * @param	boolean							&$catIsMultiLevelSeries	Is category a multi-series category
         * @param	boolean							&$valIsMultiLevelSeries	Is value set a multi-series set
         * @param	string							&$plotGroupingType		Type of grouping for multi-series values
         * @param	PHPExcel_Worksheet 				$pSheet
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writePlotGroup($plotGroup, $groupType, $objWriter, &$catIsMultiLevelSeries, &$valIsMultiLevelSeries, &$plotGroupingType, \PHPExcel_Worksheet $pSheet)
        {
        }
        /**
         * Write Plot Series Label
         *
         * @param	PHPExcel_Chart_DataSeriesValues		$plotSeriesLabel
         * @param 	PHPExcel_Shared_XMLWriter 			$objWriter 			XML Writer
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writePlotSeriesLabel($plotSeriesLabel, $objWriter)
        {
        }
        /**
         * Write Plot Series Values
         *
         * @param	PHPExcel_Chart_DataSeriesValues		$plotSeriesValues
         * @param 	PHPExcel_Shared_XMLWriter 			$objWriter 			XML Writer
         * @param	string								$groupType			Type of plot for dataseries
         * @param	string								$dataType			Datatype of series values
         * @param	PHPExcel_Worksheet 					$pSheet
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writePlotSeriesValues($plotSeriesValues, $objWriter, $groupType, $dataType = 'str', \PHPExcel_Worksheet $pSheet)
        {
        }
        /**
         * Write Bubble Chart Details
         *
         * @param	PHPExcel_Chart_DataSeriesValues		$plotSeriesValues
         * @param 	PHPExcel_Shared_XMLWriter 			$objWriter 			XML Writer
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeBubbles($plotSeriesValues, $objWriter, \PHPExcel_Worksheet $pSheet)
        {
        }
        /**
         * Write Layout
         *
         * @param	PHPExcel_Chart_Layout		$layout
         * @param 	PHPExcel_Shared_XMLWriter 	$objWriter 		XML Writer
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeLayout(\PHPExcel_Chart_Layout $layout = \NULL, $objWriter)
        {
        }
        /**
         * Write Alternate Content block
         *
         * @param 	PHPExcel_Shared_XMLWriter 	$objWriter 		XML Writer
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeAlternateContent($objWriter)
        {
        }
        /**
         * Write Printer Settings
         *
         * @param 	PHPExcel_Shared_XMLWriter 	$objWriter 		XML Writer
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writePrintSettings($objWriter)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Writer_Excel2007_Style
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Writer_Excel2007_Style extends \PHPExcel_Writer_Excel2007_WriterPart
    {
        /**
         * Write styles to XML format
         *
         * @param 	PHPExcel	$pPHPExcel
         * @return 	string 		XML Output
         * @throws 	PHPExcel_Writer_Exception
         */
        public function writeStyles(\PHPExcel $pPHPExcel = \null)
        {
        }
        /**
         * Write Fill
         *
         * @param 	PHPExcel_Shared_XMLWriter 	$objWriter 		XML Writer
         * @param 	PHPExcel_Style_Fill			$pFill			Fill style
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeFill(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Style_Fill $pFill = \null)
        {
        }
        /**
         * Write Gradient Fill
         *
         * @param 	PHPExcel_Shared_XMLWriter 	$objWriter 		XML Writer
         * @param 	PHPExcel_Style_Fill			$pFill			Fill style
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeGradientFill(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Style_Fill $pFill = \null)
        {
        }
        /**
         * Write Pattern Fill
         *
         * @param 	PHPExcel_Shared_XMLWriter			$objWriter 		XML Writer
         * @param 	PHPExcel_Style_Fill					$pFill			Fill style
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writePatternFill(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Style_Fill $pFill = \null)
        {
        }
        /**
         * Write Font
         *
         * @param 	PHPExcel_Shared_XMLWriter		$objWriter 		XML Writer
         * @param 	PHPExcel_Style_Font				$pFont			Font style
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeFont(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Style_Font $pFont = \null)
        {
        }
        /**
         * Write Border
         *
         * @param 	PHPExcel_Shared_XMLWriter			$objWriter 		XML Writer
         * @param 	PHPExcel_Style_Borders				$pBorders		Borders style
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeBorder(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Style_Borders $pBorders = \null)
        {
        }
        /**
         * Write Cell Style Xf
         *
         * @param 	PHPExcel_Shared_XMLWriter			$objWriter 		XML Writer
         * @param 	PHPExcel_Style						$pStyle			Style
         * @param 	PHPExcel							$pPHPExcel		Workbook
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeCellStyleXf(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Style $pStyle = \null, \PHPExcel $pPHPExcel = \null)
        {
        }
        /**
         * Write Cell Style Dxf
         *
         * @param 	PHPExcel_Shared_XMLWriter 		$objWriter 		XML Writer
         * @param 	PHPExcel_Style					$pStyle			Style
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeCellStyleDxf(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Style $pStyle = \null)
        {
        }
        /**
         * Write BorderPr
         *
         * @param 	PHPExcel_Shared_XMLWriter		$objWriter 		XML Writer
         * @param 	string							$pName			Element name
         * @param 	PHPExcel_Style_Border			$pBorder		Border style
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeBorderPr(\PHPExcel_Shared_XMLWriter $objWriter = \null, $pName = 'left', \PHPExcel_Style_Border $pBorder = \null)
        {
        }
        /**
         * Write NumberFormat
         *
         * @param 	PHPExcel_Shared_XMLWriter			$objWriter 		XML Writer
         * @param 	PHPExcel_Style_NumberFormat			$pNumberFormat	Number Format
         * @param 	int									$pId			Number Format identifier
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeNumFmt(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Style_NumberFormat $pNumberFormat = \null, $pId = 0)
        {
        }
        /**
         * Get an array of all styles
         *
         * @param 	PHPExcel				$pPHPExcel
         * @return 	PHPExcel_Style[]		All styles in PHPExcel
         * @throws 	PHPExcel_Writer_Exception
         */
        public function allStyles(\PHPExcel $pPHPExcel = \null)
        {
        }
        /**
         * Get an array of all conditional styles
         *
         * @param 	PHPExcel							$pPHPExcel
         * @return 	PHPExcel_Style_Conditional[]		All conditional styles in PHPExcel
         * @throws 	PHPExcel_Writer_Exception
         */
        public function allConditionalStyles(\PHPExcel $pPHPExcel = \null)
        {
        }
        /**
         * Get an array of all fills
         *
         * @param 	PHPExcel						$pPHPExcel
         * @return 	PHPExcel_Style_Fill[]		All fills in PHPExcel
         * @throws 	PHPExcel_Writer_Exception
         */
        public function allFills(\PHPExcel $pPHPExcel = \null)
        {
        }
        /**
         * Get an array of all fonts
         *
         * @param 	PHPExcel						$pPHPExcel
         * @return 	PHPExcel_Style_Font[]		All fonts in PHPExcel
         * @throws 	PHPExcel_Writer_Exception
         */
        public function allFonts(\PHPExcel $pPHPExcel = \null)
        {
        }
        /**
         * Get an array of all borders
         *
         * @param 	PHPExcel						$pPHPExcel
         * @return 	PHPExcel_Style_Borders[]		All borders in PHPExcel
         * @throws 	PHPExcel_Writer_Exception
         */
        public function allBorders(\PHPExcel $pPHPExcel = \null)
        {
        }
        /**
         * Get an array of all number formats
         *
         * @param 	PHPExcel								$pPHPExcel
         * @return 	PHPExcel_Style_NumberFormat[]		All number formats in PHPExcel
         * @throws 	PHPExcel_Writer_Exception
         */
        public function allNumberFormats(\PHPExcel $pPHPExcel = \null)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Writer_Excel2007_Workbook
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Writer_Excel2007_Workbook extends \PHPExcel_Writer_Excel2007_WriterPart
    {
        /**
         * Write workbook to XML format
         *
         * @param 	PHPExcel	$pPHPExcel
         * @param	boolean		$recalcRequired	Indicate whether formulas should be recalculated before writing
         * @return 	string 		XML Output
         * @throws 	PHPExcel_Writer_Exception
         */
        public function writeWorkbook(\PHPExcel $pPHPExcel = \null, $recalcRequired = \FALSE)
        {
        }
        /**
         * Write file version
         *
         * @param 	PHPExcel_Shared_XMLWriter $objWriter 		XML Writer
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeFileVersion(\PHPExcel_Shared_XMLWriter $objWriter = \null)
        {
        }
        /**
         * Write WorkbookPr
         *
         * @param 	PHPExcel_Shared_XMLWriter $objWriter 		XML Writer
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeWorkbookPr(\PHPExcel_Shared_XMLWriter $objWriter = \null)
        {
        }
        /**
         * Write BookViews
         *
         * @param 	PHPExcel_Shared_XMLWriter 	$objWriter 		XML Writer
         * @param 	PHPExcel					$pPHPExcel
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeBookViews(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel $pPHPExcel = \null)
        {
        }
        /**
         * Write WorkbookProtection
         *
         * @param 	PHPExcel_Shared_XMLWriter 	$objWriter 		XML Writer
         * @param 	PHPExcel					$pPHPExcel
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeWorkbookProtection(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel $pPHPExcel = \null)
        {
        }
        /**
         * Write calcPr
         *
         * @param 	PHPExcel_Shared_XMLWriter	$objWriter		XML Writer
         * @param	boolean						$recalcRequired	Indicate whether formulas should be recalculated before writing
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeCalcPr(\PHPExcel_Shared_XMLWriter $objWriter = \null, $recalcRequired = \TRUE)
        {
        }
        /**
         * Write sheets
         *
         * @param 	PHPExcel_Shared_XMLWriter 	$objWriter 		XML Writer
         * @param 	PHPExcel					$pPHPExcel
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeSheets(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel $pPHPExcel = \null)
        {
        }
        /**
         * Write sheet
         *
         * @param 	PHPExcel_Shared_XMLWriter 	$objWriter 		XML Writer
         * @param 	string 						$pSheetname 		Sheet name
         * @param 	int							$pSheetId	 		Sheet id
         * @param 	int							$pRelId				Relationship ID
         * @param   string                      $sheetState         Sheet state (visible, hidden, veryHidden)
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeSheet(\PHPExcel_Shared_XMLWriter $objWriter = \null, $pSheetname = '', $pSheetId = 1, $pRelId = 1, $sheetState = 'visible')
        {
        }
        /**
         * Write Defined Names
         *
         * @param 	PHPExcel_Shared_XMLWriter	$objWriter 		XML Writer
         * @param 	PHPExcel					$pPHPExcel
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeDefinedNames(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel $pPHPExcel = \null)
        {
        }
        /**
         * Write named ranges
         *
         * @param 	PHPExcel_Shared_XMLWriter	$objWriter 		XML Writer
         * @param 	PHPExcel					$pPHPExcel
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeNamedRanges(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel $pPHPExcel)
        {
        }
        /**
         * Write Defined Name for named range
         *
         * @param 	PHPExcel_Shared_XMLWriter	$objWriter 		XML Writer
         * @param 	PHPExcel_NamedRange			$pNamedRange
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeDefinedNameForNamedRange(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_NamedRange $pNamedRange)
        {
        }
        /**
         * Write Defined Name for autoFilter
         *
         * @param 	PHPExcel_Shared_XMLWriter	$objWriter 		XML Writer
         * @param 	PHPExcel_Worksheet			$pSheet
         * @param 	int							$pSheetId
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeDefinedNameForAutofilter(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Worksheet $pSheet = \null, $pSheetId = 0)
        {
        }
        /**
         * Write Defined Name for PrintTitles
         *
         * @param 	PHPExcel_Shared_XMLWriter	$objWriter 		XML Writer
         * @param 	PHPExcel_Worksheet			$pSheet
         * @param 	int							$pSheetId
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeDefinedNameForPrintTitles(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Worksheet $pSheet = \null, $pSheetId = 0)
        {
        }
        /**
         * Write Defined Name for PrintTitles
         *
         * @param 	PHPExcel_Shared_XMLWriter	$objWriter 		XML Writer
         * @param 	PHPExcel_Worksheet			$pSheet
         * @param 	int							$pSheetId
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeDefinedNameForPrintArea(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Worksheet $pSheet = \null, $pSheetId = 0)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version     1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Writer_Excel2007_RelsRibbon
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Writer_Excel2007_RelsRibbon extends \PHPExcel_Writer_Excel2007_WriterPart
    {
        /**
         * Write relationships for additional objects of custom UI (ribbon)
         *
         * @param 	PHPExcel	$pPHPExcel
         * @return 	string 		XML Output
         * @throws 	PHPExcel_Writer_Exception
         */
        public function writeRibbonRelationships(\PHPExcel $pPHPExcel = \null)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Writer_Excel2007_StringTable
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Writer_Excel2007_StringTable extends \PHPExcel_Writer_Excel2007_WriterPart
    {
        /**
         * Create worksheet stringtable
         *
         * @param 	PHPExcel_Worksheet 	$pSheet				Worksheet
         * @param 	string[] 				$pExistingTable 	Existing table to eventually merge with
         * @return 	string[] 				String table for worksheet
         * @throws 	PHPExcel_Writer_Exception
         */
        public function createStringTable($pSheet = \null, $pExistingTable = \null)
        {
        }
        /**
         * Write string table to XML format
         *
         * @param 	string[] 	$pStringTable
         * @return 	string 		XML Output
         * @throws 	PHPExcel_Writer_Exception
         */
        public function writeStringTable($pStringTable = \null)
        {
        }
        /**
         * Write Rich Text
         *
         * @param 	PHPExcel_Shared_XMLWriter	$objWriter 		XML Writer
         * @param 	PHPExcel_RichText			$pRichText		Rich text
         * @param 	string						$prefix			Optional Namespace prefix
         * @throws 	PHPExcel_Writer_Exception
         */
        public function writeRichText(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_RichText $pRichText = \null, $prefix = \NULL)
        {
        }
        /**
         * Write Rich Text
         *
         * @param 	PHPExcel_Shared_XMLWriter	$objWriter 		XML Writer
         * @param 	string|PHPExcel_RichText	$pRichText		text string or Rich text
         * @param 	string						$prefix			Optional Namespace prefix
         * @throws 	PHPExcel_Writer_Exception
         */
        public function writeRichTextForCharts(\PHPExcel_Shared_XMLWriter $objWriter = \null, $pRichText = \null, $prefix = \NULL)
        {
        }
        /**
         * Flip string table (for index searching)
         *
         * @param 	array	$stringTable	Stringtable
         * @return 	array
         */
        public function flipStringTable($stringTable = array())
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version     1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Writer_Excel2007_RelsVBA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Writer_Excel2007_RelsVBA extends \PHPExcel_Writer_Excel2007_WriterPart
    {
        /**
         * Write relationships for a signed VBA Project
         *
         * @param 	PHPExcel	$pPHPExcel
         * @return 	string 		XML Output
         * @throws 	PHPExcel_Writer_Exception
         */
        public function writeVBARelationships(\PHPExcel $pPHPExcel = \null)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package	PHPExcel_Writer_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license	http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version	1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Writer_Excel2007_Worksheet
     *
     * @category   PHPExcel
     * @package	PHPExcel_Writer_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Writer_Excel2007_Worksheet extends \PHPExcel_Writer_Excel2007_WriterPart
    {
        /**
         * Write worksheet to XML format
         *
         * @param	PHPExcel_Worksheet		$pSheet
         * @param	string[]				$pStringTable
         * @param	boolean					$includeCharts	Flag indicating if we should write charts
         * @return	string					XML Output
         * @throws	PHPExcel_Writer_Exception
         */
        public function writeWorksheet($pSheet = \null, $pStringTable = \null, $includeCharts = \FALSE)
        {
        }
        /**
         * Write SheetPr
         *
         * @param	PHPExcel_Shared_XMLWriter		$objWriter		XML Writer
         * @param	PHPExcel_Worksheet				$pSheet			Worksheet
         * @throws	PHPExcel_Writer_Exception
         */
        private function _writeSheetPr(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Worksheet $pSheet = \null)
        {
        }
        /**
         * Write Dimension
         *
         * @param	PHPExcel_Shared_XMLWriter	$objWriter		XML Writer
         * @param	PHPExcel_Worksheet			$pSheet			Worksheet
         * @throws	PHPExcel_Writer_Exception
         */
        private function _writeDimension(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Worksheet $pSheet = \null)
        {
        }
        /**
         * Write SheetViews
         *
         * @param	PHPExcel_Shared_XMLWriter			$objWriter		XML Writer
         * @param	PHPExcel_Worksheet					$pSheet			Worksheet
         * @throws	PHPExcel_Writer_Exception
         */
        private function _writeSheetViews(\PHPExcel_Shared_XMLWriter $objWriter = \NULL, \PHPExcel_Worksheet $pSheet = \NULL)
        {
        }
        /**
         * Write SheetFormatPr
         *
         * @param	PHPExcel_Shared_XMLWriter $objWriter		XML Writer
         * @param	PHPExcel_Worksheet		  $pSheet			Worksheet
         * @throws	PHPExcel_Writer_Exception
         */
        private function _writeSheetFormatPr(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Worksheet $pSheet = \null)
        {
        }
        /**
         * Write Cols
         *
         * @param	PHPExcel_Shared_XMLWriter			$objWriter		XML Writer
         * @param	PHPExcel_Worksheet					$pSheet			Worksheet
         * @throws	PHPExcel_Writer_Exception
         */
        private function _writeCols(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Worksheet $pSheet = \null)
        {
        }
        /**
         * Write SheetProtection
         *
         * @param	PHPExcel_Shared_XMLWriter			$objWriter		XML Writer
         * @param	PHPExcel_Worksheet					$pSheet			Worksheet
         * @throws	PHPExcel_Writer_Exception
         */
        private function _writeSheetProtection(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Worksheet $pSheet = \null)
        {
        }
        /**
         * Write ConditionalFormatting
         *
         * @param	PHPExcel_Shared_XMLWriter			$objWriter		XML Writer
         * @param	PHPExcel_Worksheet					$pSheet			Worksheet
         * @throws	PHPExcel_Writer_Exception
         */
        private function _writeConditionalFormatting(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Worksheet $pSheet = \null)
        {
        }
        /**
         * Write DataValidations
         *
         * @param	PHPExcel_Shared_XMLWriter			$objWriter		XML Writer
         * @param	PHPExcel_Worksheet					$pSheet			Worksheet
         * @throws	PHPExcel_Writer_Exception
         */
        private function _writeDataValidations(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Worksheet $pSheet = \null)
        {
        }
        /**
         * Write Hyperlinks
         *
         * @param	PHPExcel_Shared_XMLWriter			$objWriter		XML Writer
         * @param	PHPExcel_Worksheet					$pSheet			Worksheet
         * @throws	PHPExcel_Writer_Exception
         */
        private function _writeHyperlinks(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Worksheet $pSheet = \null)
        {
        }
        /**
         * Write ProtectedRanges
         *
         * @param	PHPExcel_Shared_XMLWriter			$objWriter		XML Writer
         * @param	PHPExcel_Worksheet					$pSheet			Worksheet
         * @throws	PHPExcel_Writer_Exception
         */
        private function _writeProtectedRanges(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Worksheet $pSheet = \null)
        {
        }
        /**
         * Write MergeCells
         *
         * @param	PHPExcel_Shared_XMLWriter			$objWriter		XML Writer
         * @param	PHPExcel_Worksheet					$pSheet			Worksheet
         * @throws	PHPExcel_Writer_Exception
         */
        private function _writeMergeCells(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Worksheet $pSheet = \null)
        {
        }
        /**
         * Write PrintOptions
         *
         * @param	PHPExcel_Shared_XMLWriter			$objWriter		XML Writer
         * @param	PHPExcel_Worksheet					$pSheet			Worksheet
         * @throws	PHPExcel_Writer_Exception
         */
        private function _writePrintOptions(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Worksheet $pSheet = \null)
        {
        }
        /**
         * Write PageMargins
         *
         * @param	PHPExcel_Shared_XMLWriter				$objWriter		XML Writer
         * @param	PHPExcel_Worksheet						$pSheet			Worksheet
         * @throws	PHPExcel_Writer_Exception
         */
        private function _writePageMargins(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Worksheet $pSheet = \null)
        {
        }
        /**
         * Write AutoFilter
         *
         * @param	PHPExcel_Shared_XMLWriter				$objWriter		XML Writer
         * @param	PHPExcel_Worksheet						$pSheet			Worksheet
         * @throws	PHPExcel_Writer_Exception
         */
        private function _writeAutoFilter(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Worksheet $pSheet = \null)
        {
        }
        /**
         * Write PageSetup
         *
         * @param	PHPExcel_Shared_XMLWriter			$objWriter		XML Writer
         * @param	PHPExcel_Worksheet					$pSheet			Worksheet
         * @throws	PHPExcel_Writer_Exception
         */
        private function _writePageSetup(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Worksheet $pSheet = \null)
        {
        }
        /**
         * Write Header / Footer
         *
         * @param	PHPExcel_Shared_XMLWriter		$objWriter		XML Writer
         * @param	PHPExcel_Worksheet				$pSheet			Worksheet
         * @throws	PHPExcel_Writer_Exception
         */
        private function _writeHeaderFooter(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Worksheet $pSheet = \null)
        {
        }
        /**
         * Write Breaks
         *
         * @param	PHPExcel_Shared_XMLWriter		$objWriter		XML Writer
         * @param	PHPExcel_Worksheet				$pSheet			Worksheet
         * @throws	PHPExcel_Writer_Exception
         */
        private function _writeBreaks(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Worksheet $pSheet = \null)
        {
        }
        /**
         * Write SheetData
         *
         * @param	PHPExcel_Shared_XMLWriter		$objWriter		XML Writer
         * @param	PHPExcel_Worksheet				$pSheet			Worksheet
         * @param	string[]						$pStringTable	String table
         * @throws	PHPExcel_Writer_Exception
         */
        private function _writeSheetData(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Worksheet $pSheet = \null, $pStringTable = \null)
        {
        }
        /**
         * Write Cell
         *
         * @param	PHPExcel_Shared_XMLWriter	$objWriter				XML Writer
         * @param	PHPExcel_Worksheet			$pSheet					Worksheet
         * @param	PHPExcel_Cell				$pCellAddress			Cell Address
         * @param	string[]					$pStringTable			String table
         * @param	string[]					$pFlippedStringTable	String table (flipped), for faster index searching
         * @throws	PHPExcel_Writer_Exception
         */
        private function _writeCell(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Worksheet $pSheet = \null, $pCellAddress = \null, $pStringTable = \null, $pFlippedStringTable = \null)
        {
        }
        /**
         * Write Drawings
         *
         * @param	PHPExcel_Shared_XMLWriter	$objWriter		XML Writer
         * @param	PHPExcel_Worksheet			$pSheet			Worksheet
         * @param	boolean						$includeCharts	Flag indicating if we should include drawing details for charts
         * @throws	PHPExcel_Writer_Exception
         */
        private function _writeDrawings(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Worksheet $pSheet = \null, $includeCharts = \FALSE)
        {
        }
        /**
         * Write LegacyDrawing
         *
         * @param	PHPExcel_Shared_XMLWriter		$objWriter		XML Writer
         * @param	PHPExcel_Worksheet				$pSheet			Worksheet
         * @throws	PHPExcel_Writer_Exception
         */
        private function _writeLegacyDrawing(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Worksheet $pSheet = \null)
        {
        }
        /**
         * Write LegacyDrawingHF
         *
         * @param	PHPExcel_Shared_XMLWriter		$objWriter		XML Writer
         * @param	PHPExcel_Worksheet				$pSheet			Worksheet
         * @throws	PHPExcel_Writer_Exception
         */
        private function _writeLegacyDrawingHF(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Worksheet $pSheet = \null)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Writer_Excel2007_ContentTypes
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Writer_Excel2007_ContentTypes extends \PHPExcel_Writer_Excel2007_WriterPart
    {
        /**
         * Write content types to XML format
         *
         * @param 	PHPExcel	$pPHPExcel
         * @param	boolean		$includeCharts	Flag indicating if we should include drawing details for charts
         * @return 	string 						XML Output
         * @throws 	PHPExcel_Writer_Exception
         */
        public function writeContentTypes(\PHPExcel $pPHPExcel = \null, $includeCharts = \FALSE)
        {
        }
        /**
         * Get image mime type
         *
         * @param 	string	$pFile	Filename
         * @return 	string	Mime Type
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _getImageMimeType($pFile = '')
        {
        }
        /**
         * Write Default content type
         *
         * @param 	PHPExcel_Shared_XMLWriter 	$objWriter 		XML Writer
         * @param 	string 						$pPartname 		Part name
         * @param 	string 						$pContentType 	Content type
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeDefaultContentType(\PHPExcel_Shared_XMLWriter $objWriter = \null, $pPartname = '', $pContentType = '')
        {
        }
        /**
         * Write Override content type
         *
         * @param 	PHPExcel_Shared_XMLWriter 	$objWriter 		XML Writer
         * @param 	string 						$pPartname 		Part name
         * @param 	string 						$pContentType 	Content type
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeOverrideContentType(\PHPExcel_Shared_XMLWriter $objWriter = \null, $pPartname = '', $pContentType = '')
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Writer_Excel2007_Comments
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Writer_Excel2007_Comments extends \PHPExcel_Writer_Excel2007_WriterPart
    {
        /**
         * Write comments to XML format
         *
         * @param 	PHPExcel_Worksheet				$pWorksheet
         * @return 	string 								XML Output
         * @throws 	PHPExcel_Writer_Exception
         */
        public function writeComments(\PHPExcel_Worksheet $pWorksheet = \null)
        {
        }
        /**
         * Write comment to XML format
         *
         * @param 	PHPExcel_Shared_XMLWriter		$objWriter 			XML Writer
         * @param	string							$pCellReference		Cell reference
         * @param 	PHPExcel_Comment				$pComment			Comment
         * @param	array							$pAuthors			Array of authors
         * @throws 	PHPExcel_Writer_Exception
         */
        public function _writeComment(\PHPExcel_Shared_XMLWriter $objWriter = \null, $pCellReference = 'A1', \PHPExcel_Comment $pComment = \null, $pAuthors = \null)
        {
        }
        /**
         * Write VML comments to XML format
         *
         * @param 	PHPExcel_Worksheet				$pWorksheet
         * @return 	string 								XML Output
         * @throws 	PHPExcel_Writer_Exception
         */
        public function writeVMLComments(\PHPExcel_Worksheet $pWorksheet = \null)
        {
        }
        /**
         * Write VML comment to XML format
         *
         * @param 	PHPExcel_Shared_XMLWriter		$objWriter 			XML Writer
         * @param	string							$pCellReference		Cell reference
         * @param 	PHPExcel_Comment				$pComment			Comment
         * @throws 	PHPExcel_Writer_Exception
         */
        public function _writeVMLComment(\PHPExcel_Shared_XMLWriter $objWriter = \null, $pCellReference = 'A1', \PHPExcel_Comment $pComment = \null)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Writer_Excel2007_Rels
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Writer_Excel2007_Rels extends \PHPExcel_Writer_Excel2007_WriterPart
    {
        /**
         * Write relationships to XML format
         *
         * @param 	PHPExcel	$pPHPExcel
         * @return 	string 		XML Output
         * @throws 	PHPExcel_Writer_Exception
         */
        public function writeRelationships(\PHPExcel $pPHPExcel = \null)
        {
        }
        /**
         * Write workbook relationships to XML format
         *
         * @param 	PHPExcel	$pPHPExcel
         * @return 	string 		XML Output
         * @throws 	PHPExcel_Writer_Exception
         */
        public function writeWorkbookRelationships(\PHPExcel $pPHPExcel = \null)
        {
        }
        /**
         * Write worksheet relationships to XML format
         *
         * Numbering is as follows:
         * 	rId1 				- Drawings
         *  rId_hyperlink_x 	- Hyperlinks
         *
         * @param 	PHPExcel_Worksheet	$pWorksheet
         * @param 	int					$pWorksheetId
         * @param	boolean				$includeCharts	Flag indicating if we should write charts
         * @return 	string 				XML Output
         * @throws 	PHPExcel_Writer_Exception
         */
        public function writeWorksheetRelationships(\PHPExcel_Worksheet $pWorksheet = \null, $pWorksheetId = 1, $includeCharts = \FALSE)
        {
        }
        /**
         * Write drawing relationships to XML format
         *
         * @param 	PHPExcel_Worksheet	$pWorksheet
         * @param	int					&$chartRef		Chart ID
         * @param	boolean				$includeCharts	Flag indicating if we should write charts
         * @return 	string 				XML Output
         * @throws 	PHPExcel_Writer_Exception
         */
        public function writeDrawingRelationships(\PHPExcel_Worksheet $pWorksheet = \null, &$chartRef, $includeCharts = \FALSE)
        {
        }
        /**
         * Write header/footer drawing relationships to XML format
         *
         * @param 	PHPExcel_Worksheet			$pWorksheet
         * @return 	string 						XML Output
         * @throws 	PHPExcel_Writer_Exception
         */
        public function writeHeaderFooterDrawingRelationships(\PHPExcel_Worksheet $pWorksheet = \null)
        {
        }
        /**
         * Write Override content type
         *
         * @param 	PHPExcel_Shared_XMLWriter 	$objWriter 		XML Writer
         * @param 	int							$pId			Relationship ID. rId will be prepended!
         * @param 	string						$pType			Relationship type
         * @param 	string 						$pTarget		Relationship target
         * @param 	string 						$pTargetMode	Relationship target mode
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeRelationship(\PHPExcel_Shared_XMLWriter $objWriter = \null, $pId = 1, $pType = '', $pTarget = '', $pTargetMode = '')
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Writer_Excel2007_Theme
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Writer_Excel2007_Theme extends \PHPExcel_Writer_Excel2007_WriterPart
    {
        /**
         * Map of Major fonts to write
         * @static	array of string
         *
         */
        private static $_majorFonts = array('Jpan' => ' ', 'Hang' => ' ', 'Hans' => '', 'Hant' => '', 'Arab' => 'Times New Roman', 'Hebr' => 'Times New Roman', 'Thai' => 'Tahoma', 'Ethi' => 'Nyala', 'Beng' => 'Vrinda', 'Gujr' => 'Shruti', 'Khmr' => 'MoolBoran', 'Knda' => 'Tunga', 'Guru' => 'Raavi', 'Cans' => 'Euphemia', 'Cher' => 'Plantagenet Cherokee', 'Yiii' => 'Microsoft Yi Baiti', 'Tibt' => 'Microsoft Himalaya', 'Thaa' => 'MV Boli', 'Deva' => 'Mangal', 'Telu' => 'Gautami', 'Taml' => 'Latha', 'Syrc' => 'Estrangelo Edessa', 'Orya' => 'Kalinga', 'Mlym' => 'Kartika', 'Laoo' => 'DokChampa', 'Sinh' => 'Iskoola Pota', 'Mong' => 'Mongolian Baiti', 'Viet' => 'Times New Roman', 'Uigh' => 'Microsoft Uighur', 'Geor' => 'Sylfaen');
        /**
         * Map of Minor fonts to write
         * @static	array of string
         *
         */
        private static $_minorFonts = array('Jpan' => ' ', 'Hang' => ' ', 'Hans' => '', 'Hant' => '', 'Arab' => 'Arial', 'Hebr' => 'Arial', 'Thai' => 'Tahoma', 'Ethi' => 'Nyala', 'Beng' => 'Vrinda', 'Gujr' => 'Shruti', 'Khmr' => 'DaunPenh', 'Knda' => 'Tunga', 'Guru' => 'Raavi', 'Cans' => 'Euphemia', 'Cher' => 'Plantagenet Cherokee', 'Yiii' => 'Microsoft Yi Baiti', 'Tibt' => 'Microsoft Himalaya', 'Thaa' => 'MV Boli', 'Deva' => 'Mangal', 'Telu' => 'Gautami', 'Taml' => 'Latha', 'Syrc' => 'Estrangelo Edessa', 'Orya' => 'Kalinga', 'Mlym' => 'Kartika', 'Laoo' => 'DokChampa', 'Sinh' => 'Iskoola Pota', 'Mong' => 'Mongolian Baiti', 'Viet' => 'Arial', 'Uigh' => 'Microsoft Uighur', 'Geor' => 'Sylfaen');
        /**
         * Map of core colours
         * @static	array of string
         *
         */
        private static $_colourScheme = array('dk2' => '1F497D', 'lt2' => 'EEECE1', 'accent1' => '4F81BD', 'accent2' => 'C0504D', 'accent3' => '9BBB59', 'accent4' => '8064A2', 'accent5' => '4BACC6', 'accent6' => 'F79646', 'hlink' => '0000FF', 'folHlink' => '800080');
        /**
         * Write theme to XML format
         *
         * @param 	PHPExcel	$pPHPExcel
         * @return 	string 		XML Output
         * @throws 	PHPExcel_Writer_Exception
         */
        public function writeTheme(\PHPExcel $pPHPExcel = \null)
        {
        }
        /**
         * Write fonts to XML format
         *
         * @param 	PHPExcel_Shared_XMLWriter	$objWriter
         * @param 	string						$latinFont
         * @param 	array of string				$fontSet
         * @return 	string 						XML Output
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeFonts($objWriter, $latinFont, $fontSet)
        {
        }
        /**
         * Write colour scheme to XML format
         *
         * @param 	PHPExcel_Shared_XMLWriter	$objWriter
         * @return 	string 						XML Output
         * @throws 	PHPExcel_Writer_Exception
         */
        private function _writeColourScheme($objWriter)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Writer_Excel2007_Drawing
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Writer_Excel2007_Drawing extends \PHPExcel_Writer_Excel2007_WriterPart
    {
        /**
         * Write drawings to XML format
         *
         * @param 	PHPExcel_Worksheet	$pWorksheet
         * @param	int					&$chartRef		Chart ID
         * @param	boolean				$includeCharts	Flag indicating if we should include drawing details for charts
         * @return 	string 				XML Output
         * @throws 	PHPExcel_Writer_Exception
         */
        public function writeDrawings(\PHPExcel_Worksheet $pWorksheet = \null, &$chartRef, $includeCharts = \FALSE)
        {
        }
        /**
         * Write drawings to XML format
         *
         * @param 	PHPExcel_Shared_XMLWriter	$objWriter 		XML Writer
         * @param 	PHPExcel_Chart				$pChart
         * @param 	int							$pRelationId
         * @throws 	PHPExcel_Writer_Exception
         */
        public function _writeChart(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Chart $pChart = \null, $pRelationId = -1)
        {
        }
        /**
         * Write drawings to XML format
         *
         * @param 	PHPExcel_Shared_XMLWriter			$objWriter 		XML Writer
         * @param 	PHPExcel_Worksheet_BaseDrawing		$pDrawing
         * @param 	int									$pRelationId
         * @throws 	PHPExcel_Writer_Exception
         */
        public function _writeDrawing(\PHPExcel_Shared_XMLWriter $objWriter = \null, \PHPExcel_Worksheet_BaseDrawing $pDrawing = \null, $pRelationId = -1)
        {
        }
        /**
         * Write VML header/footer images to XML format
         *
         * @param 	PHPExcel_Worksheet				$pWorksheet
         * @return 	string 								XML Output
         * @throws 	PHPExcel_Writer_Exception
         */
        public function writeVMLHeaderFooterImages(\PHPExcel_Worksheet $pWorksheet = \null)
        {
        }
        /**
         * Write VML comment to XML format
         *
         * @param 	PHPExcel_Shared_XMLWriter		$objWriter 			XML Writer
         * @param	string							$pReference			Reference
         * @param 	PHPExcel_Worksheet_HeaderFooterDrawing	$pImage		Image
         * @throws 	PHPExcel_Writer_Exception
         */
        public function _writeVMLHeaderFooterImage(\PHPExcel_Shared_XMLWriter $objWriter = \null, $pReference = '', \PHPExcel_Worksheet_HeaderFooterDrawing $pImage = \null)
        {
        }
        /**
         * Get an array of all drawings
         *
         * @param 	PHPExcel							$pPHPExcel
         * @return 	PHPExcel_Worksheet_Drawing[]		All drawings in PHPExcel
         * @throws 	PHPExcel_Writer_Exception
         */
        public function allDrawings(\PHPExcel $pPHPExcel = \null)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Writer_Excel2007_DocProps
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Writer_Excel2007_DocProps extends \PHPExcel_Writer_Excel2007_WriterPart
    {
        /**
         * Write docProps/app.xml to XML format
         *
         * @param 	PHPExcel	$pPHPExcel
         * @return 	string 		XML Output
         * @throws 	PHPExcel_Writer_Exception
         */
        public function writeDocPropsApp(\PHPExcel $pPHPExcel = \null)
        {
        }
        /**
         * Write docProps/core.xml to XML format
         *
         * @param 	PHPExcel	$pPHPExcel
         * @return 	string 		XML Output
         * @throws 	PHPExcel_Writer_Exception
         */
        public function writeDocPropsCore(\PHPExcel $pPHPExcel = \null)
        {
        }
        /**
         * Write docProps/custom.xml to XML format
         *
         * @param 	PHPExcel	$pPHPExcel
         * @return 	string 		XML Output
         * @throws 	PHPExcel_Writer_Exception
         */
        public function writeDocPropsCustom(\PHPExcel $pPHPExcel = \null)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package	PHPExcel_Writer_HTML
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license	http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version	1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Writer_HTML
     *
     * @category   PHPExcel
     * @package	PHPExcel_Writer_HTML
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Writer_HTML extends \PHPExcel_Writer_Abstract implements \PHPExcel_Writer_IWriter
    {
        /**
         * PHPExcel object
         *
         * @var PHPExcel
         */
        protected $_phpExcel;
        /**
         * Sheet index to write
         *
         * @var int
         */
        private $_sheetIndex = 0;
        /**
         * Images root
         *
         * @var string
         */
        private $_imagesRoot = '.';
        /**
         * embed images, or link to images
         *
         * @var boolean
         */
        private $_embedImages = \FALSE;
        /**
         * Use inline CSS?
         *
         * @var boolean
         */
        private $_useInlineCss = \false;
        /**
         * Array of CSS styles
         *
         * @var array
         */
        private $_cssStyles = \null;
        /**
         * Array of column widths in points
         *
         * @var array
         */
        private $_columnWidths = \null;
        /**
         * Default font
         *
         * @var PHPExcel_Style_Font
         */
        private $_defaultFont;
        /**
         * Flag whether spans have been calculated
         *
         * @var boolean
         */
        private $_spansAreCalculated = \false;
        /**
         * Excel cells that should not be written as HTML cells
         *
         * @var array
         */
        private $_isSpannedCell = array();
        /**
         * Excel cells that are upper-left corner in a cell merge
         *
         * @var array
         */
        private $_isBaseCell = array();
        /**
         * Excel rows that should not be written as HTML rows
         *
         * @var array
         */
        private $_isSpannedRow = array();
        /**
         * Is the current writer creating PDF?
         *
         * @var boolean
         */
        protected $_isPdf = \false;
        /**
         * Generate the Navigation block
         *
         * @var boolean
         */
        private $_generateSheetNavigationBlock = \true;
        /**
         * Create a new PHPExcel_Writer_HTML
         *
         * @param	PHPExcel	$phpExcel	PHPExcel object
         */
        public function __construct(\PHPExcel $phpExcel)
        {
        }
        /**
         * Save PHPExcel to file
         *
         * @param	string		$pFilename
         * @throws	PHPExcel_Writer_Exception
         */
        public function save($pFilename = \null)
        {
        }
        /**
         * Map VAlign
         *
         * @param	string		$vAlign		Vertical alignment
         * @return string
         */
        private function _mapVAlign($vAlign)
        {
        }
        /**
         * Map HAlign
         *
         * @param	string		$hAlign		Horizontal alignment
         * @return string|false
         */
        private function _mapHAlign($hAlign)
        {
        }
        /**
         * Map border style
         *
         * @param	int		$borderStyle		Sheet index
         * @return	string
         */
        private function _mapBorderStyle($borderStyle)
        {
        }
        /**
         * Get sheet index
         *
         * @return int
         */
        public function getSheetIndex()
        {
        }
        /**
         * Set sheet index
         *
         * @param	int		$pValue		Sheet index
         * @return PHPExcel_Writer_HTML
         */
        public function setSheetIndex($pValue = 0)
        {
        }
        /**
         * Get sheet index
         *
         * @return boolean
         */
        public function getGenerateSheetNavigationBlock()
        {
        }
        /**
         * Set sheet index
         *
         * @param	boolean		$pValue		Flag indicating whether the sheet navigation block should be generated or not
         * @return PHPExcel_Writer_HTML
         */
        public function setGenerateSheetNavigationBlock($pValue = \true)
        {
        }
        /**
         * Write all sheets (resets sheetIndex to NULL)
         */
        public function writeAllSheets()
        {
        }
        /**
         * Generate HTML header
         *
         * @param	boolean		$pIncludeStyles		Include styles?
         * @return	string
         * @throws PHPExcel_Writer_Exception
         */
        public function generateHTMLHeader($pIncludeStyles = \false)
        {
        }
        /**
         * Generate sheet data
         *
         * @return	string
         * @throws PHPExcel_Writer_Exception
         */
        public function generateSheetData()
        {
        }
        /**
         * Generate sheet tabs
         *
         * @return	string
         * @throws PHPExcel_Writer_Exception
         */
        public function generateNavigation()
        {
        }
        private function _extendRowsForChartsAndImages(\PHPExcel_Worksheet $pSheet, $row)
        {
        }
        /**
         * Generate image tag in cell
         *
         * @param	PHPExcel_Worksheet	$pSheet			PHPExcel_Worksheet
         * @param	string				$coordinates	Cell coordinates
         * @return	string
         * @throws	PHPExcel_Writer_Exception
         */
        private function _writeImageInCell(\PHPExcel_Worksheet $pSheet, $coordinates)
        {
        }
        /**
         * Generate chart tag in cell
         *
         * @param	PHPExcel_Worksheet	$pSheet			PHPExcel_Worksheet
         * @param	string				$coordinates	Cell coordinates
         * @return	string
         * @throws	PHPExcel_Writer_Exception
         */
        private function _writeChartInCell(\PHPExcel_Worksheet $pSheet, $coordinates)
        {
        }
        /**
         * Generate CSS styles
         *
         * @param	boolean	$generateSurroundingHTML	Generate surrounding HTML tags? (<style> and </style>)
         * @return	string
         * @throws	PHPExcel_Writer_Exception
         */
        public function generateStyles($generateSurroundingHTML = \true)
        {
        }
        /**
         * Build CSS styles
         *
         * @param	boolean	$generateSurroundingHTML	Generate surrounding HTML style? (html { })
         * @return	array
         * @throws	PHPExcel_Writer_Exception
         */
        public function buildCSS($generateSurroundingHTML = \true)
        {
        }
        /**
         * Create CSS style
         *
         * @param	PHPExcel_Style		$pStyle			PHPExcel_Style
         * @return	array
         */
        private function _createCSSStyle(\PHPExcel_Style $pStyle)
        {
        }
        /**
         * Create CSS style (PHPExcel_Style_Alignment)
         *
         * @param	PHPExcel_Style_Alignment		$pStyle			PHPExcel_Style_Alignment
         * @return	array
         */
        private function _createCSSStyleAlignment(\PHPExcel_Style_Alignment $pStyle)
        {
        }
        /**
         * Create CSS style (PHPExcel_Style_Font)
         *
         * @param	PHPExcel_Style_Font		$pStyle			PHPExcel_Style_Font
         * @return	array
         */
        private function _createCSSStyleFont(\PHPExcel_Style_Font $pStyle)
        {
        }
        /**
         * Create CSS style (PHPExcel_Style_Borders)
         *
         * @param	PHPExcel_Style_Borders		$pStyle			PHPExcel_Style_Borders
         * @return	array
         */
        private function _createCSSStyleBorders(\PHPExcel_Style_Borders $pStyle)
        {
        }
        /**
         * Create CSS style (PHPExcel_Style_Border)
         *
         * @param	PHPExcel_Style_Border		$pStyle			PHPExcel_Style_Border
         * @return	string
         */
        private function _createCSSStyleBorder(\PHPExcel_Style_Border $pStyle)
        {
        }
        /**
         * Create CSS style (PHPExcel_Style_Fill)
         *
         * @param	PHPExcel_Style_Fill		$pStyle			PHPExcel_Style_Fill
         * @return	array
         */
        private function _createCSSStyleFill(\PHPExcel_Style_Fill $pStyle)
        {
        }
        /**
         * Generate HTML footer
         */
        public function generateHTMLFooter()
        {
        }
        /**
         * Generate table header
         *
         * @param	PHPExcel_Worksheet	$pSheet		The worksheet for the table we are writing
         * @return	string
         * @throws	PHPExcel_Writer_Exception
         */
        private function _generateTableHeader($pSheet)
        {
        }
        /**
         * Generate table footer
         *
         * @throws	PHPExcel_Writer_Exception
         */
        private function _generateTableFooter()
        {
        }
        /**
         * Generate row
         *
         * @param	PHPExcel_Worksheet	$pSheet			PHPExcel_Worksheet
         * @param	array				$pValues		Array containing cells in a row
         * @param	int					$pRow			Row number (0-based)
         * @return	string
         * @throws	PHPExcel_Writer_Exception
         */
        private function _generateRow(\PHPExcel_Worksheet $pSheet, $pValues = \null, $pRow = 0)
        {
        }
        /**
         * Takes array where of CSS properties / values and converts to CSS string
         *
         * @param array
         * @return string
         */
        private function _assembleCSS($pValue = array())
        {
        }
        /**
         * Get images root
         *
         * @return string
         */
        public function getImagesRoot()
        {
        }
        /**
         * Set images root
         *
         * @param string $pValue
         * @return PHPExcel_Writer_HTML
         */
        public function setImagesRoot($pValue = '.')
        {
        }
        /**
         * Get embed images
         *
         * @return boolean
         */
        public function getEmbedImages()
        {
        }
        /**
         * Set embed images
         *
         * @param boolean $pValue
         * @return PHPExcel_Writer_HTML
         */
        public function setEmbedImages($pValue = '.')
        {
        }
        /**
         * Get use inline CSS?
         *
         * @return boolean
         */
        public function getUseInlineCss()
        {
        }
        /**
         * Set use inline CSS?
         *
         * @param boolean $pValue
         * @return PHPExcel_Writer_HTML
         */
        public function setUseInlineCss($pValue = \false)
        {
        }
        /**
         * Add color to formatted string as inline style
         *
         * @param string $pValue Plain formatted value without color
         * @param string $pFormat Format code
         * @return string
         */
        public function formatColor($pValue, $pFormat)
        {
        }
        /**
         * Calculate information about HTML colspan and rowspan which is not always the same as Excel's
         */
        private function _calculateSpans()
        {
        }
        private function _setMargins(\PHPExcel_Worksheet $pSheet)
        {
        }
    }
    /**
     *  PHPExcel
     *
     *  Copyright (c) 2006 - 2014 PHPExcel
     *
     *  This library is free software; you can redistribute it and/or
     *  modify it under the terms of the GNU Lesser General Public
     *  License as published by the Free Software Foundation; either
     *  version 2.1 of the License, or (at your option) any later version.
     *
     *  This library is distributed in the hope that it will be useful,
     *  but WITHOUT ANY WARRANTY; without even the implied warranty of
     *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     *  Lesser General Public License for more details.
     *
     *  You should have received a copy of the GNU Lesser General Public
     *  License along with this library; if not, write to the Free Software
     *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     *  @category    PHPExcel
     *  @package     PHPExcel_Writer_PDF
     *  @copyright   Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     *  @license     http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt    LGPL
     *  @version     1.8.0, 2014-03-02
     */
    /**
     *  PHPExcel_Writer_PDF_Core
     *
     *  @category    PHPExcel
     *  @package     PHPExcel_Writer_PDF
     *  @copyright   Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    abstract class PHPExcel_Writer_PDF_Core extends \PHPExcel_Writer_HTML
    {
        /**
         * Temporary storage directory
         *
         * @var string
         */
        protected $_tempDir = '';
        /**
         * Font
         *
         * @var string
         */
        protected $_font = 'freesans';
        /**
         * Orientation (Over-ride)
         *
         * @var string
         */
        protected $_orientation = \NULL;
        /**
         * Paper size (Over-ride)
         *
         * @var int
         */
        protected $_paperSize = \NULL;
        /**
         * Temporary storage for Save Array Return type
         *
         * @var string
         */
        private $_saveArrayReturnType;
        /**
         * Paper Sizes xRef List
         *
         * @var array
         */
        protected static $_paperSizes = array(
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_LETTER => 'LETTER',
            //    (8.5 in. by 11 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_LETTER_SMALL => 'LETTER',
            //    (8.5 in. by 11 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_TABLOID => array(792.0, 1224.0),
            //    (11 in. by 17 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_LEDGER => array(1224.0, 792.0),
            //    (17 in. by 11 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_LEGAL => 'LEGAL',
            //    (8.5 in. by 14 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_STATEMENT => array(396.0, 612.0),
            //    (5.5 in. by 8.5 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_EXECUTIVE => 'EXECUTIVE',
            //    (7.25 in. by 10.5 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_A3 => 'A3',
            //    (297 mm by 420 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_A4 => 'A4',
            //    (210 mm by 297 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_A4_SMALL => 'A4',
            //    (210 mm by 297 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_A5 => 'A5',
            //    (148 mm by 210 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_B4 => 'B4',
            //    (250 mm by 353 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_B5 => 'B5',
            //    (176 mm by 250 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_FOLIO => 'FOLIO',
            //    (8.5 in. by 13 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_QUARTO => array(609.45, 779.53),
            //    (215 mm by 275 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_STANDARD_1 => array(720.0, 1008.0),
            //    (10 in. by 14 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_STANDARD_2 => array(792.0, 1224.0),
            //    (11 in. by 17 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_NOTE => 'LETTER',
            //    (8.5 in. by 11 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_NO9_ENVELOPE => array(279.0, 639.0),
            //    (3.875 in. by 8.875 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_NO10_ENVELOPE => array(297.0, 684.0),
            //    (4.125 in. by 9.5 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_NO11_ENVELOPE => array(324.0, 747.0),
            //    (4.5 in. by 10.375 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_NO12_ENVELOPE => array(342.0, 792.0),
            //    (4.75 in. by 11 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_NO14_ENVELOPE => array(360.0, 828.0),
            //    (5 in. by 11.5 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_C => array(1224.0, 1584.0),
            //    (17 in. by 22 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_D => array(1584.0, 2448.0),
            //    (22 in. by 34 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_E => array(2448.0, 3168.0),
            //    (34 in. by 44 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_DL_ENVELOPE => array(311.81, 623.62),
            //    (110 mm by 220 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_C5_ENVELOPE => 'C5',
            //    (162 mm by 229 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_C3_ENVELOPE => 'C3',
            //    (324 mm by 458 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_C4_ENVELOPE => 'C4',
            //    (229 mm by 324 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_C6_ENVELOPE => 'C6',
            //    (114 mm by 162 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_C65_ENVELOPE => array(323.15, 649.13),
            //    (114 mm by 229 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_B4_ENVELOPE => 'B4',
            //    (250 mm by 353 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_B5_ENVELOPE => 'B5',
            //    (176 mm by 250 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_B6_ENVELOPE => array(498.9, 354.33),
            //    (176 mm by 125 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_ITALY_ENVELOPE => array(311.81, 651.97),
            //    (110 mm by 230 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_MONARCH_ENVELOPE => array(279.0, 540.0),
            //    (3.875 in. by 7.5 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_6_3_4_ENVELOPE => array(261.0, 468.0),
            //    (3.625 in. by 6.5 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_US_STANDARD_FANFOLD => array(1071.0, 792.0),
            //    (14.875 in. by 11 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_GERMAN_STANDARD_FANFOLD => array(612.0, 864.0),
            //    (8.5 in. by 12 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_GERMAN_LEGAL_FANFOLD => 'FOLIO',
            //    (8.5 in. by 13 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_ISO_B4 => 'B4',
            //    (250 mm by 353 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_JAPANESE_DOUBLE_POSTCARD => array(566.9299999999999, 419.53),
            //    (200 mm by 148 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_STANDARD_PAPER_1 => array(648.0, 792.0),
            //    (9 in. by 11 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_STANDARD_PAPER_2 => array(720.0, 792.0),
            //    (10 in. by 11 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_STANDARD_PAPER_3 => array(1080.0, 792.0),
            //    (15 in. by 11 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_INVITE_ENVELOPE => array(623.62, 623.62),
            //    (220 mm by 220 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_LETTER_EXTRA_PAPER => array(667.8, 864.0),
            //    (9.275 in. by 12 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_LEGAL_EXTRA_PAPER => array(667.8, 1080.0),
            //    (9.275 in. by 15 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_TABLOID_EXTRA_PAPER => array(841.6799999999999, 1296.0),
            //    (11.69 in. by 18 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_A4_EXTRA_PAPER => array(668.98, 912.76),
            //    (236 mm by 322 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_LETTER_TRANSVERSE_PAPER => array(595.8, 792.0),
            //    (8.275 in. by 11 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_A4_TRANSVERSE_PAPER => 'A4',
            //    (210 mm by 297 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_LETTER_EXTRA_TRANSVERSE_PAPER => array(667.8, 864.0),
            //    (9.275 in. by 12 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_SUPERA_SUPERA_A4_PAPER => array(643.46, 1009.13),
            //    (227 mm by 356 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_SUPERB_SUPERB_A3_PAPER => array(864.5700000000001, 1380.47),
            //    (305 mm by 487 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_LETTER_PLUS_PAPER => array(612.0, 913.6799999999999),
            //    (8.5 in. by 12.69 in.)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_A4_PLUS_PAPER => array(595.28, 935.4299999999999),
            //    (210 mm by 330 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_A5_TRANSVERSE_PAPER => 'A5',
            //    (148 mm by 210 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_JIS_B5_TRANSVERSE_PAPER => array(515.91, 728.5),
            //    (182 mm by 257 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_A3_EXTRA_PAPER => array(912.76, 1261.42),
            //    (322 mm by 445 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_A5_EXTRA_PAPER => array(493.23, 666.14),
            //    (174 mm by 235 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_ISO_B5_EXTRA_PAPER => array(569.76, 782.36),
            //    (201 mm by 276 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_A2_PAPER => 'A2',
            //    (420 mm by 594 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_A3_TRANSVERSE_PAPER => 'A3',
            //    (297 mm by 420 mm)
            \PHPExcel_Worksheet_PageSetup::PAPERSIZE_A3_EXTRA_TRANSVERSE_PAPER => array(912.76, 1261.42),
        );
        /**
         *  Create a new PHPExcel_Writer_PDF
         *
         *  @param     PHPExcel    $phpExcel    PHPExcel object
         */
        public function __construct(\PHPExcel $phpExcel)
        {
        }
        /**
         *  Get Font
         *
         *  @return string
         */
        public function getFont()
        {
        }
        /**
         *  Set font. Examples:
         *      'arialunicid0-chinese-simplified'
         *      'arialunicid0-chinese-traditional'
         *      'arialunicid0-korean'
         *      'arialunicid0-japanese'
         *
         *  @param    string    $fontName
         */
        public function setFont($fontName)
        {
        }
        /**
         *  Get Paper Size
         *
         *  @return int
         */
        public function getPaperSize()
        {
        }
        /**
         *  Set Paper Size
         *
         *  @param  string  $pValue Paper size
         *  @return PHPExcel_Writer_PDF
         */
        public function setPaperSize($pValue = \PHPExcel_Worksheet_PageSetup::PAPERSIZE_LETTER)
        {
        }
        /**
         *  Get Orientation
         *
         *  @return string
         */
        public function getOrientation()
        {
        }
        /**
         *  Set Orientation
         *
         *  @param string $pValue  Page orientation
         *  @return PHPExcel_Writer_PDF
         */
        public function setOrientation($pValue = \PHPExcel_Worksheet_PageSetup::ORIENTATION_DEFAULT)
        {
        }
        /**
         *  Get temporary storage directory
         *
         *  @return string
         */
        public function getTempDir()
        {
        }
        /**
         *  Set temporary storage directory
         *
         *  @param     string        $pValue        Temporary storage directory
         *  @throws    PHPExcel_Writer_Exception    when directory does not exist
         *  @return    PHPExcel_Writer_PDF
         */
        public function setTempDir($pValue = '')
        {
        }
        /**
         *  Save PHPExcel to PDF file, pre-save
         *
         *  @param     string     $pFilename   Name of the file to save as
         *  @throws    PHPExcel_Writer_Exception
         */
        protected function prepareForSave($pFilename = \NULL)
        {
        }
        /**
         *  Save PHPExcel to PDF file, post-save
         *
         *  @param     resource      $fileHandle
         *  @throws    PHPExcel_Writer_Exception
         */
        protected function restoreStateAfterSave($fileHandle)
        {
        }
    }
    /**
     *  PHPExcel_Writer_PDF_mPDF
     *
     *  @category    PHPExcel
     *  @package     PHPExcel_Writer_PDF
     *  @copyright   Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Writer_PDF_mPDF extends \PHPExcel_Writer_PDF_Core implements \PHPExcel_Writer_IWriter
    {
        /**
         *  Create a new PHPExcel_Writer_PDF
         *
         *  @param  PHPExcel  $phpExcel  PHPExcel object
         */
        public function __construct(\PHPExcel $phpExcel)
        {
        }
        /**
         *  Save PHPExcel to file
         *
         *  @param     string     $pFilename   Name of the file to save as
         *  @throws    PHPExcel_Writer_Exception
         */
        public function save($pFilename = \NULL)
        {
        }
    }
    /**
     *  PHPExcel_Writer_PDF_DomPDF
     *
     *  @category    PHPExcel
     *  @package     PHPExcel_Writer_PDF
     *  @copyright   Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Writer_PDF_DomPDF extends \PHPExcel_Writer_PDF_Core implements \PHPExcel_Writer_IWriter
    {
        /**
         *  Create a new PHPExcel_Writer_PDF
         *
         *  @param   PHPExcel    $phpExcel    PHPExcel object
         */
        public function __construct(\PHPExcel $phpExcel)
        {
        }
        /**
         *  Save PHPExcel to file
         *
         *  @param   string     $pFilename   Name of the file to save as
         *  @throws  PHPExcel_Writer_Exception
         */
        public function save($pFilename = \NULL)
        {
        }
    }
    /**
     *  PHPExcel_Writer_PDF_tcPDF
     *
     *  @category    PHPExcel
     *  @package     PHPExcel_Writer_PDF
     *  @copyright   Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Writer_PDF_tcPDF extends \PHPExcel_Writer_PDF_Core implements \PHPExcel_Writer_IWriter
    {
        /**
         *  Create a new PHPExcel_Writer_PDF
         *
         *  @param  PHPExcel  $phpExcel  PHPExcel object
         */
        public function __construct(\PHPExcel $phpExcel)
        {
        }
        /**
         *  Save PHPExcel to file
         *
         *  @param     string     $pFilename   Name of the file to save as
         *  @throws    PHPExcel_Writer_Exception
         */
        public function save($pFilename = \NULL)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package	PHPExcel_Writer_CSV
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license	http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version	1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Writer_CSV
     *
     * @category   PHPExcel
     * @package	PHPExcel_Writer_CSV
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Writer_CSV extends \PHPExcel_Writer_Abstract implements \PHPExcel_Writer_IWriter
    {
        /**
         * PHPExcel object
         *
         * @var PHPExcel
         */
        private $_phpExcel;
        /**
         * Delimiter
         *
         * @var string
         */
        private $_delimiter = ',';
        /**
         * Enclosure
         *
         * @var string
         */
        private $_enclosure = '"';
        /**
         * Line ending
         *
         * @var string
         */
        private $_lineEnding = \PHP_EOL;
        /**
         * Sheet index to write
         *
         * @var int
         */
        private $_sheetIndex = 0;
        /**
         * Whether to write a BOM (for UTF8).
         *
         * @var boolean
         */
        private $_useBOM = \false;
        /**
         * Whether to write a fully Excel compatible CSV file.
         *
         * @var boolean
         */
        private $_excelCompatibility = \false;
        /**
         * Create a new PHPExcel_Writer_CSV
         *
         * @param	PHPExcel	$phpExcel	PHPExcel object
         */
        public function __construct(\PHPExcel $phpExcel)
        {
        }
        /**
         * Save PHPExcel to file
         *
         * @param	string		$pFilename
         * @throws	PHPExcel_Writer_Exception
         */
        public function save($pFilename = \null)
        {
        }
        /**
         * Get delimiter
         *
         * @return string
         */
        public function getDelimiter()
        {
        }
        /**
         * Set delimiter
         *
         * @param	string	$pValue		Delimiter, defaults to ,
         * @return PHPExcel_Writer_CSV
         */
        public function setDelimiter($pValue = ',')
        {
        }
        /**
         * Get enclosure
         *
         * @return string
         */
        public function getEnclosure()
        {
        }
        /**
         * Set enclosure
         *
         * @param	string	$pValue		Enclosure, defaults to "
         * @return PHPExcel_Writer_CSV
         */
        public function setEnclosure($pValue = '"')
        {
        }
        /**
         * Get line ending
         *
         * @return string
         */
        public function getLineEnding()
        {
        }
        /**
         * Set line ending
         *
         * @param	string	$pValue		Line ending, defaults to OS line ending (PHP_EOL)
         * @return PHPExcel_Writer_CSV
         */
        public function setLineEnding($pValue = \PHP_EOL)
        {
        }
        /**
         * Get whether BOM should be used
         *
         * @return boolean
         */
        public function getUseBOM()
        {
        }
        /**
         * Set whether BOM should be used
         *
         * @param	boolean	$pValue		Use UTF-8 byte-order mark? Defaults to false
         * @return PHPExcel_Writer_CSV
         */
        public function setUseBOM($pValue = \false)
        {
        }
        /**
         * Get whether the file should be saved with full Excel Compatibility
         *
         * @return boolean
         */
        public function getExcelCompatibility()
        {
        }
        /**
         * Set whether the file should be saved with full Excel Compatibility
         *
         * @param	boolean	$pValue		Set the file to be written as a fully Excel compatible csv file
         *								Note that this overrides other settings such as useBOM, enclosure and delimiter
         * @return PHPExcel_Writer_CSV
         */
        public function setExcelCompatibility($pValue = \false)
        {
        }
        /**
         * Get sheet index
         *
         * @return int
         */
        public function getSheetIndex()
        {
        }
        /**
         * Set sheet index
         *
         * @param	int		$pValue		Sheet index
         * @return PHPExcel_Writer_CSV
         */
        public function setSheetIndex($pValue = 0)
        {
        }
        /**
         * Write line to CSV file
         *
         * @param	mixed	$pFileHandle	PHP filehandle
         * @param	array	$pValues		Array containing values in a row
         * @throws	PHPExcel_Writer_Exception
         */
        private function _writeLine($pFileHandle = \null, $pValues = \null)
        {
        }
    }
    /**
     *  PHPExcel
     *
     *  Copyright (c) 2006 - 2014 PHPExcel
     *
     *  This library is free software; you can redistribute it and/or
     *  modify it under the terms of the GNU Lesser General Public
     *  License as published by the Free Software Foundation; either
     *  version 2.1 of the License, or (at your option) any later version.
     *
     *  This library is distributed in the hope that it will be useful,
     *  but WITHOUT ANY WARRANTY; without even the implied warranty of
     *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     *  Lesser General Public License for more details.
     *
     *  You should have received a copy of the GNU Lesser General Public
     *  License along with this library; if not, write to the Free Software
     *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     *  @category    PHPExcel
     *  @package     PHPExcel_Writer_PDF
     *  @copyright   Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     *  @license     http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt    LGPL
     *  @version     1.8.0, 2014-03-02
     */
    /**
     *  PHPExcel_Writer_PDF
     *
     *  @category    PHPExcel
     *  @package     PHPExcel_Writer_PDF
     *  @copyright   Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Writer_PDF
    {
        /**
         * The wrapper for the requested PDF rendering engine
         *
         * @var PHPExcel_Writer_PDF_Core
         */
        private $_renderer = \NULL;
        /**
         *  Instantiate a new renderer of the configured type within this container class
         *
         *  @param  PHPExcel   $phpExcel         PHPExcel object
         *  @throws PHPExcel_Writer_Exception    when PDF library is not configured
         */
        public function __construct(\PHPExcel $phpExcel)
        {
        }
        /**
         *  Magic method to handle direct calls to the configured PDF renderer wrapper class.
         *
         *  @param   string   $name        Renderer library method name
         *  @param   mixed[]  $arguments   Array of arguments to pass to the renderer method
         *  @return  mixed    Returned data from the PDF renderer wrapper method
         */
        public function __call($name, $arguments)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_Excel2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Writer_Excel2007
     *
     * @category   PHPExcel
     * @package    PHPExcel_Writer_2007
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Writer_Excel2007 extends \PHPExcel_Writer_Abstract implements \PHPExcel_Writer_IWriter
    {
        /**
         * Pre-calculate formulas
         * Forces PHPExcel to recalculate all formulae in a workbook when saving, so that the pre-calculated values are
         *    immediately available to MS Excel or other office spreadsheet viewer when opening the file
         *
         * Overrides the default TRUE for this specific writer for performance reasons
         *
         * @var boolean
         */
        protected $_preCalculateFormulas = \FALSE;
        /**
         * Office2003 compatibility
         *
         * @var boolean
         */
        private $_office2003compatibility = \false;
        /**
         * Private writer parts
         *
         * @var PHPExcel_Writer_Excel2007_WriterPart[]
         */
        private $_writerParts = array();
        /**
         * Private PHPExcel
         *
         * @var PHPExcel
         */
        private $_spreadSheet;
        /**
         * Private string table
         *
         * @var string[]
         */
        private $_stringTable = array();
        /**
         * Private unique PHPExcel_Style_Conditional HashTable
         *
         * @var PHPExcel_HashTable
         */
        private $_stylesConditionalHashTable;
        /**
         * Private unique PHPExcel_Style HashTable
         *
         * @var PHPExcel_HashTable
         */
        private $_styleHashTable;
        /**
         * Private unique PHPExcel_Style_Fill HashTable
         *
         * @var PHPExcel_HashTable
         */
        private $_fillHashTable;
        /**
         * Private unique PHPExcel_Style_Font HashTable
         *
         * @var PHPExcel_HashTable
         */
        private $_fontHashTable;
        /**
         * Private unique PHPExcel_Style_Borders HashTable
         *
         * @var PHPExcel_HashTable
         */
        private $_bordersHashTable;
        /**
         * Private unique PHPExcel_Style_NumberFormat HashTable
         *
         * @var PHPExcel_HashTable
         */
        private $_numFmtHashTable;
        /**
         * Private unique PHPExcel_Worksheet_BaseDrawing HashTable
         *
         * @var PHPExcel_HashTable
         */
        private $_drawingHashTable;
        /**
         * Create a new PHPExcel_Writer_Excel2007
         *
         * @param 	PHPExcel	$pPHPExcel
         */
        public function __construct(\PHPExcel $pPHPExcel = \null)
        {
        }
        /**
         * Get writer part
         *
         * @param 	string 	$pPartName		Writer part name
         * @return 	PHPExcel_Writer_Excel2007_WriterPart
         */
        public function getWriterPart($pPartName = '')
        {
        }
        /**
         * Save PHPExcel to file
         *
         * @param 	string 		$pFilename
         * @throws 	PHPExcel_Writer_Exception
         */
        public function save($pFilename = \null)
        {
        }
        /**
         * Get PHPExcel object
         *
         * @return PHPExcel
         * @throws PHPExcel_Writer_Exception
         */
        public function getPHPExcel()
        {
        }
        /**
         * Set PHPExcel object
         *
         * @param 	PHPExcel 	$pPHPExcel	PHPExcel object
         * @throws	PHPExcel_Writer_Exception
         * @return PHPExcel_Writer_Excel2007
         */
        public function setPHPExcel(\PHPExcel $pPHPExcel = \null)
        {
        }
        /**
         * Get string table
         *
         * @return string[]
         */
        public function getStringTable()
        {
        }
        /**
         * Get PHPExcel_Style HashTable
         *
         * @return PHPExcel_HashTable
         */
        public function getStyleHashTable()
        {
        }
        /**
         * Get PHPExcel_Style_Conditional HashTable
         *
         * @return PHPExcel_HashTable
         */
        public function getStylesConditionalHashTable()
        {
        }
        /**
         * Get PHPExcel_Style_Fill HashTable
         *
         * @return PHPExcel_HashTable
         */
        public function getFillHashTable()
        {
        }
        /**
         * Get PHPExcel_Style_Font HashTable
         *
         * @return PHPExcel_HashTable
         */
        public function getFontHashTable()
        {
        }
        /**
         * Get PHPExcel_Style_Borders HashTable
         *
         * @return PHPExcel_HashTable
         */
        public function getBordersHashTable()
        {
        }
        /**
         * Get PHPExcel_Style_NumberFormat HashTable
         *
         * @return PHPExcel_HashTable
         */
        public function getNumFmtHashTable()
        {
        }
        /**
         * Get PHPExcel_Worksheet_BaseDrawing HashTable
         *
         * @return PHPExcel_HashTable
         */
        public function getDrawingHashTable()
        {
        }
        /**
         * Get Office2003 compatibility
         *
         * @return boolean
         */
        public function getOffice2003Compatibility()
        {
        }
        /**
         * Set Office2003 compatibility
         *
         * @param boolean $pValue	Office2003 compatibility?
         * @return PHPExcel_Writer_Excel2007
         */
        public function setOffice2003Compatibility($pValue = \false)
        {
        }
    }
    /**
     *	PHPExcel
     *
     *	Copyright (c) 2006 - 2014 PHPExcel
     *
     *	This library is free software; you can redistribute it and/or
     *	modify it under the terms of the GNU Lesser General Public
     *	License as published by the Free Software Foundation; either
     *	version 2.1 of the License, or (at your option) any later version.
     *
     *	This library is distributed in the hope that it will be useful,
     *	but WITHOUT ANY WARRANTY; without even the implied warranty of
     *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     *	Lesser General Public License for more details.
     *
     *	You should have received a copy of the GNU Lesser General Public
     *	License along with this library; if not, write to the Free Software
     *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     *	@category	PHPExcel
     *	@package	PHPExcel_Cell
     *	@copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     *	@license	http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     *	@version	1.8.0, 2014-03-02
     */
    /**
     *	PHPExcel_Cell
     *
     *	@category   PHPExcel
     *	@package	PHPExcel_Cell
     *	@copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Cell
    {
        /**
         *  Default range variable constant
         *
         *  @var  string
         */
        const DEFAULT_RANGE = 'A1:A1';
        /**
         *	Value binder to use
         *
         *	@var	PHPExcel_Cell_IValueBinder
         */
        private static $_valueBinder = \NULL;
        /**
         *	Value of the cell
         *
         *	@var	mixed
         */
        private $_value;
        /**
         *	Calculated value of the cell (used for caching)
         *	This returns the value last calculated by MS Excel or whichever spreadsheet program was used to
         *		create the original spreadsheet file.
         *	Note that this value is not guaranteed to reflect the actual calculated value because it is
         *		possible that auto-calculation was disabled in the original spreadsheet, and underlying data
         *		values used by the formula have changed since it was last calculated.
         *
         *	@var mixed
         */
        private $_calculatedValue = \NULL;
        /**
         *	Type of the cell data
         *
         *	@var	string
         */
        private $_dataType;
        /**
         *	Parent worksheet
         *
         *	@var	PHPExcel_CachedObjectStorage_CacheBase
         */
        private $_parent;
        /**
         *	Index to cellXf
         *
         *	@var	int
         */
        private $_xfIndex;
        /**
         *	Attributes of the formula
         *
         */
        private $_formulaAttributes;
        /**
         *	Send notification to the cache controller
         *
         *	@return void
         **/
        public function notifyCacheController()
        {
        }
        public function detach()
        {
        }
        public function attach(\PHPExcel_CachedObjectStorage_CacheBase $parent)
        {
        }
        /**
         *	Create a new Cell
         *
         *	@param	mixed				$pValue
         *	@param	string				$pDataType
         *	@param	PHPExcel_Worksheet	$pSheet
         *	@throws	PHPExcel_Exception
         */
        public function __construct($pValue = \NULL, $pDataType = \NULL, \PHPExcel_Worksheet $pSheet = \NULL)
        {
        }
        /**
         *	Get cell coordinate column
         *
         *	@return	string
         */
        public function getColumn()
        {
        }
        /**
         *	Get cell coordinate row
         *
         *	@return	int
         */
        public function getRow()
        {
        }
        /**
         *	Get cell coordinate
         *
         *	@return	string
         */
        public function getCoordinate()
        {
        }
        /**
         *	Get cell value
         *
         *	@return	mixed
         */
        public function getValue()
        {
        }
        /**
         *	Get cell value with formatting
         *
         *	@return	string
         */
        public function getFormattedValue()
        {
        }
        /**
         *	Set cell value
         *
         *	Sets the value for a cell, automatically determining the datatype using the value binder
         *
         *	@param	mixed	$pValue					Value
         *	@return	PHPExcel_Cell
         *	@throws	PHPExcel_Exception
         */
        public function setValue($pValue = \NULL)
        {
        }
        /**
         *	Set the value for a cell, with the explicit data type passed to the method (bypassing any use of the value binder)
         *
         *	@param	mixed	$pValue			Value
         *	@param	string	$pDataType		Explicit data type
         *	@return	PHPExcel_Cell
         *	@throws	PHPExcel_Exception
         */
        public function setValueExplicit($pValue = \NULL, $pDataType = \PHPExcel_Cell_DataType::TYPE_STRING)
        {
        }
        /**
         *	Get calculated cell value
         *
         *	@deprecated		Since version 1.7.8 for planned changes to cell for array formula handling
         *
         *	@param	boolean $resetLog  Whether the calculation engine logger should be reset or not
         *	@return	mixed
         *	@throws	PHPExcel_Exception
         */
        public function getCalculatedValue($resetLog = \TRUE)
        {
        }
        /**
         *	Set old calculated value (cached)
         *
         *	@param	mixed $pValue	Value
         *	@return	PHPExcel_Cell
         */
        public function setCalculatedValue($pValue = \NULL)
        {
        }
        /**
         *	Get old calculated value (cached)
         *	This returns the value last calculated by MS Excel or whichever spreadsheet program was used to
         *		create the original spreadsheet file.
         *	Note that this value is not guaranteed to refelect the actual calculated value because it is
         *		possible that auto-calculation was disabled in the original spreadsheet, and underlying data
         *		values used by the formula have changed since it was last calculated.
         *
         *	@return	mixed
         */
        public function getOldCalculatedValue()
        {
        }
        /**
         *	Get cell data type
         *
         *	@return string
         */
        public function getDataType()
        {
        }
        /**
         *	Set cell data type
         *
         *	@param	string $pDataType
         *	@return	PHPExcel_Cell
         */
        public function setDataType($pDataType = \PHPExcel_Cell_DataType::TYPE_STRING)
        {
        }
        /**
         *  Identify if the cell contains a formula
         *
         *  @return boolean
         */
        public function isFormula()
        {
        }
        /**
         *	Does this cell contain Data validation rules?
         *
         *	@return	boolean
         *	@throws	PHPExcel_Exception
         */
        public function hasDataValidation()
        {
        }
        /**
         *	Get Data validation rules
         *
         *	@return	PHPExcel_Cell_DataValidation
         *	@throws	PHPExcel_Exception
         */
        public function getDataValidation()
        {
        }
        /**
         *	Set Data validation rules
         *
         *	@param	PHPExcel_Cell_DataValidation	$pDataValidation
         *	@return	PHPExcel_Cell
         *	@throws	PHPExcel_Exception
         */
        public function setDataValidation(\PHPExcel_Cell_DataValidation $pDataValidation = \NULL)
        {
        }
        /**
         *	Does this cell contain a Hyperlink?
         *
         *	@return boolean
         *	@throws	PHPExcel_Exception
         */
        public function hasHyperlink()
        {
        }
        /**
         *	Get Hyperlink
         *
         *	@return	PHPExcel_Cell_Hyperlink
         *	@throws	PHPExcel_Exception
         */
        public function getHyperlink()
        {
        }
        /**
         *	Set Hyperlink
         *
         *	@param	PHPExcel_Cell_Hyperlink	$pHyperlink
         *	@return	PHPExcel_Cell
         *	@throws	PHPExcel_Exception
         */
        public function setHyperlink(\PHPExcel_Cell_Hyperlink $pHyperlink = \NULL)
        {
        }
        /**
         *	Get parent worksheet
         *
         *	@return PHPExcel_CachedObjectStorage_CacheBase
         */
        public function getParent()
        {
        }
        /**
         *	Get parent worksheet
         *
         *	@return PHPExcel_Worksheet
         */
        public function getWorksheet()
        {
        }
        /**
         *	Get cell style
         *
         *	@return	PHPExcel_Style
         */
        public function getStyle()
        {
        }
        /**
         *	Re-bind parent
         *
         *	@param	PHPExcel_Worksheet $parent
         *	@return	PHPExcel_Cell
         */
        public function rebindParent(\PHPExcel_Worksheet $parent)
        {
        }
        /**
         *	Is cell in a specific range?
         *
         *	@param	string	$pRange		Cell range (e.g. A1:A1)
         *	@return	boolean
         */
        public function isInRange($pRange = 'A1:A1')
        {
        }
        /**
         *	Coordinate from string
         *
         *	@param	string	$pCoordinateString
         *	@return	array	Array containing column and row (indexes 0 and 1)
         *	@throws	PHPExcel_Exception
         */
        public static function coordinateFromString($pCoordinateString = 'A1')
        {
        }
        /**
         *	Make string row, column or cell coordinate absolute
         *
         *	@param	string	$pCoordinateString		e.g. 'A' or '1' or 'A1'
         *					Note that this value can be a row or column reference as well as a cell reference
         *	@return	string	Absolute coordinate		e.g. '$A' or '$1' or '$A$1'
         *	@throws	PHPExcel_Exception
         */
        public static function absoluteReference($pCoordinateString = 'A1')
        {
        }
        /**
         *	Make string coordinate absolute
         *
         *	@param	string	$pCoordinateString		e.g. 'A1'
         *	@return	string	Absolute coordinate		e.g. '$A$1'
         *	@throws	PHPExcel_Exception
         */
        public static function absoluteCoordinate($pCoordinateString = 'A1')
        {
        }
        /**
         *	Split range into coordinate strings
         *
         *	@param	string	$pRange		e.g. 'B4:D9' or 'B4:D9,H2:O11' or 'B4'
         *	@return	array	Array containg one or more arrays containing one or two coordinate strings
         *								e.g. array('B4','D9') or array(array('B4','D9'),array('H2','O11'))
         *										or array('B4')
         */
        public static function splitRange($pRange = 'A1:A1')
        {
        }
        /**
         *	Build range from coordinate strings
         *
         *	@param	array	$pRange	Array containg one or more arrays containing one or two coordinate strings
         *	@return	string	String representation of $pRange
         *	@throws	PHPExcel_Exception
         */
        public static function buildRange($pRange)
        {
        }
        /**
         *	Calculate range boundaries
         *
         *	@param	string	$pRange		Cell range (e.g. A1:A1)
         *	@return	array	Range coordinates array(Start Cell, End Cell)
         *					where Start Cell and End Cell are arrays (Column Number, Row Number)
         */
        public static function rangeBoundaries($pRange = 'A1:A1')
        {
        }
        /**
         *	Calculate range dimension
         *
         *	@param	string	$pRange		Cell range (e.g. A1:A1)
         *	@return	array	Range dimension (width, height)
         */
        public static function rangeDimension($pRange = 'A1:A1')
        {
        }
        /**
         *	Calculate range boundaries
         *
         *	@param	string	$pRange		Cell range (e.g. A1:A1)
         *	@return	array	Range coordinates array(Start Cell, End Cell)
         *					where Start Cell and End Cell are arrays (Column ID, Row Number)
         */
        public static function getRangeBoundaries($pRange = 'A1:A1')
        {
        }
        /**
         *	Column index from string
         *
         *	@param	string $pString
         *	@return	int Column index (base 1 !!!)
         */
        public static function columnIndexFromString($pString = 'A')
        {
        }
        /**
         *	String from columnindex
         *
         *	@param	int $pColumnIndex Column index (base 0 !!!)
         *	@return	string
         */
        public static function stringFromColumnIndex($pColumnIndex = 0)
        {
        }
        /**
         *	Extract all cell references in range
         *
         *	@param	string	$pRange		Range (e.g. A1 or A1:C10 or A1:E10 A20:E25)
         *	@return	array	Array containing single cell references
         */
        public static function extractAllCellReferencesInRange($pRange = 'A1')
        {
        }
        /**
         * Compare 2 cells
         *
         * @param	PHPExcel_Cell	$a	Cell a
         * @param	PHPExcel_Cell	$b	Cell b
         * @return	int		Result of comparison (always -1 or 1, never zero!)
         */
        public static function compareCells(\PHPExcel_Cell $a, \PHPExcel_Cell $b)
        {
        }
        /**
         * Get value binder to use
         *
         * @return PHPExcel_Cell_IValueBinder
         */
        public static function getValueBinder()
        {
        }
        /**
         * Set value binder to use
         *
         * @param PHPExcel_Cell_IValueBinder $binder
         * @throws PHPExcel_Exception
         */
        public static function setValueBinder(\PHPExcel_Cell_IValueBinder $binder = \NULL)
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
        /**
         * Get index to cellXf
         *
         * @return int
         */
        public function getXfIndex()
        {
        }
        /**
         * Set index to cellXf
         *
         * @param int $pValue
         * @return PHPExcel_Cell
         */
        public function setXfIndex($pValue = 0)
        {
        }
        /**
         *	@deprecated		Since version 1.7.8 for planned changes to cell for array formula handling
         */
        public function setFormulaAttributes($pAttributes)
        {
        }
        /**
         *	@deprecated		Since version 1.7.8 for planned changes to cell for array formula handling
         */
        public function getFormulaAttributes()
        {
        }
        /**
         * Convert to string
         *
         * @return string
         */
        public function __toString()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt    LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Worksheet
     *
     * @category   PHPExcel
     * @package    PHPExcel_Worksheet
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Worksheet implements \PHPExcel_IComparable
    {
        /* Break types */
        const BREAK_NONE = 0;
        const BREAK_ROW = 1;
        const BREAK_COLUMN = 2;
        /* Sheet state */
        const SHEETSTATE_VISIBLE = 'visible';
        const SHEETSTATE_HIDDEN = 'hidden';
        const SHEETSTATE_VERYHIDDEN = 'veryHidden';
        /**
         * Invalid characters in sheet title
         *
         * @var array
         */
        private static $_invalidCharacters = array('*', ':', '/', '\\', '?', '[', ']');
        /**
         * Parent spreadsheet
         *
         * @var PHPExcel
         */
        private $_parent;
        /**
         * Cacheable collection of cells
         *
         * @var PHPExcel_CachedObjectStorage_xxx
         */
        private $_cellCollection = \null;
        /**
         * Collection of row dimensions
         *
         * @var PHPExcel_Worksheet_RowDimension[]
         */
        private $_rowDimensions = array();
        /**
         * Default row dimension
         *
         * @var PHPExcel_Worksheet_RowDimension
         */
        private $_defaultRowDimension = \null;
        /**
         * Collection of column dimensions
         *
         * @var PHPExcel_Worksheet_ColumnDimension[]
         */
        private $_columnDimensions = array();
        /**
         * Default column dimension
         *
         * @var PHPExcel_Worksheet_ColumnDimension
         */
        private $_defaultColumnDimension = \null;
        /**
         * Collection of drawings
         *
         * @var PHPExcel_Worksheet_BaseDrawing[]
         */
        private $_drawingCollection = \null;
        /**
         * Collection of Chart objects
         *
         * @var PHPExcel_Chart[]
         */
        private $_chartCollection = array();
        /**
         * Worksheet title
         *
         * @var string
         */
        private $_title;
        /**
         * Sheet state
         *
         * @var string
         */
        private $_sheetState;
        /**
         * Page setup
         *
         * @var PHPExcel_Worksheet_PageSetup
         */
        private $_pageSetup;
        /**
         * Page margins
         *
         * @var PHPExcel_Worksheet_PageMargins
         */
        private $_pageMargins;
        /**
         * Page header/footer
         *
         * @var PHPExcel_Worksheet_HeaderFooter
         */
        private $_headerFooter;
        /**
         * Sheet view
         *
         * @var PHPExcel_Worksheet_SheetView
         */
        private $_sheetView;
        /**
         * Protection
         *
         * @var PHPExcel_Worksheet_Protection
         */
        private $_protection;
        /**
         * Collection of styles
         *
         * @var PHPExcel_Style[]
         */
        private $_styles = array();
        /**
         * Conditional styles. Indexed by cell coordinate, e.g. 'A1'
         *
         * @var array
         */
        private $_conditionalStylesCollection = array();
        /**
         * Is the current cell collection sorted already?
         *
         * @var boolean
         */
        private $_cellCollectionIsSorted = \false;
        /**
         * Collection of breaks
         *
         * @var array
         */
        private $_breaks = array();
        /**
         * Collection of merged cell ranges
         *
         * @var array
         */
        private $_mergeCells = array();
        /**
         * Collection of protected cell ranges
         *
         * @var array
         */
        private $_protectedCells = array();
        /**
         * Autofilter Range and selection
         *
         * @var PHPExcel_Worksheet_AutoFilter
         */
        private $_autoFilter = \NULL;
        /**
         * Freeze pane
         *
         * @var string
         */
        private $_freezePane = '';
        /**
         * Show gridlines?
         *
         * @var boolean
         */
        private $_showGridlines = \true;
        /**
         * Print gridlines?
         *
         * @var boolean
         */
        private $_printGridlines = \false;
        /**
         * Show row and column headers?
         *
         * @var boolean
         */
        private $_showRowColHeaders = \true;
        /**
         * Show summary below? (Row/Column outline)
         *
         * @var boolean
         */
        private $_showSummaryBelow = \true;
        /**
         * Show summary right? (Row/Column outline)
         *
         * @var boolean
         */
        private $_showSummaryRight = \true;
        /**
         * Collection of comments
         *
         * @var PHPExcel_Comment[]
         */
        private $_comments = array();
        /**
         * Active cell. (Only one!)
         *
         * @var string
         */
        private $_activeCell = 'A1';
        /**
         * Selected cells
         *
         * @var string
         */
        private $_selectedCells = 'A1';
        /**
         * Cached highest column
         *
         * @var string
         */
        private $_cachedHighestColumn = 'A';
        /**
         * Cached highest row
         *
         * @var int
         */
        private $_cachedHighestRow = 1;
        /**
         * Right-to-left?
         *
         * @var boolean
         */
        private $_rightToLeft = \false;
        /**
         * Hyperlinks. Indexed by cell coordinate, e.g. 'A1'
         *
         * @var array
         */
        private $_hyperlinkCollection = array();
        /**
         * Data validation objects. Indexed by cell coordinate, e.g. 'A1'
         *
         * @var array
         */
        private $_dataValidationCollection = array();
        /**
         * Tab color
         *
         * @var PHPExcel_Style_Color
         */
        private $_tabColor;
        /**
         * Dirty flag
         *
         * @var boolean
         */
        private $_dirty = \true;
        /**
         * Hash
         *
         * @var string
         */
        private $_hash = \null;
        /**
         * CodeName
         *
         * @var string
         */
        private $_codeName = \null;
        /**
         * Create a new worksheet
         *
         * @param PHPExcel        $pParent
         * @param string        $pTitle
         */
        public function __construct(\PHPExcel $pParent = \null, $pTitle = 'Worksheet')
        {
        }
        /**
         * Disconnect all cells from this PHPExcel_Worksheet object,
         *    typically so that the worksheet object can be unset
         *
         */
        public function disconnectCells()
        {
        }
        /**
         * Code to execute when this worksheet is unset()
         *
         */
        function __destruct()
        {
        }
        /**
         * Return the cache controller for the cell collection
         *
         * @return PHPExcel_CachedObjectStorage_xxx
         */
        public function getCellCacheController()
        {
        }
        //    function getCellCacheController()
        /**
         * Get array of invalid characters for sheet title
         *
         * @return array
         */
        public static function getInvalidCharacters()
        {
        }
        /**
         * Check sheet code name for valid Excel syntax
         *
         * @param string $pValue The string to check
         * @return string The valid string
         * @throws Exception
         */
        private static function _checkSheetCodeName($pValue)
        {
        }
        /**
         * Check sheet title for valid Excel syntax
         *
         * @param string $pValue The string to check
         * @return string The valid string
         * @throws PHPExcel_Exception
         */
        private static function _checkSheetTitle($pValue)
        {
        }
        /**
         * Get collection of cells
         *
         * @param boolean $pSorted Also sort the cell collection?
         * @return PHPExcel_Cell[]
         */
        public function getCellCollection($pSorted = \true)
        {
        }
        /**
         * Sort collection of cells
         *
         * @return PHPExcel_Worksheet
         */
        public function sortCellCollection()
        {
        }
        /**
         * Get collection of row dimensions
         *
         * @return PHPExcel_Worksheet_RowDimension[]
         */
        public function getRowDimensions()
        {
        }
        /**
         * Get default row dimension
         *
         * @return PHPExcel_Worksheet_RowDimension
         */
        public function getDefaultRowDimension()
        {
        }
        /**
         * Get collection of column dimensions
         *
         * @return PHPExcel_Worksheet_ColumnDimension[]
         */
        public function getColumnDimensions()
        {
        }
        /**
         * Get default column dimension
         *
         * @return PHPExcel_Worksheet_ColumnDimension
         */
        public function getDefaultColumnDimension()
        {
        }
        /**
         * Get collection of drawings
         *
         * @return PHPExcel_Worksheet_BaseDrawing[]
         */
        public function getDrawingCollection()
        {
        }
        /**
         * Get collection of charts
         *
         * @return PHPExcel_Chart[]
         */
        public function getChartCollection()
        {
        }
        /**
         * Add chart
         *
         * @param PHPExcel_Chart $pChart
         * @param int|null $iChartIndex Index where chart should go (0,1,..., or null for last)
         * @return PHPExcel_Chart
         */
        public function addChart(\PHPExcel_Chart $pChart = \null, $iChartIndex = \null)
        {
        }
        /**
         * Return the count of charts on this worksheet
         *
         * @return int        The number of charts
         */
        public function getChartCount()
        {
        }
        /**
         * Get a chart by its index position
         *
         * @param string $index Chart index position
         * @return false|PHPExcel_Chart
         * @throws PHPExcel_Exception
         */
        public function getChartByIndex($index = \null)
        {
        }
        /**
         * Return an array of the names of charts on this worksheet
         *
         * @return string[] The names of charts
         * @throws PHPExcel_Exception
         */
        public function getChartNames()
        {
        }
        /**
         * Get a chart by name
         *
         * @param string $chartName Chart name
         * @return false|PHPExcel_Chart
         * @throws PHPExcel_Exception
         */
        public function getChartByName($chartName = '')
        {
        }
        /**
         * Refresh column dimensions
         *
         * @return PHPExcel_Worksheet
         */
        public function refreshColumnDimensions()
        {
        }
        /**
         * Refresh row dimensions
         *
         * @return PHPExcel_Worksheet
         */
        public function refreshRowDimensions()
        {
        }
        /**
         * Calculate worksheet dimension
         *
         * @return string  String containing the dimension of this worksheet
         */
        public function calculateWorksheetDimension()
        {
        }
        /**
         * Calculate worksheet data dimension
         *
         * @return string  String containing the dimension of this worksheet that actually contain data
         */
        public function calculateWorksheetDataDimension()
        {
        }
        /**
         * Calculate widths for auto-size columns
         *
         * @param  boolean  $calculateMergeCells  Calculate merge cell width
         * @return PHPExcel_Worksheet;
         */
        public function calculateColumnWidths($calculateMergeCells = \false)
        {
        }
        /**
         * Get parent
         *
         * @return PHPExcel
         */
        public function getParent()
        {
        }
        /**
         * Re-bind parent
         *
         * @param PHPExcel $parent
         * @return PHPExcel_Worksheet
         */
        public function rebindParent(\PHPExcel $parent)
        {
        }
        /**
         * Get title
         *
         * @return string
         */
        public function getTitle()
        {
        }
        /**
         * Set title
         *
         * @param string $pValue String containing the dimension of this worksheet
         * @param string $updateFormulaCellReferences boolean Flag indicating whether cell references in formulae should
         *        	be updated to reflect the new sheet name.
         *          This should be left as the default true, unless you are
         *          certain that no formula cells on any worksheet contain
         *          references to this worksheet
         * @return PHPExcel_Worksheet
         */
        public function setTitle($pValue = 'Worksheet', $updateFormulaCellReferences = \true)
        {
        }
        /**
         * Get sheet state
         *
         * @return string Sheet state (visible, hidden, veryHidden)
         */
        public function getSheetState()
        {
        }
        /**
         * Set sheet state
         *
         * @param string $value Sheet state (visible, hidden, veryHidden)
         * @return PHPExcel_Worksheet
         */
        public function setSheetState($value = \PHPExcel_Worksheet::SHEETSTATE_VISIBLE)
        {
        }
        /**
         * Get page setup
         *
         * @return PHPExcel_Worksheet_PageSetup
         */
        public function getPageSetup()
        {
        }
        /**
         * Set page setup
         *
         * @param PHPExcel_Worksheet_PageSetup    $pValue
         * @return PHPExcel_Worksheet
         */
        public function setPageSetup(\PHPExcel_Worksheet_PageSetup $pValue)
        {
        }
        /**
         * Get page margins
         *
         * @return PHPExcel_Worksheet_PageMargins
         */
        public function getPageMargins()
        {
        }
        /**
         * Set page margins
         *
         * @param PHPExcel_Worksheet_PageMargins    $pValue
         * @return PHPExcel_Worksheet
         */
        public function setPageMargins(\PHPExcel_Worksheet_PageMargins $pValue)
        {
        }
        /**
         * Get page header/footer
         *
         * @return PHPExcel_Worksheet_HeaderFooter
         */
        public function getHeaderFooter()
        {
        }
        /**
         * Set page header/footer
         *
         * @param PHPExcel_Worksheet_HeaderFooter    $pValue
         * @return PHPExcel_Worksheet
         */
        public function setHeaderFooter(\PHPExcel_Worksheet_HeaderFooter $pValue)
        {
        }
        /**
         * Get sheet view
         *
         * @return PHPExcel_Worksheet_SheetView
         */
        public function getSheetView()
        {
        }
        /**
         * Set sheet view
         *
         * @param PHPExcel_Worksheet_SheetView    $pValue
         * @return PHPExcel_Worksheet
         */
        public function setSheetView(\PHPExcel_Worksheet_SheetView $pValue)
        {
        }
        /**
         * Get Protection
         *
         * @return PHPExcel_Worksheet_Protection
         */
        public function getProtection()
        {
        }
        /**
         * Set Protection
         *
         * @param PHPExcel_Worksheet_Protection    $pValue
         * @return PHPExcel_Worksheet
         */
        public function setProtection(\PHPExcel_Worksheet_Protection $pValue)
        {
        }
        /**
         * Get highest worksheet column
         *
         * @param   string     $row        Return the data highest column for the specified row,
         *                                     or the highest column of any row if no row number is passed
         * @return string Highest column name
         */
        public function getHighestColumn($row = \null)
        {
        }
        /**
         * Get highest worksheet column that contains data
         *
         * @param   string     $row        Return the highest data column for the specified row,
         *                                     or the highest data column of any row if no row number is passed
         * @return string Highest column name that contains data
         */
        public function getHighestDataColumn($row = \null)
        {
        }
        /**
         * Get highest worksheet row
         *
         * @param   string     $column     Return the highest data row for the specified column,
         *                                     or the highest row of any column if no column letter is passed
         * @return int Highest row number
         */
        public function getHighestRow($column = \null)
        {
        }
        /**
         * Get highest worksheet row that contains data
         *
         * @param   string     $column     Return the highest data row for the specified column,
         *                                     or the highest data row of any column if no column letter is passed
         * @return string Highest row number that contains data
         */
        public function getHighestDataRow($column = \null)
        {
        }
        /**
         * Get highest worksheet column and highest row that have cell records
         *
         * @return array Highest column name and highest row number
         */
        public function getHighestRowAndColumn()
        {
        }
        /**
         * Set a cell value
         *
         * @param string $pCoordinate Coordinate of the cell
         * @param mixed $pValue Value of the cell
         * @param bool $returnCell   Return the worksheet (false, default) or the cell (true)
         * @return PHPExcel_Worksheet|PHPExcel_Cell    Depending on the last parameter being specified
         */
        public function setCellValue($pCoordinate = 'A1', $pValue = \null, $returnCell = \false)
        {
        }
        /**
         * Set a cell value by using numeric cell coordinates
         *
         * @param string $pColumn Numeric column coordinate of the cell (A = 0)
         * @param string $pRow Numeric row coordinate of the cell
         * @param mixed $pValue Value of the cell
         * @param bool $returnCell Return the worksheet (false, default) or the cell (true)
         * @return PHPExcel_Worksheet|PHPExcel_Cell    Depending on the last parameter being specified
         */
        public function setCellValueByColumnAndRow($pColumn = 0, $pRow = 1, $pValue = \null, $returnCell = \false)
        {
        }
        /**
         * Set a cell value
         *
         * @param string $pCoordinate Coordinate of the cell
         * @param mixed  $pValue Value of the cell
         * @param string $pDataType Explicit data type
         * @param bool $returnCell Return the worksheet (false, default) or the cell (true)
         * @return PHPExcel_Worksheet|PHPExcel_Cell    Depending on the last parameter being specified
         */
        public function setCellValueExplicit($pCoordinate = 'A1', $pValue = \null, $pDataType = \PHPExcel_Cell_DataType::TYPE_STRING, $returnCell = \false)
        {
        }
        /**
         * Set a cell value by using numeric cell coordinates
         *
         * @param string $pColumn Numeric column coordinate of the cell
         * @param string $pRow Numeric row coordinate of the cell
         * @param mixed $pValue Value of the cell
         * @param string $pDataType Explicit data type
         * @param bool $returnCell Return the worksheet (false, default) or the cell (true)
         * @return PHPExcel_Worksheet|PHPExcel_Cell    Depending on the last parameter being specified
         */
        public function setCellValueExplicitByColumnAndRow($pColumn = 0, $pRow = 1, $pValue = \null, $pDataType = \PHPExcel_Cell_DataType::TYPE_STRING, $returnCell = \false)
        {
        }
        /**
         * Get cell at a specific coordinate
         *
         * @param string $pCoordinate    Coordinate of the cell
         * @throws PHPExcel_Exception
         * @return PHPExcel_Cell Cell that was found
         */
        public function getCell($pCoordinate = 'A1')
        {
        }
        /**
         * Get cell at a specific coordinate by using numeric cell coordinates
         *
         * @param  string $pColumn Numeric column coordinate of the cell
         * @param string $pRow Numeric row coordinate of the cell
         * @return PHPExcel_Cell Cell that was found
         */
        public function getCellByColumnAndRow($pColumn = 0, $pRow = 1)
        {
        }
        /**
         * Create a new cell at the specified coordinate
         *
         * @param string $pCoordinate    Coordinate of the cell
         * @return PHPExcel_Cell Cell that was created
         */
        private function _createNewCell($pCoordinate)
        {
        }
        /**
         * Does the cell at a specific coordinate exist?
         *
         * @param string $pCoordinate  Coordinate of the cell
         * @throws PHPExcel_Exception
         * @return boolean
         */
        public function cellExists($pCoordinate = 'A1')
        {
        }
        /**
         * Cell at a specific coordinate by using numeric cell coordinates exists?
         *
         * @param string $pColumn Numeric column coordinate of the cell
         * @param string $pRow Numeric row coordinate of the cell
         * @return boolean
         */
        public function cellExistsByColumnAndRow($pColumn = 0, $pRow = 1)
        {
        }
        /**
         * Get row dimension at a specific row
         *
         * @param int $pRow Numeric index of the row
         * @return PHPExcel_Worksheet_RowDimension
         */
        public function getRowDimension($pRow = 1, $create = \TRUE)
        {
        }
        /**
         * Get column dimension at a specific column
         *
         * @param string $pColumn String index of the column
         * @return PHPExcel_Worksheet_ColumnDimension
         */
        public function getColumnDimension($pColumn = 'A', $create = \TRUE)
        {
        }
        /**
         * Get column dimension at a specific column by using numeric cell coordinates
         *
         * @param string $pColumn Numeric column coordinate of the cell
         * @return PHPExcel_Worksheet_ColumnDimension
         */
        public function getColumnDimensionByColumn($pColumn = 0)
        {
        }
        /**
         * Get styles
         *
         * @return PHPExcel_Style[]
         */
        public function getStyles()
        {
        }
        /**
         * Get default style of workbook.
         *
         * @deprecated
         * @return PHPExcel_Style
         * @throws PHPExcel_Exception
         */
        public function getDefaultStyle()
        {
        }
        /**
         * Set default style - should only be used by PHPExcel_IReader implementations!
         *
         * @deprecated
         * @param PHPExcel_Style $pValue
         * @throws PHPExcel_Exception
         * @return PHPExcel_Worksheet
         */
        public function setDefaultStyle(\PHPExcel_Style $pValue)
        {
        }
        /**
         * Get style for cell
         *
         * @param string $pCellCoordinate Cell coordinate to get style for
         * @return PHPExcel_Style
         * @throws PHPExcel_Exception
         */
        public function getStyle($pCellCoordinate = 'A1')
        {
        }
        /**
         * Get conditional styles for a cell
         *
         * @param string $pCoordinate
         * @return PHPExcel_Style_Conditional[]
         */
        public function getConditionalStyles($pCoordinate = 'A1')
        {
        }
        /**
         * Do conditional styles exist for this cell?
         *
         * @param string $pCoordinate
         * @return boolean
         */
        public function conditionalStylesExists($pCoordinate = 'A1')
        {
        }
        /**
         * Removes conditional styles for a cell
         *
         * @param string $pCoordinate
         * @return PHPExcel_Worksheet
         */
        public function removeConditionalStyles($pCoordinate = 'A1')
        {
        }
        /**
         * Get collection of conditional styles
         *
         * @return array
         */
        public function getConditionalStylesCollection()
        {
        }
        /**
         * Set conditional styles
         *
         * @param $pCoordinate string E.g. 'A1'
         * @param $pValue PHPExcel_Style_Conditional[]
         * @return PHPExcel_Worksheet
         */
        public function setConditionalStyles($pCoordinate = 'A1', $pValue)
        {
        }
        /**
         * Get style for cell by using numeric cell coordinates
         *
         * @param int $pColumn  Numeric column coordinate of the cell
         * @param int $pRow Numeric row coordinate of the cell
         * @return PHPExcel_Style
         */
        public function getStyleByColumnAndRow($pColumn = 0, $pRow = 1)
        {
        }
        /**
         * Set shared cell style to a range of cells
         *
         * Please note that this will overwrite existing cell styles for cells in range!
         *
         * @deprecated
         * @param PHPExcel_Style $pSharedCellStyle Cell style to share
         * @param string $pRange Range of cells (i.e. "A1:B10"), or just one cell (i.e. "A1")
         * @throws PHPExcel_Exception
         * @return PHPExcel_Worksheet
         */
        public function setSharedStyle(\PHPExcel_Style $pSharedCellStyle = \null, $pRange = '')
        {
        }
        /**
         * Duplicate cell style to a range of cells
         *
         * Please note that this will overwrite existing cell styles for cells in range!
         *
         * @param PHPExcel_Style $pCellStyle Cell style to duplicate
         * @param string $pRange Range of cells (i.e. "A1:B10"), or just one cell (i.e. "A1")
         * @throws PHPExcel_Exception
         * @return PHPExcel_Worksheet
         */
        public function duplicateStyle(\PHPExcel_Style $pCellStyle = \null, $pRange = '')
        {
        }
        /**
         * Duplicate conditional style to a range of cells
         *
         * Please note that this will overwrite existing cell styles for cells in range!
         *
         * @param	array of PHPExcel_Style_Conditional	$pCellStyle	Cell style to duplicate
         * @param string $pRange Range of cells (i.e. "A1:B10"), or just one cell (i.e. "A1")
         * @throws PHPExcel_Exception
         * @return PHPExcel_Worksheet
         */
        public function duplicateConditionalStyle(array $pCellStyle = \null, $pRange = '')
        {
        }
        /**
         * Duplicate cell style array to a range of cells
         *
         * Please note that this will overwrite existing cell styles for cells in range,
         * if they are in the styles array. For example, if you decide to set a range of
         * cells to font bold, only include font bold in the styles array.
         *
         * @deprecated
         * @param array $pStyles Array containing style information
         * @param string $pRange Range of cells (i.e. "A1:B10"), or just one cell (i.e. "A1")
         * @param boolean $pAdvanced Advanced mode for setting borders.
         * @throws PHPExcel_Exception
         * @return PHPExcel_Worksheet
         */
        public function duplicateStyleArray($pStyles = \null, $pRange = '', $pAdvanced = \true)
        {
        }
        /**
         * Set break on a cell
         *
         * @param string $pCell Cell coordinate (e.g. A1)
         * @param int $pBreak Break type (type of PHPExcel_Worksheet::BREAK_*)
         * @throws PHPExcel_Exception
         * @return PHPExcel_Worksheet
         */
        public function setBreak($pCell = 'A1', $pBreak = \PHPExcel_Worksheet::BREAK_NONE)
        {
        }
        /**
         * Set break on a cell by using numeric cell coordinates
         *
         * @param integer $pColumn Numeric column coordinate of the cell
         * @param integer $pRow Numeric row coordinate of the cell
         * @param  integer $pBreak Break type (type of PHPExcel_Worksheet::BREAK_*)
         * @return PHPExcel_Worksheet
         */
        public function setBreakByColumnAndRow($pColumn = 0, $pRow = 1, $pBreak = \PHPExcel_Worksheet::BREAK_NONE)
        {
        }
        /**
         * Get breaks
         *
         * @return array[]
         */
        public function getBreaks()
        {
        }
        /**
         * Set merge on a cell range
         *
         * @param string $pRange  Cell range (e.g. A1:E1)
         * @throws PHPExcel_Exception
         * @return PHPExcel_Worksheet
         */
        public function mergeCells($pRange = 'A1:A1')
        {
        }
        /**
         * Set merge on a cell range by using numeric cell coordinates
         *
         * @param int $pColumn1    Numeric column coordinate of the first cell
         * @param int $pRow1        Numeric row coordinate of the first cell
         * @param int $pColumn2    Numeric column coordinate of the last cell
         * @param int $pRow2        Numeric row coordinate of the last cell
         * @throws    PHPExcel_Exception
         * @return PHPExcel_Worksheet
         */
        public function mergeCellsByColumnAndRow($pColumn1 = 0, $pRow1 = 1, $pColumn2 = 0, $pRow2 = 1)
        {
        }
        /**
         * Remove merge on a cell range
         *
         * @param    string            $pRange        Cell range (e.g. A1:E1)
         * @throws    PHPExcel_Exception
         * @return PHPExcel_Worksheet
         */
        public function unmergeCells($pRange = 'A1:A1')
        {
        }
        /**
         * Remove merge on a cell range by using numeric cell coordinates
         *
         * @param int $pColumn1    Numeric column coordinate of the first cell
         * @param int $pRow1        Numeric row coordinate of the first cell
         * @param int $pColumn2    Numeric column coordinate of the last cell
         * @param int $pRow2        Numeric row coordinate of the last cell
         * @throws    PHPExcel_Exception
         * @return PHPExcel_Worksheet
         */
        public function unmergeCellsByColumnAndRow($pColumn1 = 0, $pRow1 = 1, $pColumn2 = 0, $pRow2 = 1)
        {
        }
        /**
         * Get merge cells array.
         *
         * @return array[]
         */
        public function getMergeCells()
        {
        }
        /**
         * Set merge cells array for the entire sheet. Use instead mergeCells() to merge
         * a single cell range.
         *
         * @param array
         */
        public function setMergeCells($pValue = array())
        {
        }
        /**
         * Set protection on a cell range
         *
         * @param    string            $pRange                Cell (e.g. A1) or cell range (e.g. A1:E1)
         * @param    string            $pPassword            Password to unlock the protection
         * @param    boolean        $pAlreadyHashed    If the password has already been hashed, set this to true
         * @throws    PHPExcel_Exception
         * @return PHPExcel_Worksheet
         */
        public function protectCells($pRange = 'A1', $pPassword = '', $pAlreadyHashed = \false)
        {
        }
        /**
         * Set protection on a cell range by using numeric cell coordinates
         *
         * @param int  $pColumn1            Numeric column coordinate of the first cell
         * @param int  $pRow1                Numeric row coordinate of the first cell
         * @param int  $pColumn2            Numeric column coordinate of the last cell
         * @param int  $pRow2                Numeric row coordinate of the last cell
         * @param string $pPassword            Password to unlock the protection
         * @param    boolean $pAlreadyHashed    If the password has already been hashed, set this to true
         * @throws    PHPExcel_Exception
         * @return PHPExcel_Worksheet
         */
        public function protectCellsByColumnAndRow($pColumn1 = 0, $pRow1 = 1, $pColumn2 = 0, $pRow2 = 1, $pPassword = '', $pAlreadyHashed = \false)
        {
        }
        /**
         * Remove protection on a cell range
         *
         * @param    string            $pRange        Cell (e.g. A1) or cell range (e.g. A1:E1)
         * @throws    PHPExcel_Exception
         * @return PHPExcel_Worksheet
         */
        public function unprotectCells($pRange = 'A1')
        {
        }
        /**
         * Remove protection on a cell range by using numeric cell coordinates
         *
         * @param int  $pColumn1            Numeric column coordinate of the first cell
         * @param int  $pRow1                Numeric row coordinate of the first cell
         * @param int  $pColumn2            Numeric column coordinate of the last cell
         * @param int $pRow2                Numeric row coordinate of the last cell
         * @param string $pPassword            Password to unlock the protection
         * @param    boolean $pAlreadyHashed    If the password has already been hashed, set this to true
         * @throws    PHPExcel_Exception
         * @return PHPExcel_Worksheet
         */
        public function unprotectCellsByColumnAndRow($pColumn1 = 0, $pRow1 = 1, $pColumn2 = 0, $pRow2 = 1, $pPassword = '', $pAlreadyHashed = \false)
        {
        }
        /**
         * Get protected cells
         *
         * @return array[]
         */
        public function getProtectedCells()
        {
        }
        /**
         *    Get Autofilter
         *
         *    @return PHPExcel_Worksheet_AutoFilter
         */
        public function getAutoFilter()
        {
        }
        /**
         *    Set AutoFilter
         *
         *    @param    PHPExcel_Worksheet_AutoFilter|string   $pValue
         *            A simple string containing a Cell range like 'A1:E10' is permitted for backward compatibility
         *    @throws    PHPExcel_Exception
         *    @return PHPExcel_Worksheet
         */
        public function setAutoFilter($pValue)
        {
        }
        /**
         *    Set Autofilter Range by using numeric cell coordinates
         *
         *    @param  integer  $pColumn1    Numeric column coordinate of the first cell
         *    @param  integer  $pRow1       Numeric row coordinate of the first cell
         *    @param  integer  $pColumn2    Numeric column coordinate of the second cell
         *    @param  integer  $pRow2       Numeric row coordinate of the second cell
         *    @throws    PHPExcel_Exception
         *    @return PHPExcel_Worksheet
         */
        public function setAutoFilterByColumnAndRow($pColumn1 = 0, $pRow1 = 1, $pColumn2 = 0, $pRow2 = 1)
        {
        }
        /**
         * Remove autofilter
         *
         * @return PHPExcel_Worksheet
         */
        public function removeAutoFilter()
        {
        }
        /**
         * Get Freeze Pane
         *
         * @return string
         */
        public function getFreezePane()
        {
        }
        /**
         * Freeze Pane
         *
         * @param    string        $pCell        Cell (i.e. A2)
         *                                    Examples:
         *                                        A2 will freeze the rows above cell A2 (i.e row 1)
         *                                        B1 will freeze the columns to the left of cell B1 (i.e column A)
         *                                        B2 will freeze the rows above and to the left of cell A2
         *                                            (i.e row 1 and column A)
         * @throws    PHPExcel_Exception
         * @return PHPExcel_Worksheet
         */
        public function freezePane($pCell = '')
        {
        }
        /**
         * Freeze Pane by using numeric cell coordinates
         *
         * @param int $pColumn    Numeric column coordinate of the cell
         * @param int $pRow        Numeric row coordinate of the cell
         * @throws    PHPExcel_Exception
         * @return PHPExcel_Worksheet
         */
        public function freezePaneByColumnAndRow($pColumn = 0, $pRow = 1)
        {
        }
        /**
         * Unfreeze Pane
         *
         * @return PHPExcel_Worksheet
         */
        public function unfreezePane()
        {
        }
        /**
         * Insert a new row, updating all possible related data
         *
         * @param int $pBefore    Insert before this one
         * @param int $pNumRows    Number of rows to insert
         * @throws    PHPExcel_Exception
         * @return PHPExcel_Worksheet
         */
        public function insertNewRowBefore($pBefore = 1, $pNumRows = 1)
        {
        }
        /**
         * Insert a new column, updating all possible related data
         *
         * @param int $pBefore    Insert before this one
         * @param int $pNumCols    Number of columns to insert
         * @throws    PHPExcel_Exception
         * @return PHPExcel_Worksheet
         */
        public function insertNewColumnBefore($pBefore = 'A', $pNumCols = 1)
        {
        }
        /**
         * Insert a new column, updating all possible related data
         *
         * @param int $pBefore    Insert before this one (numeric column coordinate of the cell)
         * @param int $pNumCols    Number of columns to insert
         * @throws    PHPExcel_Exception
         * @return PHPExcel_Worksheet
         */
        public function insertNewColumnBeforeByIndex($pBefore = 0, $pNumCols = 1)
        {
        }
        /**
         * Delete a row, updating all possible related data
         *
         * @param int $pRow        Remove starting with this one
         * @param int $pNumRows    Number of rows to remove
         * @throws    PHPExcel_Exception
         * @return PHPExcel_Worksheet
         */
        public function removeRow($pRow = 1, $pNumRows = 1)
        {
        }
        /**
         * Remove a column, updating all possible related data
         *
         * @param int $pColumn    Remove starting with this one
         * @param int $pNumCols    Number of columns to remove
         * @throws    PHPExcel_Exception
         * @return PHPExcel_Worksheet
         */
        public function removeColumn($pColumn = 'A', $pNumCols = 1)
        {
        }
        /**
         * Remove a column, updating all possible related data
         *
         * @param int $pColumn    Remove starting with this one (numeric column coordinate of the cell)
         * @param int $pNumCols    Number of columns to remove
         * @throws    PHPExcel_Exception
         * @return PHPExcel_Worksheet
         */
        public function removeColumnByIndex($pColumn = 0, $pNumCols = 1)
        {
        }
        /**
         * Show gridlines?
         *
         * @return boolean
         */
        public function getShowGridlines()
        {
        }
        /**
         * Set show gridlines
         *
         * @param boolean $pValue    Show gridlines (true/false)
         * @return PHPExcel_Worksheet
         */
        public function setShowGridlines($pValue = \false)
        {
        }
        /**
         * Print gridlines?
         *
         * @return boolean
         */
        public function getPrintGridlines()
        {
        }
        /**
         * Set print gridlines
         *
         * @param boolean $pValue Print gridlines (true/false)
         * @return PHPExcel_Worksheet
         */
        public function setPrintGridlines($pValue = \false)
        {
        }
        /**
         * Show row and column headers?
         *
         * @return boolean
         */
        public function getShowRowColHeaders()
        {
        }
        /**
         * Set show row and column headers
         *
         * @param boolean $pValue Show row and column headers (true/false)
         * @return PHPExcel_Worksheet
         */
        public function setShowRowColHeaders($pValue = \false)
        {
        }
        /**
         * Show summary below? (Row/Column outlining)
         *
         * @return boolean
         */
        public function getShowSummaryBelow()
        {
        }
        /**
         * Set show summary below
         *
         * @param boolean $pValue    Show summary below (true/false)
         * @return PHPExcel_Worksheet
         */
        public function setShowSummaryBelow($pValue = \true)
        {
        }
        /**
         * Show summary right? (Row/Column outlining)
         *
         * @return boolean
         */
        public function getShowSummaryRight()
        {
        }
        /**
         * Set show summary right
         *
         * @param boolean $pValue    Show summary right (true/false)
         * @return PHPExcel_Worksheet
         */
        public function setShowSummaryRight($pValue = \true)
        {
        }
        /**
         * Get comments
         *
         * @return PHPExcel_Comment[]
         */
        public function getComments()
        {
        }
        /**
         * Set comments array for the entire sheet.
         *
         * @param array of PHPExcel_Comment
         * @return PHPExcel_Worksheet
         */
        public function setComments($pValue = array())
        {
        }
        /**
         * Get comment for cell
         *
         * @param string $pCellCoordinate    Cell coordinate to get comment for
         * @return PHPExcel_Comment
         * @throws PHPExcel_Exception
         */
        public function getComment($pCellCoordinate = 'A1')
        {
        }
        /**
         * Get comment for cell by using numeric cell coordinates
         *
         * @param int $pColumn    Numeric column coordinate of the cell
         * @param int $pRow        Numeric row coordinate of the cell
         * @return PHPExcel_Comment
         */
        public function getCommentByColumnAndRow($pColumn = 0, $pRow = 1)
        {
        }
        /**
         * Get selected cell
         *
         * @deprecated
         * @return string
         */
        public function getSelectedCell()
        {
        }
        /**
         * Get active cell
         *
         * @return string Example: 'A1'
         */
        public function getActiveCell()
        {
        }
        /**
         * Get selected cells
         *
         * @return string
         */
        public function getSelectedCells()
        {
        }
        /**
         * Selected cell
         *
         * @param    string        $pCoordinate    Cell (i.e. A1)
         * @return PHPExcel_Worksheet
         */
        public function setSelectedCell($pCoordinate = 'A1')
        {
        }
        /**
         * Select a range of cells.
         *
         * @param    string        $pCoordinate    Cell range, examples: 'A1', 'B2:G5', 'A:C', '3:6'
         * @throws    PHPExcel_Exception
         * @return PHPExcel_Worksheet
         */
        public function setSelectedCells($pCoordinate = 'A1')
        {
        }
        /**
         * Selected cell by using numeric cell coordinates
         *
         * @param int $pColumn Numeric column coordinate of the cell
         * @param int $pRow Numeric row coordinate of the cell
         * @throws PHPExcel_Exception
         * @return PHPExcel_Worksheet
         */
        public function setSelectedCellByColumnAndRow($pColumn = 0, $pRow = 1)
        {
        }
        /**
         * Get right-to-left
         *
         * @return boolean
         */
        public function getRightToLeft()
        {
        }
        /**
         * Set right-to-left
         *
         * @param boolean $value    Right-to-left true/false
         * @return PHPExcel_Worksheet
         */
        public function setRightToLeft($value = \false)
        {
        }
        /**
         * Fill worksheet from values in array
         *
         * @param array $source Source array
         * @param mixed $nullValue Value in source array that stands for blank cell
         * @param string $startCell Insert array starting from this cell address as the top left coordinate
         * @param boolean $strictNullComparison Apply strict comparison when testing for null values in the array
         * @throws PHPExcel_Exception
         * @return PHPExcel_Worksheet
         */
        public function fromArray($source = \null, $nullValue = \null, $startCell = 'A1', $strictNullComparison = \false)
        {
        }
        /**
         * Create array from a range of cells
         *
         * @param string $pRange Range of cells (i.e. "A1:B10"), or just one cell (i.e. "A1")
         * @param mixed $nullValue Value returned in the array entry if a cell doesn't exist
         * @param boolean $calculateFormulas Should formulas be calculated?
         * @param boolean $formatData Should formatting be applied to cell values?
         * @param boolean $returnCellRef False - Return a simple array of rows and columns indexed by number counting from zero
         *                               True - Return rows and columns indexed by their actual row and column IDs
         * @return array
         */
        public function rangeToArray($pRange = 'A1', $nullValue = \null, $calculateFormulas = \true, $formatData = \true, $returnCellRef = \false)
        {
        }
        /**
         * Create array from a range of cells
         *
         * @param  string $pNamedRange Name of the Named Range
         * @param  mixed  $nullValue Value returned in the array entry if a cell doesn't exist
         * @param  boolean $calculateFormulas  Should formulas be calculated?
         * @param  boolean $formatData  Should formatting be applied to cell values?
         * @param  boolean $returnCellRef False - Return a simple array of rows and columns indexed by number counting from zero
         *                                True - Return rows and columns indexed by their actual row and column IDs
         * @return array
         * @throws PHPExcel_Exception
         */
        public function namedRangeToArray($pNamedRange = '', $nullValue = \null, $calculateFormulas = \true, $formatData = \true, $returnCellRef = \false)
        {
        }
        /**
         * Create array from worksheet
         *
         * @param mixed $nullValue Value returned in the array entry if a cell doesn't exist
         * @param boolean $calculateFormulas Should formulas be calculated?
         * @param boolean $formatData  Should formatting be applied to cell values?
         * @param boolean $returnCellRef False - Return a simple array of rows and columns indexed by number counting from zero
         *                               True - Return rows and columns indexed by their actual row and column IDs
         * @return array
         */
        public function toArray($nullValue = \null, $calculateFormulas = \true, $formatData = \true, $returnCellRef = \false)
        {
        }
        /**
         * Get row iterator
         *
         * @param  integer                           $startRow    The row number at which to start iterating
         * @return PHPExcel_Worksheet_RowIterator
         */
        public function getRowIterator($startRow = 1)
        {
        }
        /**
         * Run PHPExcel garabage collector.
         *
         * @return PHPExcel_Worksheet
         */
        public function garbageCollect()
        {
        }
        /**
         * Get hash code
         *
         * @return string    Hash code
         */
        public function getHashCode()
        {
        }
        /**
         * Extract worksheet title from range.
         *
         * Example: extractSheetTitle("testSheet!A1") ==> 'A1'
         * Example: extractSheetTitle("'testSheet 1'!A1", true) ==> array('testSheet 1', 'A1');
         *
         * @param string $pRange    Range to extract title from
         * @param bool $returnRange    Return range? (see example)
         * @return mixed
         */
        public static function extractSheetTitle($pRange, $returnRange = \false)
        {
        }
        /**
         * Get hyperlink
         *
         * @param string $pCellCoordinate    Cell coordinate to get hyperlink for
         */
        public function getHyperlink($pCellCoordinate = 'A1')
        {
        }
        /**
         * Set hyperlnk
         *
         * @param string $pCellCoordinate    Cell coordinate to insert hyperlink
         * @param    PHPExcel_Cell_Hyperlink    $pHyperlink
         * @return PHPExcel_Worksheet
         */
        public function setHyperlink($pCellCoordinate = 'A1', \PHPExcel_Cell_Hyperlink $pHyperlink = \null)
        {
        }
        /**
         * Hyperlink at a specific coordinate exists?
         *
         * @param string $pCoordinate
         * @return boolean
         */
        public function hyperlinkExists($pCoordinate = 'A1')
        {
        }
        /**
         * Get collection of hyperlinks
         *
         * @return PHPExcel_Cell_Hyperlink[]
         */
        public function getHyperlinkCollection()
        {
        }
        /**
         * Get data validation
         *
         * @param string $pCellCoordinate Cell coordinate to get data validation for
         */
        public function getDataValidation($pCellCoordinate = 'A1')
        {
        }
        /**
         * Set data validation
         *
         * @param string $pCellCoordinate    Cell coordinate to insert data validation
         * @param    PHPExcel_Cell_DataValidation    $pDataValidation
         * @return PHPExcel_Worksheet
         */
        public function setDataValidation($pCellCoordinate = 'A1', \PHPExcel_Cell_DataValidation $pDataValidation = \null)
        {
        }
        /**
         * Data validation at a specific coordinate exists?
         *
         * @param string $pCoordinate
         * @return boolean
         */
        public function dataValidationExists($pCoordinate = 'A1')
        {
        }
        /**
         * Get collection of data validations
         *
         * @return PHPExcel_Cell_DataValidation[]
         */
        public function getDataValidationCollection()
        {
        }
        /**
         * Accepts a range, returning it as a range that falls within the current highest row and column of the worksheet
         *
         * @param string $range
         * @return string Adjusted range value
         */
        public function shrinkRangeToFit($range)
        {
        }
        /**
         * Get tab color
         *
         * @return PHPExcel_Style_Color
         */
        public function getTabColor()
        {
        }
        /**
         * Reset tab color
         *
         * @return PHPExcel_Worksheet
         */
        public function resetTabColor()
        {
        }
        /**
         * Tab color set?
         *
         * @return boolean
         */
        public function isTabColorSet()
        {
        }
        /**
         * Copy worksheet (!= clone!)
         *
         * @return PHPExcel_Worksheet
         */
        public function copy()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
        /**
         * Define the code name of the sheet
         *
         * @param null|string Same rule as Title minus space not allowed (but, like Excel, change silently space to underscore)
         * @return objWorksheet
         * @throws PHPExcel_Exception
         */
        public function setCodeName($pValue = \null)
        {
        }
        /**
         * Return the code name of the sheet
         *
         * @return null|string
         */
        public function getCodeName()
        {
        }
        /**
         * Sheet has a code name ?
         * @return boolean
         */
        public function hasCodeName()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Style
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.4.5, 2007-08-23
     */
    /**
     * PHPExcel_Style_Protection
     *
     * @category   PHPExcel
     * @package    PHPExcel_Style
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Style_Protection extends \PHPExcel_Style_Supervisor implements \PHPExcel_IComparable
    {
        /** Protection styles */
        const PROTECTION_INHERIT = 'inherit';
        const PROTECTION_PROTECTED = 'protected';
        const PROTECTION_UNPROTECTED = 'unprotected';
        /**
         * Locked
         *
         * @var string
         */
        protected $_locked;
        /**
         * Hidden
         *
         * @var string
         */
        protected $_hidden;
        /**
         * Create a new PHPExcel_Style_Protection
         *
         * @param	boolean	$isSupervisor	Flag indicating if this is a supervisor or not
         *									Leave this value at default unless you understand exactly what
         *										its ramifications are
         * @param	boolean	$isConditional	Flag indicating if this is a conditional style or not
         *									Leave this value at default unless you understand exactly what
         *										its ramifications are
         */
        public function __construct($isSupervisor = \FALSE, $isConditional = \FALSE)
        {
        }
        /**
         * Get the shared style component for the currently active cell in currently active sheet.
         * Only used for style supervisor
         *
         * @return PHPExcel_Style_Protection
         */
        public function getSharedComponent()
        {
        }
        /**
         * Build style array from subcomponents
         *
         * @param array $array
         * @return array
         */
        public function getStyleArray($array)
        {
        }
        /**
         * Apply styles from array
         *
         * <code>
         * $objPHPExcel->getActiveSheet()->getStyle('B2')->getLocked()->applyFromArray(
         *		array(
         *			'locked' => TRUE,
         *			'hidden' => FALSE
         *		)
         * );
         * </code>
         *
         * @param	array	$pStyles	Array containing style information
         * @throws	PHPExcel_Exception
         * @return PHPExcel_Style_Protection
         */
        public function applyFromArray($pStyles = \NULL)
        {
        }
        /**
         * Get locked
         *
         * @return string
         */
        public function getLocked()
        {
        }
        /**
         * Set locked
         *
         * @param string $pValue
         * @return PHPExcel_Style_Protection
         */
        public function setLocked($pValue = self::PROTECTION_INHERIT)
        {
        }
        /**
         * Get hidden
         *
         * @return string
         */
        public function getHidden()
        {
        }
        /**
         * Set hidden
         *
         * @param string $pValue
         * @return PHPExcel_Style_Protection
         */
        public function setHidden($pValue = self::PROTECTION_INHERIT)
        {
        }
        /**
         * Get hash code
         *
         * @return string	Hash code
         */
        public function getHashCode()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package	PHPExcel_Style
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license	http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version	1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Style_Alignment
     *
     * @category   PHPExcel
     * @package	PHPExcel_Style
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Style_Alignment extends \PHPExcel_Style_Supervisor implements \PHPExcel_IComparable
    {
        /* Horizontal alignment styles */
        const HORIZONTAL_GENERAL = 'general';
        const HORIZONTAL_LEFT = 'left';
        const HORIZONTAL_RIGHT = 'right';
        const HORIZONTAL_CENTER = 'center';
        const HORIZONTAL_CENTER_CONTINUOUS = 'centerContinuous';
        const HORIZONTAL_JUSTIFY = 'justify';
        const HORIZONTAL_FILL = 'fill';
        const HORIZONTAL_DISTRIBUTED = 'distributed';
        // Excel2007 only
        /* Vertical alignment styles */
        const VERTICAL_BOTTOM = 'bottom';
        const VERTICAL_TOP = 'top';
        const VERTICAL_CENTER = 'center';
        const VERTICAL_JUSTIFY = 'justify';
        const VERTICAL_DISTRIBUTED = 'distributed';
        // Excel2007 only
        /**
         * Horizontal
         *
         * @var string
         */
        protected $_horizontal = \PHPExcel_Style_Alignment::HORIZONTAL_GENERAL;
        /**
         * Vertical
         *
         * @var string
         */
        protected $_vertical = \PHPExcel_Style_Alignment::VERTICAL_BOTTOM;
        /**
         * Text rotation
         *
         * @var int
         */
        protected $_textRotation = 0;
        /**
         * Wrap text
         *
         * @var boolean
         */
        protected $_wrapText = \FALSE;
        /**
         * Shrink to fit
         *
         * @var boolean
         */
        protected $_shrinkToFit = \FALSE;
        /**
         * Indent - only possible with horizontal alignment left and right
         *
         * @var int
         */
        protected $_indent = 0;
        /**
         * Create a new PHPExcel_Style_Alignment
         *
         * @param	boolean	$isSupervisor	Flag indicating if this is a supervisor or not
         *									Leave this value at default unless you understand exactly what
         *										its ramifications are
         * @param	boolean	$isConditional	Flag indicating if this is a conditional style or not
         *									Leave this value at default unless you understand exactly what
         *										its ramifications are
         */
        public function __construct($isSupervisor = \FALSE, $isConditional = \FALSE)
        {
        }
        /**
         * Get the shared style component for the currently active cell in currently active sheet.
         * Only used for style supervisor
         *
         * @return PHPExcel_Style_Alignment
         */
        public function getSharedComponent()
        {
        }
        /**
         * Build style array from subcomponents
         *
         * @param array $array
         * @return array
         */
        public function getStyleArray($array)
        {
        }
        /**
         * Apply styles from array
         *
         * <code>
         * $objPHPExcel->getActiveSheet()->getStyle('B2')->getAlignment()->applyFromArray(
         *		array(
         *			'horizontal' => PHPExcel_Style_Alignment::HORIZONTAL_CENTER,
         *			'vertical'   => PHPExcel_Style_Alignment::VERTICAL_CENTER,
         *			'rotation'   => 0,
         *			'wrap'			=> TRUE
         *		)
         * );
         * </code>
         *
         * @param	array	$pStyles	Array containing style information
         * @throws	PHPExcel_Exception
         * @return PHPExcel_Style_Alignment
         */
        public function applyFromArray($pStyles = \NULL)
        {
        }
        /**
         * Get Horizontal
         *
         * @return string
         */
        public function getHorizontal()
        {
        }
        /**
         * Set Horizontal
         *
         * @param string $pValue
         * @return PHPExcel_Style_Alignment
         */
        public function setHorizontal($pValue = \PHPExcel_Style_Alignment::HORIZONTAL_GENERAL)
        {
        }
        /**
         * Get Vertical
         *
         * @return string
         */
        public function getVertical()
        {
        }
        /**
         * Set Vertical
         *
         * @param string $pValue
         * @return PHPExcel_Style_Alignment
         */
        public function setVertical($pValue = \PHPExcel_Style_Alignment::VERTICAL_BOTTOM)
        {
        }
        /**
         * Get TextRotation
         *
         * @return int
         */
        public function getTextRotation()
        {
        }
        /**
         * Set TextRotation
         *
         * @param int $pValue
         * @throws PHPExcel_Exception
         * @return PHPExcel_Style_Alignment
         */
        public function setTextRotation($pValue = 0)
        {
        }
        /**
         * Get Wrap Text
         *
         * @return boolean
         */
        public function getWrapText()
        {
        }
        /**
         * Set Wrap Text
         *
         * @param boolean $pValue
         * @return PHPExcel_Style_Alignment
         */
        public function setWrapText($pValue = \FALSE)
        {
        }
        /**
         * Get Shrink to fit
         *
         * @return boolean
         */
        public function getShrinkToFit()
        {
        }
        /**
         * Set Shrink to fit
         *
         * @param boolean $pValue
         * @return PHPExcel_Style_Alignment
         */
        public function setShrinkToFit($pValue = \FALSE)
        {
        }
        /**
         * Get indent
         *
         * @return int
         */
        public function getIndent()
        {
        }
        /**
         * Set indent
         *
         * @param int $pValue
         * @return PHPExcel_Style_Alignment
         */
        public function setIndent($pValue = 0)
        {
        }
        /**
         * Get hash code
         *
         * @return string	Hash code
         */
        public function getHashCode()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package	PHPExcel_Style
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license	http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version	1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Style_Fill
     *
     * @category   PHPExcel
     * @package	PHPExcel_Style
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Style_Fill extends \PHPExcel_Style_Supervisor implements \PHPExcel_IComparable
    {
        /* Fill types */
        const FILL_NONE = 'none';
        const FILL_SOLID = 'solid';
        const FILL_GRADIENT_LINEAR = 'linear';
        const FILL_GRADIENT_PATH = 'path';
        const FILL_PATTERN_DARKDOWN = 'darkDown';
        const FILL_PATTERN_DARKGRAY = 'darkGray';
        const FILL_PATTERN_DARKGRID = 'darkGrid';
        const FILL_PATTERN_DARKHORIZONTAL = 'darkHorizontal';
        const FILL_PATTERN_DARKTRELLIS = 'darkTrellis';
        const FILL_PATTERN_DARKUP = 'darkUp';
        const FILL_PATTERN_DARKVERTICAL = 'darkVertical';
        const FILL_PATTERN_GRAY0625 = 'gray0625';
        const FILL_PATTERN_GRAY125 = 'gray125';
        const FILL_PATTERN_LIGHTDOWN = 'lightDown';
        const FILL_PATTERN_LIGHTGRAY = 'lightGray';
        const FILL_PATTERN_LIGHTGRID = 'lightGrid';
        const FILL_PATTERN_LIGHTHORIZONTAL = 'lightHorizontal';
        const FILL_PATTERN_LIGHTTRELLIS = 'lightTrellis';
        const FILL_PATTERN_LIGHTUP = 'lightUp';
        const FILL_PATTERN_LIGHTVERTICAL = 'lightVertical';
        const FILL_PATTERN_MEDIUMGRAY = 'mediumGray';
        /**
         * Fill type
         *
         * @var string
         */
        protected $_fillType = \PHPExcel_Style_Fill::FILL_NONE;
        /**
         * Rotation
         *
         * @var double
         */
        protected $_rotation = 0;
        /**
         * Start color
         *
         * @var PHPExcel_Style_Color
         */
        protected $_startColor;
        /**
         * End color
         *
         * @var PHPExcel_Style_Color
         */
        protected $_endColor;
        /**
         * Create a new PHPExcel_Style_Fill
         *
         * @param	boolean	$isSupervisor	Flag indicating if this is a supervisor or not
         *									Leave this value at default unless you understand exactly what
         *										its ramifications are
         * @param	boolean	$isConditional	Flag indicating if this is a conditional style or not
         *									Leave this value at default unless you understand exactly what
         *										its ramifications are
         */
        public function __construct($isSupervisor = \FALSE, $isConditional = \FALSE)
        {
        }
        /**
         * Get the shared style component for the currently active cell in currently active sheet.
         * Only used for style supervisor
         *
         * @return PHPExcel_Style_Fill
         */
        public function getSharedComponent()
        {
        }
        /**
         * Build style array from subcomponents
         *
         * @param array $array
         * @return array
         */
        public function getStyleArray($array)
        {
        }
        /**
         * Apply styles from array
         *
         * <code>
         * $objPHPExcel->getActiveSheet()->getStyle('B2')->getFill()->applyFromArray(
         *		array(
         *			'type'	   => PHPExcel_Style_Fill::FILL_GRADIENT_LINEAR,
         *			'rotation'   => 0,
         *			'startcolor' => array(
         *				'rgb' => '000000'
         *			),
         *			'endcolor'   => array(
         *				'argb' => 'FFFFFFFF'
         *			)
         *		)
         * );
         * </code>
         *
         * @param	array	$pStyles	Array containing style information
         * @throws	PHPExcel_Exception
         * @return PHPExcel_Style_Fill
         */
        public function applyFromArray($pStyles = \null)
        {
        }
        /**
         * Get Fill Type
         *
         * @return string
         */
        public function getFillType()
        {
        }
        /**
         * Set Fill Type
         *
         * @param string $pValue	PHPExcel_Style_Fill fill type
         * @return PHPExcel_Style_Fill
         */
        public function setFillType($pValue = \PHPExcel_Style_Fill::FILL_NONE)
        {
        }
        /**
         * Get Rotation
         *
         * @return double
         */
        public function getRotation()
        {
        }
        /**
         * Set Rotation
         *
         * @param double $pValue
         * @return PHPExcel_Style_Fill
         */
        public function setRotation($pValue = 0)
        {
        }
        /**
         * Get Start Color
         *
         * @return PHPExcel_Style_Color
         */
        public function getStartColor()
        {
        }
        /**
         * Set Start Color
         *
         * @param	PHPExcel_Style_Color $pValue
         * @throws	PHPExcel_Exception
         * @return PHPExcel_Style_Fill
         */
        public function setStartColor(\PHPExcel_Style_Color $pValue = \null)
        {
        }
        /**
         * Get End Color
         *
         * @return PHPExcel_Style_Color
         */
        public function getEndColor()
        {
        }
        /**
         * Set End Color
         *
         * @param	PHPExcel_Style_Color $pValue
         * @throws	PHPExcel_Exception
         * @return PHPExcel_Style_Fill
         */
        public function setEndColor(\PHPExcel_Style_Color $pValue = \null)
        {
        }
        /**
         * Get hash code
         *
         * @return string	Hash code
         */
        public function getHashCode()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package	PHPExcel_Style
     * @copyright Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version 1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Style_Color
     *
     * @category   PHPExcel
     * @package	PHPExcel_Style
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Style_Color extends \PHPExcel_Style_Supervisor implements \PHPExcel_IComparable
    {
        /* Colors */
        const COLOR_BLACK = 'FF000000';
        const COLOR_WHITE = 'FFFFFFFF';
        const COLOR_RED = 'FFFF0000';
        const COLOR_DARKRED = 'FF800000';
        const COLOR_BLUE = 'FF0000FF';
        const COLOR_DARKBLUE = 'FF000080';
        const COLOR_GREEN = 'FF00FF00';
        const COLOR_DARKGREEN = 'FF008000';
        const COLOR_YELLOW = 'FFFFFF00';
        const COLOR_DARKYELLOW = 'FF808000';
        /**
         * Indexed colors array
         *
         * @var array
         */
        protected static $_indexedColors;
        /**
         * ARGB - Alpha RGB
         *
         * @var string
         */
        protected $_argb = \NULL;
        /**
         * Parent property name
         *
         * @var string
         */
        protected $_parentPropertyName;
        /**
         * Create a new PHPExcel_Style_Color
         *
         * @param	string	$pARGB			ARGB value for the colour
         * @param	boolean	$isSupervisor	Flag indicating if this is a supervisor or not
         *									Leave this value at default unless you understand exactly what
         *										its ramifications are
         * @param	boolean	$isConditional	Flag indicating if this is a conditional style or not
         *									Leave this value at default unless you understand exactly what
         *										its ramifications are
         */
        public function __construct($pARGB = \PHPExcel_Style_Color::COLOR_BLACK, $isSupervisor = \FALSE, $isConditional = \FALSE)
        {
        }
        /**
         * Bind parent. Only used for supervisor
         *
         * @param mixed $parent
         * @param string $parentPropertyName
         * @return PHPExcel_Style_Color
         */
        public function bindParent($parent, $parentPropertyName = \NULL)
        {
        }
        /**
         * Get the shared style component for the currently active cell in currently active sheet.
         * Only used for style supervisor
         *
         * @return PHPExcel_Style_Color
         */
        public function getSharedComponent()
        {
        }
        /**
         * Build style array from subcomponents
         *
         * @param array $array
         * @return array
         */
        public function getStyleArray($array)
        {
        }
        /**
         * Apply styles from array
         *
         * <code>
         * $objPHPExcel->getActiveSheet()->getStyle('B2')->getFont()->getColor()->applyFromArray( array('rgb' => '808080') );
         * </code>
         *
         * @param	array	$pStyles	Array containing style information
         * @throws	PHPExcel_Exception
         * @return PHPExcel_Style_Color
         */
        public function applyFromArray($pStyles = \NULL)
        {
        }
        /**
         * Get ARGB
         *
         * @return string
         */
        public function getARGB()
        {
        }
        /**
         * Set ARGB
         *
         * @param string $pValue
         * @return PHPExcel_Style_Color
         */
        public function setARGB($pValue = \PHPExcel_Style_Color::COLOR_BLACK)
        {
        }
        /**
         * Get RGB
         *
         * @return string
         */
        public function getRGB()
        {
        }
        /**
         * Set RGB
         *
         * @param	string	$pValue	RGB value
         * @return PHPExcel_Style_Color
         */
        public function setRGB($pValue = '000000')
        {
        }
        /**
         * Get a specified colour component of an RGB value
         *
         * @private
         * @param	string		$RGB		The colour as an RGB value (e.g. FF00CCCC or CCDDEE
         * @param	int			$offset		Position within the RGB value to extract
         * @param	boolean		$hex		Flag indicating whether the component should be returned as a hex or a
         *									decimal value
         * @return	string		The extracted colour component
         */
        private static function _getColourComponent($RGB, $offset, $hex = \TRUE)
        {
        }
        /**
         * Get the red colour component of an RGB value
         *
         * @param	string		$RGB		The colour as an RGB value (e.g. FF00CCCC or CCDDEE
         * @param	boolean		$hex		Flag indicating whether the component should be returned as a hex or a
         *									decimal value
         * @return	string		The red colour component
         */
        public static function getRed($RGB, $hex = \TRUE)
        {
        }
        /**
         * Get the green colour component of an RGB value
         *
         * @param	string		$RGB		The colour as an RGB value (e.g. FF00CCCC or CCDDEE
         * @param	boolean		$hex		Flag indicating whether the component should be returned as a hex or a
         *									decimal value
         * @return	string		The green colour component
         */
        public static function getGreen($RGB, $hex = \TRUE)
        {
        }
        /**
         * Get the blue colour component of an RGB value
         *
         * @param	string		$RGB		The colour as an RGB value (e.g. FF00CCCC or CCDDEE
         * @param	boolean		$hex		Flag indicating whether the component should be returned as a hex or a
         *									decimal value
         * @return	string		The blue colour component
         */
        public static function getBlue($RGB, $hex = \TRUE)
        {
        }
        /**
         * Adjust the brightness of a color
         *
         * @param	string		$hex	The colour as an RGBA or RGB value (e.g. FF00CCCC or CCDDEE)
         * @param	float		$adjustPercentage	The percentage by which to adjust the colour as a float from -1 to 1
         * @return	string		The adjusted colour as an RGBA or RGB value (e.g. FF00CCCC or CCDDEE)
         */
        public static function changeBrightness($hex, $adjustPercentage)
        {
        }
        /**
         * Get indexed color
         *
         * @param	int			$pIndex			Index entry point into the colour array
         * @param	boolean		$background		Flag to indicate whether default background or foreground colour
         *											should be returned if the indexed colour doesn't exist
         * @return	PHPExcel_Style_Color
         */
        public static function indexedColor($pIndex, $background = \FALSE)
        {
        }
        /**
         * Get hash code
         *
         * @return string	Hash code
         */
        public function getHashCode()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Style
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Style_Conditional
     *
     * @category   PHPExcel
     * @package    PHPExcel_Style
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Style_Conditional implements \PHPExcel_IComparable
    {
        /* Condition types */
        const CONDITION_NONE = 'none';
        const CONDITION_CELLIS = 'cellIs';
        const CONDITION_CONTAINSTEXT = 'containsText';
        const CONDITION_EXPRESSION = 'expression';
        /* Operator types */
        const OPERATOR_NONE = '';
        const OPERATOR_BEGINSWITH = 'beginsWith';
        const OPERATOR_ENDSWITH = 'endsWith';
        const OPERATOR_EQUAL = 'equal';
        const OPERATOR_GREATERTHAN = 'greaterThan';
        const OPERATOR_GREATERTHANOREQUAL = 'greaterThanOrEqual';
        const OPERATOR_LESSTHAN = 'lessThan';
        const OPERATOR_LESSTHANOREQUAL = 'lessThanOrEqual';
        const OPERATOR_NOTEQUAL = 'notEqual';
        const OPERATOR_CONTAINSTEXT = 'containsText';
        const OPERATOR_NOTCONTAINS = 'notContains';
        const OPERATOR_BETWEEN = 'between';
        /**
         * Condition type
         *
         * @var int
         */
        private $_conditionType;
        /**
         * Operator type
         *
         * @var int
         */
        private $_operatorType;
        /**
         * Text
         *
         * @var string
         */
        private $_text;
        /**
         * Condition
         *
         * @var string[]
         */
        private $_condition = array();
        /**
         * Style
         *
         * @var PHPExcel_Style
         */
        private $_style;
        /**
         * Create a new PHPExcel_Style_Conditional
         */
        public function __construct()
        {
        }
        /**
         * Get Condition type
         *
         * @return string
         */
        public function getConditionType()
        {
        }
        /**
         * Set Condition type
         *
         * @param string $pValue	PHPExcel_Style_Conditional condition type
         * @return PHPExcel_Style_Conditional
         */
        public function setConditionType($pValue = \PHPExcel_Style_Conditional::CONDITION_NONE)
        {
        }
        /**
         * Get Operator type
         *
         * @return string
         */
        public function getOperatorType()
        {
        }
        /**
         * Set Operator type
         *
         * @param string $pValue	PHPExcel_Style_Conditional operator type
         * @return PHPExcel_Style_Conditional
         */
        public function setOperatorType($pValue = \PHPExcel_Style_Conditional::OPERATOR_NONE)
        {
        }
        /**
         * Get text
         *
         * @return string
         */
        public function getText()
        {
        }
        /**
         * Set text
         *
         * @param string $value
         * @return PHPExcel_Style_Conditional
         */
        public function setText($value = \null)
        {
        }
        /**
         * Get Condition
         *
         * @deprecated Deprecated, use getConditions instead
         * @return string
         */
        public function getCondition()
        {
        }
        /**
         * Set Condition
         *
         * @deprecated Deprecated, use setConditions instead
         * @param string $pValue	Condition
         * @return PHPExcel_Style_Conditional
         */
        public function setCondition($pValue = '')
        {
        }
        /**
         * Get Conditions
         *
         * @return string[]
         */
        public function getConditions()
        {
        }
        /**
         * Set Conditions
         *
         * @param string[] $pValue	Condition
         * @return PHPExcel_Style_Conditional
         */
        public function setConditions($pValue)
        {
        }
        /**
         * Add Condition
         *
         * @param string $pValue	Condition
         * @return PHPExcel_Style_Conditional
         */
        public function addCondition($pValue = '')
        {
        }
        /**
         * Get Style
         *
         * @return PHPExcel_Style
         */
        public function getStyle()
        {
        }
        /**
         * Set Style
         *
         * @param 	PHPExcel_Style $pValue
         * @throws 	PHPExcel_Exception
         * @return PHPExcel_Style_Conditional
         */
        public function setStyle(\PHPExcel_Style $pValue = \null)
        {
        }
        /**
         * Get hash code
         *
         * @return string	Hash code
         */
        public function getHashCode()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Style
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Style_Borders
     *
     * @category   PHPExcel
     * @package    PHPExcel_Style
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Style_Borders extends \PHPExcel_Style_Supervisor implements \PHPExcel_IComparable
    {
        /* Diagonal directions */
        const DIAGONAL_NONE = 0;
        const DIAGONAL_UP = 1;
        const DIAGONAL_DOWN = 2;
        const DIAGONAL_BOTH = 3;
        /**
         * Left
         *
         * @var PHPExcel_Style_Border
         */
        protected $_left;
        /**
         * Right
         *
         * @var PHPExcel_Style_Border
         */
        protected $_right;
        /**
         * Top
         *
         * @var PHPExcel_Style_Border
         */
        protected $_top;
        /**
         * Bottom
         *
         * @var PHPExcel_Style_Border
         */
        protected $_bottom;
        /**
         * Diagonal
         *
         * @var PHPExcel_Style_Border
         */
        protected $_diagonal;
        /**
         * DiagonalDirection
         *
         * @var int
         */
        protected $_diagonalDirection;
        /**
         * All borders psedo-border. Only applies to supervisor.
         *
         * @var PHPExcel_Style_Border
         */
        protected $_allBorders;
        /**
         * Outline psedo-border. Only applies to supervisor.
         *
         * @var PHPExcel_Style_Border
         */
        protected $_outline;
        /**
         * Inside psedo-border. Only applies to supervisor.
         *
         * @var PHPExcel_Style_Border
         */
        protected $_inside;
        /**
         * Vertical pseudo-border. Only applies to supervisor.
         *
         * @var PHPExcel_Style_Border
         */
        protected $_vertical;
        /**
         * Horizontal pseudo-border. Only applies to supervisor.
         *
         * @var PHPExcel_Style_Border
         */
        protected $_horizontal;
        /**
         * Create a new PHPExcel_Style_Borders
         *
         * @param	boolean	$isSupervisor	Flag indicating if this is a supervisor or not
         *									Leave this value at default unless you understand exactly what
         *										its ramifications are
         * @param	boolean	$isConditional	Flag indicating if this is a conditional style or not
         *									Leave this value at default unless you understand exactly what
         *										its ramifications are
         */
        public function __construct($isSupervisor = \FALSE, $isConditional = \FALSE)
        {
        }
        /**
         * Get the shared style component for the currently active cell in currently active sheet.
         * Only used for style supervisor
         *
         * @return PHPExcel_Style_Borders
         */
        public function getSharedComponent()
        {
        }
        /**
         * Build style array from subcomponents
         *
         * @param array $array
         * @return array
         */
        public function getStyleArray($array)
        {
        }
        /**
         * Apply styles from array
         *
         * <code>
         * $objPHPExcel->getActiveSheet()->getStyle('B2')->getBorders()->applyFromArray(
         * 		array(
         * 			'bottom'     => array(
         * 				'style' => PHPExcel_Style_Border::BORDER_DASHDOT,
         * 				'color' => array(
         * 					'rgb' => '808080'
         * 				)
         * 			),
         * 			'top'     => array(
         * 				'style' => PHPExcel_Style_Border::BORDER_DASHDOT,
         * 				'color' => array(
         * 					'rgb' => '808080'
         * 				)
         * 			)
         * 		)
         * );
         * </code>
         * <code>
         * $objPHPExcel->getActiveSheet()->getStyle('B2')->getBorders()->applyFromArray(
         * 		array(
         * 			'allborders' => array(
         * 				'style' => PHPExcel_Style_Border::BORDER_DASHDOT,
         * 				'color' => array(
         * 					'rgb' => '808080'
         * 				)
         * 			)
         * 		)
         * );
         * </code>
         *
         * @param	array	$pStyles	Array containing style information
         * @throws	PHPExcel_Exception
         * @return PHPExcel_Style_Borders
         */
        public function applyFromArray($pStyles = \null)
        {
        }
        /**
         * Get Left
         *
         * @return PHPExcel_Style_Border
         */
        public function getLeft()
        {
        }
        /**
         * Get Right
         *
         * @return PHPExcel_Style_Border
         */
        public function getRight()
        {
        }
        /**
         * Get Top
         *
         * @return PHPExcel_Style_Border
         */
        public function getTop()
        {
        }
        /**
         * Get Bottom
         *
         * @return PHPExcel_Style_Border
         */
        public function getBottom()
        {
        }
        /**
         * Get Diagonal
         *
         * @return PHPExcel_Style_Border
         */
        public function getDiagonal()
        {
        }
        /**
         * Get AllBorders (pseudo-border). Only applies to supervisor.
         *
         * @return PHPExcel_Style_Border
         * @throws PHPExcel_Exception
         */
        public function getAllBorders()
        {
        }
        /**
         * Get Outline (pseudo-border). Only applies to supervisor.
         *
         * @return boolean
         * @throws PHPExcel_Exception
         */
        public function getOutline()
        {
        }
        /**
         * Get Inside (pseudo-border). Only applies to supervisor.
         *
         * @return boolean
         * @throws PHPExcel_Exception
         */
        public function getInside()
        {
        }
        /**
         * Get Vertical (pseudo-border). Only applies to supervisor.
         *
         * @return PHPExcel_Style_Border
         * @throws PHPExcel_Exception
         */
        public function getVertical()
        {
        }
        /**
         * Get Horizontal (pseudo-border). Only applies to supervisor.
         *
         * @return PHPExcel_Style_Border
         * @throws PHPExcel_Exception
         */
        public function getHorizontal()
        {
        }
        /**
         * Get DiagonalDirection
         *
         * @return int
         */
        public function getDiagonalDirection()
        {
        }
        /**
         * Set DiagonalDirection
         *
         * @param int $pValue
         * @return PHPExcel_Style_Borders
         */
        public function setDiagonalDirection($pValue = \PHPExcel_Style_Borders::DIAGONAL_NONE)
        {
        }
        /**
         * Get hash code
         *
         * @return string	Hash code
         */
        public function getHashCode()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package	PHPExcel_Style
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license	http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version	1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Style_Font
     *
     * @category   PHPExcel
     * @package	PHPExcel_Style
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Style_Font extends \PHPExcel_Style_Supervisor implements \PHPExcel_IComparable
    {
        /* Underline types */
        const UNDERLINE_NONE = 'none';
        const UNDERLINE_DOUBLE = 'double';
        const UNDERLINE_DOUBLEACCOUNTING = 'doubleAccounting';
        const UNDERLINE_SINGLE = 'single';
        const UNDERLINE_SINGLEACCOUNTING = 'singleAccounting';
        /**
         * Font Name
         *
         * @var string
         */
        protected $_name = 'Calibri';
        /**
         * Font Size
         *
         * @var float
         */
        protected $_size = 11;
        /**
         * Bold
         *
         * @var boolean
         */
        protected $_bold = \FALSE;
        /**
         * Italic
         *
         * @var boolean
         */
        protected $_italic = \FALSE;
        /**
         * Superscript
         *
         * @var boolean
         */
        protected $_superScript = \FALSE;
        /**
         * Subscript
         *
         * @var boolean
         */
        protected $_subScript = \FALSE;
        /**
         * Underline
         *
         * @var string
         */
        protected $_underline = self::UNDERLINE_NONE;
        /**
         * Strikethrough
         *
         * @var boolean
         */
        protected $_strikethrough = \FALSE;
        /**
         * Foreground color
         *
         * @var PHPExcel_Style_Color
         */
        protected $_color;
        /**
         * Create a new PHPExcel_Style_Font
         *
         * @param	boolean	$isSupervisor	Flag indicating if this is a supervisor or not
         *									Leave this value at default unless you understand exactly what
         *										its ramifications are
         * @param	boolean	$isConditional	Flag indicating if this is a conditional style or not
         *									Leave this value at default unless you understand exactly what
         *										its ramifications are
         */
        public function __construct($isSupervisor = \FALSE, $isConditional = \FALSE)
        {
        }
        /**
         * Get the shared style component for the currently active cell in currently active sheet.
         * Only used for style supervisor
         *
         * @return PHPExcel_Style_Font
         */
        public function getSharedComponent()
        {
        }
        /**
         * Build style array from subcomponents
         *
         * @param array $array
         * @return array
         */
        public function getStyleArray($array)
        {
        }
        /**
         * Apply styles from array
         *
         * <code>
         * $objPHPExcel->getActiveSheet()->getStyle('B2')->getFont()->applyFromArray(
         *		array(
         *			'name'		=> 'Arial',
         *			'bold'		=> TRUE,
         *			'italic'	=> FALSE,
         *			'underline' => PHPExcel_Style_Font::UNDERLINE_DOUBLE,
         *			'strike'	=> FALSE,
         *			'color'		=> array(
         *				'rgb' => '808080'
         *			)
         *		)
         * );
         * </code>
         *
         * @param	array	$pStyles	Array containing style information
         * @throws	PHPExcel_Exception
         * @return PHPExcel_Style_Font
         */
        public function applyFromArray($pStyles = \null)
        {
        }
        /**
         * Get Name
         *
         * @return string
         */
        public function getName()
        {
        }
        /**
         * Set Name
         *
         * @param string $pValue
         * @return PHPExcel_Style_Font
         */
        public function setName($pValue = 'Calibri')
        {
        }
        /**
         * Get Size
         *
         * @return double
         */
        public function getSize()
        {
        }
        /**
         * Set Size
         *
         * @param double $pValue
         * @return PHPExcel_Style_Font
         */
        public function setSize($pValue = 10)
        {
        }
        /**
         * Get Bold
         *
         * @return boolean
         */
        public function getBold()
        {
        }
        /**
         * Set Bold
         *
         * @param boolean $pValue
         * @return PHPExcel_Style_Font
         */
        public function setBold($pValue = \false)
        {
        }
        /**
         * Get Italic
         *
         * @return boolean
         */
        public function getItalic()
        {
        }
        /**
         * Set Italic
         *
         * @param boolean $pValue
         * @return PHPExcel_Style_Font
         */
        public function setItalic($pValue = \false)
        {
        }
        /**
         * Get SuperScript
         *
         * @return boolean
         */
        public function getSuperScript()
        {
        }
        /**
         * Set SuperScript
         *
         * @param boolean $pValue
         * @return PHPExcel_Style_Font
         */
        public function setSuperScript($pValue = \false)
        {
        }
        /**
         * Get SubScript
         *
         * @return boolean
         */
        public function getSubScript()
        {
        }
        /**
         * Set SubScript
         *
         * @param boolean $pValue
         * @return PHPExcel_Style_Font
         */
        public function setSubScript($pValue = \false)
        {
        }
        /**
         * Get Underline
         *
         * @return string
         */
        public function getUnderline()
        {
        }
        /**
         * Set Underline
         *
         * @param string|boolean $pValue	PHPExcel_Style_Font underline type
         *									If a boolean is passed, then TRUE equates to UNDERLINE_SINGLE,
         *										false equates to UNDERLINE_NONE
         * @return PHPExcel_Style_Font
         */
        public function setUnderline($pValue = self::UNDERLINE_NONE)
        {
        }
        /**
         * Get Strikethrough
         *
         * @return boolean
         */
        public function getStrikethrough()
        {
        }
        /**
         * Set Strikethrough
         *
         * @param boolean $pValue
         * @return PHPExcel_Style_Font
         */
        public function setStrikethrough($pValue = \false)
        {
        }
        /**
         * Get Color
         *
         * @return PHPExcel_Style_Color
         */
        public function getColor()
        {
        }
        /**
         * Set Color
         *
         * @param	PHPExcel_Style_Color $pValue
         * @throws	PHPExcel_Exception
         * @return PHPExcel_Style_Font
         */
        public function setColor(\PHPExcel_Style_Color $pValue = \null)
        {
        }
        /**
         * Get hash code
         *
         * @return string	Hash code
         */
        public function getHashCode()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package	PHPExcel_Style
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license	http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version	1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Style_Border
     *
     * @category   PHPExcel
     * @package	PHPExcel_Style
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Style_Border extends \PHPExcel_Style_Supervisor implements \PHPExcel_IComparable
    {
        /* Border style */
        const BORDER_NONE = 'none';
        const BORDER_DASHDOT = 'dashDot';
        const BORDER_DASHDOTDOT = 'dashDotDot';
        const BORDER_DASHED = 'dashed';
        const BORDER_DOTTED = 'dotted';
        const BORDER_DOUBLE = 'double';
        const BORDER_HAIR = 'hair';
        const BORDER_MEDIUM = 'medium';
        const BORDER_MEDIUMDASHDOT = 'mediumDashDot';
        const BORDER_MEDIUMDASHDOTDOT = 'mediumDashDotDot';
        const BORDER_MEDIUMDASHED = 'mediumDashed';
        const BORDER_SLANTDASHDOT = 'slantDashDot';
        const BORDER_THICK = 'thick';
        const BORDER_THIN = 'thin';
        /**
         * Border style
         *
         * @var string
         */
        protected $_borderStyle = \PHPExcel_Style_Border::BORDER_NONE;
        /**
         * Border color
         *
         * @var PHPExcel_Style_Color
         */
        protected $_color;
        /**
         * Parent property name
         *
         * @var string
         */
        protected $_parentPropertyName;
        /**
         * Create a new PHPExcel_Style_Border
         *
         * @param	boolean	$isSupervisor	Flag indicating if this is a supervisor or not
         *									Leave this value at default unless you understand exactly what
         *										its ramifications are
         * @param	boolean	$isConditional	Flag indicating if this is a conditional style or not
         *									Leave this value at default unless you understand exactly what
         *										its ramifications are
         */
        public function __construct($isSupervisor = \FALSE, $isConditional = \FALSE)
        {
        }
        /**
         * Bind parent. Only used for supervisor
         *
         * @param PHPExcel_Style_Borders $parent
         * @param string $parentPropertyName
         * @return PHPExcel_Style_Border
         */
        public function bindParent($parent, $parentPropertyName = \NULL)
        {
        }
        /**
         * Get the shared style component for the currently active cell in currently active sheet.
         * Only used for style supervisor
         *
         * @return PHPExcel_Style_Border
         * @throws PHPExcel_Exception
         */
        public function getSharedComponent()
        {
        }
        /**
         * Build style array from subcomponents
         *
         * @param array $array
         * @return array
         */
        public function getStyleArray($array)
        {
        }
        /**
         * Apply styles from array
         *
         * <code>
         * $objPHPExcel->getActiveSheet()->getStyle('B2')->getBorders()->getTop()->applyFromArray(
         *		array(
         *			'style' => PHPExcel_Style_Border::BORDER_DASHDOT,
         *			'color' => array(
         *				'rgb' => '808080'
         *			)
         *		)
         * );
         * </code>
         *
         * @param	array	$pStyles	Array containing style information
         * @throws	PHPExcel_Exception
         * @return PHPExcel_Style_Border
         */
        public function applyFromArray($pStyles = \null)
        {
        }
        /**
         * Get Border style
         *
         * @return string
         */
        public function getBorderStyle()
        {
        }
        /**
         * Set Border style
         *
         * @param string|boolean	$pValue
         *							When passing a boolean, FALSE equates PHPExcel_Style_Border::BORDER_NONE
         *								and TRUE to PHPExcel_Style_Border::BORDER_MEDIUM
         * @return PHPExcel_Style_Border
         */
        public function setBorderStyle($pValue = \PHPExcel_Style_Border::BORDER_NONE)
        {
        }
        /**
         * Get Border Color
         *
         * @return PHPExcel_Style_Color
         */
        public function getColor()
        {
        }
        /**
         * Set Border Color
         *
         * @param	PHPExcel_Style_Color $pValue
         * @throws	PHPExcel_Exception
         * @return PHPExcel_Style_Border
         */
        public function setColor(\PHPExcel_Style_Color $pValue = \null)
        {
        }
        /**
         * Get hash code
         *
         * @return string	Hash code
         */
        public function getHashCode()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package	PHPExcel_Style
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license	http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version	1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Style_NumberFormat
     *
     * @category   PHPExcel
     * @package	PHPExcel_Style
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Style_NumberFormat extends \PHPExcel_Style_Supervisor implements \PHPExcel_IComparable
    {
        /* Pre-defined formats */
        const FORMAT_GENERAL = 'General';
        const FORMAT_TEXT = '@';
        const FORMAT_NUMBER = '0';
        const FORMAT_NUMBER_00 = '0.00';
        const FORMAT_NUMBER_COMMA_SEPARATED1 = '#,##0.00';
        const FORMAT_NUMBER_COMMA_SEPARATED2 = '#,##0.00_-';
        const FORMAT_PERCENTAGE = '0%';
        const FORMAT_PERCENTAGE_00 = '0.00%';
        const FORMAT_DATE_YYYYMMDD2 = 'yyyy-mm-dd';
        const FORMAT_DATE_YYYYMMDD = 'yy-mm-dd';
        const FORMAT_DATE_DDMMYYYY = 'dd/mm/yy';
        const FORMAT_DATE_DMYSLASH = 'd/m/y';
        const FORMAT_DATE_DMYMINUS = 'd-m-y';
        const FORMAT_DATE_DMMINUS = 'd-m';
        const FORMAT_DATE_MYMINUS = 'm-y';
        const FORMAT_DATE_XLSX14 = 'mm-dd-yy';
        const FORMAT_DATE_XLSX15 = 'd-mmm-yy';
        const FORMAT_DATE_XLSX16 = 'd-mmm';
        const FORMAT_DATE_XLSX17 = 'mmm-yy';
        const FORMAT_DATE_XLSX22 = 'm/d/yy h:mm';
        const FORMAT_DATE_DATETIME = 'd/m/y h:mm';
        const FORMAT_DATE_TIME1 = 'h:mm AM/PM';
        const FORMAT_DATE_TIME2 = 'h:mm:ss AM/PM';
        const FORMAT_DATE_TIME3 = 'h:mm';
        const FORMAT_DATE_TIME4 = 'h:mm:ss';
        const FORMAT_DATE_TIME5 = 'mm:ss';
        const FORMAT_DATE_TIME6 = 'h:mm:ss';
        const FORMAT_DATE_TIME7 = 'i:s.S';
        const FORMAT_DATE_TIME8 = 'h:mm:ss;@';
        const FORMAT_DATE_YYYYMMDDSLASH = 'yy/mm/dd;@';
        const FORMAT_CURRENCY_USD_SIMPLE = '"$"#,##0.00_-';
        const FORMAT_CURRENCY_USD = '$#,##0_-';
        const FORMAT_CURRENCY_EUR_SIMPLE = '[$EUR ]#,##0.00_-';
        /**
         * Excel built-in number formats
         *
         * @var array
         */
        protected static $_builtInFormats;
        /**
         * Excel built-in number formats (flipped, for faster lookups)
         *
         * @var array
         */
        protected static $_flippedBuiltInFormats;
        /**
         * Format Code
         *
         * @var string
         */
        protected $_formatCode = \PHPExcel_Style_NumberFormat::FORMAT_GENERAL;
        /**
         * Built-in format Code
         *
         * @var string
         */
        protected $_builtInFormatCode = 0;
        /**
         * Create a new PHPExcel_Style_NumberFormat
         *
         * @param	boolean	$isSupervisor	Flag indicating if this is a supervisor or not
         *									Leave this value at default unless you understand exactly what
         *										its ramifications are
         * @param	boolean	$isConditional	Flag indicating if this is a conditional style or not
         *									Leave this value at default unless you understand exactly what
         *										its ramifications are
         */
        public function __construct($isSupervisor = \FALSE, $isConditional = \FALSE)
        {
        }
        /**
         * Get the shared style component for the currently active cell in currently active sheet.
         * Only used for style supervisor
         *
         * @return PHPExcel_Style_NumberFormat
         */
        public function getSharedComponent()
        {
        }
        /**
         * Build style array from subcomponents
         *
         * @param array $array
         * @return array
         */
        public function getStyleArray($array)
        {
        }
        /**
         * Apply styles from array
         *
         * <code>
         * $objPHPExcel->getActiveSheet()->getStyle('B2')->getNumberFormat()->applyFromArray(
         *		array(
         *			'code' => PHPExcel_Style_NumberFormat::FORMAT_CURRENCY_EUR_SIMPLE
         *		)
         * );
         * </code>
         *
         * @param	array	$pStyles	Array containing style information
         * @throws	PHPExcel_Exception
         * @return PHPExcel_Style_NumberFormat
         */
        public function applyFromArray($pStyles = \null)
        {
        }
        /**
         * Get Format Code
         *
         * @return string
         */
        public function getFormatCode()
        {
        }
        /**
         * Set Format Code
         *
         * @param string $pValue
         * @return PHPExcel_Style_NumberFormat
         */
        public function setFormatCode($pValue = \PHPExcel_Style_NumberFormat::FORMAT_GENERAL)
        {
        }
        /**
         * Get Built-In Format Code
         *
         * @return int
         */
        public function getBuiltInFormatCode()
        {
        }
        /**
         * Set Built-In Format Code
         *
         * @param int $pValue
         * @return PHPExcel_Style_NumberFormat
         */
        public function setBuiltInFormatCode($pValue = 0)
        {
        }
        /**
         * Fill built-in format codes
         */
        private static function fillBuiltInFormatCodes()
        {
        }
        /**
         * Get built-in format code
         *
         * @param	int		$pIndex
         * @return	string
         */
        public static function builtInFormatCode($pIndex)
        {
        }
        /**
         * Get built-in format code index
         *
         * @param	string		$formatCode
         * @return	int|boolean
         */
        public static function builtInFormatCodeIndex($formatCode)
        {
        }
        /**
         * Get hash code
         *
         * @return string	Hash code
         */
        public function getHashCode()
        {
        }
        /**
         * Search/replace values to convert Excel date/time format masks to PHP format masks
         *
         * @var array
         */
        private static $_dateFormatReplacements = array(
            // first remove escapes related to non-format characters
            '\\' => '',
            //	12-hour suffix
            'am/pm' => 'A',
            //	4-digit year
            'e' => 'Y',
            'yyyy' => 'Y',
            //	2-digit year
            'yy' => 'y',
            //	first letter of month - no php equivalent
            'mmmmm' => 'M',
            //	full month name
            'mmmm' => 'F',
            //	short month name
            'mmm' => 'M',
            //	mm is minutes if time, but can also be month w/leading zero
            //	so we try to identify times be the inclusion of a : separator in the mask
            //	It isn't perfect, but the best way I know how
            ':mm' => ':i',
            'mm:' => 'i:',
            //	month leading zero
            'mm' => 'm',
            //	month no leading zero
            'm' => 'n',
            //	full day of week name
            'dddd' => 'l',
            //	short day of week name
            'ddd' => 'D',
            //	days leading zero
            'dd' => 'd',
            //	days no leading zero
            'd' => 'j',
            //	seconds
            'ss' => 's',
            //	fractional seconds - no php equivalent
            '.s' => '',
        );
        /**
         * Search/replace values to convert Excel date/time format masks hours to PHP format masks (24 hr clock)
         *
         * @var array
         */
        private static $_dateFormatReplacements24 = array('hh' => 'H', 'h' => 'G');
        /**
         * Search/replace values to convert Excel date/time format masks hours to PHP format masks (12 hr clock)
         *
         * @var array
         */
        private static $_dateFormatReplacements12 = array('hh' => 'h', 'h' => 'g');
        private static function _formatAsDate(&$value, &$format)
        {
        }
        private static function _formatAsPercentage(&$value, &$format)
        {
        }
        private static function _formatAsFraction(&$value, &$format)
        {
        }
        private static function _complexNumberFormatMask($number, $mask)
        {
        }
        /**
         * Convert a value in a pre-defined format to a PHP string
         *
         * @param mixed	$value		Value to format
         * @param string	$format		Format code
         * @param array		$callBack	Callback function for additional formatting of string
         * @return string	Formatted string
         */
        public static function toFormattedString($value = '0', $format = \PHPExcel_Style_NumberFormat::FORMAT_GENERAL, $callBack = \null)
        {
        }
    }
    /**
     * PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_RichText
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_RichText_ITextElement
     *
     * @category   PHPExcel
     * @package    PHPExcel_RichText
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    interface PHPExcel_RichText_ITextElement
    {
        /**
         * Get text
         *
         * @return string	Text
         */
        public function getText();
        /**
         * Set text
         *
         * @param 	$pText string	Text
         * @return PHPExcel_RichText_ITextElement
         */
        public function setText($pText = '');
        /**
         * Get font
         *
         * @return PHPExcel_Style_Font
         */
        public function getFont();
        /**
         * Get hash code
         *
         * @return string	Hash code
         */
        public function getHashCode();
    }
    /**
     * PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_RichText
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_RichText_TextElement
     *
     * @category   PHPExcel
     * @package    PHPExcel_RichText
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_RichText_TextElement implements \PHPExcel_RichText_ITextElement
    {
        /**
         * Text
         *
         * @var string
         */
        private $_text;
        /**
         * Create a new PHPExcel_RichText_TextElement instance
         *
         * @param 	string		$pText		Text
         */
        public function __construct($pText = '')
        {
        }
        /**
         * Get text
         *
         * @return string	Text
         */
        public function getText()
        {
        }
        /**
         * Set text
         *
         * @param 	$pText string	Text
         * @return PHPExcel_RichText_ITextElement
         */
        public function setText($pText = '')
        {
        }
        /**
         * Get font
         *
         * @return PHPExcel_Style_Font
         */
        public function getFont()
        {
        }
        /**
         * Get hash code
         *
         * @return string	Hash code
         */
        public function getHashCode()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    /**
     * PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_RichText
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_RichText_Run
     *
     * @category   PHPExcel
     * @package    PHPExcel_RichText
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_RichText_Run extends \PHPExcel_RichText_TextElement implements \PHPExcel_RichText_ITextElement
    {
        /**
         * Font
         *
         * @var PHPExcel_Style_Font
         */
        private $_font;
        /**
         * Create a new PHPExcel_RichText_Run instance
         *
         * @param 	string		$pText		Text
         */
        public function __construct($pText = '')
        {
        }
        /**
         * Get font
         *
         * @return PHPExcel_Style_Font
         */
        public function getFont()
        {
        }
        /**
         * Set font
         *
         * @param	PHPExcel_Style_Font		$pFont		Font
         * @throws 	PHPExcel_Exception
         * @return PHPExcel_RichText_ITextElement
         */
        public function setFont(\PHPExcel_Style_Font $pFont = \null)
        {
        }
        /**
         * Get hash code
         *
         * @return string	Hash code
         */
        public function getHashCode()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_DocumentSecurity
     *
     * @category   PHPExcel
     * @package    PHPExcel
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_DocumentSecurity
    {
        /**
         * LockRevision
         *
         * @var boolean
         */
        private $_lockRevision;
        /**
         * LockStructure
         *
         * @var boolean
         */
        private $_lockStructure;
        /**
         * LockWindows
         *
         * @var boolean
         */
        private $_lockWindows;
        /**
         * RevisionsPassword
         *
         * @var string
         */
        private $_revisionsPassword;
        /**
         * WorkbookPassword
         *
         * @var string
         */
        private $_workbookPassword;
        /**
         * Create a new PHPExcel_DocumentSecurity
         */
        public function __construct()
        {
        }
        /**
         * Is some sort of dcument security enabled?
         *
         * @return boolean
         */
        function isSecurityEnabled()
        {
        }
        /**
         * Get LockRevision
         *
         * @return boolean
         */
        function getLockRevision()
        {
        }
        /**
         * Set LockRevision
         *
         * @param boolean $pValue
         * @return PHPExcel_DocumentSecurity
         */
        function setLockRevision($pValue = \false)
        {
        }
        /**
         * Get LockStructure
         *
         * @return boolean
         */
        function getLockStructure()
        {
        }
        /**
         * Set LockStructure
         *
         * @param boolean $pValue
         * @return PHPExcel_DocumentSecurity
         */
        function setLockStructure($pValue = \false)
        {
        }
        /**
         * Get LockWindows
         *
         * @return boolean
         */
        function getLockWindows()
        {
        }
        /**
         * Set LockWindows
         *
         * @param boolean $pValue
         * @return PHPExcel_DocumentSecurity
         */
        function setLockWindows($pValue = \false)
        {
        }
        /**
         * Get RevisionsPassword (hashed)
         *
         * @return string
         */
        function getRevisionsPassword()
        {
        }
        /**
         * Set RevisionsPassword
         *
         * @param string 	$pValue
         * @param boolean 	$pAlreadyHashed If the password has already been hashed, set this to true
         * @return PHPExcel_DocumentSecurity
         */
        function setRevisionsPassword($pValue = '', $pAlreadyHashed = \false)
        {
        }
        /**
         * Get WorkbookPassword (hashed)
         *
         * @return string
         */
        function getWorkbookPassword()
        {
        }
        /**
         * Set WorkbookPassword
         *
         * @param string 	$pValue
         * @param boolean 	$pAlreadyHashed If the password has already been hashed, set this to true
         * @return PHPExcel_DocumentSecurity
         */
        function setWorkbookPassword($pValue = '', $pAlreadyHashed = \false)
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    /**
     * PHPExcel_IOFactory
     *
     * @category   PHPExcel
     * @package    PHPExcel
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_IOFactory
    {
        /**
         * Search locations
         *
         * @var	array
         * @access	private
         * @static
         */
        private static $_searchLocations = array(array('type' => 'IWriter', 'path' => 'PHPExcel/Writer/{0}.php', 'class' => 'PHPExcel_Writer_{0}'), array('type' => 'IReader', 'path' => 'PHPExcel/Reader/{0}.php', 'class' => 'PHPExcel_Reader_{0}'));
        /**
         * Autoresolve classes
         *
         * @var	array
         * @access	private
         * @static
         */
        private static $_autoResolveClasses = array('Excel2007', 'Excel5', 'Excel2003XML', 'OOCalc', 'SYLK', 'Gnumeric', 'HTML', 'CSV');
        /**
         *	Private constructor for PHPExcel_IOFactory
         */
        private function __construct()
        {
        }
        /**
         * Get search locations
         *
         * @static
         * @access	public
         * @return	array
         */
        public static function getSearchLocations()
        {
        }
        //	function getSearchLocations()
        /**
         * Set search locations
         *
         * @static
         * @access	public
         * @param	array $value
         * @throws	PHPExcel_Reader_Exception
         */
        public static function setSearchLocations($value)
        {
        }
        //	function setSearchLocations()
        /**
         * Add search location
         *
         * @static
         * @access	public
         * @param	string $type		Example: IWriter
         * @param	string $location	Example: PHPExcel/Writer/{0}.php
         * @param	string $classname 	Example: PHPExcel_Writer_{0}
         */
        public static function addSearchLocation($type = '', $location = '', $classname = '')
        {
        }
        //	function addSearchLocation()
        /**
         * Create PHPExcel_Writer_IWriter
         *
         * @static
         * @access	public
         * @param	PHPExcel $phpExcel
         * @param	string  $writerType	Example: Excel2007
         * @return	PHPExcel_Writer_IWriter
         * @throws	PHPExcel_Reader_Exception
         */
        public static function createWriter(\PHPExcel $phpExcel, $writerType = '')
        {
        }
        //	function createWriter()
        /**
         * Create PHPExcel_Reader_IReader
         *
         * @static
         * @access	public
         * @param	string $readerType	Example: Excel2007
         * @return	PHPExcel_Reader_IReader
         * @throws	PHPExcel_Reader_Exception
         */
        public static function createReader($readerType = '')
        {
        }
        //	function createReader()
        /**
         * Loads PHPExcel from file using automatic PHPExcel_Reader_IReader resolution
         *
         * @static
         * @access public
         * @param 	string 		$pFilename		The name of the spreadsheet file
         * @return	PHPExcel
         * @throws	PHPExcel_Reader_Exception
         */
        public static function load($pFilename)
        {
        }
        //	function load()
        /**
         * Identify file type using automatic PHPExcel_Reader_IReader resolution
         *
         * @static
         * @access public
         * @param 	string 		$pFilename		The name of the spreadsheet file to identify
         * @return	string
         * @throws	PHPExcel_Reader_Exception
         */
        public static function identify($pFilename)
        {
        }
        //	function identify()
        /**
         * Create PHPExcel_Reader_IReader for file using automatic PHPExcel_Reader_IReader resolution
         *
         * @static
         * @access	public
         * @param 	string 		$pFilename		The name of the spreadsheet file
         * @return	PHPExcel_Reader_IReader
         * @throws	PHPExcel_Reader_Exception
         */
        public static function createReaderForFile($pFilename)
        {
        }
        //	function createReaderForFile()
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Calculation
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license	http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version	1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_CalcEngine_CyclicReferenceStack
     *
     * @category	PHPExcel_CalcEngine_CyclicReferenceStack
     * @package		PHPExcel_Calculation
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_CalcEngine_CyclicReferenceStack
    {
        /**
         *  The call stack for calculated cells
         *
         *  @var mixed[]
         */
        private $_stack = array();
        /**
         * Return the number of entries on the stack
         *
         * @return  integer
         */
        public function count()
        {
        }
        /**
         * Push a new entry onto the stack
         *
         * @param  mixed  $value
         */
        public function push($value)
        {
        }
        //	function push()
        /**
         * Pop the last entry from the stack
         *
         * @return  mixed
         */
        public function pop()
        {
        }
        //	function pop()
        /**
         * Test to see if a specified entry exists on the stack
         *
         * @param  mixed  $value  The value to test
         */
        public function onStack($value)
        {
        }
        /**
         * Clear the stack
         */
        public function clear()
        {
        }
        //	function push()
        /**
         * Return an array of all entries on the stack
         *
         * @return  mixed[]
         */
        public function showStack()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Calculation
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license	http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version	1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_CalcEngine_Logger
     *
     * @category	PHPExcel
     * @package		PHPExcel_Calculation
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_CalcEngine_Logger
    {
        /**
         * Flag to determine whether a debug log should be generated by the calculation engine
         *		If true, then a debug log will be generated
         *		If false, then a debug log will not be generated
         *
         * @var boolean
         */
        private $_writeDebugLog = \FALSE;
        /**
         * Flag to determine whether a debug log should be echoed by the calculation engine
         *		If true, then a debug log will be echoed
         *		If false, then a debug log will not be echoed
         * A debug log can only be echoed if it is generated
         *
         * @var boolean
         */
        private $_echoDebugLog = \FALSE;
        /**
         * The debug log generated by the calculation engine
         *
         * @var string[]
         */
        private $_debugLog = array();
        /**
         * The calculation engine cell reference stack
         *
         * @var PHPExcel_CalcEngine_CyclicReferenceStack
         */
        private $_cellStack;
        /**
         * Instantiate a Calculation engine logger
         *
         * @param  PHPExcel_CalcEngine_CyclicReferenceStack $stack
         */
        public function __construct(\PHPExcel_CalcEngine_CyclicReferenceStack $stack)
        {
        }
        /**
         * Enable/Disable Calculation engine logging
         *
         * @param  boolean $pValue
         */
        public function setWriteDebugLog($pValue = \FALSE)
        {
        }
        /**
         * Return whether calculation engine logging is enabled or disabled
         *
         * @return  boolean
         */
        public function getWriteDebugLog()
        {
        }
        /**
         * Enable/Disable echoing of debug log information
         *
         * @param  boolean $pValue
         */
        public function setEchoDebugLog($pValue = \FALSE)
        {
        }
        /**
         * Return whether echoing of debug log information is enabled or disabled
         *
         * @return  boolean
         */
        public function getEchoDebugLog()
        {
        }
        /**
         * Write an entry to the calculation engine debug log
         */
        public function writeDebugLog()
        {
        }
        //	function _writeDebug()
        /**
         * Clear the calculation engine debug log
         */
        public function clearLog()
        {
        }
        //	function flushLogger()
        /**
         * Return the calculation engine debug log
         *
         * @return  string[]
         */
        public function getLog()
        {
        }
        //	function flushLogger()
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_NamedRange
     *
     * @category   PHPExcel
     * @package    PHPExcel
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_NamedRange
    {
        /**
         * Range name
         *
         * @var string
         */
        private $_name;
        /**
         * Worksheet on which the named range can be resolved
         *
         * @var PHPExcel_Worksheet
         */
        private $_worksheet;
        /**
         * Range of the referenced cells
         *
         * @var string
         */
        private $_range;
        /**
         * Is the named range local? (i.e. can only be used on $this->_worksheet)
         *
         * @var bool
         */
        private $_localOnly;
        /**
         * Scope
         *
         * @var PHPExcel_Worksheet
         */
        private $_scope;
        /**
         * Create a new NamedRange
         *
         * @param string $pName
         * @param PHPExcel_Worksheet $pWorksheet
         * @param string $pRange
         * @param bool $pLocalOnly
         * @param PHPExcel_Worksheet|null $pScope	Scope. Only applies when $pLocalOnly = true. Null for global scope.
         * @throws PHPExcel_Exception
         */
        public function __construct($pName = \null, \PHPExcel_Worksheet $pWorksheet, $pRange = 'A1', $pLocalOnly = \false, $pScope = \null)
        {
        }
        /**
         * Get name
         *
         * @return string
         */
        public function getName()
        {
        }
        /**
         * Set name
         *
         * @param string $value
         * @return PHPExcel_NamedRange
         */
        public function setName($value = \null)
        {
        }
        /**
         * Get worksheet
         *
         * @return PHPExcel_Worksheet
         */
        public function getWorksheet()
        {
        }
        /**
         * Set worksheet
         *
         * @param PHPExcel_Worksheet $value
         * @return PHPExcel_NamedRange
         */
        public function setWorksheet(\PHPExcel_Worksheet $value = \null)
        {
        }
        /**
         * Get range
         *
         * @return string
         */
        public function getRange()
        {
        }
        /**
         * Set range
         *
         * @param string $value
         * @return PHPExcel_NamedRange
         */
        public function setRange($value = \null)
        {
        }
        /**
         * Get localOnly
         *
         * @return bool
         */
        public function getLocalOnly()
        {
        }
        /**
         * Set localOnly
         *
         * @param bool $value
         * @return PHPExcel_NamedRange
         */
        public function setLocalOnly($value = \false)
        {
        }
        /**
         * Get scope
         *
         * @return PHPExcel_Worksheet|null
         */
        public function getScope()
        {
        }
        /**
         * Set scope
         *
         * @param PHPExcel_Worksheet|null $value
         * @return PHPExcel_NamedRange
         */
        public function setScope(\PHPExcel_Worksheet $value = \null)
        {
        }
        /**
         * Resolve a named range to a regular cell range
         *
         * @param string $pNamedRange Named range
         * @param PHPExcel_Worksheet|null $pSheet Scope. Use null for global scope
         * @return PHPExcel_NamedRange
         */
        public static function resolveRange($pNamedRange = '', \PHPExcel_Worksheet $pSheet)
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Cell
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt    LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Cell_IValueBinder
     *
     * @category   PHPExcel
     * @package    PHPExcel_Cell
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    interface PHPExcel_Cell_IValueBinder
    {
        /**
         * Bind value to a cell
         *
         * @param  PHPExcel_Cell $cell    Cell to bind value to
         * @param  mixed $value           Value to bind in cell
         * @return boolean
         */
        public function bindValue(\PHPExcel_Cell $cell, $value = \NULL);
    }
    /**
     * PHPExcel_Cell_DefaultValueBinder
     *
     * @category   PHPExcel
     * @package    PHPExcel_Cell
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Cell_DefaultValueBinder implements \PHPExcel_Cell_IValueBinder
    {
        /**
         * Bind value to a cell
         *
         * @param  PHPExcel_Cell  $cell   Cell to bind value to
         * @param  mixed          $value  Value to bind in cell
         * @return boolean
         */
        public function bindValue(\PHPExcel_Cell $cell, $value = \null)
        {
        }
        /**
         * DataType for value
         *
         * @param   mixed  $pValue
         * @return  string
         */
        public static function dataTypeForValue($pValue = \null)
        {
        }
    }
    /**
     * PHPExcel_Cell_AdvancedValueBinder
     *
     * @category   PHPExcel
     * @package    PHPExcel_Cell
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Cell_AdvancedValueBinder extends \PHPExcel_Cell_DefaultValueBinder implements \PHPExcel_Cell_IValueBinder
    {
        /**
         * Bind value to a cell
         *
         * @param  PHPExcel_Cell  $cell  Cell to bind value to
         * @param  mixed $value          Value to bind in cell
         * @return boolean
         */
        public function bindValue(\PHPExcel_Cell $cell, $value = \null)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Cell
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt    LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Cell_DataType
     *
     * @category   PHPExcel
     * @package    PHPExcel_Cell
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Cell_DataType
    {
        /* Data types */
        const TYPE_STRING2 = 'str';
        const TYPE_STRING = 's';
        const TYPE_FORMULA = 'f';
        const TYPE_NUMERIC = 'n';
        const TYPE_BOOL = 'b';
        const TYPE_NULL = 'null';
        const TYPE_INLINE = 'inlineStr';
        const TYPE_ERROR = 'e';
        /**
         * List of error codes
         *
         * @var array
         */
        private static $_errorCodes = array('#NULL!' => 0, '#DIV/0!' => 1, '#VALUE!' => 2, '#REF!' => 3, '#NAME?' => 4, '#NUM!' => 5, '#N/A' => 6);
        /**
         * Get list of error codes
         *
         * @return array
         */
        public static function getErrorCodes()
        {
        }
        /**
         * DataType for value
         *
         * @deprecated  Replaced by PHPExcel_Cell_IValueBinder infrastructure, will be removed in version 1.8.0
         * @param       mixed  $pValue
         * @return      string
         */
        public static function dataTypeForValue($pValue = \null)
        {
        }
        /**
         * Check a string that it satisfies Excel requirements
         *
         * @param  mixed  Value to sanitize to an Excel string
         * @return mixed  Sanitized value
         */
        public static function checkString($pValue = \null)
        {
        }
        /**
         * Check a value that it is a valid error code
         *
         * @param  mixed   Value to sanitize to an Excel error code
         * @return string  Sanitized value
         */
        public static function checkErrorCode($pValue = \null)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Cell
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt    LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Cell_Hyperlink
     *
     * @category   PHPExcel
     * @package    PHPExcel_Cell
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Cell_Hyperlink
    {
        /**
         * URL to link the cell to
         *
         * @var string
         */
        private $_url;
        /**
         * Tooltip to display on the hyperlink
         *
         * @var string
         */
        private $_tooltip;
        /**
         * Create a new PHPExcel_Cell_Hyperlink
         *
         * @param  string  $pUrl      Url to link the cell to
         * @param  string  $pTooltip  Tooltip to display on the hyperlink
         */
        public function __construct($pUrl = '', $pTooltip = '')
        {
        }
        /**
         * Get URL
         *
         * @return string
         */
        public function getUrl()
        {
        }
        /**
         * Set URL
         *
         * @param  string    $value
         * @return PHPExcel_Cell_Hyperlink
         */
        public function setUrl($value = '')
        {
        }
        /**
         * Get tooltip
         *
         * @return string
         */
        public function getTooltip()
        {
        }
        /**
         * Set tooltip
         *
         * @param  string    $value
         * @return PHPExcel_Cell_Hyperlink
         */
        public function setTooltip($value = '')
        {
        }
        /**
         * Is this hyperlink internal? (to another worksheet)
         *
         * @return boolean
         */
        public function isInternal()
        {
        }
        /**
         * Get hash code
         *
         * @return string    Hash code
         */
        public function getHashCode()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Cell
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt    LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Cell_DataValidation
     *
     * @category   PHPExcel
     * @package    PHPExcel_Cell
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Cell_DataValidation
    {
        /* Data validation types */
        const TYPE_NONE = 'none';
        const TYPE_CUSTOM = 'custom';
        const TYPE_DATE = 'date';
        const TYPE_DECIMAL = 'decimal';
        const TYPE_LIST = 'list';
        const TYPE_TEXTLENGTH = 'textLength';
        const TYPE_TIME = 'time';
        const TYPE_WHOLE = 'whole';
        /* Data validation error styles */
        const STYLE_STOP = 'stop';
        const STYLE_WARNING = 'warning';
        const STYLE_INFORMATION = 'information';
        /* Data validation operators */
        const OPERATOR_BETWEEN = 'between';
        const OPERATOR_EQUAL = 'equal';
        const OPERATOR_GREATERTHAN = 'greaterThan';
        const OPERATOR_GREATERTHANOREQUAL = 'greaterThanOrEqual';
        const OPERATOR_LESSTHAN = 'lessThan';
        const OPERATOR_LESSTHANOREQUAL = 'lessThanOrEqual';
        const OPERATOR_NOTBETWEEN = 'notBetween';
        const OPERATOR_NOTEQUAL = 'notEqual';
        /**
         * Formula 1
         *
         * @var string
         */
        private $_formula1;
        /**
         * Formula 2
         *
         * @var string
         */
        private $_formula2;
        /**
         * Type
         *
         * @var string
         */
        private $_type = \PHPExcel_Cell_DataValidation::TYPE_NONE;
        /**
         * Error style
         *
         * @var string
         */
        private $_errorStyle = \PHPExcel_Cell_DataValidation::STYLE_STOP;
        /**
         * Operator
         *
         * @var string
         */
        private $_operator;
        /**
         * Allow Blank
         *
         * @var boolean
         */
        private $_allowBlank;
        /**
         * Show DropDown
         *
         * @var boolean
         */
        private $_showDropDown;
        /**
         * Show InputMessage
         *
         * @var boolean
         */
        private $_showInputMessage;
        /**
         * Show ErrorMessage
         *
         * @var boolean
         */
        private $_showErrorMessage;
        /**
         * Error title
         *
         * @var string
         */
        private $_errorTitle;
        /**
         * Error
         *
         * @var string
         */
        private $_error;
        /**
         * Prompt title
         *
         * @var string
         */
        private $_promptTitle;
        /**
         * Prompt
         *
         * @var string
         */
        private $_prompt;
        /**
         * Create a new PHPExcel_Cell_DataValidation
         */
        public function __construct()
        {
        }
        /**
         * Get Formula 1
         *
         * @return string
         */
        public function getFormula1()
        {
        }
        /**
         * Set Formula 1
         *
         * @param  string    $value
         * @return PHPExcel_Cell_DataValidation
         */
        public function setFormula1($value = '')
        {
        }
        /**
         * Get Formula 2
         *
         * @return string
         */
        public function getFormula2()
        {
        }
        /**
         * Set Formula 2
         *
         * @param  string    $value
         * @return PHPExcel_Cell_DataValidation
         */
        public function setFormula2($value = '')
        {
        }
        /**
         * Get Type
         *
         * @return string
         */
        public function getType()
        {
        }
        /**
         * Set Type
         *
         * @param  string    $value
         * @return PHPExcel_Cell_DataValidation
         */
        public function setType($value = \PHPExcel_Cell_DataValidation::TYPE_NONE)
        {
        }
        /**
         * Get Error style
         *
         * @return string
         */
        public function getErrorStyle()
        {
        }
        /**
         * Set Error style
         *
         * @param  string    $value
         * @return PHPExcel_Cell_DataValidation
         */
        public function setErrorStyle($value = \PHPExcel_Cell_DataValidation::STYLE_STOP)
        {
        }
        /**
         * Get Operator
         *
         * @return string
         */
        public function getOperator()
        {
        }
        /**
         * Set Operator
         *
         * @param  string    $value
         * @return PHPExcel_Cell_DataValidation
         */
        public function setOperator($value = '')
        {
        }
        /**
         * Get Allow Blank
         *
         * @return boolean
         */
        public function getAllowBlank()
        {
        }
        /**
         * Set Allow Blank
         *
         * @param  boolean    $value
         * @return PHPExcel_Cell_DataValidation
         */
        public function setAllowBlank($value = \false)
        {
        }
        /**
         * Get Show DropDown
         *
         * @return boolean
         */
        public function getShowDropDown()
        {
        }
        /**
         * Set Show DropDown
         *
         * @param  boolean    $value
         * @return PHPExcel_Cell_DataValidation
         */
        public function setShowDropDown($value = \false)
        {
        }
        /**
         * Get Show InputMessage
         *
         * @return boolean
         */
        public function getShowInputMessage()
        {
        }
        /**
         * Set Show InputMessage
         *
         * @param  boolean    $value
         * @return PHPExcel_Cell_DataValidation
         */
        public function setShowInputMessage($value = \false)
        {
        }
        /**
         * Get Show ErrorMessage
         *
         * @return boolean
         */
        public function getShowErrorMessage()
        {
        }
        /**
         * Set Show ErrorMessage
         *
         * @param  boolean    $value
         * @return PHPExcel_Cell_DataValidation
         */
        public function setShowErrorMessage($value = \false)
        {
        }
        /**
         * Get Error title
         *
         * @return string
         */
        public function getErrorTitle()
        {
        }
        /**
         * Set Error title
         *
         * @param  string    $value
         * @return PHPExcel_Cell_DataValidation
         */
        public function setErrorTitle($value = '')
        {
        }
        /**
         * Get Error
         *
         * @return string
         */
        public function getError()
        {
        }
        /**
         * Set Error
         *
         * @param  string    $value
         * @return PHPExcel_Cell_DataValidation
         */
        public function setError($value = '')
        {
        }
        /**
         * Get Prompt title
         *
         * @return string
         */
        public function getPromptTitle()
        {
        }
        /**
         * Set Prompt title
         *
         * @param  string    $value
         * @return PHPExcel_Cell_DataValidation
         */
        public function setPromptTitle($value = '')
        {
        }
        /**
         * Get Prompt
         *
         * @return string
         */
        public function getPrompt()
        {
        }
        /**
         * Set Prompt
         *
         * @param  string    $value
         * @return PHPExcel_Cell_DataValidation
         */
        public function setPrompt($value = '')
        {
        }
        /**
         * Get hash code
         *
         * @return string    Hash code
         */
        public function getHashCode()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt    LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Comment
     *
     * @category   PHPExcel
     * @package    PHPExcel
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Comment implements \PHPExcel_IComparable
    {
        /**
         * Author
         *
         * @var string
         */
        private $_author;
        /**
         * Rich text comment
         *
         * @var PHPExcel_RichText
         */
        private $_text;
        /**
         * Comment width (CSS style, i.e. XXpx or YYpt)
         *
         * @var string
         */
        private $_width = '96pt';
        /**
         * Left margin (CSS style, i.e. XXpx or YYpt)
         *
         * @var string
         */
        private $_marginLeft = '59.25pt';
        /**
         * Top margin (CSS style, i.e. XXpx or YYpt)
         *
         * @var string
         */
        private $_marginTop = '1.5pt';
        /**
         * Visible
         *
         * @var boolean
         */
        private $_visible = \false;
        /**
         * Comment height (CSS style, i.e. XXpx or YYpt)
         *
         * @var string
         */
        private $_height = '55.5pt';
        /**
         * Comment fill color
         *
         * @var PHPExcel_Style_Color
         */
        private $_fillColor;
        /**
         * Alignment
         *
         * @var string
         */
        private $_alignment;
        /**
         * Create a new PHPExcel_Comment
         *
         * @throws PHPExcel_Exception
         */
        public function __construct()
        {
        }
        /**
         * Get Author
         *
         * @return string
         */
        public function getAuthor()
        {
        }
        /**
         * Set Author
         *
         * @param string $pValue
         * @return PHPExcel_Comment
         */
        public function setAuthor($pValue = '')
        {
        }
        /**
         * Get Rich text comment
         *
         * @return PHPExcel_RichText
         */
        public function getText()
        {
        }
        /**
         * Set Rich text comment
         *
         * @param PHPExcel_RichText $pValue
         * @return PHPExcel_Comment
         */
        public function setText(\PHPExcel_RichText $pValue)
        {
        }
        /**
         * Get comment width (CSS style, i.e. XXpx or YYpt)
         *
         * @return string
         */
        public function getWidth()
        {
        }
        /**
         * Set comment width (CSS style, i.e. XXpx or YYpt)
         *
         * @param string $value
         * @return PHPExcel_Comment
         */
        public function setWidth($value = '96pt')
        {
        }
        /**
         * Get comment height (CSS style, i.e. XXpx or YYpt)
         *
         * @return string
         */
        public function getHeight()
        {
        }
        /**
         * Set comment height (CSS style, i.e. XXpx or YYpt)
         *
         * @param string $value
         * @return PHPExcel_Comment
         */
        public function setHeight($value = '55.5pt')
        {
        }
        /**
         * Get left margin (CSS style, i.e. XXpx or YYpt)
         *
         * @return string
         */
        public function getMarginLeft()
        {
        }
        /**
         * Set left margin (CSS style, i.e. XXpx or YYpt)
         *
         * @param string $value
         * @return PHPExcel_Comment
         */
        public function setMarginLeft($value = '59.25pt')
        {
        }
        /**
         * Get top margin (CSS style, i.e. XXpx or YYpt)
         *
         * @return string
         */
        public function getMarginTop()
        {
        }
        /**
         * Set top margin (CSS style, i.e. XXpx or YYpt)
         *
         * @param string $value
         * @return PHPExcel_Comment
         */
        public function setMarginTop($value = '1.5pt')
        {
        }
        /**
         * Is the comment visible by default?
         *
         * @return boolean
         */
        public function getVisible()
        {
        }
        /**
         * Set comment default visibility
         *
         * @param boolean $value
         * @return PHPExcel_Comment
         */
        public function setVisible($value = \false)
        {
        }
        /**
         * Get fill color
         *
         * @return PHPExcel_Style_Color
         */
        public function getFillColor()
        {
        }
        /**
         * Set Alignment
         *
         * @param string $pValue
         * @return PHPExcel_Comment
         */
        public function setAlignment($pValue = \PHPExcel_Style_Alignment::HORIZONTAL_GENERAL)
        {
        }
        /**
         * Get Alignment
         *
         * @return string
         */
        public function getAlignment()
        {
        }
        /**
         * Get hash code
         *
         * @return string    Hash code
         */
        public function getHashCode()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
        /**
         * Convert to string
         *
         * @return string
         */
        public function __toString()
        {
        }
    }
    /**
     * PHPExcel_Calculation_MathTrig
     *
     * @category	PHPExcel
     * @package		PHPExcel_Calculation
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Calculation_MathTrig
    {
        //
        //	Private method to return an array of the factors of the input value
        //
        private static function _factors($value)
        {
        }
        //	function _factors()
        private static function _romanCut($num, $n)
        {
        }
        //	function _romanCut()
        /**
         * ATAN2
         *
         * This function calculates the arc tangent of the two variables x and y. It is similar to
         *		calculating the arc tangent of y  x, except that the signs of both arguments are used
         *		to determine the quadrant of the result.
         * The arctangent is the angle from the x-axis to a line containing the origin (0, 0) and a
         *		point with coordinates (xCoordinate, yCoordinate). The angle is given in radians between
         *		-pi and pi, excluding -pi.
         *
         * Note that the Excel ATAN2() function accepts its arguments in the reverse order to the standard
         *		PHP atan2() function, so we need to reverse them here before calling the PHP atan() function.
         *
         * Excel Function:
         *		ATAN2(xCoordinate,yCoordinate)
         *
         * @access	public
         * @category Mathematical and Trigonometric Functions
         * @param	float	$xCoordinate		The x-coordinate of the point.
         * @param	float	$yCoordinate		The y-coordinate of the point.
         * @return	float	The inverse tangent of the specified x- and y-coordinates.
         */
        public static function ATAN2($xCoordinate = \NULL, $yCoordinate = \NULL)
        {
        }
        //	function ATAN2()
        /**
         * CEILING
         *
         * Returns number rounded up, away from zero, to the nearest multiple of significance.
         *		For example, if you want to avoid using pennies in your prices and your product is
         *		priced at $4.42, use the formula =CEILING(4.42,0.05) to round prices up to the
         *		nearest nickel.
         *
         * Excel Function:
         *		CEILING(number[,significance])
         *
         * @access	public
         * @category Mathematical and Trigonometric Functions
         * @param	float	$number			The number you want to round.
         * @param	float	$significance	The multiple to which you want to round.
         * @return	float	Rounded Number
         */
        public static function CEILING($number, $significance = \NULL)
        {
        }
        //	function CEILING()
        /**
         * COMBIN
         *
         * Returns the number of combinations for a given number of items. Use COMBIN to
         *		determine the total possible number of groups for a given number of items.
         *
         * Excel Function:
         *		COMBIN(numObjs,numInSet)
         *
         * @access	public
         * @category Mathematical and Trigonometric Functions
         * @param	int		$numObjs	Number of different objects
         * @param	int		$numInSet	Number of objects in each combination
         * @return	int		Number of combinations
         */
        public static function COMBIN($numObjs, $numInSet)
        {
        }
        //	function COMBIN()
        /**
         * EVEN
         *
         * Returns number rounded up to the nearest even integer.
         * You can use this function for processing items that come in twos. For example,
         *		a packing crate accepts rows of one or two items. The crate is full when
         *		the number of items, rounded up to the nearest two, matches the crate's
         *		capacity.
         *
         * Excel Function:
         *		EVEN(number)
         *
         * @access	public
         * @category Mathematical and Trigonometric Functions
         * @param	float	$number			Number to round
         * @return	int		Rounded Number
         */
        public static function EVEN($number)
        {
        }
        //	function EVEN()
        /**
         * FACT
         *
         * Returns the factorial of a number.
         * The factorial of a number is equal to 1*2*3*...* number.
         *
         * Excel Function:
         *		FACT(factVal)
         *
         * @access	public
         * @category Mathematical and Trigonometric Functions
         * @param	float	$factVal	Factorial Value
         * @return	int		Factorial
         */
        public static function FACT($factVal)
        {
        }
        //	function FACT()
        /**
         * FACTDOUBLE
         *
         * Returns the double factorial of a number.
         *
         * Excel Function:
         *		FACTDOUBLE(factVal)
         *
         * @access	public
         * @category Mathematical and Trigonometric Functions
         * @param	float	$factVal	Factorial Value
         * @return	int		Double Factorial
         */
        public static function FACTDOUBLE($factVal)
        {
        }
        //	function FACTDOUBLE()
        /**
         * FLOOR
         *
         * Rounds number down, toward zero, to the nearest multiple of significance.
         *
         * Excel Function:
         *		FLOOR(number[,significance])
         *
         * @access	public
         * @category Mathematical and Trigonometric Functions
         * @param	float	$number			Number to round
         * @param	float	$significance	Significance
         * @return	float	Rounded Number
         */
        public static function FLOOR($number, $significance = \NULL)
        {
        }
        //	function FLOOR()
        /**
         * GCD
         *
         * Returns the greatest common divisor of a series of numbers.
         * The greatest common divisor is the largest integer that divides both
         *		number1 and number2 without a remainder.
         *
         * Excel Function:
         *		GCD(number1[,number2[, ...]])
         *
         * @access	public
         * @category Mathematical and Trigonometric Functions
         * @param	mixed	$arg,...		Data values
         * @return	integer					Greatest Common Divisor
         */
        public static function GCD()
        {
        }
        //	function GCD()
        /**
         * INT
         *
         * Casts a floating point value to an integer
         *
         * Excel Function:
         *		INT(number)
         *
         * @access	public
         * @category Mathematical and Trigonometric Functions
         * @param	float	$number			Number to cast to an integer
         * @return	integer	Integer value
         */
        public static function INT($number)
        {
        }
        //	function INT()
        /**
         * LCM
         *
         * Returns the lowest common multiplier of a series of numbers
         * The least common multiple is the smallest positive integer that is a multiple
         * of all integer arguments number1, number2, and so on. Use LCM to add fractions
         * with different denominators.
         *
         * Excel Function:
         *		LCM(number1[,number2[, ...]])
         *
         * @access	public
         * @category Mathematical and Trigonometric Functions
         * @param	mixed	$arg,...		Data values
         * @return	int		Lowest Common Multiplier
         */
        public static function LCM()
        {
        }
        //	function LCM()
        /**
         * LOG_BASE
         *
         * Returns the logarithm of a number to a specified base. The default base is 10.
         *
         * Excel Function:
         *		LOG(number[,base])
         *
         * @access	public
         * @category Mathematical and Trigonometric Functions
         * @param	float	$number		The positive real number for which you want the logarithm
         * @param	float	$base		The base of the logarithm. If base is omitted, it is assumed to be 10.
         * @return	float
         */
        public static function LOG_BASE($number = \NULL, $base = 10)
        {
        }
        //	function LOG_BASE()
        /**
         * MDETERM
         *
         * Returns the matrix determinant of an array.
         *
         * Excel Function:
         *		MDETERM(array)
         *
         * @access	public
         * @category Mathematical and Trigonometric Functions
         * @param	array	$matrixValues	A matrix of values
         * @return	float
         */
        public static function MDETERM($matrixValues)
        {
        }
        //	function MDETERM()
        /**
         * MINVERSE
         *
         * Returns the inverse matrix for the matrix stored in an array.
         *
         * Excel Function:
         *		MINVERSE(array)
         *
         * @access	public
         * @category Mathematical and Trigonometric Functions
         * @param	array	$matrixValues	A matrix of values
         * @return	array
         */
        public static function MINVERSE($matrixValues)
        {
        }
        //	function MINVERSE()
        /**
         * MMULT
         *
         * @param	array	$matrixData1	A matrix of values
         * @param	array	$matrixData2	A matrix of values
         * @return	array
         */
        public static function MMULT($matrixData1, $matrixData2)
        {
        }
        //	function MMULT()
        /**
         * MOD
         *
         * @param	int		$a		Dividend
         * @param	int		$b		Divisor
         * @return	int		Remainder
         */
        public static function MOD($a = 1, $b = 1)
        {
        }
        //	function MOD()
        /**
         * MROUND
         *
         * Rounds a number to the nearest multiple of a specified value
         *
         * @param	float	$number			Number to round
         * @param	int		$multiple		Multiple to which you want to round $number
         * @return	float	Rounded Number
         */
        public static function MROUND($number, $multiple)
        {
        }
        //	function MROUND()
        /**
         * MULTINOMIAL
         *
         * Returns the ratio of the factorial of a sum of values to the product of factorials.
         *
         * @param	array of mixed		Data Series
         * @return	float
         */
        public static function MULTINOMIAL()
        {
        }
        //	function MULTINOMIAL()
        /**
         * ODD
         *
         * Returns number rounded up to the nearest odd integer.
         *
         * @param	float	$number			Number to round
         * @return	int		Rounded Number
         */
        public static function ODD($number)
        {
        }
        //	function ODD()
        /**
         * POWER
         *
         * Computes x raised to the power y.
         *
         * @param	float		$x
         * @param	float		$y
         * @return	float
         */
        public static function POWER($x = 0, $y = 2)
        {
        }
        //	function POWER()
        /**
         * PRODUCT
         *
         * PRODUCT returns the product of all the values and cells referenced in the argument list.
         *
         * Excel Function:
         *		PRODUCT(value1[,value2[, ...]])
         *
         * @access	public
         * @category Mathematical and Trigonometric Functions
         * @param	mixed		$arg,...		Data values
         * @return	float
         */
        public static function PRODUCT()
        {
        }
        //	function PRODUCT()
        /**
         * QUOTIENT
         *
         * QUOTIENT function returns the integer portion of a division. Numerator is the divided number
         *		and denominator is the divisor.
         *
         * Excel Function:
         *		QUOTIENT(value1[,value2[, ...]])
         *
         * @access	public
         * @category Mathematical and Trigonometric Functions
         * @param	mixed		$arg,...		Data values
         * @return	float
         */
        public static function QUOTIENT()
        {
        }
        //	function QUOTIENT()
        /**
         * RAND
         *
         * @param	int		$min	Minimal value
         * @param	int		$max	Maximal value
         * @return	int		Random number
         */
        public static function RAND($min = 0, $max = 0)
        {
        }
        //	function RAND()
        public static function ROMAN($aValue, $style = 0)
        {
        }
        //	function ROMAN()
        /**
         * ROUNDUP
         *
         * Rounds a number up to a specified number of decimal places
         *
         * @param	float	$number			Number to round
         * @param	int		$digits			Number of digits to which you want to round $number
         * @return	float	Rounded Number
         */
        public static function ROUNDUP($number, $digits)
        {
        }
        //	function ROUNDUP()
        /**
         * ROUNDDOWN
         *
         * Rounds a number down to a specified number of decimal places
         *
         * @param	float	$number			Number to round
         * @param	int		$digits			Number of digits to which you want to round $number
         * @return	float	Rounded Number
         */
        public static function ROUNDDOWN($number, $digits)
        {
        }
        //	function ROUNDDOWN()
        /**
         * SERIESSUM
         *
         * Returns the sum of a power series
         *
         * @param	float			$x	Input value to the power series
         * @param	float			$n	Initial power to which you want to raise $x
         * @param	float			$m	Step by which to increase $n for each term in the series
         * @param	array of mixed		Data Series
         * @return	float
         */
        public static function SERIESSUM()
        {
        }
        //	function SERIESSUM()
        /**
         * SIGN
         *
         * Determines the sign of a number. Returns 1 if the number is positive, zero (0)
         *		if the number is 0, and -1 if the number is negative.
         *
         * @param	float	$number			Number to round
         * @return	int		sign value
         */
        public static function SIGN($number)
        {
        }
        //	function SIGN()
        /**
         * SQRTPI
         *
         * Returns the square root of (number * pi).
         *
         * @param	float	$number		Number
         * @return	float	Square Root of Number * Pi
         */
        public static function SQRTPI($number)
        {
        }
        //	function SQRTPI()
        /**
         * SUBTOTAL
         *
         * Returns a subtotal in a list or database.
         *
         * @param	int		the number 1 to 11 that specifies which function to
         *					use in calculating subtotals within a list.
         * @param	array of mixed		Data Series
         * @return	float
         */
        public static function SUBTOTAL()
        {
        }
        //	function SUBTOTAL()
        /**
         * SUM
         *
         * SUM computes the sum of all the values and cells referenced in the argument list.
         *
         * Excel Function:
         *		SUM(value1[,value2[, ...]])
         *
         * @access	public
         * @category Mathematical and Trigonometric Functions
         * @param	mixed		$arg,...		Data values
         * @return	float
         */
        public static function SUM()
        {
        }
        //	function SUM()
        /**
         * SUMIF
         *
         * Counts the number of cells that contain numbers within the list of arguments
         *
         * Excel Function:
         *		SUMIF(value1[,value2[, ...]],condition)
         *
         * @access	public
         * @category Mathematical and Trigonometric Functions
         * @param	mixed		$arg,...		Data values
         * @param	string		$condition		The criteria that defines which cells will be summed.
         * @return	float
         */
        public static function SUMIF($aArgs, $condition, $sumArgs = array())
        {
        }
        //	function SUMIF()
        /**
         * SUMPRODUCT
         *
         * Excel Function:
         *		SUMPRODUCT(value1[,value2[, ...]])
         *
         * @access	public
         * @category Mathematical and Trigonometric Functions
         * @param	mixed		$arg,...		Data values
         * @return	float
         */
        public static function SUMPRODUCT()
        {
        }
        //	function SUMPRODUCT()
        /**
         * SUMSQ
         *
         * SUMSQ returns the sum of the squares of the arguments
         *
         * Excel Function:
         *		SUMSQ(value1[,value2[, ...]])
         *
         * @access	public
         * @category Mathematical and Trigonometric Functions
         * @param	mixed		$arg,...		Data values
         * @return	float
         */
        public static function SUMSQ()
        {
        }
        //	function SUMSQ()
        /**
         * SUMX2MY2
         *
         * @param	mixed[]	$matrixData1	Matrix #1
         * @param	mixed[]	$matrixData2	Matrix #2
         * @return	float
         */
        public static function SUMX2MY2($matrixData1, $matrixData2)
        {
        }
        //	function SUMX2MY2()
        /**
         * SUMX2PY2
         *
         * @param	mixed[]	$matrixData1	Matrix #1
         * @param	mixed[]	$matrixData2	Matrix #2
         * @return	float
         */
        public static function SUMX2PY2($matrixData1, $matrixData2)
        {
        }
        //	function SUMX2PY2()
        /**
         * SUMXMY2
         *
         * @param	mixed[]	$matrixData1	Matrix #1
         * @param	mixed[]	$matrixData2	Matrix #2
         * @return	float
         */
        public static function SUMXMY2($matrixData1, $matrixData2)
        {
        }
        //	function SUMXMY2()
        /**
         * TRUNC
         *
         * Truncates value to the number of fractional digits by number_digits.
         *
         * @param	float		$value
         * @param	int			$digits
         * @return	float		Truncated value
         */
        public static function TRUNC($value = 0, $digits = 0)
        {
        }
        //	function TRUNC()
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Calculation
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license	http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version	1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Calculation_Exception
     *
     * @category   PHPExcel
     * @package    PHPExcel_Calculation
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Calculation_Exception extends \PHPExcel_Exception
    {
        /**
         * Error handler callback
         *
         * @param mixed $code
         * @param mixed $string
         * @param mixed $file
         * @param mixed $line
         * @param mixed $context
         */
        public static function errorHandlerCallback($code, $string, $file, $line, $context)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Calculation
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /*
    PARTLY BASED ON:
    	Copyright (c) 2007 E. W. Bachtal, Inc.
    
    	Permission is hereby granted, free of charge, to any person obtaining a copy of this software
    	and associated documentation files (the "Software"), to deal in the Software without restriction,
    	including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
    	and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
    	subject to the following conditions:
    
    	  The above copyright notice and this permission notice shall be included in all copies or substantial
    	  portions of the Software.
    
    	The software is provided "as is", without warranty of any kind, express or implied, including but not
    	limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In
    	no event shall the authors or copyright holders be liable for any claim, damages or other liability,
    	whether in an action of contract, tort or otherwise, arising from, out of or in connection with the
    	software or the use or other dealings in the software.
    
    	http://ewbi.blogs.com/develops/2007/03/excel_formula_p.html
    	http://ewbi.blogs.com/develops/2004/12/excel_formula_p.html
    */
    /**
     * PHPExcel_Calculation_FormulaToken
     *
     * @category   PHPExcel
     * @package    PHPExcel_Calculation
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Calculation_FormulaToken
    {
        /* Token types */
        const TOKEN_TYPE_NOOP = 'Noop';
        const TOKEN_TYPE_OPERAND = 'Operand';
        const TOKEN_TYPE_FUNCTION = 'Function';
        const TOKEN_TYPE_SUBEXPRESSION = 'Subexpression';
        const TOKEN_TYPE_ARGUMENT = 'Argument';
        const TOKEN_TYPE_OPERATORPREFIX = 'OperatorPrefix';
        const TOKEN_TYPE_OPERATORINFIX = 'OperatorInfix';
        const TOKEN_TYPE_OPERATORPOSTFIX = 'OperatorPostfix';
        const TOKEN_TYPE_WHITESPACE = 'Whitespace';
        const TOKEN_TYPE_UNKNOWN = 'Unknown';
        /* Token subtypes */
        const TOKEN_SUBTYPE_NOTHING = 'Nothing';
        const TOKEN_SUBTYPE_START = 'Start';
        const TOKEN_SUBTYPE_STOP = 'Stop';
        const TOKEN_SUBTYPE_TEXT = 'Text';
        const TOKEN_SUBTYPE_NUMBER = 'Number';
        const TOKEN_SUBTYPE_LOGICAL = 'Logical';
        const TOKEN_SUBTYPE_ERROR = 'Error';
        const TOKEN_SUBTYPE_RANGE = 'Range';
        const TOKEN_SUBTYPE_MATH = 'Math';
        const TOKEN_SUBTYPE_CONCATENATION = 'Concatenation';
        const TOKEN_SUBTYPE_INTERSECTION = 'Intersection';
        const TOKEN_SUBTYPE_UNION = 'Union';
        /**
         * Value
         *
         * @var string
         */
        private $_value;
        /**
         * Token Type (represented by TOKEN_TYPE_*)
         *
         * @var string
         */
        private $_tokenType;
        /**
         * Token SubType (represented by TOKEN_SUBTYPE_*)
         *
         * @var string
         */
        private $_tokenSubType;
        /**
         * Create a new PHPExcel_Calculation_FormulaToken
         *
         * @param string	$pValue
         * @param string	$pTokenType 	Token type (represented by TOKEN_TYPE_*)
         * @param string	$pTokenSubType 	Token Subtype (represented by TOKEN_SUBTYPE_*)
         */
        public function __construct($pValue, $pTokenType = \PHPExcel_Calculation_FormulaToken::TOKEN_TYPE_UNKNOWN, $pTokenSubType = \PHPExcel_Calculation_FormulaToken::TOKEN_SUBTYPE_NOTHING)
        {
        }
        /**
         * Get Value
         *
         * @return string
         */
        public function getValue()
        {
        }
        /**
         * Set Value
         *
         * @param string	$value
         */
        public function setValue($value)
        {
        }
        /**
         * Get Token Type (represented by TOKEN_TYPE_*)
         *
         * @return string
         */
        public function getTokenType()
        {
        }
        /**
         * Set Token Type
         *
         * @param string	$value
         */
        public function setTokenType($value = \PHPExcel_Calculation_FormulaToken::TOKEN_TYPE_UNKNOWN)
        {
        }
        /**
         * Get Token SubType (represented by TOKEN_SUBTYPE_*)
         *
         * @return string
         */
        public function getTokenSubType()
        {
        }
        /**
         * Set Token SubType
         *
         * @param string	$value
         */
        public function setTokenSubType($value = \PHPExcel_Calculation_FormulaToken::TOKEN_SUBTYPE_NOTHING)
        {
        }
    }
    /**
     * PHPExcel_Calculation_Financial
     *
     * @category	PHPExcel
     * @package		PHPExcel_Calculation
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Calculation_Financial
    {
        /**
         * _lastDayOfMonth
         *
         * Returns a boolean TRUE/FALSE indicating if this date is the last date of the month
         *
         * @param	DateTime	$testDate	The date for testing
         * @return	boolean
         */
        private static function _lastDayOfMonth($testDate)
        {
        }
        //	function _lastDayOfMonth()
        /**
         * _firstDayOfMonth
         *
         * Returns a boolean TRUE/FALSE indicating if this date is the first date of the month
         *
         * @param	DateTime	$testDate	The date for testing
         * @return	boolean
         */
        private static function _firstDayOfMonth($testDate)
        {
        }
        //	function _firstDayOfMonth()
        private static function _coupFirstPeriodDate($settlement, $maturity, $frequency, $next)
        {
        }
        //	function _coupFirstPeriodDate()
        private static function _validFrequency($frequency)
        {
        }
        //	function _validFrequency()
        /**
         * _daysPerYear
         *
         * Returns the number of days in a specified year, as defined by the "basis" value
         *
         * @param	integer		$year	The year against which we're testing
         * @param   integer		$basis	The type of day count:
         *									0 or omitted US (NASD)	360
         *									1						Actual (365 or 366 in a leap year)
         *									2						360
         *									3						365
         *									4						European 360
         * @return	integer
         */
        private static function _daysPerYear($year, $basis = 0)
        {
        }
        //	function _daysPerYear()
        private static function _interestAndPrincipal($rate = 0, $per = 0, $nper = 0, $pv = 0, $fv = 0, $type = 0)
        {
        }
        //	function _interestAndPrincipal()
        /**
         * ACCRINT
         *
         * Returns the accrued interest for a security that pays periodic interest.
         *
         * Excel Function:
         *		ACCRINT(issue,firstinterest,settlement,rate,par,frequency[,basis])
         *
         * @access	public
         * @category Financial Functions
         * @param	mixed	$issue			The security's issue date.
         * @param	mixed	$firstinterest	The security's first interest date.
         * @param	mixed	$settlement		The security's settlement date.
         *									The security settlement date is the date after the issue date
         *									when the security is traded to the buyer.
         * @param	float	$rate			The security's annual coupon rate.
         * @param	float	$par			The security's par value.
         *									If you omit par, ACCRINT uses $1,000.
         * @param	integer	$frequency		the number of coupon payments per year.
         *									Valid frequency values are:
         *										1	Annual
         *										2	Semi-Annual
         *										4	Quarterly
         *									If working in Gnumeric Mode, the following frequency options are
         *									also available
         *										6	Bimonthly
         *										12	Monthly
         * @param	integer	$basis			The type of day count to use.
         *										0 or omitted	US (NASD) 30/360
         *										1				Actual/actual
         *										2				Actual/360
         *										3				Actual/365
         *										4				European 30/360
         * @return	float
         */
        public static function ACCRINT($issue, $firstinterest, $settlement, $rate, $par = 1000, $frequency = 1, $basis = 0)
        {
        }
        //	function ACCRINT()
        /**
         * ACCRINTM
         *
         * Returns the accrued interest for a security that pays interest at maturity.
         *
         * Excel Function:
         *		ACCRINTM(issue,settlement,rate[,par[,basis]])
         *
         * @access	public
         * @category Financial Functions
         * @param	mixed	issue		The security's issue date.
         * @param	mixed	settlement	The security's settlement (or maturity) date.
         * @param	float	rate		The security's annual coupon rate.
         * @param	float	par			The security's par value.
         *									If you omit par, ACCRINT uses $1,000.
         * @param	integer	basis		The type of day count to use.
         *										0 or omitted	US (NASD) 30/360
         *										1				Actual/actual
         *										2				Actual/360
         *										3				Actual/365
         *										4				European 30/360
         * @return	float
         */
        public static function ACCRINTM($issue, $settlement, $rate, $par = 1000, $basis = 0)
        {
        }
        //	function ACCRINTM()
        /**
         * AMORDEGRC
         *
         * Returns the depreciation for each accounting period.
         * This function is provided for the French accounting system. If an asset is purchased in
         * the middle of the accounting period, the prorated depreciation is taken into account.
         * The function is similar to AMORLINC, except that a depreciation coefficient is applied in
         * the calculation depending on the life of the assets.
         * This function will return the depreciation until the last period of the life of the assets
         * or until the cumulated value of depreciation is greater than the cost of the assets minus
         * the salvage value.
         *
         * Excel Function:
         *		AMORDEGRC(cost,purchased,firstPeriod,salvage,period,rate[,basis])
         *
         * @access	public
         * @category Financial Functions
         * @param	float	cost		The cost of the asset.
         * @param	mixed	purchased	Date of the purchase of the asset.
         * @param	mixed	firstPeriod	Date of the end of the first period.
         * @param	mixed	salvage		The salvage value at the end of the life of the asset.
         * @param	float	period		The period.
         * @param	float	rate		Rate of depreciation.
         * @param	integer	basis		The type of day count to use.
         *										0 or omitted	US (NASD) 30/360
         *										1				Actual/actual
         *										2				Actual/360
         *										3				Actual/365
         *										4				European 30/360
         * @return	float
         */
        public static function AMORDEGRC($cost, $purchased, $firstPeriod, $salvage, $period, $rate, $basis = 0)
        {
        }
        //	function AMORDEGRC()
        /**
         * AMORLINC
         *
         * Returns the depreciation for each accounting period.
         * This function is provided for the French accounting system. If an asset is purchased in
         * the middle of the accounting period, the prorated depreciation is taken into account.
         *
         * Excel Function:
         *		AMORLINC(cost,purchased,firstPeriod,salvage,period,rate[,basis])
         *
         * @access	public
         * @category Financial Functions
         * @param	float	cost		The cost of the asset.
         * @param	mixed	purchased	Date of the purchase of the asset.
         * @param	mixed	firstPeriod	Date of the end of the first period.
         * @param	mixed	salvage		The salvage value at the end of the life of the asset.
         * @param	float	period		The period.
         * @param	float	rate		Rate of depreciation.
         * @param	integer	basis		The type of day count to use.
         *										0 or omitted	US (NASD) 30/360
         *										1				Actual/actual
         *										2				Actual/360
         *										3				Actual/365
         *										4				European 30/360
         * @return	float
         */
        public static function AMORLINC($cost, $purchased, $firstPeriod, $salvage, $period, $rate, $basis = 0)
        {
        }
        //	function AMORLINC()
        /**
         * COUPDAYBS
         *
         * Returns the number of days from the beginning of the coupon period to the settlement date.
         *
         * Excel Function:
         *		COUPDAYBS(settlement,maturity,frequency[,basis])
         *
         * @access	public
         * @category Financial Functions
         * @param	mixed	settlement	The security's settlement date.
         *								The security settlement date is the date after the issue
         *								date when the security is traded to the buyer.
         * @param	mixed	maturity	The security's maturity date.
         *								The maturity date is the date when the security expires.
         * @param	mixed	frequency	the number of coupon payments per year.
         *									Valid frequency values are:
         *										1	Annual
         *										2	Semi-Annual
         *										4	Quarterly
         *									If working in Gnumeric Mode, the following frequency options are
         *									also available
         *										6	Bimonthly
         *										12	Monthly
         * @param	integer		basis		The type of day count to use.
         *										0 or omitted	US (NASD) 30/360
         *										1				Actual/actual
         *										2				Actual/360
         *										3				Actual/365
         *										4				European 30/360
         * @return	float
         */
        public static function COUPDAYBS($settlement, $maturity, $frequency, $basis = 0)
        {
        }
        //	function COUPDAYBS()
        /**
         * COUPDAYS
         *
         * Returns the number of days in the coupon period that contains the settlement date.
         *
         * Excel Function:
         *		COUPDAYS(settlement,maturity,frequency[,basis])
         *
         * @access	public
         * @category Financial Functions
         * @param	mixed	settlement	The security's settlement date.
         *								The security settlement date is the date after the issue
         *								date when the security is traded to the buyer.
         * @param	mixed	maturity	The security's maturity date.
         *								The maturity date is the date when the security expires.
         * @param	mixed	frequency	the number of coupon payments per year.
         *									Valid frequency values are:
         *										1	Annual
         *										2	Semi-Annual
         *										4	Quarterly
         *									If working in Gnumeric Mode, the following frequency options are
         *									also available
         *										6	Bimonthly
         *										12	Monthly
         * @param	integer		basis		The type of day count to use.
         *										0 or omitted	US (NASD) 30/360
         *										1				Actual/actual
         *										2				Actual/360
         *										3				Actual/365
         *										4				European 30/360
         * @return	float
         */
        public static function COUPDAYS($settlement, $maturity, $frequency, $basis = 0)
        {
        }
        //	function COUPDAYS()
        /**
         * COUPDAYSNC
         *
         * Returns the number of days from the settlement date to the next coupon date.
         *
         * Excel Function:
         *		COUPDAYSNC(settlement,maturity,frequency[,basis])
         *
         * @access	public
         * @category Financial Functions
         * @param	mixed	settlement	The security's settlement date.
         *								The security settlement date is the date after the issue
         *								date when the security is traded to the buyer.
         * @param	mixed	maturity	The security's maturity date.
         *								The maturity date is the date when the security expires.
         * @param	mixed	frequency	the number of coupon payments per year.
         *									Valid frequency values are:
         *										1	Annual
         *										2	Semi-Annual
         *										4	Quarterly
         *									If working in Gnumeric Mode, the following frequency options are
         *									also available
         *										6	Bimonthly
         *										12	Monthly
         * @param	integer		basis		The type of day count to use.
         *										0 or omitted	US (NASD) 30/360
         *										1				Actual/actual
         *										2				Actual/360
         *										3				Actual/365
         *										4				European 30/360
         * @return	float
         */
        public static function COUPDAYSNC($settlement, $maturity, $frequency, $basis = 0)
        {
        }
        //	function COUPDAYSNC()
        /**
         * COUPNCD
         *
         * Returns the next coupon date after the settlement date.
         *
         * Excel Function:
         *		COUPNCD(settlement,maturity,frequency[,basis])
         *
         * @access	public
         * @category Financial Functions
         * @param	mixed	settlement	The security's settlement date.
         *								The security settlement date is the date after the issue
         *								date when the security is traded to the buyer.
         * @param	mixed	maturity	The security's maturity date.
         *								The maturity date is the date when the security expires.
         * @param	mixed	frequency	the number of coupon payments per year.
         *									Valid frequency values are:
         *										1	Annual
         *										2	Semi-Annual
         *										4	Quarterly
         *									If working in Gnumeric Mode, the following frequency options are
         *									also available
         *										6	Bimonthly
         *										12	Monthly
         * @param	integer		basis		The type of day count to use.
         *										0 or omitted	US (NASD) 30/360
         *										1				Actual/actual
         *										2				Actual/360
         *										3				Actual/365
         *										4				European 30/360
         * @return	mixed	Excel date/time serial value, PHP date/time serial value or PHP date/time object,
         *						depending on the value of the ReturnDateType flag
         */
        public static function COUPNCD($settlement, $maturity, $frequency, $basis = 0)
        {
        }
        //	function COUPNCD()
        /**
         * COUPNUM
         *
         * Returns the number of coupons payable between the settlement date and maturity date,
         * rounded up to the nearest whole coupon.
         *
         * Excel Function:
         *		COUPNUM(settlement,maturity,frequency[,basis])
         *
         * @access	public
         * @category Financial Functions
         * @param	mixed	settlement	The security's settlement date.
         *								The security settlement date is the date after the issue
         *								date when the security is traded to the buyer.
         * @param	mixed	maturity	The security's maturity date.
         *								The maturity date is the date when the security expires.
         * @param	mixed	frequency	the number of coupon payments per year.
         *									Valid frequency values are:
         *										1	Annual
         *										2	Semi-Annual
         *										4	Quarterly
         *									If working in Gnumeric Mode, the following frequency options are
         *									also available
         *										6	Bimonthly
         *										12	Monthly
         * @param	integer		basis		The type of day count to use.
         *										0 or omitted	US (NASD) 30/360
         *										1				Actual/actual
         *										2				Actual/360
         *										3				Actual/365
         *										4				European 30/360
         * @return	integer
         */
        public static function COUPNUM($settlement, $maturity, $frequency, $basis = 0)
        {
        }
        //	function COUPNUM()
        /**
         * COUPPCD
         *
         * Returns the previous coupon date before the settlement date.
         *
         * Excel Function:
         *		COUPPCD(settlement,maturity,frequency[,basis])
         *
         * @access	public
         * @category Financial Functions
         * @param	mixed	settlement	The security's settlement date.
         *								The security settlement date is the date after the issue
         *								date when the security is traded to the buyer.
         * @param	mixed	maturity	The security's maturity date.
         *								The maturity date is the date when the security expires.
         * @param	mixed	frequency	the number of coupon payments per year.
         *									Valid frequency values are:
         *										1	Annual
         *										2	Semi-Annual
         *										4	Quarterly
         *									If working in Gnumeric Mode, the following frequency options are
         *									also available
         *										6	Bimonthly
         *										12	Monthly
         * @param	integer		basis		The type of day count to use.
         *										0 or omitted	US (NASD) 30/360
         *										1				Actual/actual
         *										2				Actual/360
         *										3				Actual/365
         *										4				European 30/360
         * @return	mixed	Excel date/time serial value, PHP date/time serial value or PHP date/time object,
         *						depending on the value of the ReturnDateType flag
         */
        public static function COUPPCD($settlement, $maturity, $frequency, $basis = 0)
        {
        }
        //	function COUPPCD()
        /**
         * CUMIPMT
         *
         * Returns the cumulative interest paid on a loan between the start and end periods.
         *
         * Excel Function:
         *		CUMIPMT(rate,nper,pv,start,end[,type])
         *
         * @access	public
         * @category Financial Functions
         * @param	float	$rate	The Interest rate
         * @param	integer	$nper	The total number of payment periods
         * @param	float	$pv		Present Value
         * @param	integer	$start	The first period in the calculation.
         *							Payment periods are numbered beginning with 1.
         * @param	integer	$end	The last period in the calculation.
         * @param	integer	$type	A number 0 or 1 and indicates when payments are due:
         *								0 or omitted	At the end of the period.
         *								1				At the beginning of the period.
         * @return	float
         */
        public static function CUMIPMT($rate, $nper, $pv, $start, $end, $type = 0)
        {
        }
        //	function CUMIPMT()
        /**
         * CUMPRINC
         *
         * Returns the cumulative principal paid on a loan between the start and end periods.
         *
         * Excel Function:
         *		CUMPRINC(rate,nper,pv,start,end[,type])
         *
         * @access	public
         * @category Financial Functions
         * @param	float	$rate	The Interest rate
         * @param	integer	$nper	The total number of payment periods
         * @param	float	$pv		Present Value
         * @param	integer	$start	The first period in the calculation.
         *							Payment periods are numbered beginning with 1.
         * @param	integer	$end	The last period in the calculation.
         * @param	integer	$type	A number 0 or 1 and indicates when payments are due:
         *								0 or omitted	At the end of the period.
         *								1				At the beginning of the period.
         * @return	float
         */
        public static function CUMPRINC($rate, $nper, $pv, $start, $end, $type = 0)
        {
        }
        //	function CUMPRINC()
        /**
         * DB
         *
         * Returns the depreciation of an asset for a specified period using the
         * fixed-declining balance method.
         * This form of depreciation is used if you want to get a higher depreciation value
         * at the beginning of the depreciation (as opposed to linear depreciation). The
         * depreciation value is reduced with every depreciation period by the depreciation
         * already deducted from the initial cost.
         *
         * Excel Function:
         *		DB(cost,salvage,life,period[,month])
         *
         * @access	public
         * @category Financial Functions
         * @param	float	cost		Initial cost of the asset.
         * @param	float	salvage		Value at the end of the depreciation.
         *								(Sometimes called the salvage value of the asset)
         * @param	integer	life		Number of periods over which the asset is depreciated.
         *								(Sometimes called the useful life of the asset)
         * @param	integer	period		The period for which you want to calculate the
         *								depreciation. Period must use the same units as life.
         * @param	integer	month		Number of months in the first year. If month is omitted,
         *								it defaults to 12.
         * @return	float
         */
        public static function DB($cost, $salvage, $life, $period, $month = 12)
        {
        }
        //	function DB()
        /**
         * DDB
         *
         * Returns the depreciation of an asset for a specified period using the
         * double-declining balance method or some other method you specify.
         *
         * Excel Function:
         *		DDB(cost,salvage,life,period[,factor])
         *
         * @access	public
         * @category Financial Functions
         * @param	float	cost		Initial cost of the asset.
         * @param	float	salvage		Value at the end of the depreciation.
         *								(Sometimes called the salvage value of the asset)
         * @param	integer	life		Number of periods over which the asset is depreciated.
         *								(Sometimes called the useful life of the asset)
         * @param	integer	period		The period for which you want to calculate the
         *								depreciation. Period must use the same units as life.
         * @param	float	factor		The rate at which the balance declines.
         *								If factor is omitted, it is assumed to be 2 (the
         *								double-declining balance method).
         * @return	float
         */
        public static function DDB($cost, $salvage, $life, $period, $factor = 2.0)
        {
        }
        //	function DDB()
        /**
         * DISC
         *
         * Returns the discount rate for a security.
         *
         * Excel Function:
         *		DISC(settlement,maturity,price,redemption[,basis])
         *
         * @access	public
         * @category Financial Functions
         * @param	mixed	settlement	The security's settlement date.
         *								The security settlement date is the date after the issue
         *								date when the security is traded to the buyer.
         * @param	mixed	maturity	The security's maturity date.
         *								The maturity date is the date when the security expires.
         * @param	integer	price		The security's price per $100 face value.
         * @param	integer	redemption	The security's redemption value per $100 face value.
         * @param	integer	basis		The type of day count to use.
         *										0 or omitted	US (NASD) 30/360
         *										1				Actual/actual
         *										2				Actual/360
         *										3				Actual/365
         *										4				European 30/360
         * @return	float
         */
        public static function DISC($settlement, $maturity, $price, $redemption, $basis = 0)
        {
        }
        //	function DISC()
        /**
         * DOLLARDE
         *
         * Converts a dollar price expressed as an integer part and a fraction
         *		part into a dollar price expressed as a decimal number.
         * Fractional dollar numbers are sometimes used for security prices.
         *
         * Excel Function:
         *		DOLLARDE(fractional_dollar,fraction)
         *
         * @access	public
         * @category Financial Functions
         * @param	float	$fractional_dollar	Fractional Dollar
         * @param	integer	$fraction			Fraction
         * @return	float
         */
        public static function DOLLARDE($fractional_dollar = \Null, $fraction = 0)
        {
        }
        //	function DOLLARDE()
        /**
         * DOLLARFR
         *
         * Converts a dollar price expressed as a decimal number into a dollar price
         *		expressed as a fraction.
         * Fractional dollar numbers are sometimes used for security prices.
         *
         * Excel Function:
         *		DOLLARFR(decimal_dollar,fraction)
         *
         * @access	public
         * @category Financial Functions
         * @param	float	$decimal_dollar		Decimal Dollar
         * @param	integer	$fraction			Fraction
         * @return	float
         */
        public static function DOLLARFR($decimal_dollar = \Null, $fraction = 0)
        {
        }
        //	function DOLLARFR()
        /**
         * EFFECT
         *
         * Returns the effective interest rate given the nominal rate and the number of
         *		compounding payments per year.
         *
         * Excel Function:
         *		EFFECT(nominal_rate,npery)
         *
         * @access	public
         * @category Financial Functions
         * @param	float	$nominal_rate		Nominal interest rate
         * @param	integer	$npery				Number of compounding payments per year
         * @return	float
         */
        public static function EFFECT($nominal_rate = 0, $npery = 0)
        {
        }
        //	function EFFECT()
        /**
         * FV
         *
         * Returns the Future Value of a cash flow with constant payments and interest rate (annuities).
         *
         * Excel Function:
         *		FV(rate,nper,pmt[,pv[,type]])
         *
         * @access	public
         * @category Financial Functions
         * @param	float	$rate	The interest rate per period
         * @param	int		$nper	Total number of payment periods in an annuity
         * @param	float	$pmt	The payment made each period: it cannot change over the
         *							life of the annuity. Typically, pmt contains principal
         *							and interest but no other fees or taxes.
         * @param	float	$pv		Present Value, or the lump-sum amount that a series of
         *							future payments is worth right now.
         * @param	integer	$type	A number 0 or 1 and indicates when payments are due:
         *								0 or omitted	At the end of the period.
         *								1				At the beginning of the period.
         * @return	float
         */
        public static function FV($rate = 0, $nper = 0, $pmt = 0, $pv = 0, $type = 0)
        {
        }
        //	function FV()
        /**
         * FVSCHEDULE
         *
         * Returns the future value of an initial principal after applying a series of compound interest rates.
         * Use FVSCHEDULE to calculate the future value of an investment with a variable or adjustable rate.
         *
         * Excel Function:
         *		FVSCHEDULE(principal,schedule)
         *
         * @param	float	$principal	The present value.
         * @param	float[]	$schedule	An array of interest rates to apply.
         * @return	float
         */
        public static function FVSCHEDULE($principal, $schedule)
        {
        }
        //	function FVSCHEDULE()
        /**
         * INTRATE
         *
         * Returns the interest rate for a fully invested security.
         *
         * Excel Function:
         *		INTRATE(settlement,maturity,investment,redemption[,basis])
         *
         * @param	mixed	$settlement	The security's settlement date.
         *								The security settlement date is the date after the issue date when the security is traded to the buyer.
         * @param	mixed	$maturity	The security's maturity date.
         *								The maturity date is the date when the security expires.
         * @param	integer	$investment	The amount invested in the security.
         * @param	integer	$redemption	The amount to be received at maturity.
         * @param	integer	$basis		The type of day count to use.
         *										0 or omitted	US (NASD) 30/360
         *										1				Actual/actual
         *										2				Actual/360
         *										3				Actual/365
         *										4				European 30/360
         * @return	float
         */
        public static function INTRATE($settlement, $maturity, $investment, $redemption, $basis = 0)
        {
        }
        //	function INTRATE()
        /**
         * IPMT
         *
         * Returns the interest payment for a given period for an investment based on periodic, constant payments and a constant interest rate.
         *
         * Excel Function:
         *		IPMT(rate,per,nper,pv[,fv][,type])
         *
         * @param	float	$rate	Interest rate per period
         * @param	int		$per	Period for which we want to find the interest
         * @param	int		$nper	Number of periods
         * @param	float	$pv		Present Value
         * @param	float	$fv		Future Value
         * @param	int		$type	Payment type: 0 = at the end of each period, 1 = at the beginning of each period
         * @return	float
         */
        public static function IPMT($rate, $per, $nper, $pv, $fv = 0, $type = 0)
        {
        }
        //	function IPMT()
        /**
         * IRR
         *
         * Returns the internal rate of return for a series of cash flows represented by the numbers in values. 
         * These cash flows do not have to be even, as they would be for an annuity. However, the cash flows must occur 
         * at regular intervals, such as monthly or annually. The internal rate of return is the interest rate received
         * for an investment consisting of payments (negative values) and income (positive values) that occur at regular 
         * periods.
         *
         * Excel Function:
         *		IRR(values[,guess])
         *
         * @param	float[]	$values		An array or a reference to cells that contain numbers for which you want
         *									to calculate the internal rate of return.
         *								Values must contain at least one positive value and one negative value to 
         *									calculate the internal rate of return.
         * @param	float	$guess		A number that you guess is close to the result of IRR
         * @return	float
         */
        public static function IRR($values, $guess = 0.1)
        {
        }
        //	function IRR()
        /**
         * ISPMT
         *
         * Returns the interest payment for an investment based on an interest rate and a constant payment schedule.
         *
         * Excel Function:
         *     =ISPMT(interest_rate, period, number_payments, PV)
         *
         * interest_rate is the interest rate for the investment
         *
         * period is the period to calculate the interest rate.  It must be betweeen 1 and number_payments.
         *
         * number_payments is the number of payments for the annuity
         *
         * PV is the loan amount or present value of the payments
         */
        public static function ISPMT()
        {
        }
        //	function ISPMT()
        /**
         * MIRR
         *
         * Returns the modified internal rate of return for a series of periodic cash flows. MIRR considers both 
         *		the cost of the investment and the interest received on reinvestment of cash.
         *
         * Excel Function:
         *		MIRR(values,finance_rate, reinvestment_rate)
         *
         * @param	float[]	$values				An array or a reference to cells that contain a series of payments and
         *											income occurring at regular intervals.
         *										Payments are negative value, income is positive values.
         * @param	float	$finance_rate		The interest rate you pay on the money used in the cash flows
         * @param	float	$reinvestment_rate	The interest rate you receive on the cash flows as you reinvest them
         * @return	float
         */
        public static function MIRR($values, $finance_rate, $reinvestment_rate)
        {
        }
        //	function MIRR()
        /**
         * NOMINAL
         *
         * Returns the nominal interest rate given the effective rate and the number of compounding payments per year.
         *
         * @param	float	$effect_rate	Effective interest rate
         * @param	int		$npery			Number of compounding payments per year
         * @return	float
         */
        public static function NOMINAL($effect_rate = 0, $npery = 0)
        {
        }
        //	function NOMINAL()
        /**
         * NPER
         *
         * Returns the number of periods for a cash flow with constant periodic payments (annuities), and interest rate.
         *
         * @param	float	$rate	Interest rate per period
         * @param	int		$pmt	Periodic payment (annuity)
         * @param	float	$pv		Present Value
         * @param	float	$fv		Future Value
         * @param	int		$type	Payment type: 0 = at the end of each period, 1 = at the beginning of each period
         * @return	float
         */
        public static function NPER($rate = 0, $pmt = 0, $pv = 0, $fv = 0, $type = 0)
        {
        }
        //	function NPER()
        /**
         * NPV
         *
         * Returns the Net Present Value of a cash flow series given a discount rate.
         *
         * @return	float
         */
        public static function NPV()
        {
        }
        //	function NPV()
        /**
         * PMT
         *
         * Returns the constant payment (annuity) for a cash flow with a constant interest rate.
         *
         * @param	float	$rate	Interest rate per period
         * @param	int		$nper	Number of periods
         * @param	float	$pv		Present Value
         * @param	float	$fv		Future Value
         * @param	int		$type	Payment type: 0 = at the end of each period, 1 = at the beginning of each period
         * @return	float
         */
        public static function PMT($rate = 0, $nper = 0, $pv = 0, $fv = 0, $type = 0)
        {
        }
        //	function PMT()
        /**
         * PPMT
         *
         * Returns the interest payment for a given period for an investment based on periodic, constant payments and a constant interest rate.
         *
         * @param	float	$rate	Interest rate per period
         * @param	int		$per	Period for which we want to find the interest
         * @param	int		$nper	Number of periods
         * @param	float	$pv		Present Value
         * @param	float	$fv		Future Value
         * @param	int		$type	Payment type: 0 = at the end of each period, 1 = at the beginning of each period
         * @return	float
         */
        public static function PPMT($rate, $per, $nper, $pv, $fv = 0, $type = 0)
        {
        }
        //	function PPMT()
        public static function PRICE($settlement, $maturity, $rate, $yield, $redemption, $frequency, $basis = 0)
        {
        }
        //	function PRICE()
        /**
         * PRICEDISC
         *
         * Returns the price per $100 face value of a discounted security.
         *
         * @param	mixed	settlement	The security's settlement date.
         *								The security settlement date is the date after the issue date when the security is traded to the buyer.
         * @param	mixed	maturity	The security's maturity date.
         *								The maturity date is the date when the security expires.
         * @param	int		discount	The security's discount rate.
         * @param	int		redemption	The security's redemption value per $100 face value.
         * @param	int		basis		The type of day count to use.
         *										0 or omitted	US (NASD) 30/360
         *										1				Actual/actual
         *										2				Actual/360
         *										3				Actual/365
         *										4				European 30/360
         * @return	float
         */
        public static function PRICEDISC($settlement, $maturity, $discount, $redemption, $basis = 0)
        {
        }
        //	function PRICEDISC()
        /**
         * PRICEMAT
         *
         * Returns the price per $100 face value of a security that pays interest at maturity.
         *
         * @param	mixed	settlement	The security's settlement date.
         *								The security's settlement date is the date after the issue date when the security is traded to the buyer.
         * @param	mixed	maturity	The security's maturity date.
         *								The maturity date is the date when the security expires.
         * @param	mixed	issue		The security's issue date.
         * @param	int		rate		The security's interest rate at date of issue.
         * @param	int		yield		The security's annual yield.
         * @param	int		basis		The type of day count to use.
         *										0 or omitted	US (NASD) 30/360
         *										1				Actual/actual
         *										2				Actual/360
         *										3				Actual/365
         *										4				European 30/360
         * @return	float
         */
        public static function PRICEMAT($settlement, $maturity, $issue, $rate, $yield, $basis = 0)
        {
        }
        //	function PRICEMAT()
        /**
         * PV
         *
         * Returns the Present Value of a cash flow with constant payments and interest rate (annuities).
         *
         * @param	float	$rate	Interest rate per period
         * @param	int		$nper	Number of periods
         * @param	float	$pmt	Periodic payment (annuity)
         * @param	float	$fv		Future Value
         * @param	int		$type	Payment type: 0 = at the end of each period, 1 = at the beginning of each period
         * @return	float
         */
        public static function PV($rate = 0, $nper = 0, $pmt = 0, $fv = 0, $type = 0)
        {
        }
        //	function PV()
        /**
         * RATE
         *
         * Returns the interest rate per period of an annuity.
         * RATE is calculated by iteration and can have zero or more solutions.
         * If the successive results of RATE do not converge to within 0.0000001 after 20 iterations,
         * RATE returns the #NUM! error value.
         *
         * Excel Function:
         *		RATE(nper,pmt,pv[,fv[,type[,guess]]])
         *
         * @access	public
         * @category Financial Functions
         * @param	float	nper		The total number of payment periods in an annuity.
         * @param	float	pmt			The payment made each period and cannot change over the life
         *									of the annuity.
         *								Typically, pmt includes principal and interest but no other
         *									fees or taxes.
         * @param	float	pv			The present value - the total amount that a series of future
         *									payments is worth now.
         * @param	float	fv			The future value, or a cash balance you want to attain after
         *									the last payment is made. If fv is omitted, it is assumed
         *									to be 0 (the future value of a loan, for example, is 0).
         * @param	integer	type		A number 0 or 1 and indicates when payments are due:
         *										0 or omitted	At the end of the period.
         *										1				At the beginning of the period.
         * @param	float	guess		Your guess for what the rate will be.
         *									If you omit guess, it is assumed to be 10 percent.
         * @return	float
         **/
        public static function RATE($nper, $pmt, $pv, $fv = 0.0, $type = 0, $guess = 0.1)
        {
        }
        //	function RATE()
        /**
         * RECEIVED
         *
         * Returns the price per $100 face value of a discounted security.
         *
         * @param	mixed	settlement	The security's settlement date.
         *								The security settlement date is the date after the issue date when the security is traded to the buyer.
         * @param	mixed	maturity	The security's maturity date.
         *								The maturity date is the date when the security expires.
         * @param	int		investment	The amount invested in the security.
         * @param	int		discount	The security's discount rate.
         * @param	int		basis		The type of day count to use.
         *										0 or omitted	US (NASD) 30/360
         *										1				Actual/actual
         *										2				Actual/360
         *										3				Actual/365
         *										4				European 30/360
         * @return	float
         */
        public static function RECEIVED($settlement, $maturity, $investment, $discount, $basis = 0)
        {
        }
        //	function RECEIVED()
        /**
         * SLN
         *
         * Returns the straight-line depreciation of an asset for one period
         *
         * @param	cost		Initial cost of the asset
         * @param	salvage		Value at the end of the depreciation
         * @param	life		Number of periods over which the asset is depreciated
         * @return	float
         */
        public static function SLN($cost, $salvage, $life)
        {
        }
        //	function SLN()
        /**
         * SYD
         *
         * Returns the sum-of-years' digits depreciation of an asset for a specified period.
         *
         * @param	cost		Initial cost of the asset
         * @param	salvage		Value at the end of the depreciation
         * @param	life		Number of periods over which the asset is depreciated
         * @param	period		Period
         * @return	float
         */
        public static function SYD($cost, $salvage, $life, $period)
        {
        }
        //	function SYD()
        /**
         * TBILLEQ
         *
         * Returns the bond-equivalent yield for a Treasury bill.
         *
         * @param	mixed	settlement	The Treasury bill's settlement date.
         *								The Treasury bill's settlement date is the date after the issue date when the Treasury bill is traded to the buyer.
         * @param	mixed	maturity	The Treasury bill's maturity date.
         *								The maturity date is the date when the Treasury bill expires.
         * @param	int		discount	The Treasury bill's discount rate.
         * @return	float
         */
        public static function TBILLEQ($settlement, $maturity, $discount)
        {
        }
        //	function TBILLEQ()
        /**
         * TBILLPRICE
         *
         * Returns the yield for a Treasury bill.
         *
         * @param	mixed	settlement	The Treasury bill's settlement date.
         *								The Treasury bill's settlement date is the date after the issue date when the Treasury bill is traded to the buyer.
         * @param	mixed	maturity	The Treasury bill's maturity date.
         *								The maturity date is the date when the Treasury bill expires.
         * @param	int		discount	The Treasury bill's discount rate.
         * @return	float
         */
        public static function TBILLPRICE($settlement, $maturity, $discount)
        {
        }
        //	function TBILLPRICE()
        /**
         * TBILLYIELD
         *
         * Returns the yield for a Treasury bill.
         *
         * @param	mixed	settlement	The Treasury bill's settlement date.
         *								The Treasury bill's settlement date is the date after the issue date when the Treasury bill is traded to the buyer.
         * @param	mixed	maturity	The Treasury bill's maturity date.
         *								The maturity date is the date when the Treasury bill expires.
         * @param	int		price		The Treasury bill's price per $100 face value.
         * @return	float
         */
        public static function TBILLYIELD($settlement, $maturity, $price)
        {
        }
        //	function TBILLYIELD()
        public static function XIRR($values, $dates, $guess = 0.1)
        {
        }
        /**
         * XNPV
         *
         * Returns the net present value for a schedule of cash flows that is not necessarily periodic.
         * To calculate the net present value for a series of cash flows that is periodic, use the NPV function.
         *
         * Excel Function:
         *		=XNPV(rate,values,dates)
         *
         * @param	float			$rate		The discount rate to apply to the cash flows.
         * @param	array of float	$values		A series of cash flows that corresponds to a schedule of payments in dates. The first payment is optional and corresponds to a cost or payment that occurs at the beginning of the investment. If the first value is a cost or payment, it must be a negative value. All succeeding payments are discounted based on a 365-day year. The series of values must contain at least one positive value and one negative value.
         * @param	array of mixed	$dates		A schedule of payment dates that corresponds to the cash flow payments. The first payment date indicates the beginning of the schedule of payments. All other dates must be later than this date, but they may occur in any order.
         * @return	float
         */
        public static function XNPV($rate, $values, $dates)
        {
        }
        //	function XNPV()
        /**
         * YIELDDISC
         *
         * Returns the annual yield of a security that pays interest at maturity.
         *
         * @param	mixed	settlement	The security's settlement date.
         *								The security's settlement date is the date after the issue date when the security is traded to the buyer.
         * @param	mixed	maturity	The security's maturity date.
         *								The maturity date is the date when the security expires.
         * @param	int		price		The security's price per $100 face value.
         * @param	int		redemption	The security's redemption value per $100 face value.
         * @param	int		basis		The type of day count to use.
         *										0 or omitted	US (NASD) 30/360
         *										1				Actual/actual
         *										2				Actual/360
         *										3				Actual/365
         *										4				European 30/360
         * @return	float
         */
        public static function YIELDDISC($settlement, $maturity, $price, $redemption, $basis = 0)
        {
        }
        //	function YIELDDISC()
        /**
         * YIELDMAT
         *
         * Returns the annual yield of a security that pays interest at maturity.
         *
         * @param	mixed	settlement	The security's settlement date.
         *								The security's settlement date is the date after the issue date when the security is traded to the buyer.
         * @param	mixed	maturity	The security's maturity date.
         *								The maturity date is the date when the security expires.
         * @param	mixed	issue		The security's issue date.
         * @param	int		rate		The security's interest rate at date of issue.
         * @param	int		price		The security's price per $100 face value.
         * @param	int		basis		The type of day count to use.
         *										0 or omitted	US (NASD) 30/360
         *										1				Actual/actual
         *										2				Actual/360
         *										3				Actual/365
         *										4				European 30/360
         * @return	float
         */
        public static function YIELDMAT($settlement, $maturity, $issue, $rate, $price, $basis = 0)
        {
        }
        //	function YIELDMAT()
    }
    /**
     * PHPExcel_Calculation_TextData
     *
     * @category	PHPExcel
     * @package		PHPExcel_Calculation
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Calculation_TextData
    {
        private static $_invalidChars = \Null;
        private static function _uniord($c)
        {
        }
        //	function _uniord()
        /**
         * CHARACTER
         *
         * @param	string	$character	Value
         * @return	int
         */
        public static function CHARACTER($character)
        {
        }
        /**
         * TRIMNONPRINTABLE
         *
         * @param	mixed	$stringValue	Value to check
         * @return	string
         */
        public static function TRIMNONPRINTABLE($stringValue = '')
        {
        }
        //	function TRIMNONPRINTABLE()
        /**
         * TRIMSPACES
         *
         * @param	mixed	$stringValue	Value to check
         * @return	string
         */
        public static function TRIMSPACES($stringValue = '')
        {
        }
        //	function TRIMSPACES()
        /**
         * ASCIICODE
         *
         * @param	string	$characters		Value
         * @return	int
         */
        public static function ASCIICODE($characters)
        {
        }
        //	function ASCIICODE()
        /**
         * CONCATENATE
         *
         * @return	string
         */
        public static function CONCATENATE()
        {
        }
        //	function CONCATENATE()
        /**
         * DOLLAR
         *
         * This function converts a number to text using currency format, with the decimals rounded to the specified place.
         * The format used is $#,##0.00_);($#,##0.00)..
         *
         * @param	float	$value			The value to format
         * @param	int		$decimals		The number of digits to display to the right of the decimal point.
         *									If decimals is negative, number is rounded to the left of the decimal point.
         *									If you omit decimals, it is assumed to be 2
         * @return	string
         */
        public static function DOLLAR($value = 0, $decimals = 2)
        {
        }
        //	function DOLLAR()
        /**
         * SEARCHSENSITIVE
         *
         * @param	string	$needle		The string to look for
         * @param	string	$haystack	The string in which to look
         * @param	int		$offset		Offset within $haystack
         * @return	string
         */
        public static function SEARCHSENSITIVE($needle, $haystack, $offset = 1)
        {
        }
        //	function SEARCHSENSITIVE()
        /**
         * SEARCHINSENSITIVE
         *
         * @param	string	$needle		The string to look for
         * @param	string	$haystack	The string in which to look
         * @param	int		$offset		Offset within $haystack
         * @return	string
         */
        public static function SEARCHINSENSITIVE($needle, $haystack, $offset = 1)
        {
        }
        //	function SEARCHINSENSITIVE()
        /**
         * FIXEDFORMAT
         *
         * @param	mixed		$value	Value to check
         * @param	integer		$decimals
         * @param	boolean		$no_commas
         * @return	boolean
         */
        public static function FIXEDFORMAT($value, $decimals = 2, $no_commas = \FALSE)
        {
        }
        //	function FIXEDFORMAT()
        /**
         * LEFT
         *
         * @param	string	$value	Value
         * @param	int		$chars	Number of characters
         * @return	string
         */
        public static function LEFT($value = '', $chars = 1)
        {
        }
        //	function LEFT()
        /**
         * MID
         *
         * @param	string	$value	Value
         * @param	int		$start	Start character
         * @param	int		$chars	Number of characters
         * @return	string
         */
        public static function MID($value = '', $start = 1, $chars = \null)
        {
        }
        //	function MID()
        /**
         * RIGHT
         *
         * @param	string	$value	Value
         * @param	int		$chars	Number of characters
         * @return	string
         */
        public static function RIGHT($value = '', $chars = 1)
        {
        }
        //	function RIGHT()
        /**
         * STRINGLENGTH
         *
         * @param	string	$value	Value
         * @return	string
         */
        public static function STRINGLENGTH($value = '')
        {
        }
        //	function STRINGLENGTH()
        /**
         * LOWERCASE
         *
         * Converts a string value to upper case.
         *
         * @param	string		$mixedCaseString
         * @return	string
         */
        public static function LOWERCASE($mixedCaseString)
        {
        }
        //	function LOWERCASE()
        /**
         * UPPERCASE
         *
         * Converts a string value to upper case.
         *
         * @param	string		$mixedCaseString
         * @return	string
         */
        public static function UPPERCASE($mixedCaseString)
        {
        }
        //	function UPPERCASE()
        /**
         * PROPERCASE
         *
         * Converts a string value to upper case.
         *
         * @param	string		$mixedCaseString
         * @return	string
         */
        public static function PROPERCASE($mixedCaseString)
        {
        }
        //	function PROPERCASE()
        /**
         * REPLACE
         *
         * @param	string	$oldText	String to modify
         * @param	int		$start		Start character
         * @param	int		$chars		Number of characters
         * @param	string	$newText	String to replace in defined position 
         * @return	string
         */
        public static function REPLACE($oldText = '', $start = 1, $chars = \null, $newText)
        {
        }
        //	function REPLACE()
        /**
         * SUBSTITUTE
         *
         * @param	string	$text		Value
         * @param	string	$fromText	From Value
         * @param	string	$toText		To Value
         * @param	integer	$instance	Instance Number
         * @return	string
         */
        public static function SUBSTITUTE($text = '', $fromText = '', $toText = '', $instance = 0)
        {
        }
        //	function SUBSTITUTE()
        /**
         * RETURNSTRING
         *
         * @param	mixed	$testValue	Value to check
         * @return	boolean
         */
        public static function RETURNSTRING($testValue = '')
        {
        }
        //	function RETURNSTRING()
        /**
         * TEXTFORMAT
         *
         * @param	mixed	$value	Value to check
         * @param	string	$format	Format mask to use
         * @return	boolean
         */
        public static function TEXTFORMAT($value, $format)
        {
        }
        //	function TEXTFORMAT()
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Calculation
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Calculation_Function
     *
     * @category   PHPExcel
     * @package    PHPExcel_Calculation
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Calculation_Function
    {
        /* Function categories */
        const CATEGORY_CUBE = 'Cube';
        const CATEGORY_DATABASE = 'Database';
        const CATEGORY_DATE_AND_TIME = 'Date and Time';
        const CATEGORY_ENGINEERING = 'Engineering';
        const CATEGORY_FINANCIAL = 'Financial';
        const CATEGORY_INFORMATION = 'Information';
        const CATEGORY_LOGICAL = 'Logical';
        const CATEGORY_LOOKUP_AND_REFERENCE = 'Lookup and Reference';
        const CATEGORY_MATH_AND_TRIG = 'Math and Trig';
        const CATEGORY_STATISTICAL = 'Statistical';
        const CATEGORY_TEXT_AND_DATA = 'Text and Data';
        /**
         * Category (represented by CATEGORY_*)
         *
         * @var string
         */
        private $_category;
        /**
         * Excel name
         *
         * @var string
         */
        private $_excelName;
        /**
         * PHPExcel name
         *
         * @var string
         */
        private $_phpExcelName;
        /**
         * Create a new PHPExcel_Calculation_Function
         *
         * @param 	string		$pCategory 		Category (represented by CATEGORY_*)
         * @param 	string		$pExcelName		Excel function name
         * @param 	string		$pPHPExcelName	PHPExcel function mapping
         * @throws 	PHPExcel_Calculation_Exception
         */
        public function __construct($pCategory = \NULL, $pExcelName = \NULL, $pPHPExcelName = \NULL)
        {
        }
        /**
         * Get Category (represented by CATEGORY_*)
         *
         * @return string
         */
        public function getCategory()
        {
        }
        /**
         * Set Category (represented by CATEGORY_*)
         *
         * @param 	string		$value
         * @throws 	PHPExcel_Calculation_Exception
         */
        public function setCategory($value = \null)
        {
        }
        /**
         * Get Excel name
         *
         * @return string
         */
        public function getExcelName()
        {
        }
        /**
         * Set Excel name
         *
         * @param string	$value
         */
        public function setExcelName($value)
        {
        }
        /**
         * Get PHPExcel name
         *
         * @return string
         */
        public function getPHPExcelName()
        {
        }
        /**
         * Set PHPExcel name
         *
         * @param string	$value
         */
        public function setPHPExcelName($value)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Calculation
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /*
    PARTLY BASED ON:
    	Copyright (c) 2007 E. W. Bachtal, Inc.
    
    	Permission is hereby granted, free of charge, to any person obtaining a copy of this software
    	and associated documentation files (the "Software"), to deal in the Software without restriction,
    	including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
    	and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
    	subject to the following conditions:
    
    	  The above copyright notice and this permission notice shall be included in all copies or substantial
    	  portions of the Software.
    
    	The software is provided "as is", without warranty of any kind, express or implied, including but not
    	limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In
    	no event shall the authors or copyright holders be liable for any claim, damages or other liability,
    	whether in an action of contract, tort or otherwise, arising from, out of or in connection with the
    	software or the use or other dealings in the software.
    
    	http://ewbi.blogs.com/develops/2007/03/excel_formula_p.html
    	http://ewbi.blogs.com/develops/2004/12/excel_formula_p.html
    */
    /**
     * PHPExcel_Calculation_FormulaParser
     *
     * @category   PHPExcel
     * @package    PHPExcel_Calculation
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Calculation_FormulaParser
    {
        /* Character constants */
        const QUOTE_DOUBLE = '"';
        const QUOTE_SINGLE = '\'';
        const BRACKET_CLOSE = ']';
        const BRACKET_OPEN = '[';
        const BRACE_OPEN = '{';
        const BRACE_CLOSE = '}';
        const PAREN_OPEN = '(';
        const PAREN_CLOSE = ')';
        const SEMICOLON = ';';
        const WHITESPACE = ' ';
        const COMMA = ',';
        const ERROR_START = '#';
        const OPERATORS_SN = "+-";
        const OPERATORS_INFIX = "+-*/^&=><";
        const OPERATORS_POSTFIX = "%";
        /**
         * Formula
         *
         * @var string
         */
        private $_formula;
        /**
         * Tokens
         *
         * @var PHPExcel_Calculation_FormulaToken[]
         */
        private $_tokens = array();
        /**
         * Create a new PHPExcel_Calculation_FormulaParser
         *
         * @param 	string		$pFormula	Formula to parse
         * @throws 	PHPExcel_Calculation_Exception
         */
        public function __construct($pFormula = '')
        {
        }
        /**
         * Get Formula
         *
         * @return string
         */
        public function getFormula()
        {
        }
        /**
         * Get Token
         *
         * @param 	int		$pId	Token id
         * @return	string
         * @throws  PHPExcel_Calculation_Exception
         */
        public function getToken($pId = 0)
        {
        }
        /**
         * Get Token count
         *
         * @return string
         */
        public function getTokenCount()
        {
        }
        /**
         * Get Tokens
         *
         * @return PHPExcel_Calculation_FormulaToken[]
         */
        public function getTokens()
        {
        }
        /**
         * Parse to tokens
         */
        private function _parseToTokens()
        {
        }
    }
    /**
     * PHPExcel_Calculation_Statistical
     *
     * @category	PHPExcel
     * @package		PHPExcel_Calculation
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Calculation_Statistical
    {
        private static function _checkTrendArrays(&$array1, &$array2)
        {
        }
        //	function _checkTrendArrays()
        /**
         * Beta function.
         *
         * @author Jaco van Kooten
         *
         * @param p require p>0
         * @param q require q>0
         * @return 0 if p<=0, q<=0 or p+q>2.55E305 to avoid errors and over/underflow
         */
        private static function _beta($p, $q)
        {
        }
        //	function _beta()
        /**
         * Incomplete beta function
         *
         * @author Jaco van Kooten
         * @author Paul Meagher
         *
         * The computation is based on formulas from Numerical Recipes, Chapter 6.4 (W.H. Press et al, 1992).
         * @param x require 0<=x<=1
         * @param p require p>0
         * @param q require q>0
         * @return 0 if x<0, p<=0, q<=0 or p+q>2.55E305 and 1 if x>1 to avoid errors and over/underflow
         */
        private static function _incompleteBeta($x, $p, $q)
        {
        }
        //	function _incompleteBeta()
        // Function cache for _logBeta function
        private static $_logBetaCache_p = 0.0;
        private static $_logBetaCache_q = 0.0;
        private static $_logBetaCache_result = 0.0;
        /**
         * The natural logarithm of the beta function.
         *
         * @param p require p>0
         * @param q require q>0
         * @return 0 if p<=0, q<=0 or p+q>2.55E305 to avoid errors and over/underflow
         * @author Jaco van Kooten
         */
        private static function _logBeta($p, $q)
        {
        }
        //	function _logBeta()
        /**
         * Evaluates of continued fraction part of incomplete beta function.
         * Based on an idea from Numerical Recipes (W.H. Press et al, 1992).
         * @author Jaco van Kooten
         */
        private static function _betaFraction($x, $p, $q)
        {
        }
        //	function _betaFraction()
        /**
         * logGamma function
         *
         * @version 1.1
         * @author Jaco van Kooten
         *
         * Original author was Jaco van Kooten. Ported to PHP by Paul Meagher.
         *
         * The natural logarithm of the gamma function. <br />
         * Based on public domain NETLIB (Fortran) code by W. J. Cody and L. Stoltz <br />
         * Applied Mathematics Division <br />
         * Argonne National Laboratory <br />
         * Argonne, IL 60439 <br />
         * <p>
         * References:
         * <ol>
         * <li>W. J. Cody and K. E. Hillstrom, 'Chebyshev Approximations for the Natural
         *	 Logarithm of the Gamma Function,' Math. Comp. 21, 1967, pp. 198-203.</li>
         * <li>K. E. Hillstrom, ANL/AMD Program ANLC366S, DGAMMA/DLGAMA, May, 1969.</li>
         * <li>Hart, Et. Al., Computer Approximations, Wiley and sons, New York, 1968.</li>
         * </ol>
         * </p>
         * <p>
         * From the original documentation:
         * </p>
         * <p>
         * This routine calculates the LOG(GAMMA) function for a positive real argument X.
         * Computation is based on an algorithm outlined in references 1 and 2.
         * The program uses rational functions that theoretically approximate LOG(GAMMA)
         * to at least 18 significant decimal digits. The approximation for X > 12 is from
         * reference 3, while approximations for X < 12.0 are similar to those in reference
         * 1, but are unpublished. The accuracy achieved depends on the arithmetic system,
         * the compiler, the intrinsic functions, and proper selection of the
         * machine-dependent constants.
         * </p>
         * <p>
         * Error returns: <br />
         * The program returns the value XINF for X .LE. 0.0 or when overflow would occur.
         * The computation is believed to be free of underflow and overflow.
         * </p>
         * @return MAX_VALUE for x < 0.0 or when overflow would occur, i.e. x > 2.55E305
         */
        // Function cache for logGamma
        private static $_logGammaCache_result = 0.0;
        private static $_logGammaCache_x = 0.0;
        private static function _logGamma($x)
        {
        }
        //	function _logGamma()
        //
        //	Private implementation of the incomplete Gamma function
        //
        private static function _incompleteGamma($a, $x)
        {
        }
        //	function _incompleteGamma()
        //
        //	Private implementation of the Gamma function
        //
        private static function _gamma($data)
        {
        }
        //	function _gamma()
        /***************************************************************************
         *								inverse_ncdf.php
         *							-------------------
         *	begin				: Friday, January 16, 2004
         *	copyright			: (C) 2004 Michael Nickerson
         *	email				: nickersonm@yahoo.com
         *
         ***************************************************************************/
        private static function _inverse_ncdf($p)
        {
        }
        //	function _inverse_ncdf()
        private static function _inverse_ncdf2($prob)
        {
        }
        //	function _inverse_ncdf2()
        private static function _inverse_ncdf3($p)
        {
        }
        //	function _inverse_ncdf3()
        /**
         * AVEDEV
         *
         * Returns the average of the absolute deviations of data points from their mean.
         * AVEDEV is a measure of the variability in a data set.
         *
         * Excel Function:
         *		AVEDEV(value1[,value2[, ...]])
         *
         * @access	public
         * @category Statistical Functions
         * @param	mixed		$arg,...		Data values
         * @return	float
         */
        public static function AVEDEV()
        {
        }
        //	function AVEDEV()
        /**
         * AVERAGE
         *
         * Returns the average (arithmetic mean) of the arguments
         *
         * Excel Function:
         *		AVERAGE(value1[,value2[, ...]])
         *
         * @access	public
         * @category Statistical Functions
         * @param	mixed		$arg,...		Data values
         * @return	float
         */
        public static function AVERAGE()
        {
        }
        //	function AVERAGE()
        /**
         * AVERAGEA
         *
         * Returns the average of its arguments, including numbers, text, and logical values
         *
         * Excel Function:
         *		AVERAGEA(value1[,value2[, ...]])
         *
         * @access	public
         * @category Statistical Functions
         * @param	mixed		$arg,...		Data values
         * @return	float
         */
        public static function AVERAGEA()
        {
        }
        //	function AVERAGEA()
        /**
         * AVERAGEIF
         *
         * Returns the average value from a range of cells that contain numbers within the list of arguments
         *
         * Excel Function:
         *		AVERAGEIF(value1[,value2[, ...]],condition)
         *
         * @access	public
         * @category Mathematical and Trigonometric Functions
         * @param	mixed		$arg,...		Data values
         * @param	string		$condition		The criteria that defines which cells will be checked.
         * @param	mixed[]		$averageArgs	Data values
         * @return	float
         */
        public static function AVERAGEIF($aArgs, $condition, $averageArgs = array())
        {
        }
        //	function AVERAGEIF()
        /**
         * BETADIST
         *
         * Returns the beta distribution.
         *
         * @param	float		$value			Value at which you want to evaluate the distribution
         * @param	float		$alpha			Parameter to the distribution
         * @param	float		$beta			Parameter to the distribution
         * @param	boolean		$cumulative
         * @return	float
         *
         */
        public static function BETADIST($value, $alpha, $beta, $rMin = 0, $rMax = 1)
        {
        }
        //	function BETADIST()
        /**
         * BETAINV
         *
         * Returns the inverse of the beta distribution.
         *
         * @param	float		$probability	Probability at which you want to evaluate the distribution
         * @param	float		$alpha			Parameter to the distribution
         * @param	float		$beta			Parameter to the distribution
         * @param	float		$rMin			Minimum value
         * @param	float		$rMax			Maximum value
         * @param	boolean		$cumulative
         * @return	float
         *
         */
        public static function BETAINV($probability, $alpha, $beta, $rMin = 0, $rMax = 1)
        {
        }
        //	function BETAINV()
        /**
         * BINOMDIST
         *
         * Returns the individual term binomial distribution probability. Use BINOMDIST in problems with
         *		a fixed number of tests or trials, when the outcomes of any trial are only success or failure,
         *		when trials are independent, and when the probability of success is constant throughout the
         *		experiment. For example, BINOMDIST can calculate the probability that two of the next three
         *		babies born are male.
         *
         * @param	float		$value			Number of successes in trials
         * @param	float		$trials			Number of trials
         * @param	float		$probability	Probability of success on each trial
         * @param	boolean		$cumulative
         * @return	float
         *
         * @todo	Cumulative distribution function
         *
         */
        public static function BINOMDIST($value, $trials, $probability, $cumulative)
        {
        }
        //	function BINOMDIST()
        /**
         * CHIDIST
         *
         * Returns the one-tailed probability of the chi-squared distribution.
         *
         * @param	float		$value			Value for the function
         * @param	float		$degrees		degrees of freedom
         * @return	float
         */
        public static function CHIDIST($value, $degrees)
        {
        }
        //	function CHIDIST()
        /**
         * CHIINV
         *
         * Returns the one-tailed probability of the chi-squared distribution.
         *
         * @param	float		$probability	Probability for the function
         * @param	float		$degrees		degrees of freedom
         * @return	float
         */
        public static function CHIINV($probability, $degrees)
        {
        }
        //	function CHIINV()
        /**
         * CONFIDENCE
         *
         * Returns the confidence interval for a population mean
         *
         * @param	float		$alpha
         * @param	float		$stdDev		Standard Deviation
         * @param	float		$size
         * @return	float
         *
         */
        public static function CONFIDENCE($alpha, $stdDev, $size)
        {
        }
        //	function CONFIDENCE()
        /**
         * CORREL
         *
         * Returns covariance, the average of the products of deviations for each data point pair.
         *
         * @param	array of mixed		Data Series Y
         * @param	array of mixed		Data Series X
         * @return	float
         */
        public static function CORREL($yValues, $xValues = \null)
        {
        }
        //	function CORREL()
        /**
         * COUNT
         *
         * Counts the number of cells that contain numbers within the list of arguments
         *
         * Excel Function:
         *		COUNT(value1[,value2[, ...]])
         *
         * @access	public
         * @category Statistical Functions
         * @param	mixed		$arg,...		Data values
         * @return	int
         */
        public static function COUNT()
        {
        }
        //	function COUNT()
        /**
         * COUNTA
         *
         * Counts the number of cells that are not empty within the list of arguments
         *
         * Excel Function:
         *		COUNTA(value1[,value2[, ...]])
         *
         * @access	public
         * @category Statistical Functions
         * @param	mixed		$arg,...		Data values
         * @return	int
         */
        public static function COUNTA()
        {
        }
        //	function COUNTA()
        /**
         * COUNTBLANK
         *
         * Counts the number of empty cells within the list of arguments
         *
         * Excel Function:
         *		COUNTBLANK(value1[,value2[, ...]])
         *
         * @access	public
         * @category Statistical Functions
         * @param	mixed		$arg,...		Data values
         * @return	int
         */
        public static function COUNTBLANK()
        {
        }
        //	function COUNTBLANK()
        /**
         * COUNTIF
         *
         * Counts the number of cells that contain numbers within the list of arguments
         *
         * Excel Function:
         *		COUNTIF(value1[,value2[, ...]],condition)
         *
         * @access	public
         * @category Statistical Functions
         * @param	mixed		$arg,...		Data values
         * @param	string		$condition		The criteria that defines which cells will be counted.
         * @return	int
         */
        public static function COUNTIF($aArgs, $condition)
        {
        }
        //	function COUNTIF()
        /**
         * COVAR
         *
         * Returns covariance, the average of the products of deviations for each data point pair.
         *
         * @param	array of mixed		Data Series Y
         * @param	array of mixed		Data Series X
         * @return	float
         */
        public static function COVAR($yValues, $xValues)
        {
        }
        //	function COVAR()
        /**
         * CRITBINOM
         *
         * Returns the smallest value for which the cumulative binomial distribution is greater
         *		than or equal to a criterion value
         *
         * See http://support.microsoft.com/kb/828117/ for details of the algorithm used
         *
         * @param	float		$trials			number of Bernoulli trials
         * @param	float		$probability	probability of a success on each trial
         * @param	float		$alpha			criterion value
         * @return	int
         *
         * @todo	Warning. This implementation differs from the algorithm detailed on the MS
         *			web site in that $CumPGuessMinus1 = $CumPGuess - 1 rather than $CumPGuess - $PGuess
         *			This eliminates a potential endless loop error, but may have an adverse affect on the
         *			accuracy of the function (although all my tests have so far returned correct results).
         *
         */
        public static function CRITBINOM($trials, $probability, $alpha)
        {
        }
        //	function CRITBINOM()
        /**
         * DEVSQ
         *
         * Returns the sum of squares of deviations of data points from their sample mean.
         *
         * Excel Function:
         *		DEVSQ(value1[,value2[, ...]])
         *
         * @access	public
         * @category Statistical Functions
         * @param	mixed		$arg,...		Data values
         * @return	float
         */
        public static function DEVSQ()
        {
        }
        //	function DEVSQ()
        /**
         * EXPONDIST
         *
         *	Returns the exponential distribution. Use EXPONDIST to model the time between events,
         *		such as how long an automated bank teller takes to deliver cash. For example, you can
         *		use EXPONDIST to determine the probability that the process takes at most 1 minute.
         *
         * @param	float		$value			Value of the function
         * @param	float		$lambda			The parameter value
         * @param	boolean		$cumulative
         * @return	float
         */
        public static function EXPONDIST($value, $lambda, $cumulative)
        {
        }
        //	function EXPONDIST()
        /**
         * FISHER
         *
         * Returns the Fisher transformation at x. This transformation produces a function that
         *		is normally distributed rather than skewed. Use this function to perform hypothesis
         *		testing on the correlation coefficient.
         *
         * @param	float		$value
         * @return	float
         */
        public static function FISHER($value)
        {
        }
        //	function FISHER()
        /**
         * FISHERINV
         *
         * Returns the inverse of the Fisher transformation. Use this transformation when
         *		analyzing correlations between ranges or arrays of data. If y = FISHER(x), then
         *		FISHERINV(y) = x.
         *
         * @param	float		$value
         * @return	float
         */
        public static function FISHERINV($value)
        {
        }
        //	function FISHERINV()
        /**
         * FORECAST
         *
         * Calculates, or predicts, a future value by using existing values. The predicted value is a y-value for a given x-value.
         *
         * @param	float				Value of X for which we want to find Y
         * @param	array of mixed		Data Series Y
         * @param	array of mixed		Data Series X
         * @return	float
         */
        public static function FORECAST($xValue, $yValues, $xValues)
        {
        }
        //	function FORECAST()
        /**
         * GAMMADIST
         *
         * Returns the gamma distribution.
         *
         * @param	float		$value			Value at which you want to evaluate the distribution
         * @param	float		$a				Parameter to the distribution
         * @param	float		$b				Parameter to the distribution
         * @param	boolean		$cumulative
         * @return	float
         *
         */
        public static function GAMMADIST($value, $a, $b, $cumulative)
        {
        }
        //	function GAMMADIST()
        /**
         * GAMMAINV
         *
         * Returns the inverse of the beta distribution.
         *
         * @param	float		$probability	Probability at which you want to evaluate the distribution
         * @param	float		$alpha			Parameter to the distribution
         * @param	float		$beta			Parameter to the distribution
         * @return	float
         *
         */
        public static function GAMMAINV($probability, $alpha, $beta)
        {
        }
        //	function GAMMAINV()
        /**
         * GAMMALN
         *
         * Returns the natural logarithm of the gamma function.
         *
         * @param	float		$value
         * @return	float
         */
        public static function GAMMALN($value)
        {
        }
        //	function GAMMALN()
        /**
         * GEOMEAN
         *
         * Returns the geometric mean of an array or range of positive data. For example, you
         *		can use GEOMEAN to calculate average growth rate given compound interest with
         *		variable rates.
         *
         * Excel Function:
         *		GEOMEAN(value1[,value2[, ...]])
         *
         * @access	public
         * @category Statistical Functions
         * @param	mixed		$arg,...		Data values
         * @return	float
         */
        public static function GEOMEAN()
        {
        }
        //	GEOMEAN()
        /**
         * GROWTH
         *
         * Returns values along a predicted emponential trend
         *
         * @param	array of mixed		Data Series Y
         * @param	array of mixed		Data Series X
         * @param	array of mixed		Values of X for which we want to find Y
         * @param	boolean				A logical value specifying whether to force the intersect to equal 0.
         * @return	array of float
         */
        public static function GROWTH($yValues, $xValues = array(), $newValues = array(), $const = \True)
        {
        }
        //	function GROWTH()
        /**
         * HARMEAN
         *
         * Returns the harmonic mean of a data set. The harmonic mean is the reciprocal of the
         *		arithmetic mean of reciprocals.
         *
         * Excel Function:
         *		HARMEAN(value1[,value2[, ...]])
         *
         * @access	public
         * @category Statistical Functions
         * @param	mixed		$arg,...		Data values
         * @return	float
         */
        public static function HARMEAN()
        {
        }
        //	function HARMEAN()
        /**
         * HYPGEOMDIST
         *
         * Returns the hypergeometric distribution. HYPGEOMDIST returns the probability of a given number of
         * sample successes, given the sample size, population successes, and population size.
         *
         * @param	float		$sampleSuccesses		Number of successes in the sample
         * @param	float		$sampleNumber			Size of the sample
         * @param	float		$populationSuccesses	Number of successes in the population
         * @param	float		$populationNumber		Population size
         * @return	float
         *
         */
        public static function HYPGEOMDIST($sampleSuccesses, $sampleNumber, $populationSuccesses, $populationNumber)
        {
        }
        //	function HYPGEOMDIST()
        /**
         * INTERCEPT
         *
         * Calculates the point at which a line will intersect the y-axis by using existing x-values and y-values.
         *
         * @param	array of mixed		Data Series Y
         * @param	array of mixed		Data Series X
         * @return	float
         */
        public static function INTERCEPT($yValues, $xValues)
        {
        }
        //	function INTERCEPT()
        /**
         * KURT
         *
         * Returns the kurtosis of a data set. Kurtosis characterizes the relative peakedness
         * or flatness of a distribution compared with the normal distribution. Positive
         * kurtosis indicates a relatively peaked distribution. Negative kurtosis indicates a
         * relatively flat distribution.
         *
         * @param	array	Data Series
         * @return	float
         */
        public static function KURT()
        {
        }
        //	function KURT()
        /**
         * LARGE
         *
         * Returns the nth largest value in a data set. You can use this function to
         *		select a value based on its relative standing.
         *
         * Excel Function:
         *		LARGE(value1[,value2[, ...]],entry)
         *
         * @access	public
         * @category Statistical Functions
         * @param	mixed		$arg,...		Data values
         * @param	int			$entry			Position (ordered from the largest) in the array or range of data to return
         * @return	float
         *
         */
        public static function LARGE()
        {
        }
        //	function LARGE()
        /**
         * LINEST
         *
         * Calculates the statistics for a line by using the "least squares" method to calculate a straight line that best fits your data,
         *		and then returns an array that describes the line.
         *
         * @param	array of mixed		Data Series Y
         * @param	array of mixed		Data Series X
         * @param	boolean				A logical value specifying whether to force the intersect to equal 0.
         * @param	boolean				A logical value specifying whether to return additional regression statistics.
         * @return	array
         */
        public static function LINEST($yValues, $xValues = \NULL, $const = \TRUE, $stats = \FALSE)
        {
        }
        //	function LINEST()
        /**
         * LOGEST
         *
         * Calculates an exponential curve that best fits the X and Y data series,
         *		and then returns an array that describes the line.
         *
         * @param	array of mixed		Data Series Y
         * @param	array of mixed		Data Series X
         * @param	boolean				A logical value specifying whether to force the intersect to equal 0.
         * @param	boolean				A logical value specifying whether to return additional regression statistics.
         * @return	array
         */
        public static function LOGEST($yValues, $xValues = \null, $const = \True, $stats = \False)
        {
        }
        //	function LOGEST()
        /**
         * LOGINV
         *
         * Returns the inverse of the normal cumulative distribution
         *
         * @param	float		$probability
         * @param	float		$mean
         * @param	float		$stdDev
         * @return	float
         *
         * @todo	Try implementing P J Acklam's refinement algorithm for greater
         *			accuracy if I can get my head round the mathematics
         *			(as described at) http://home.online.no/~pjacklam/notes/invnorm/
         */
        public static function LOGINV($probability, $mean, $stdDev)
        {
        }
        //	function LOGINV()
        /**
         * LOGNORMDIST
         *
         * Returns the cumulative lognormal distribution of x, where ln(x) is normally distributed
         * with parameters mean and standard_dev.
         *
         * @param	float		$value
         * @param	float		$mean
         * @param	float		$stdDev
         * @return	float
         */
        public static function LOGNORMDIST($value, $mean, $stdDev)
        {
        }
        //	function LOGNORMDIST()
        /**
         * MAX
         *
         * MAX returns the value of the element of the values passed that has the highest value,
         *		with negative numbers considered smaller than positive numbers.
         *
         * Excel Function:
         *		MAX(value1[,value2[, ...]])
         *
         * @access	public
         * @category Statistical Functions
         * @param	mixed		$arg,...		Data values
         * @return	float
         */
        public static function MAX()
        {
        }
        //	function MAX()
        /**
         * MAXA
         *
         * Returns the greatest value in a list of arguments, including numbers, text, and logical values
         *
         * Excel Function:
         *		MAXA(value1[,value2[, ...]])
         *
         * @access	public
         * @category Statistical Functions
         * @param	mixed		$arg,...		Data values
         * @return	float
         */
        public static function MAXA()
        {
        }
        //	function MAXA()
        /**
         * MAXIF
         *
         * Counts the maximum value within a range of cells that contain numbers within the list of arguments
         *
         * Excel Function:
         *		MAXIF(value1[,value2[, ...]],condition)
         *
         * @access	public
         * @category Mathematical and Trigonometric Functions
         * @param	mixed		$arg,...		Data values
         * @param	string		$condition		The criteria that defines which cells will be checked.
         * @return	float
         */
        public static function MAXIF($aArgs, $condition, $sumArgs = array())
        {
        }
        //	function MAXIF()
        /**
         * MEDIAN
         *
         * Returns the median of the given numbers. The median is the number in the middle of a set of numbers.
         *
         * Excel Function:
         *		MEDIAN(value1[,value2[, ...]])
         *
         * @access	public
         * @category Statistical Functions
         * @param	mixed		$arg,...		Data values
         * @return	float
         */
        public static function MEDIAN()
        {
        }
        //	function MEDIAN()
        /**
         * MIN
         *
         * MIN returns the value of the element of the values passed that has the smallest value,
         *		with negative numbers considered smaller than positive numbers.
         *
         * Excel Function:
         *		MIN(value1[,value2[, ...]])
         *
         * @access	public
         * @category Statistical Functions
         * @param	mixed		$arg,...		Data values
         * @return	float
         */
        public static function MIN()
        {
        }
        //	function MIN()
        /**
         * MINA
         *
         * Returns the smallest value in a list of arguments, including numbers, text, and logical values
         *
         * Excel Function:
         *		MINA(value1[,value2[, ...]])
         *
         * @access	public
         * @category Statistical Functions
         * @param	mixed		$arg,...		Data values
         * @return	float
         */
        public static function MINA()
        {
        }
        //	function MINA()
        /**
         * MINIF
         *
         * Returns the minimum value within a range of cells that contain numbers within the list of arguments
         *
         * Excel Function:
         *		MINIF(value1[,value2[, ...]],condition)
         *
         * @access	public
         * @category Mathematical and Trigonometric Functions
         * @param	mixed		$arg,...		Data values
         * @param	string		$condition		The criteria that defines which cells will be checked.
         * @return	float
         */
        public static function MINIF($aArgs, $condition, $sumArgs = array())
        {
        }
        //	function MINIF()
        //
        //	Special variant of array_count_values that isn't limited to strings and integers,
        //		but can work with floating point numbers as values
        //
        private static function _modeCalc($data)
        {
        }
        //	function _modeCalc()
        /**
         * MODE
         *
         * Returns the most frequently occurring, or repetitive, value in an array or range of data
         *
         * Excel Function:
         *		MODE(value1[,value2[, ...]])
         *
         * @access	public
         * @category Statistical Functions
         * @param	mixed		$arg,...		Data values
         * @return	float
         */
        public static function MODE()
        {
        }
        //	function MODE()
        /**
         * NEGBINOMDIST
         *
         * Returns the negative binomial distribution. NEGBINOMDIST returns the probability that
         *		there will be number_f failures before the number_s-th success, when the constant
         *		probability of a success is probability_s. This function is similar to the binomial
         *		distribution, except that the number of successes is fixed, and the number of trials is
         *		variable. Like the binomial, trials are assumed to be independent.
         *
         * @param	float		$failures		Number of Failures
         * @param	float		$successes		Threshold number of Successes
         * @param	float		$probability	Probability of success on each trial
         * @return	float
         *
         */
        public static function NEGBINOMDIST($failures, $successes, $probability)
        {
        }
        //	function NEGBINOMDIST()
        /**
         * NORMDIST
         *
         * Returns the normal distribution for the specified mean and standard deviation. This
         * function has a very wide range of applications in statistics, including hypothesis
         * testing.
         *
         * @param	float		$value
         * @param	float		$mean		Mean Value
         * @param	float		$stdDev		Standard Deviation
         * @param	boolean		$cumulative
         * @return	float
         *
         */
        public static function NORMDIST($value, $mean, $stdDev, $cumulative)
        {
        }
        //	function NORMDIST()
        /**
         * NORMINV
         *
         * Returns the inverse of the normal cumulative distribution for the specified mean and standard deviation.
         *
         * @param	float		$value
         * @param	float		$mean		Mean Value
         * @param	float		$stdDev		Standard Deviation
         * @return	float
         *
         */
        public static function NORMINV($probability, $mean, $stdDev)
        {
        }
        //	function NORMINV()
        /**
         * NORMSDIST
         *
         * Returns the standard normal cumulative distribution function. The distribution has
         * a mean of 0 (zero) and a standard deviation of one. Use this function in place of a
         * table of standard normal curve areas.
         *
         * @param	float		$value
         * @return	float
         */
        public static function NORMSDIST($value)
        {
        }
        //	function NORMSDIST()
        /**
         * NORMSINV
         *
         * Returns the inverse of the standard normal cumulative distribution
         *
         * @param	float		$value
         * @return	float
         */
        public static function NORMSINV($value)
        {
        }
        //	function NORMSINV()
        /**
         * PERCENTILE
         *
         * Returns the nth percentile of values in a range..
         *
         * Excel Function:
         *		PERCENTILE(value1[,value2[, ...]],entry)
         *
         * @access	public
         * @category Statistical Functions
         * @param	mixed		$arg,...		Data values
         * @param	float		$entry			Percentile value in the range 0..1, inclusive.
         * @return	float
         */
        public static function PERCENTILE()
        {
        }
        //	function PERCENTILE()
        /**
         * PERCENTRANK
         *
         * Returns the rank of a value in a data set as a percentage of the data set.
         *
         * @param	array of number		An array of, or a reference to, a list of numbers.
         * @param	number				The number whose rank you want to find.
         * @param	number				The number of significant digits for the returned percentage value.
         * @return	float
         */
        public static function PERCENTRANK($valueSet, $value, $significance = 3)
        {
        }
        //	function PERCENTRANK()
        /**
         * PERMUT
         *
         * Returns the number of permutations for a given number of objects that can be
         *		selected from number objects. A permutation is any set or subset of objects or
         *		events where internal order is significant. Permutations are different from
         *		combinations, for which the internal order is not significant. Use this function
         *		for lottery-style probability calculations.
         *
         * @param	int		$numObjs	Number of different objects
         * @param	int		$numInSet	Number of objects in each permutation
         * @return	int		Number of permutations
         */
        public static function PERMUT($numObjs, $numInSet)
        {
        }
        //	function PERMUT()
        /**
         * POISSON
         *
         * Returns the Poisson distribution. A common application of the Poisson distribution
         * is predicting the number of events over a specific time, such as the number of
         * cars arriving at a toll plaza in 1 minute.
         *
         * @param	float		$value
         * @param	float		$mean		Mean Value
         * @param	boolean		$cumulative
         * @return	float
         *
         */
        public static function POISSON($value, $mean, $cumulative)
        {
        }
        //	function POISSON()
        /**
         * QUARTILE
         *
         * Returns the quartile of a data set.
         *
         * Excel Function:
         *		QUARTILE(value1[,value2[, ...]],entry)
         *
         * @access	public
         * @category Statistical Functions
         * @param	mixed		$arg,...		Data values
         * @param	int			$entry			Quartile value in the range 1..3, inclusive.
         * @return	float
         */
        public static function QUARTILE()
        {
        }
        //	function QUARTILE()
        /**
         * RANK
         *
         * Returns the rank of a number in a list of numbers.
         *
         * @param	number				The number whose rank you want to find.
         * @param	array of number		An array of, or a reference to, a list of numbers.
         * @param	mixed				Order to sort the values in the value set
         * @return	float
         */
        public static function RANK($value, $valueSet, $order = 0)
        {
        }
        //	function RANK()
        /**
         * RSQ
         *
         * Returns the square of the Pearson product moment correlation coefficient through data points in known_y's and known_x's.
         *
         * @param	array of mixed		Data Series Y
         * @param	array of mixed		Data Series X
         * @return	float
         */
        public static function RSQ($yValues, $xValues)
        {
        }
        //	function RSQ()
        /**
         * SKEW
         *
         * Returns the skewness of a distribution. Skewness characterizes the degree of asymmetry
         * of a distribution around its mean. Positive skewness indicates a distribution with an
         * asymmetric tail extending toward more positive values. Negative skewness indicates a
         * distribution with an asymmetric tail extending toward more negative values.
         *
         * @param	array	Data Series
         * @return	float
         */
        public static function SKEW()
        {
        }
        //	function SKEW()
        /**
         * SLOPE
         *
         * Returns the slope of the linear regression line through data points in known_y's and known_x's.
         *
         * @param	array of mixed		Data Series Y
         * @param	array of mixed		Data Series X
         * @return	float
         */
        public static function SLOPE($yValues, $xValues)
        {
        }
        //	function SLOPE()
        /**
         * SMALL
         *
         * Returns the nth smallest value in a data set. You can use this function to
         *		select a value based on its relative standing.
         *
         * Excel Function:
         *		SMALL(value1[,value2[, ...]],entry)
         *
         * @access	public
         * @category Statistical Functions
         * @param	mixed		$arg,...		Data values
         * @param	int			$entry			Position (ordered from the smallest) in the array or range of data to return
         * @return	float
         */
        public static function SMALL()
        {
        }
        //	function SMALL()
        /**
         * STANDARDIZE
         *
         * Returns a normalized value from a distribution characterized by mean and standard_dev.
         *
         * @param	float	$value		Value to normalize
         * @param	float	$mean		Mean Value
         * @param	float	$stdDev		Standard Deviation
         * @return	float	Standardized value
         */
        public static function STANDARDIZE($value, $mean, $stdDev)
        {
        }
        //	function STANDARDIZE()
        /**
         * STDEV
         *
         * Estimates standard deviation based on a sample. The standard deviation is a measure of how
         *		widely values are dispersed from the average value (the mean).
         *
         * Excel Function:
         *		STDEV(value1[,value2[, ...]])
         *
         * @access	public
         * @category Statistical Functions
         * @param	mixed		$arg,...		Data values
         * @return	float
         */
        public static function STDEV()
        {
        }
        //	function STDEV()
        /**
         * STDEVA
         *
         * Estimates standard deviation based on a sample, including numbers, text, and logical values
         *
         * Excel Function:
         *		STDEVA(value1[,value2[, ...]])
         *
         * @access	public
         * @category Statistical Functions
         * @param	mixed		$arg,...		Data values
         * @return	float
         */
        public static function STDEVA()
        {
        }
        //	function STDEVA()
        /**
         * STDEVP
         *
         * Calculates standard deviation based on the entire population
         *
         * Excel Function:
         *		STDEVP(value1[,value2[, ...]])
         *
         * @access	public
         * @category Statistical Functions
         * @param	mixed		$arg,...		Data values
         * @return	float
         */
        public static function STDEVP()
        {
        }
        //	function STDEVP()
        /**
         * STDEVPA
         *
         * Calculates standard deviation based on the entire population, including numbers, text, and logical values
         *
         * Excel Function:
         *		STDEVPA(value1[,value2[, ...]])
         *
         * @access	public
         * @category Statistical Functions
         * @param	mixed		$arg,...		Data values
         * @return	float
         */
        public static function STDEVPA()
        {
        }
        //	function STDEVPA()
        /**
         * STEYX
         *
         * Returns the standard error of the predicted y-value for each x in the regression.
         *
         * @param	array of mixed		Data Series Y
         * @param	array of mixed		Data Series X
         * @return	float
         */
        public static function STEYX($yValues, $xValues)
        {
        }
        //	function STEYX()
        /**
         * TDIST
         *
         * Returns the probability of Student's T distribution.
         *
         * @param	float		$value			Value for the function
         * @param	float		$degrees		degrees of freedom
         * @param	float		$tails			number of tails (1 or 2)
         * @return	float
         */
        public static function TDIST($value, $degrees, $tails)
        {
        }
        //	function TDIST()
        /**
         * TINV
         *
         * Returns the one-tailed probability of the chi-squared distribution.
         *
         * @param	float		$probability	Probability for the function
         * @param	float		$degrees		degrees of freedom
         * @return	float
         */
        public static function TINV($probability, $degrees)
        {
        }
        //	function TINV()
        /**
         * TREND
         *
         * Returns values along a linear trend
         *
         * @param	array of mixed		Data Series Y
         * @param	array of mixed		Data Series X
         * @param	array of mixed		Values of X for which we want to find Y
         * @param	boolean				A logical value specifying whether to force the intersect to equal 0.
         * @return	array of float
         */
        public static function TREND($yValues, $xValues = array(), $newValues = array(), $const = \True)
        {
        }
        //	function TREND()
        /**
         * TRIMMEAN
         *
         * Returns the mean of the interior of a data set. TRIMMEAN calculates the mean
         *		taken by excluding a percentage of data points from the top and bottom tails
         *		of a data set.
         *
         * Excel Function:
         *		TRIMEAN(value1[,value2[, ...]],$discard)
         *
         * @access	public
         * @category Statistical Functions
         * @param	mixed		$arg,...		Data values
         * @param	float		$discard		Percentage to discard
         * @return	float
         */
        public static function TRIMMEAN()
        {
        }
        //	function TRIMMEAN()
        /**
         * VARFunc
         *
         * Estimates variance based on a sample.
         *
         * Excel Function:
         *		VAR(value1[,value2[, ...]])
         *
         * @access	public
         * @category Statistical Functions
         * @param	mixed		$arg,...		Data values
         * @return	float
         */
        public static function VARFunc()
        {
        }
        //	function VARFunc()
        /**
         * VARA
         *
         * Estimates variance based on a sample, including numbers, text, and logical values
         *
         * Excel Function:
         *		VARA(value1[,value2[, ...]])
         *
         * @access	public
         * @category Statistical Functions
         * @param	mixed		$arg,...		Data values
         * @return	float
         */
        public static function VARA()
        {
        }
        //	function VARA()
        /**
         * VARP
         *
         * Calculates variance based on the entire population
         *
         * Excel Function:
         *		VARP(value1[,value2[, ...]])
         *
         * @access	public
         * @category Statistical Functions
         * @param	mixed		$arg,...		Data values
         * @return	float
         */
        public static function VARP()
        {
        }
        //	function VARP()
        /**
         * VARPA
         *
         * Calculates variance based on the entire population, including numbers, text, and logical values
         *
         * Excel Function:
         *		VARPA(value1[,value2[, ...]])
         *
         * @access	public
         * @category Statistical Functions
         * @param	mixed		$arg,...		Data values
         * @return	float
         */
        public static function VARPA()
        {
        }
        //	function VARPA()
        /**
         * WEIBULL
         *
         * Returns the Weibull distribution. Use this distribution in reliability
         * analysis, such as calculating a device's mean time to failure.
         *
         * @param	float		$value
         * @param	float		$alpha		Alpha Parameter
         * @param	float		$beta		Beta Parameter
         * @param	boolean		$cumulative
         * @return	float
         *
         */
        public static function WEIBULL($value, $alpha, $beta, $cumulative)
        {
        }
        //	function WEIBULL()
        /**
         * ZTEST
         *
         * Returns the Weibull distribution. Use this distribution in reliability
         * analysis, such as calculating a device's mean time to failure.
         *
         * @param	float		$dataSet
         * @param	float		$m0		Alpha Parameter
         * @param	float		$sigma	Beta Parameter
         * @param	boolean		$cumulative
         * @return	float
         *
         */
        public static function ZTEST($dataSet, $m0, $sigma = \NULL)
        {
        }
        //	function ZTEST()
    }
    /**
     * PHPExcel_Calculation_LookupRef
     *
     * @category	PHPExcel
     * @package		PHPExcel_Calculation
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Calculation_LookupRef
    {
        /**
         * CELL_ADDRESS
         *
         * Creates a cell address as text, given specified row and column numbers.
         *
         * Excel Function:
         *		=ADDRESS(row, column, [relativity], [referenceStyle], [sheetText])
         *
         * @param	row				Row number to use in the cell reference
         * @param	column			Column number to use in the cell reference
         * @param	relativity		Flag indicating the type of reference to return
         *								1 or omitted	Absolute
         *								2				Absolute row; relative column
         *								3				Relative row; absolute column
         *								4				Relative
         * @param	referenceStyle	A logical value that specifies the A1 or R1C1 reference style.
         *								TRUE or omitted		CELL_ADDRESS returns an A1-style reference
         *								FALSE				CELL_ADDRESS returns an R1C1-style reference
         * @param	sheetText		Optional Name of worksheet to use
         * @return	string
         */
        public static function CELL_ADDRESS($row, $column, $relativity = 1, $referenceStyle = \True, $sheetText = '')
        {
        }
        //	function CELL_ADDRESS()
        /**
         * COLUMN
         *
         * Returns the column number of the given cell reference
         * If the cell reference is a range of cells, COLUMN returns the column numbers of each column in the reference as a horizontal array.
         * If cell reference is omitted, and the function is being called through the calculation engine, then it is assumed to be the
         *		reference of the cell in which the COLUMN function appears; otherwise this function returns 0.
         *
         * Excel Function:
         *		=COLUMN([cellAddress])
         *
         * @param	cellAddress		A reference to a range of cells for which you want the column numbers
         * @return	integer or array of integer
         */
        public static function COLUMN($cellAddress = \Null)
        {
        }
        //	function COLUMN()
        /**
         * COLUMNS
         *
         * Returns the number of columns in an array or reference.
         *
         * Excel Function:
         *		=COLUMNS(cellAddress)
         *
         * @param	cellAddress		An array or array formula, or a reference to a range of cells for which you want the number of columns
         * @return	integer			The number of columns in cellAddress
         */
        public static function COLUMNS($cellAddress = \Null)
        {
        }
        //	function COLUMNS()
        /**
         * ROW
         *
         * Returns the row number of the given cell reference
         * If the cell reference is a range of cells, ROW returns the row numbers of each row in the reference as a vertical array.
         * If cell reference is omitted, and the function is being called through the calculation engine, then it is assumed to be the
         *		reference of the cell in which the ROW function appears; otherwise this function returns 0.
         *
         * Excel Function:
         *		=ROW([cellAddress])
         *
         * @param	cellAddress		A reference to a range of cells for which you want the row numbers
         * @return	integer or array of integer
         */
        public static function ROW($cellAddress = \Null)
        {
        }
        //	function ROW()
        /**
         * ROWS
         *
         * Returns the number of rows in an array or reference.
         *
         * Excel Function:
         *		=ROWS(cellAddress)
         *
         * @param	cellAddress		An array or array formula, or a reference to a range of cells for which you want the number of rows
         * @return	integer			The number of rows in cellAddress
         */
        public static function ROWS($cellAddress = \Null)
        {
        }
        //	function ROWS()
        /**
         * HYPERLINK
         *
         * Excel Function:
         *		=HYPERLINK(linkURL,displayName)
         *
         * @access	public
         * @category Logical Functions
         * @param	string			$linkURL		Value to check, is also the value returned when no error
         * @param	string			$displayName	Value to return when testValue is an error condition
         * @param	PHPExcel_Cell	$pCell			The cell to set the hyperlink in
         * @return	mixed	The value of $displayName (or $linkURL if $displayName was blank)
         */
        public static function HYPERLINK($linkURL = '', $displayName = \null, \PHPExcel_Cell $pCell = \null)
        {
        }
        //	function HYPERLINK()
        /**
         * INDIRECT
         *
         * Returns the reference specified by a text string.
         * References are immediately evaluated to display their contents.
         *
         * Excel Function:
         *		=INDIRECT(cellAddress)
         *
         * NOTE - INDIRECT() does not yet support the optional a1 parameter introduced in Excel 2010
         *
         * @param	cellAddress		$cellAddress	The cell address of the current cell (containing this formula)
         * @param	PHPExcel_Cell	$pCell			The current cell (containing this formula)
         * @return	mixed			The cells referenced by cellAddress
         *
         * @todo	Support for the optional a1 parameter introduced in Excel 2010
         *
         */
        public static function INDIRECT($cellAddress = \NULL, \PHPExcel_Cell $pCell = \NULL)
        {
        }
        //	function INDIRECT()
        /**
         * OFFSET
         *
         * Returns a reference to a range that is a specified number of rows and columns from a cell or range of cells.
         * The reference that is returned can be a single cell or a range of cells. You can specify the number of rows and
         * the number of columns to be returned.
         *
         * Excel Function:
         *		=OFFSET(cellAddress, rows, cols, [height], [width])
         *
         * @param	cellAddress		The reference from which you want to base the offset. Reference must refer to a cell or
         *								range of adjacent cells; otherwise, OFFSET returns the #VALUE! error value.
         * @param	rows			The number of rows, up or down, that you want the upper-left cell to refer to.
         *								Using 5 as the rows argument specifies that the upper-left cell in the reference is
         *								five rows below reference. Rows can be positive (which means below the starting reference)
         *								or negative (which means above the starting reference).
         * @param	cols			The number of columns, to the left or right, that you want the upper-left cell of the result
         *								to refer to. Using 5 as the cols argument specifies that the upper-left cell in the
         *								reference is five columns to the right of reference. Cols can be positive (which means
         *								to the right of the starting reference) or negative (which means to the left of the
         *								starting reference).
         * @param	height			The height, in number of rows, that you want the returned reference to be. Height must be a positive number.
         * @param	width			The width, in number of columns, that you want the returned reference to be. Width must be a positive number.
         * @return	string			A reference to a cell or range of cells
         */
        public static function OFFSET($cellAddress = \Null, $rows = 0, $columns = 0, $height = \null, $width = \null)
        {
        }
        //	function OFFSET()
        /**
         * CHOOSE
         *
         * Uses lookup_value to return a value from the list of value arguments.
         * Use CHOOSE to select one of up to 254 values based on the lookup_value.
         *
         * Excel Function:
         *		=CHOOSE(index_num, value1, [value2], ...)
         *
         * @param	index_num		Specifies which value argument is selected.
         *							Index_num must be a number between 1 and 254, or a formula or reference to a cell containing a number
         *								between 1 and 254.
         * @param	value1...		Value1 is required, subsequent values are optional.
         *							Between 1 to 254 value arguments from which CHOOSE selects a value or an action to perform based on
         *								index_num. The arguments can be numbers, cell references, defined names, formulas, functions, or
         *								text.
         * @return	mixed			The selected value
         */
        public static function CHOOSE()
        {
        }
        //	function CHOOSE()
        /**
         * MATCH
         *
         * The MATCH function searches for a specified item in a range of cells
         *
         * Excel Function:
         *		=MATCH(lookup_value, lookup_array, [match_type])
         *
         * @param	lookup_value	The value that you want to match in lookup_array
         * @param	lookup_array	The range of cells being searched
         * @param	match_type		The number -1, 0, or 1. -1 means above, 0 means exact match, 1 means below. If match_type is 1 or -1, the list has to be ordered.
         * @return	integer			The relative position of the found item
         */
        public static function MATCH($lookup_value, $lookup_array, $match_type = 1)
        {
        }
        //	function MATCH()
        /**
         * INDEX
         *
         * Uses an index to choose a value from a reference or array
         *
         * Excel Function:
         *		=INDEX(range_array, row_num, [column_num])
         *
         * @param	range_array		A range of cells or an array constant
         * @param	row_num			The row in array from which to return a value. If row_num is omitted, column_num is required.
         * @param	column_num		The column in array from which to return a value. If column_num is omitted, row_num is required.
         * @return	mixed			the value of a specified cell or array of cells
         */
        public static function INDEX($arrayValues, $rowNum = 0, $columnNum = 0)
        {
        }
        //	function INDEX()
        /**
         * TRANSPOSE
         *
         * @param	array	$matrixData	A matrix of values
         * @return	array
         *
         * Unlike the Excel TRANSPOSE function, which will only work on a single row or column, this function will transpose a full matrix.
         */
        public static function TRANSPOSE($matrixData)
        {
        }
        //	function TRANSPOSE()
        private static function _vlookupSort($a, $b)
        {
        }
        //	function _vlookupSort()
        /**
         * VLOOKUP
         * The VLOOKUP function searches for value in the left-most column of lookup_array and returns the value in the same row based on the index_number.
         * @param	lookup_value	The value that you want to match in lookup_array
         * @param	lookup_array	The range of cells being searched
         * @param	index_number	The column number in table_array from which the matching value must be returned. The first column is 1.
         * @param	not_exact_match	Determines if you are looking for an exact match based on lookup_value.
         * @return	mixed			The value of the found cell
         */
        public static function VLOOKUP($lookup_value, $lookup_array, $index_number, $not_exact_match = \true)
        {
        }
        //	function VLOOKUP()
        /**
         * HLOOKUP
         * The HLOOKUP function searches for value in the top-most row of lookup_array and returns the value in the same column based on the index_number.
         * @param    lookup_value    The value that you want to match in lookup_array
         * @param    lookup_array    The range of cells being searched
         * @param    index_number    The row number in table_array from which the matching value must be returned. The first row is 1.
         * @param    not_exact_match Determines if you are looking for an exact match based on lookup_value.
         * @return   mixed           The value of the found cell
         */
        public static function HLOOKUP($lookup_value, $lookup_array, $index_number, $not_exact_match = \true)
        {
        }
        //  function HLOOKUP()
        /**
         * LOOKUP
         * The LOOKUP function searches for value either from a one-row or one-column range or from an array.
         * @param	lookup_value	The value that you want to match in lookup_array
         * @param	lookup_vector	The range of cells being searched
         * @param	result_vector	The column from which the matching value must be returned
         * @return	mixed			The value of the found cell
         */
        public static function LOOKUP($lookup_value, $lookup_vector, $result_vector = \null)
        {
        }
        //	function LOOKUP()
    }
    /**
     * PHPExcel_Calculation_Database
     *
     * @category	PHPExcel
     * @package		PHPExcel_Calculation
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Calculation_Database
    {
        /**
         * __fieldExtract
         *
         * Extracts the column ID to use for the data field.
         *
         * @access	private
         * @param	mixed[]		$database		The range of cells that makes up the list or database.
         *										A database is a list of related data in which rows of related
         *										information are records, and columns of data are fields. The
         *										first row of the list contains labels for each column.
         * @param	mixed		$field			Indicates which column is used in the function. Enter the
         *										column label enclosed between double quotation marks, such as
         *										"Age" or "Yield," or a number (without quotation marks) that
         *										represents the position of the column within the list: 1 for
         *										the first column, 2 for the second column, and so on.
         * @return	string|NULL
         *
         */
        private static function __fieldExtract($database, $field)
        {
        }
        /**
         * __filter
         *
         * Parses the selection criteria, extracts the database rows that match those criteria, and
         * returns that subset of rows.
         *
         * @access	private
         * @param	mixed[]		$database		The range of cells that makes up the list or database.
         *										A database is a list of related data in which rows of related
         *										information are records, and columns of data are fields. The
         *										first row of the list contains labels for each column.
         * @param	mixed[]		$criteria		The range of cells that contains the conditions you specify.
         *										You can use any range for the criteria argument, as long as it
         *										includes at least one column label and at least one cell below
         *										the column label in which you specify a condition for the
         *										column.
         * @return	array of mixed
         *
         */
        private static function __filter($database, $criteria)
        {
        }
        /**
         * DAVERAGE
         *
         * Averages the values in a column of a list or database that match conditions you specify.
         *
         * Excel Function:
         *		DAVERAGE(database,field,criteria)
         *
         * @access	public
         * @category Database Functions
         * @param	mixed[]			$database	The range of cells that makes up the list or database.
         *										A database is a list of related data in which rows of related
         *										information are records, and columns of data are fields. The
         *										first row of the list contains labels for each column.
         * @param	string|integer	$field		Indicates which column is used in the function. Enter the
         *										column label enclosed between double quotation marks, such as
         *										"Age" or "Yield," or a number (without quotation marks) that
         *										represents the position of the column within the list: 1 for
         *										the first column, 2 for the second column, and so on.
         * @param	mixed[]			$criteria	The range of cells that contains the conditions you specify.
         *										You can use any range for the criteria argument, as long as it
         *										includes at least one column label and at least one cell below
         *										the column label in which you specify a condition for the
         *										column.
         * @return	float
         *
         */
        public static function DAVERAGE($database, $field, $criteria)
        {
        }
        //	function DAVERAGE()
        /**
         * DCOUNT
         *
         * Counts the cells that contain numbers in a column of a list or database that match conditions
         * that you specify.
         *
         * Excel Function:
         *		DCOUNT(database,[field],criteria)
         *
         * Excel Function:
         *		DAVERAGE(database,field,criteria)
         *
         * @access	public
         * @category Database Functions
         * @param	mixed[]			$database	The range of cells that makes up the list or database.
         *										A database is a list of related data in which rows of related
         *										information are records, and columns of data are fields. The
         *										first row of the list contains labels for each column.
         * @param	string|integer	$field		Indicates which column is used in the function. Enter the
         *										column label enclosed between double quotation marks, such as
         *										"Age" or "Yield," or a number (without quotation marks) that
         *										represents the position of the column within the list: 1 for
         *										the first column, 2 for the second column, and so on.
         * @param	mixed[]			$criteria	The range of cells that contains the conditions you specify.
         *										You can use any range for the criteria argument, as long as it
         *										includes at least one column label and at least one cell below
         *										the column label in which you specify a condition for the
         *										column.
         * @return	integer
         *
         * @TODO	The field argument is optional. If field is omitted, DCOUNT counts all records in the
         *			database that match the criteria.
         *
         */
        public static function DCOUNT($database, $field, $criteria)
        {
        }
        //	function DCOUNT()
        /**
         * DCOUNTA
         *
         * Counts the nonblank cells in a column of a list or database that match conditions that you specify.
         *
         * Excel Function:
         *		DCOUNTA(database,[field],criteria)
         *
         * @access	public
         * @category Database Functions
         * @param	mixed[]			$database	The range of cells that makes up the list or database.
         *										A database is a list of related data in which rows of related
         *										information are records, and columns of data are fields. The
         *										first row of the list contains labels for each column.
         * @param	string|integer	$field		Indicates which column is used in the function. Enter the
         *										column label enclosed between double quotation marks, such as
         *										"Age" or "Yield," or a number (without quotation marks) that
         *										represents the position of the column within the list: 1 for
         *										the first column, 2 for the second column, and so on.
         * @param	mixed[]			$criteria	The range of cells that contains the conditions you specify.
         *										You can use any range for the criteria argument, as long as it
         *										includes at least one column label and at least one cell below
         *										the column label in which you specify a condition for the
         *										column.
         * @return	integer
         *
         * @TODO	The field argument is optional. If field is omitted, DCOUNTA counts all records in the
         *			database that match the criteria.
         *
         */
        public static function DCOUNTA($database, $field, $criteria)
        {
        }
        //	function DCOUNTA()
        /**
         * DGET
         *
         * Extracts a single value from a column of a list or database that matches conditions that you
         * specify.
         *
         * Excel Function:
         *		DGET(database,field,criteria)
         *
         * @access	public
         * @category Database Functions
         * @param	mixed[]			$database	The range of cells that makes up the list or database.
         *										A database is a list of related data in which rows of related
         *										information are records, and columns of data are fields. The
         *										first row of the list contains labels for each column.
         * @param	string|integer	$field		Indicates which column is used in the function. Enter the
         *										column label enclosed between double quotation marks, such as
         *										"Age" or "Yield," or a number (without quotation marks) that
         *										represents the position of the column within the list: 1 for
         *										the first column, 2 for the second column, and so on.
         * @param	mixed[]			$criteria	The range of cells that contains the conditions you specify.
         *										You can use any range for the criteria argument, as long as it
         *										includes at least one column label and at least one cell below
         *										the column label in which you specify a condition for the
         *										column.
         * @return	mixed
         *
         */
        public static function DGET($database, $field, $criteria)
        {
        }
        //	function DGET()
        /**
         * DMAX
         *
         * Returns the largest number in a column of a list or database that matches conditions you that
         * specify.
         *
         * Excel Function:
         *		DMAX(database,field,criteria)
         *
         * @access	public
         * @category Database Functions
         * @param	mixed[]			$database	The range of cells that makes up the list or database.
         *										A database is a list of related data in which rows of related
         *										information are records, and columns of data are fields. The
         *										first row of the list contains labels for each column.
         * @param	string|integer	$field		Indicates which column is used in the function. Enter the
         *										column label enclosed between double quotation marks, such as
         *										"Age" or "Yield," or a number (without quotation marks) that
         *										represents the position of the column within the list: 1 for
         *										the first column, 2 for the second column, and so on.
         * @param	mixed[]			$criteria	The range of cells that contains the conditions you specify.
         *										You can use any range for the criteria argument, as long as it
         *										includes at least one column label and at least one cell below
         *										the column label in which you specify a condition for the
         *										column.
         * @return	float
         *
         */
        public static function DMAX($database, $field, $criteria)
        {
        }
        //	function DMAX()
        /**
         * DMIN
         *
         * Returns the smallest number in a column of a list or database that matches conditions you that
         * specify.
         *
         * Excel Function:
         *		DMIN(database,field,criteria)
         *
         * @access	public
         * @category Database Functions
         * @param	mixed[]			$database	The range of cells that makes up the list or database.
         *										A database is a list of related data in which rows of related
         *										information are records, and columns of data are fields. The
         *										first row of the list contains labels for each column.
         * @param	string|integer	$field		Indicates which column is used in the function. Enter the
         *										column label enclosed between double quotation marks, such as
         *										"Age" or "Yield," or a number (without quotation marks) that
         *										represents the position of the column within the list: 1 for
         *										the first column, 2 for the second column, and so on.
         * @param	mixed[]			$criteria	The range of cells that contains the conditions you specify.
         *										You can use any range for the criteria argument, as long as it
         *										includes at least one column label and at least one cell below
         *										the column label in which you specify a condition for the
         *										column.
         * @return	float
         *
         */
        public static function DMIN($database, $field, $criteria)
        {
        }
        //	function DMIN()
        /**
         * DPRODUCT
         *
         * Multiplies the values in a column of a list or database that match conditions that you specify.
         *
         * Excel Function:
         *		DPRODUCT(database,field,criteria)
         *
         * @access	public
         * @category Database Functions
         * @param	mixed[]			$database	The range of cells that makes up the list or database.
         *										A database is a list of related data in which rows of related
         *										information are records, and columns of data are fields. The
         *										first row of the list contains labels for each column.
         * @param	string|integer	$field		Indicates which column is used in the function. Enter the
         *										column label enclosed between double quotation marks, such as
         *										"Age" or "Yield," or a number (without quotation marks) that
         *										represents the position of the column within the list: 1 for
         *										the first column, 2 for the second column, and so on.
         * @param	mixed[]			$criteria	The range of cells that contains the conditions you specify.
         *										You can use any range for the criteria argument, as long as it
         *										includes at least one column label and at least one cell below
         *										the column label in which you specify a condition for the
         *										column.
         * @return	float
         *
         */
        public static function DPRODUCT($database, $field, $criteria)
        {
        }
        //	function DPRODUCT()
        /**
         * DSTDEV
         *
         * Estimates the standard deviation of a population based on a sample by using the numbers in a
         * column of a list or database that match conditions that you specify.
         *
         * Excel Function:
         *		DSTDEV(database,field,criteria)
         *
         * @access	public
         * @category Database Functions
         * @param	mixed[]			$database	The range of cells that makes up the list or database.
         *										A database is a list of related data in which rows of related
         *										information are records, and columns of data are fields. The
         *										first row of the list contains labels for each column.
         * @param	string|integer	$field		Indicates which column is used in the function. Enter the
         *										column label enclosed between double quotation marks, such as
         *										"Age" or "Yield," or a number (without quotation marks) that
         *										represents the position of the column within the list: 1 for
         *										the first column, 2 for the second column, and so on.
         * @param	mixed[]			$criteria	The range of cells that contains the conditions you specify.
         *										You can use any range for the criteria argument, as long as it
         *										includes at least one column label and at least one cell below
         *										the column label in which you specify a condition for the
         *										column.
         * @return	float
         *
         */
        public static function DSTDEV($database, $field, $criteria)
        {
        }
        //	function DSTDEV()
        /**
         * DSTDEVP
         *
         * Calculates the standard deviation of a population based on the entire population by using the
         * numbers in a column of a list or database that match conditions that you specify.
         *
         * Excel Function:
         *		DSTDEVP(database,field,criteria)
         *
         * @access	public
         * @category Database Functions
         * @param	mixed[]			$database	The range of cells that makes up the list or database.
         *										A database is a list of related data in which rows of related
         *										information are records, and columns of data are fields. The
         *										first row of the list contains labels for each column.
         * @param	string|integer	$field		Indicates which column is used in the function. Enter the
         *										column label enclosed between double quotation marks, such as
         *										"Age" or "Yield," or a number (without quotation marks) that
         *										represents the position of the column within the list: 1 for
         *										the first column, 2 for the second column, and so on.
         * @param	mixed[]			$criteria	The range of cells that contains the conditions you specify.
         *										You can use any range for the criteria argument, as long as it
         *										includes at least one column label and at least one cell below
         *										the column label in which you specify a condition for the
         *										column.
         * @return	float
         *
         */
        public static function DSTDEVP($database, $field, $criteria)
        {
        }
        //	function DSTDEVP()
        /**
         * DSUM
         *
         * Adds the numbers in a column of a list or database that match conditions that you specify.
         *
         * Excel Function:
         *		DSUM(database,field,criteria)
         *
         * @access	public
         * @category Database Functions
         * @param	mixed[]			$database	The range of cells that makes up the list or database.
         *										A database is a list of related data in which rows of related
         *										information are records, and columns of data are fields. The
         *										first row of the list contains labels for each column.
         * @param	string|integer	$field		Indicates which column is used in the function. Enter the
         *										column label enclosed between double quotation marks, such as
         *										"Age" or "Yield," or a number (without quotation marks) that
         *										represents the position of the column within the list: 1 for
         *										the first column, 2 for the second column, and so on.
         * @param	mixed[]			$criteria	The range of cells that contains the conditions you specify.
         *										You can use any range for the criteria argument, as long as it
         *										includes at least one column label and at least one cell below
         *										the column label in which you specify a condition for the
         *										column.
         * @return	float
         *
         */
        public static function DSUM($database, $field, $criteria)
        {
        }
        //	function DSUM()
        /**
         * DVAR
         *
         * Estimates the variance of a population based on a sample by using the numbers in a column
         * of a list or database that match conditions that you specify.
         *
         * Excel Function:
         *		DVAR(database,field,criteria)
         *
         * @access	public
         * @category Database Functions
         * @param	mixed[]			$database	The range of cells that makes up the list or database.
         *										A database is a list of related data in which rows of related
         *										information are records, and columns of data are fields. The
         *										first row of the list contains labels for each column.
         * @param	string|integer	$field		Indicates which column is used in the function. Enter the
         *										column label enclosed between double quotation marks, such as
         *										"Age" or "Yield," or a number (without quotation marks) that
         *										represents the position of the column within the list: 1 for
         *										the first column, 2 for the second column, and so on.
         * @param	mixed[]			$criteria	The range of cells that contains the conditions you specify.
         *										You can use any range for the criteria argument, as long as it
         *										includes at least one column label and at least one cell below
         *										the column label in which you specify a condition for the
         *										column.
         * @return	float
         *
         */
        public static function DVAR($database, $field, $criteria)
        {
        }
        //	function DVAR()
        /**
         * DVARP
         *
         * Calculates the variance of a population based on the entire population by using the numbers
         * in a column of a list or database that match conditions that you specify.
         *
         * Excel Function:
         *		DVARP(database,field,criteria)
         *
         * @access	public
         * @category Database Functions
         * @param	mixed[]			$database	The range of cells that makes up the list or database.
         *										A database is a list of related data in which rows of related
         *										information are records, and columns of data are fields. The
         *										first row of the list contains labels for each column.
         * @param	string|integer	$field		Indicates which column is used in the function. Enter the
         *										column label enclosed between double quotation marks, such as
         *										"Age" or "Yield," or a number (without quotation marks) that
         *										represents the position of the column within the list: 1 for
         *										the first column, 2 for the second column, and so on.
         * @param	mixed[]			$criteria	The range of cells that contains the conditions you specify.
         *										You can use any range for the criteria argument, as long as it
         *										includes at least one column label and at least one cell below
         *										the column label in which you specify a condition for the
         *										column.
         * @return	float
         *
         */
        public static function DVARP($database, $field, $criteria)
        {
        }
        //	function DVARP()
    }
    /**
     * PHPExcel_Calculation_DateTime
     *
     * @category	PHPExcel
     * @package		PHPExcel_Calculation
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Calculation_DateTime
    {
        /**
         * Identify if a year is a leap year or not
         *
         * @param	integer	$year	The year to test
         * @return	boolean			TRUE if the year is a leap year, otherwise FALSE
         */
        public static function _isLeapYear($year)
        {
        }
        //	function _isLeapYear()
        /**
         * Return the number of days between two dates based on a 360 day calendar
         *
         * @param	integer	$startDay		Day of month of the start date
         * @param	integer	$startMonth		Month of the start date
         * @param	integer	$startYear		Year of the start date
         * @param	integer	$endDay			Day of month of the start date
         * @param	integer	$endMonth		Month of the start date
         * @param	integer	$endYear		Year of the start date
         * @param	boolean $methodUS		Whether to use the US method or the European method of calculation
         * @return	integer	Number of days between the start date and the end date
         */
        private static function _dateDiff360($startDay, $startMonth, $startYear, $endDay, $endMonth, $endYear, $methodUS)
        {
        }
        //	function _dateDiff360()
        /**
         * _getDateValue
         *
         * @param	string	$dateValue
         * @return	mixed	Excel date/time serial value, or string if error
         */
        public static function _getDateValue($dateValue)
        {
        }
        //	function _getDateValue()
        /**
         * _getTimeValue
         *
         * @param	string	$timeValue
         * @return	mixed	Excel date/time serial value, or string if error
         */
        private static function _getTimeValue($timeValue)
        {
        }
        //	function _getTimeValue()
        private static function _adjustDateByMonths($dateValue = 0, $adjustmentMonths = 0)
        {
        }
        //	function _adjustDateByMonths()
        /**
         * DATETIMENOW
         *
         * Returns the current date and time.
         * The NOW function is useful when you need to display the current date and time on a worksheet or
         * calculate a value based on the current date and time, and have that value updated each time you
         * open the worksheet.
         *
         * NOTE: When used in a Cell Formula, MS Excel changes the cell format so that it matches the date
         * and time format of your regional settings. PHPExcel does not change cell formatting in this way.
         *
         * Excel Function:
         *		NOW()
         *
         * @access	public
         * @category Date/Time Functions
         * @return	mixed	Excel date/time serial value, PHP date/time serial value or PHP date/time object,
         *						depending on the value of the ReturnDateType flag
         */
        public static function DATETIMENOW()
        {
        }
        //	function DATETIMENOW()
        /**
         * DATENOW
         *
         * Returns the current date.
         * The NOW function is useful when you need to display the current date and time on a worksheet or
         * calculate a value based on the current date and time, and have that value updated each time you
         * open the worksheet.
         *
         * NOTE: When used in a Cell Formula, MS Excel changes the cell format so that it matches the date
         * and time format of your regional settings. PHPExcel does not change cell formatting in this way.
         *
         * Excel Function:
         *		TODAY()
         *
         * @access	public
         * @category Date/Time Functions
         * @return	mixed	Excel date/time serial value, PHP date/time serial value or PHP date/time object,
         *						depending on the value of the ReturnDateType flag
         */
        public static function DATENOW()
        {
        }
        //	function DATENOW()
        /**
         * DATE
         *
         * The DATE function returns a value that represents a particular date.
         *
         * NOTE: When used in a Cell Formula, MS Excel changes the cell format so that it matches the date
         * format of your regional settings. PHPExcel does not change cell formatting in this way.
         *
         * Excel Function:
         *		DATE(year,month,day)
         *
         * PHPExcel is a lot more forgiving than MS Excel when passing non numeric values to this function.
         * A Month name or abbreviation (English only at this point) such as 'January' or 'Jan' will still be accepted,
         *     as will a day value with a suffix (e.g. '21st' rather than simply 21); again only English language.
         *
         * @access	public
         * @category Date/Time Functions
         * @param	integer		$year	The value of the year argument can include one to four digits.
         *								Excel interprets the year argument according to the configured
         *								date system: 1900 or 1904.
         *								If year is between 0 (zero) and 1899 (inclusive), Excel adds that
         *								value to 1900 to calculate the year. For example, DATE(108,1,2)
         *								returns January 2, 2008 (1900+108).
         *								If year is between 1900 and 9999 (inclusive), Excel uses that
         *								value as the year. For example, DATE(2008,1,2) returns January 2,
         *								2008.
         *								If year is less than 0 or is 10000 or greater, Excel returns the
         *								#NUM! error value.
         * @param	integer		$month	A positive or negative integer representing the month of the year
         *								from 1 to 12 (January to December).
         *								If month is greater than 12, month adds that number of months to
         *								the first month in the year specified. For example, DATE(2008,14,2)
         *								returns the serial number representing February 2, 2009.
         *								If month is less than 1, month subtracts the magnitude of that
         *								number of months, plus 1, from the first month in the year
         *								specified. For example, DATE(2008,-3,2) returns the serial number
         *								representing September 2, 2007.
         * @param	integer		$day	A positive or negative integer representing the day of the month
         *								from 1 to 31.
         *								If day is greater than the number of days in the month specified,
         *								day adds that number of days to the first day in the month. For
         *								example, DATE(2008,1,35) returns the serial number representing
         *								February 4, 2008.
         *								If day is less than 1, day subtracts the magnitude that number of
         *								days, plus one, from the first day of the month specified. For
         *								example, DATE(2008,1,-15) returns the serial number representing
         *								December 16, 2007.
         * @return	mixed	Excel date/time serial value, PHP date/time serial value or PHP date/time object,
         *						depending on the value of the ReturnDateType flag
         */
        public static function DATE($year = 0, $month = 1, $day = 1)
        {
        }
        //	function DATE()
        /**
         * TIME
         *
         * The TIME function returns a value that represents a particular time.
         *
         * NOTE: When used in a Cell Formula, MS Excel changes the cell format so that it matches the time
         * format of your regional settings. PHPExcel does not change cell formatting in this way.
         *
         * Excel Function:
         *		TIME(hour,minute,second)
         *
         * @access	public
         * @category Date/Time Functions
         * @param	integer		$hour		A number from 0 (zero) to 32767 representing the hour.
         *									Any value greater than 23 will be divided by 24 and the remainder
         *									will be treated as the hour value. For example, TIME(27,0,0) =
         *									TIME(3,0,0) = .125 or 3:00 AM.
         * @param	integer		$minute		A number from 0 to 32767 representing the minute.
         *									Any value greater than 59 will be converted to hours and minutes.
         *									For example, TIME(0,750,0) = TIME(12,30,0) = .520833 or 12:30 PM.
         * @param	integer		$second		A number from 0 to 32767 representing the second.
         *									Any value greater than 59 will be converted to hours, minutes,
         *									and seconds. For example, TIME(0,0,2000) = TIME(0,33,22) = .023148
         *									or 12:33:20 AM
         * @return	mixed	Excel date/time serial value, PHP date/time serial value or PHP date/time object,
         *						depending on the value of the ReturnDateType flag
         */
        public static function TIME($hour = 0, $minute = 0, $second = 0)
        {
        }
        //	function TIME()
        /**
         * DATEVALUE
         *
         * Returns a value that represents a particular date.
         * Use DATEVALUE to convert a date represented by a text string to an Excel or PHP date/time stamp
         * value.
         *
         * NOTE: When used in a Cell Formula, MS Excel changes the cell format so that it matches the date
         * format of your regional settings. PHPExcel does not change cell formatting in this way.
         *
         * Excel Function:
         *		DATEVALUE(dateValue)
         *
         * @access	public
         * @category Date/Time Functions
         * @param	string	$dateValue		Text that represents a date in a Microsoft Excel date format.
         *									For example, "1/30/2008" or "30-Jan-2008" are text strings within
         *									quotation marks that represent dates. Using the default date
         *									system in Excel for Windows, date_text must represent a date from
         *									January 1, 1900, to December 31, 9999. Using the default date
         *									system in Excel for the Macintosh, date_text must represent a date
         *									from January 1, 1904, to December 31, 9999. DATEVALUE returns the
         *									#VALUE! error value if date_text is out of this range.
         * @return	mixed	Excel date/time serial value, PHP date/time serial value or PHP date/time object,
         *						depending on the value of the ReturnDateType flag
         */
        public static function DATEVALUE($dateValue = 1)
        {
        }
        //	function DATEVALUE()
        /**
         * TIMEVALUE
         *
         * Returns a value that represents a particular time.
         * Use TIMEVALUE to convert a time represented by a text string to an Excel or PHP date/time stamp
         * value.
         *
         * NOTE: When used in a Cell Formula, MS Excel changes the cell format so that it matches the time
         * format of your regional settings. PHPExcel does not change cell formatting in this way.
         *
         * Excel Function:
         *		TIMEVALUE(timeValue)
         *
         * @access	public
         * @category Date/Time Functions
         * @param	string	$timeValue		A text string that represents a time in any one of the Microsoft
         *									Excel time formats; for example, "6:45 PM" and "18:45" text strings
         *									within quotation marks that represent time.
         *									Date information in time_text is ignored.
         * @return	mixed	Excel date/time serial value, PHP date/time serial value or PHP date/time object,
         *						depending on the value of the ReturnDateType flag
         */
        public static function TIMEVALUE($timeValue)
        {
        }
        //	function TIMEVALUE()
        /**
         * DATEDIF
         *
         * @param	mixed	$startDate		Excel date serial value, PHP date/time stamp, PHP DateTime object
         *									or a standard date string
         * @param	mixed	$endDate		Excel date serial value, PHP date/time stamp, PHP DateTime object
         *									or a standard date string
         * @param	string	$unit
         * @return	integer	Interval between the dates
         */
        public static function DATEDIF($startDate = 0, $endDate = 0, $unit = 'D')
        {
        }
        //	function DATEDIF()
        /**
         * DAYS360
         *
         * Returns the number of days between two dates based on a 360-day year (twelve 30-day months),
         * which is used in some accounting calculations. Use this function to help compute payments if
         * your accounting system is based on twelve 30-day months.
         *
         * Excel Function:
         *		DAYS360(startDate,endDate[,method])
         *
         * @access	public
         * @category Date/Time Functions
         * @param	mixed		$startDate		Excel date serial value (float), PHP date timestamp (integer),
         *										PHP DateTime object, or a standard date string
         * @param	mixed		$endDate		Excel date serial value (float), PHP date timestamp (integer),
         *										PHP DateTime object, or a standard date string
         * @param	boolean		$method			US or European Method
         *										FALSE or omitted: U.S. (NASD) method. If the starting date is
         *										the last day of a month, it becomes equal to the 30th of the
         *										same month. If the ending date is the last day of a month and
         *										the starting date is earlier than the 30th of a month, the
         *										ending date becomes equal to the 1st of the next month;
         *										otherwise the ending date becomes equal to the 30th of the
         *										same month.
         *										TRUE: European method. Starting dates and ending dates that
         *										occur on the 31st of a month become equal to the 30th of the
         *										same month.
         * @return	integer		Number of days between start date and end date
         */
        public static function DAYS360($startDate = 0, $endDate = 0, $method = \false)
        {
        }
        //	function DAYS360()
        /**
         * YEARFRAC
         *
         * Calculates the fraction of the year represented by the number of whole days between two dates
         * (the start_date and the end_date).
         * Use the YEARFRAC worksheet function to identify the proportion of a whole year's benefits or
         * obligations to assign to a specific term.
         *
         * Excel Function:
         *		YEARFRAC(startDate,endDate[,method])
         *
         * @access	public
         * @category Date/Time Functions
         * @param	mixed	$startDate		Excel date serial value (float), PHP date timestamp (integer),
         *									PHP DateTime object, or a standard date string
         * @param	mixed	$endDate		Excel date serial value (float), PHP date timestamp (integer),
         *									PHP DateTime object, or a standard date string
         * @param	integer	$method			Method used for the calculation
         *										0 or omitted	US (NASD) 30/360
         *										1				Actual/actual
         *										2				Actual/360
         *										3				Actual/365
         *										4				European 30/360
         * @return	float	fraction of the year
         */
        public static function YEARFRAC($startDate = 0, $endDate = 0, $method = 0)
        {
        }
        //	function YEARFRAC()
        /**
         * NETWORKDAYS
         *
         * Returns the number of whole working days between start_date and end_date. Working days
         * exclude weekends and any dates identified in holidays.
         * Use NETWORKDAYS to calculate employee benefits that accrue based on the number of days
         * worked during a specific term.
         *
         * Excel Function:
         *		NETWORKDAYS(startDate,endDate[,holidays[,holiday[,...]]])
         *
         * @access	public
         * @category Date/Time Functions
         * @param	mixed			$startDate		Excel date serial value (float), PHP date timestamp (integer),
         *											PHP DateTime object, or a standard date string
         * @param	mixed			$endDate		Excel date serial value (float), PHP date timestamp (integer),
         *											PHP DateTime object, or a standard date string
         * @param	mixed			$holidays,...	Optional series of Excel date serial value (float), PHP date
         *											timestamp (integer), PHP DateTime object, or a standard date
         *											strings that will be excluded from the working calendar, such
         *											as state and federal holidays and floating holidays.
         * @return	integer			Interval between the dates
         */
        public static function NETWORKDAYS($startDate, $endDate)
        {
        }
        //	function NETWORKDAYS()
        /**
         * WORKDAY
         *
         * Returns the date that is the indicated number of working days before or after a date (the
         * starting date). Working days exclude weekends and any dates identified as holidays.
         * Use WORKDAY to exclude weekends or holidays when you calculate invoice due dates, expected
         * delivery times, or the number of days of work performed.
         *
         * Excel Function:
         *		WORKDAY(startDate,endDays[,holidays[,holiday[,...]]])
         *
         * @access	public
         * @category Date/Time Functions
         * @param	mixed		$startDate		Excel date serial value (float), PHP date timestamp (integer),
         *										PHP DateTime object, or a standard date string
         * @param	integer		$endDays		The number of nonweekend and nonholiday days before or after
         *										startDate. A positive value for days yields a future date; a
         *										negative value yields a past date.
         * @param	mixed		$holidays,...	Optional series of Excel date serial value (float), PHP date
         *										timestamp (integer), PHP DateTime object, or a standard date
         *										strings that will be excluded from the working calendar, such
         *										as state and federal holidays and floating holidays.
         * @return	mixed	Excel date/time serial value, PHP date/time serial value or PHP date/time object,
         *						depending on the value of the ReturnDateType flag
         */
        public static function WORKDAY($startDate, $endDays)
        {
        }
        //	function WORKDAY()
        /**
         * DAYOFMONTH
         *
         * Returns the day of the month, for a specified date. The day is given as an integer
         * ranging from 1 to 31.
         *
         * Excel Function:
         *		DAY(dateValue)
         *
         * @param	mixed	$dateValue		Excel date serial value (float), PHP date timestamp (integer),
         *									PHP DateTime object, or a standard date string
         * @return	int		Day of the month
         */
        public static function DAYOFMONTH($dateValue = 1)
        {
        }
        //	function DAYOFMONTH()
        /**
         * DAYOFWEEK
         *
         * Returns the day of the week for a specified date. The day is given as an integer
         * ranging from 0 to 7 (dependent on the requested style).
         *
         * Excel Function:
         *		WEEKDAY(dateValue[,style])
         *
         * @param	mixed	$dateValue		Excel date serial value (float), PHP date timestamp (integer),
         *									PHP DateTime object, or a standard date string
         * @param	int		$style			A number that determines the type of return value
         *										1 or omitted	Numbers 1 (Sunday) through 7 (Saturday).
         *										2				Numbers 1 (Monday) through 7 (Sunday).
         *										3				Numbers 0 (Monday) through 6 (Sunday).
         * @return	int		Day of the week value
         */
        public static function DAYOFWEEK($dateValue = 1, $style = 1)
        {
        }
        //	function DAYOFWEEK()
        /**
         * WEEKOFYEAR
         *
         * Returns the week of the year for a specified date.
         * The WEEKNUM function considers the week containing January 1 to be the first week of the year.
         * However, there is a European standard that defines the first week as the one with the majority
         * of days (four or more) falling in the new year. This means that for years in which there are
         * three days or less in the first week of January, the WEEKNUM function returns week numbers
         * that are incorrect according to the European standard.
         *
         * Excel Function:
         *		WEEKNUM(dateValue[,style])
         *
         * @param	mixed	$dateValue		Excel date serial value (float), PHP date timestamp (integer),
         *									PHP DateTime object, or a standard date string
         * @param	boolean	$method			Week begins on Sunday or Monday
         *										1 or omitted	Week begins on Sunday.
         *										2				Week begins on Monday.
         * @return	int		Week Number
         */
        public static function WEEKOFYEAR($dateValue = 1, $method = 1)
        {
        }
        //	function WEEKOFYEAR()
        /**
         * MONTHOFYEAR
         *
         * Returns the month of a date represented by a serial number.
         * The month is given as an integer, ranging from 1 (January) to 12 (December).
         *
         * Excel Function:
         *		MONTH(dateValue)
         *
         * @param	mixed	$dateValue		Excel date serial value (float), PHP date timestamp (integer),
         *									PHP DateTime object, or a standard date string
         * @return	int		Month of the year
         */
        public static function MONTHOFYEAR($dateValue = 1)
        {
        }
        //	function MONTHOFYEAR()
        /**
         * YEAR
         *
         * Returns the year corresponding to a date.
         * The year is returned as an integer in the range 1900-9999.
         *
         * Excel Function:
         *		YEAR(dateValue)
         *
         * @param	mixed	$dateValue		Excel date serial value (float), PHP date timestamp (integer),
         *									PHP DateTime object, or a standard date string
         * @return	int		Year
         */
        public static function YEAR($dateValue = 1)
        {
        }
        //	function YEAR()
        /**
         * HOUROFDAY
         *
         * Returns the hour of a time value.
         * The hour is given as an integer, ranging from 0 (12:00 A.M.) to 23 (11:00 P.M.).
         *
         * Excel Function:
         *		HOUR(timeValue)
         *
         * @param	mixed	$timeValue		Excel date serial value (float), PHP date timestamp (integer),
         *									PHP DateTime object, or a standard time string
         * @return	int		Hour
         */
        public static function HOUROFDAY($timeValue = 0)
        {
        }
        //	function HOUROFDAY()
        /**
         * MINUTEOFHOUR
         *
         * Returns the minutes of a time value.
         * The minute is given as an integer, ranging from 0 to 59.
         *
         * Excel Function:
         *		MINUTE(timeValue)
         *
         * @param	mixed	$timeValue		Excel date serial value (float), PHP date timestamp (integer),
         *									PHP DateTime object, or a standard time string
         * @return	int		Minute
         */
        public static function MINUTEOFHOUR($timeValue = 0)
        {
        }
        //	function MINUTEOFHOUR()
        /**
         * SECONDOFMINUTE
         *
         * Returns the seconds of a time value.
         * The second is given as an integer in the range 0 (zero) to 59.
         *
         * Excel Function:
         *		SECOND(timeValue)
         *
         * @param	mixed	$timeValue		Excel date serial value (float), PHP date timestamp (integer),
         *									PHP DateTime object, or a standard time string
         * @return	int		Second
         */
        public static function SECONDOFMINUTE($timeValue = 0)
        {
        }
        //	function SECONDOFMINUTE()
        /**
         * EDATE
         *
         * Returns the serial number that represents the date that is the indicated number of months
         * before or after a specified date (the start_date).
         * Use EDATE to calculate maturity dates or due dates that fall on the same day of the month
         * as the date of issue.
         *
         * Excel Function:
         *		EDATE(dateValue,adjustmentMonths)
         *
         * @param	mixed	$dateValue			Excel date serial value (float), PHP date timestamp (integer),
         *										PHP DateTime object, or a standard date string
         * @param	int		$adjustmentMonths	The number of months before or after start_date.
         *										A positive value for months yields a future date;
         *										a negative value yields a past date.
         * @return	mixed	Excel date/time serial value, PHP date/time serial value or PHP date/time object,
         *						depending on the value of the ReturnDateType flag
         */
        public static function EDATE($dateValue = 1, $adjustmentMonths = 0)
        {
        }
        //	function EDATE()
        /**
         * EOMONTH
         *
         * Returns the date value for the last day of the month that is the indicated number of months
         * before or after start_date.
         * Use EOMONTH to calculate maturity dates or due dates that fall on the last day of the month.
         *
         * Excel Function:
         *		EOMONTH(dateValue,adjustmentMonths)
         *
         * @param	mixed	$dateValue			Excel date serial value (float), PHP date timestamp (integer),
         *										PHP DateTime object, or a standard date string
         * @param	int		$adjustmentMonths	The number of months before or after start_date.
         *										A positive value for months yields a future date;
         *										a negative value yields a past date.
         * @return	mixed	Excel date/time serial value, PHP date/time serial value or PHP date/time object,
         *						depending on the value of the ReturnDateType flag
         */
        public static function EOMONTH($dateValue = 1, $adjustmentMonths = 0)
        {
        }
        //	function EOMONTH()
    }
    /**
     * PHPExcel_Calculation_Functions
     *
     * @category	PHPExcel
     * @package		PHPExcel_Calculation
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Calculation_Functions
    {
        /** constants */
        const COMPATIBILITY_EXCEL = 'Excel';
        const COMPATIBILITY_GNUMERIC = 'Gnumeric';
        const COMPATIBILITY_OPENOFFICE = 'OpenOfficeCalc';
        const RETURNDATE_PHP_NUMERIC = 'P';
        const RETURNDATE_PHP_OBJECT = 'O';
        const RETURNDATE_EXCEL = 'E';
        /**
         * Compatibility mode to use for error checking and responses
         *
         * @access	private
         * @var string
         */
        protected static $compatibilityMode = self::COMPATIBILITY_EXCEL;
        /**
         * Data Type to use when returning date values
         *
         * @access	private
         * @var string
         */
        protected static $ReturnDateType = self::RETURNDATE_EXCEL;
        /**
         * List of error codes
         *
         * @access	private
         * @var array
         */
        protected static $_errorCodes = array('null' => '#NULL!', 'divisionbyzero' => '#DIV/0!', 'value' => '#VALUE!', 'reference' => '#REF!', 'name' => '#NAME?', 'num' => '#NUM!', 'na' => '#N/A', 'gettingdata' => '#GETTING_DATA');
        /**
         * Set the Compatibility Mode
         *
         * @access	public
         * @category Function Configuration
         * @param	 string		$compatibilityMode		Compatibility Mode
         *												Permitted values are:
         *													PHPExcel_Calculation_Functions::COMPATIBILITY_EXCEL			'Excel'
         *													PHPExcel_Calculation_Functions::COMPATIBILITY_GNUMERIC		'Gnumeric'
         *													PHPExcel_Calculation_Functions::COMPATIBILITY_OPENOFFICE	'OpenOfficeCalc'
         * @return	 boolean	(Success or Failure)
         */
        public static function setCompatibilityMode($compatibilityMode)
        {
        }
        //	function setCompatibilityMode()
        /**
         * Return the current Compatibility Mode
         *
         * @access	public
         * @category Function Configuration
         * @return	 string		Compatibility Mode
         *							Possible Return values are:
         *								PHPExcel_Calculation_Functions::COMPATIBILITY_EXCEL			'Excel'
         *								PHPExcel_Calculation_Functions::COMPATIBILITY_GNUMERIC		'Gnumeric'
         *								PHPExcel_Calculation_Functions::COMPATIBILITY_OPENOFFICE	'OpenOfficeCalc'
         */
        public static function getCompatibilityMode()
        {
        }
        //	function getCompatibilityMode()
        /**
         * Set the Return Date Format used by functions that return a date/time (Excel, PHP Serialized Numeric or PHP Object)
         *
         * @access	public
         * @category Function Configuration
         * @param	 string	$returnDateType			Return Date Format
         *												Permitted values are:
         *													PHPExcel_Calculation_Functions::RETURNDATE_PHP_NUMERIC		'P'
         *													PHPExcel_Calculation_Functions::RETURNDATE_PHP_OBJECT		'O'
         *													PHPExcel_Calculation_Functions::RETURNDATE_EXCEL			'E'
         * @return	 boolean							Success or failure
         */
        public static function setReturnDateType($returnDateType)
        {
        }
        //	function setReturnDateType()
        /**
         * Return the current Return Date Format for functions that return a date/time (Excel, PHP Serialized Numeric or PHP Object)
         *
         * @access	public
         * @category Function Configuration
         * @return	 string		Return Date Format
         *							Possible Return values are:
         *								PHPExcel_Calculation_Functions::RETURNDATE_PHP_NUMERIC		'P'
         *								PHPExcel_Calculation_Functions::RETURNDATE_PHP_OBJECT		'O'
         *								PHPExcel_Calculation_Functions::RETURNDATE_EXCEL			'E'
         */
        public static function getReturnDateType()
        {
        }
        //	function getReturnDateType()
        /**
         * DUMMY
         *
         * @access	public
         * @category Error Returns
         * @return	string	#Not Yet Implemented
         */
        public static function DUMMY()
        {
        }
        //	function DUMMY()
        /**
         * DIV0
         *
         * @access	public
         * @category Error Returns
         * @return	string	#Not Yet Implemented
         */
        public static function DIV0()
        {
        }
        //	function DIV0()
        /**
         * NA
         *
         * Excel Function:
         *		=NA()
         *
         * Returns the error value #N/A
         *		#N/A is the error value that means "no value is available."
         *
         * @access	public
         * @category Logical Functions
         * @return	string	#N/A!
         */
        public static function NA()
        {
        }
        //	function NA()
        /**
         * NaN
         *
         * Returns the error value #NUM!
         *
         * @access	public
         * @category Error Returns
         * @return	string	#NUM!
         */
        public static function NaN()
        {
        }
        //	function NaN()
        /**
         * NAME
         *
         * Returns the error value #NAME?
         *
         * @access	public
         * @category Error Returns
         * @return	string	#NAME?
         */
        public static function NAME()
        {
        }
        //	function NAME()
        /**
         * REF
         *
         * Returns the error value #REF!
         *
         * @access	public
         * @category Error Returns
         * @return	string	#REF!
         */
        public static function REF()
        {
        }
        //	function REF()
        /**
         * NULL
         *
         * Returns the error value #NULL!
         *
         * @access	public
         * @category Error Returns
         * @return	string	#NULL!
         */
        public static function NULL()
        {
        }
        //	function NULL()
        /**
         * VALUE
         *
         * Returns the error value #VALUE!
         *
         * @access	public
         * @category Error Returns
         * @return	string	#VALUE!
         */
        public static function VALUE()
        {
        }
        //	function VALUE()
        public static function isMatrixValue($idx)
        {
        }
        public static function isValue($idx)
        {
        }
        public static function isCellValue($idx)
        {
        }
        public static function _ifCondition($condition)
        {
        }
        //	function _ifCondition()
        /**
         * ERROR_TYPE
         *
         * @param	mixed	$value	Value to check
         * @return	boolean
         */
        public static function ERROR_TYPE($value = '')
        {
        }
        //	function ERROR_TYPE()
        /**
         * IS_BLANK
         *
         * @param	mixed	$value	Value to check
         * @return	boolean
         */
        public static function IS_BLANK($value = \NULL)
        {
        }
        //	function IS_BLANK()
        /**
         * IS_ERR
         *
         * @param	mixed	$value	Value to check
         * @return	boolean
         */
        public static function IS_ERR($value = '')
        {
        }
        //	function IS_ERR()
        /**
         * IS_ERROR
         *
         * @param	mixed	$value	Value to check
         * @return	boolean
         */
        public static function IS_ERROR($value = '')
        {
        }
        //	function IS_ERROR()
        /**
         * IS_NA
         *
         * @param	mixed	$value	Value to check
         * @return	boolean
         */
        public static function IS_NA($value = '')
        {
        }
        //	function IS_NA()
        /**
         * IS_EVEN
         *
         * @param	mixed	$value	Value to check
         * @return	boolean
         */
        public static function IS_EVEN($value = \NULL)
        {
        }
        //	function IS_EVEN()
        /**
         * IS_ODD
         *
         * @param	mixed	$value	Value to check
         * @return	boolean
         */
        public static function IS_ODD($value = \NULL)
        {
        }
        //	function IS_ODD()
        /**
         * IS_NUMBER
         *
         * @param	mixed	$value		Value to check
         * @return	boolean
         */
        public static function IS_NUMBER($value = \NULL)
        {
        }
        //	function IS_NUMBER()
        /**
         * IS_LOGICAL
         *
         * @param	mixed	$value		Value to check
         * @return	boolean
         */
        public static function IS_LOGICAL($value = \NULL)
        {
        }
        //	function IS_LOGICAL()
        /**
         * IS_TEXT
         *
         * @param	mixed	$value		Value to check
         * @return	boolean
         */
        public static function IS_TEXT($value = \NULL)
        {
        }
        //	function IS_TEXT()
        /**
         * IS_NONTEXT
         *
         * @param	mixed	$value		Value to check
         * @return	boolean
         */
        public static function IS_NONTEXT($value = \NULL)
        {
        }
        //	function IS_NONTEXT()
        /**
         * VERSION
         *
         * @return	string	Version information
         */
        public static function VERSION()
        {
        }
        //	function VERSION()
        /**
         * N
         *
         * Returns a value converted to a number
         *
         * @param	value		The value you want converted
         * @return	number		N converts values listed in the following table
         *		If value is or refers to N returns
         *		A number			That number
         *		A date				The serial number of that date
         *		TRUE				1
         *		FALSE				0
         *		An error value		The error value
         *		Anything else		0
         */
        public static function N($value = \NULL)
        {
        }
        //	function N()
        /**
         * TYPE
         *
         * Returns a number that identifies the type of a value
         *
         * @param	value		The value you want tested
         * @return	number		N converts values listed in the following table
         *		If value is or refers to N returns
         *		A number			1
         *		Text				2
         *		Logical Value		4
         *		An error value		16
         *		Array or Matrix		64
         */
        public static function TYPE($value = \NULL)
        {
        }
        //	function TYPE()
        /**
         * Convert a multi-dimensional array to a simple 1-dimensional array
         *
         * @param	array	$array	Array to be flattened
         * @return	array	Flattened array
         */
        public static function flattenArray($array)
        {
        }
        //	function flattenArray()
        /**
         * Convert a multi-dimensional array to a simple 1-dimensional array, but retain an element of indexing
         *
         * @param	array	$array	Array to be flattened
         * @return	array	Flattened array
         */
        public static function flattenArrayIndexed($array)
        {
        }
        //	function flattenArrayIndexed()
        /**
         * Convert an array to a single scalar value by extracting the first element
         *
         * @param	mixed		$value		Array or scalar value
         * @return	mixed
         */
        public static function flattenSingleValue($value = '')
        {
        }
        //	function flattenSingleValue()
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Calculation
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license	http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version	1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Calculation_ExceptionHandler
     *
     * @category   PHPExcel
     * @package    PHPExcel_Calculation
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Calculation_ExceptionHandler
    {
        /**
         * Register errorhandler
         */
        public function __construct()
        {
        }
        /**
         * Unregister errorhandler
         */
        public function __destruct()
        {
        }
    }
    /**
     * PHPExcel_Calculation_Engineering
     *
     * @category	PHPExcel
     * @package		PHPExcel_Calculation
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Calculation_Engineering
    {
        /**
         * Details of the Units of measure that can be used in CONVERTUOM()
         *
         * @var mixed[]
         */
        private static $_conversionUnits = array('g' => array('Group' => 'Mass', 'Unit Name' => 'Gram', 'AllowPrefix' => \True), 'sg' => array('Group' => 'Mass', 'Unit Name' => 'Slug', 'AllowPrefix' => \False), 'lbm' => array('Group' => 'Mass', 'Unit Name' => 'Pound mass (avoirdupois)', 'AllowPrefix' => \False), 'u' => array('Group' => 'Mass', 'Unit Name' => 'U (atomic mass unit)', 'AllowPrefix' => \True), 'ozm' => array('Group' => 'Mass', 'Unit Name' => 'Ounce mass (avoirdupois)', 'AllowPrefix' => \False), 'm' => array('Group' => 'Distance', 'Unit Name' => 'Meter', 'AllowPrefix' => \True), 'mi' => array('Group' => 'Distance', 'Unit Name' => 'Statute mile', 'AllowPrefix' => \False), 'Nmi' => array('Group' => 'Distance', 'Unit Name' => 'Nautical mile', 'AllowPrefix' => \False), 'in' => array('Group' => 'Distance', 'Unit Name' => 'Inch', 'AllowPrefix' => \False), 'ft' => array('Group' => 'Distance', 'Unit Name' => 'Foot', 'AllowPrefix' => \False), 'yd' => array('Group' => 'Distance', 'Unit Name' => 'Yard', 'AllowPrefix' => \False), 'ang' => array('Group' => 'Distance', 'Unit Name' => 'Angstrom', 'AllowPrefix' => \True), 'Pica' => array('Group' => 'Distance', 'Unit Name' => 'Pica (1/72 in)', 'AllowPrefix' => \False), 'yr' => array('Group' => 'Time', 'Unit Name' => 'Year', 'AllowPrefix' => \False), 'day' => array('Group' => 'Time', 'Unit Name' => 'Day', 'AllowPrefix' => \False), 'hr' => array('Group' => 'Time', 'Unit Name' => 'Hour', 'AllowPrefix' => \False), 'mn' => array('Group' => 'Time', 'Unit Name' => 'Minute', 'AllowPrefix' => \False), 'sec' => array('Group' => 'Time', 'Unit Name' => 'Second', 'AllowPrefix' => \True), 'Pa' => array('Group' => 'Pressure', 'Unit Name' => 'Pascal', 'AllowPrefix' => \True), 'p' => array('Group' => 'Pressure', 'Unit Name' => 'Pascal', 'AllowPrefix' => \True), 'atm' => array('Group' => 'Pressure', 'Unit Name' => 'Atmosphere', 'AllowPrefix' => \True), 'at' => array('Group' => 'Pressure', 'Unit Name' => 'Atmosphere', 'AllowPrefix' => \True), 'mmHg' => array('Group' => 'Pressure', 'Unit Name' => 'mm of Mercury', 'AllowPrefix' => \True), 'N' => array('Group' => 'Force', 'Unit Name' => 'Newton', 'AllowPrefix' => \True), 'dyn' => array('Group' => 'Force', 'Unit Name' => 'Dyne', 'AllowPrefix' => \True), 'dy' => array('Group' => 'Force', 'Unit Name' => 'Dyne', 'AllowPrefix' => \True), 'lbf' => array('Group' => 'Force', 'Unit Name' => 'Pound force', 'AllowPrefix' => \False), 'J' => array('Group' => 'Energy', 'Unit Name' => 'Joule', 'AllowPrefix' => \True), 'e' => array('Group' => 'Energy', 'Unit Name' => 'Erg', 'AllowPrefix' => \True), 'c' => array('Group' => 'Energy', 'Unit Name' => 'Thermodynamic calorie', 'AllowPrefix' => \True), 'cal' => array('Group' => 'Energy', 'Unit Name' => 'IT calorie', 'AllowPrefix' => \True), 'eV' => array('Group' => 'Energy', 'Unit Name' => 'Electron volt', 'AllowPrefix' => \True), 'ev' => array('Group' => 'Energy', 'Unit Name' => 'Electron volt', 'AllowPrefix' => \True), 'HPh' => array('Group' => 'Energy', 'Unit Name' => 'Horsepower-hour', 'AllowPrefix' => \False), 'hh' => array('Group' => 'Energy', 'Unit Name' => 'Horsepower-hour', 'AllowPrefix' => \False), 'Wh' => array('Group' => 'Energy', 'Unit Name' => 'Watt-hour', 'AllowPrefix' => \True), 'wh' => array('Group' => 'Energy', 'Unit Name' => 'Watt-hour', 'AllowPrefix' => \True), 'flb' => array('Group' => 'Energy', 'Unit Name' => 'Foot-pound', 'AllowPrefix' => \False), 'BTU' => array('Group' => 'Energy', 'Unit Name' => 'BTU', 'AllowPrefix' => \False), 'btu' => array('Group' => 'Energy', 'Unit Name' => 'BTU', 'AllowPrefix' => \False), 'HP' => array('Group' => 'Power', 'Unit Name' => 'Horsepower', 'AllowPrefix' => \False), 'h' => array('Group' => 'Power', 'Unit Name' => 'Horsepower', 'AllowPrefix' => \False), 'W' => array('Group' => 'Power', 'Unit Name' => 'Watt', 'AllowPrefix' => \True), 'w' => array('Group' => 'Power', 'Unit Name' => 'Watt', 'AllowPrefix' => \True), 'T' => array('Group' => 'Magnetism', 'Unit Name' => 'Tesla', 'AllowPrefix' => \True), 'ga' => array('Group' => 'Magnetism', 'Unit Name' => 'Gauss', 'AllowPrefix' => \True), 'C' => array('Group' => 'Temperature', 'Unit Name' => 'Celsius', 'AllowPrefix' => \False), 'cel' => array('Group' => 'Temperature', 'Unit Name' => 'Celsius', 'AllowPrefix' => \False), 'F' => array('Group' => 'Temperature', 'Unit Name' => 'Fahrenheit', 'AllowPrefix' => \False), 'fah' => array('Group' => 'Temperature', 'Unit Name' => 'Fahrenheit', 'AllowPrefix' => \False), 'K' => array('Group' => 'Temperature', 'Unit Name' => 'Kelvin', 'AllowPrefix' => \False), 'kel' => array('Group' => 'Temperature', 'Unit Name' => 'Kelvin', 'AllowPrefix' => \False), 'tsp' => array('Group' => 'Liquid', 'Unit Name' => 'Teaspoon', 'AllowPrefix' => \False), 'tbs' => array('Group' => 'Liquid', 'Unit Name' => 'Tablespoon', 'AllowPrefix' => \False), 'oz' => array('Group' => 'Liquid', 'Unit Name' => 'Fluid Ounce', 'AllowPrefix' => \False), 'cup' => array('Group' => 'Liquid', 'Unit Name' => 'Cup', 'AllowPrefix' => \False), 'pt' => array('Group' => 'Liquid', 'Unit Name' => 'U.S. Pint', 'AllowPrefix' => \False), 'us_pt' => array('Group' => 'Liquid', 'Unit Name' => 'U.S. Pint', 'AllowPrefix' => \False), 'uk_pt' => array('Group' => 'Liquid', 'Unit Name' => 'U.K. Pint', 'AllowPrefix' => \False), 'qt' => array('Group' => 'Liquid', 'Unit Name' => 'Quart', 'AllowPrefix' => \False), 'gal' => array('Group' => 'Liquid', 'Unit Name' => 'Gallon', 'AllowPrefix' => \False), 'l' => array('Group' => 'Liquid', 'Unit Name' => 'Litre', 'AllowPrefix' => \True), 'lt' => array('Group' => 'Liquid', 'Unit Name' => 'Litre', 'AllowPrefix' => \True));
        /**
         * Details of the Multiplier prefixes that can be used with Units of Measure in CONVERTUOM()
         *
         * @var mixed[]
         */
        private static $_conversionMultipliers = array('Y' => array('multiplier' => 1.0E+24, 'name' => 'yotta'), 'Z' => array('multiplier' => 1.0E+21, 'name' => 'zetta'), 'E' => array('multiplier' => 1.0E+18, 'name' => 'exa'), 'P' => array('multiplier' => 1000000000000000.0, 'name' => 'peta'), 'T' => array('multiplier' => 1000000000000.0, 'name' => 'tera'), 'G' => array('multiplier' => 1000000000.0, 'name' => 'giga'), 'M' => array('multiplier' => 1000000.0, 'name' => 'mega'), 'k' => array('multiplier' => 1000.0, 'name' => 'kilo'), 'h' => array('multiplier' => 100.0, 'name' => 'hecto'), 'e' => array('multiplier' => 10.0, 'name' => 'deka'), 'd' => array('multiplier' => 0.1, 'name' => 'deci'), 'c' => array('multiplier' => 0.01, 'name' => 'centi'), 'm' => array('multiplier' => 0.001, 'name' => 'milli'), 'u' => array('multiplier' => 1.0E-6, 'name' => 'micro'), 'n' => array('multiplier' => 1.0E-9, 'name' => 'nano'), 'p' => array('multiplier' => 1.0E-12, 'name' => 'pico'), 'f' => array('multiplier' => 1.0E-15, 'name' => 'femto'), 'a' => array('multiplier' => 1.0E-18, 'name' => 'atto'), 'z' => array('multiplier' => 9.999999999999999E-22, 'name' => 'zepto'), 'y' => array('multiplier' => 9.999999999999999E-25, 'name' => 'yocto'));
        /**
         * Details of the Units of measure conversion factors, organised by group
         *
         * @var mixed[]
         */
        private static $_unitConversions = array('Mass' => array('g' => array('g' => 1.0, 'sg' => 6.85220500053478E-5, 'lbm' => 0.00220462291469134, 'u' => 6.02217E+23, 'ozm' => 0.0352739718003627), 'sg' => array('g' => 14593.8424189287, 'sg' => 1.0, 'lbm' => 32.1739194101647, 'u' => 8.788659999999999E+27, 'ozm' => 514.782785944229), 'lbm' => array('g' => 453.5923097488115, 'sg' => 0.0310810749306493, 'lbm' => 1.0, 'u' => 2.73161E+26, 'ozm' => 16.000002342941), 'u' => array('g' => 1.66053100460465E-24, 'sg' => 1.1378298853295E-28, 'lbm' => 3.66084470330684E-27, 'u' => 1.0, 'ozm' => 5.85735238300524E-26), 'ozm' => array('g' => 28.3495152079732, 'sg' => 0.00194256689870811, 'lbm' => 0.0624999908478882, 'u' => 1.707256E+25, 'ozm' => 1.0)), 'Distance' => array('m' => array('m' => 1.0, 'mi' => 0.000621371192237334, 'Nmi' => 0.000539956803455724, 'in' => 39.3700787401575, 'ft' => 3.28083989501312, 'yd' => 1.09361329797891, 'ang' => 10000000000.0, 'Pica' => 2834.64566929116), 'mi' => array('m' => 1609.344, 'mi' => 1.0, 'Nmi' => 0.868976241900648, 'in' => 63360.0, 'ft' => 5280.0, 'yd' => 1760.0, 'ang' => 16093440000000.0, 'Pica' => 4561919.99999971), 'Nmi' => array('m' => 1852.0, 'mi' => 1.15077944802354, 'Nmi' => 1.0, 'in' => 72913.3858267717, 'ft' => 6076.1154855643, 'yd' => 2025.37182785694, 'ang' => 18520000000000.0, 'Pica' => 5249763.77952723), 'in' => array('m' => 0.0254, 'mi' => 1.57828282828283E-5, 'Nmi' => 1.37149028077754E-5, 'in' => 1.0, 'ft' => 0.0833333333333333, 'yd' => 0.0277777777686643, 'ang' => 254000000.0, 'Pica' => 71.9999999999955), 'ft' => array('m' => 0.3048, 'mi' => 0.000189393939393939, 'Nmi' => 0.000164578833693305, 'in' => 12.0, 'ft' => 1.0, 'yd' => 0.333333333223972, 'ang' => 3048000000.0, 'Pica' => 863.999999999946), 'yd' => array('m' => 0.9144000003, 'mi' => 0.00056818181836823, 'Nmi' => 0.000493736501241901, 'in' => 36.000000011811, 'ft' => 3.0, 'yd' => 1.0, 'ang' => 9144000003.0, 'Pica' => 2592.00000085023), 'ang' => array('m' => 1.0E-10, 'mi' => 6.213711922373341E-14, 'Nmi' => 5.39956803455724E-14, 'in' => 3.93700787401575E-9, 'ft' => 3.28083989501312E-10, 'yd' => 1.09361329797891E-10, 'ang' => 1.0, 'Pica' => 2.83464566929116E-7), 'Pica' => array('m' => 0.0003527777777778, 'mi' => 2.19205948372629E-7, 'Nmi' => 1.90484761219114E-7, 'in' => 0.0138888888888898, 'ft' => 0.00115740740740748, 'yd' => 0.000385802469009251, 'ang' => 3527777.777778, 'Pica' => 1.0)), 'Time' => array('yr' => array('yr' => 1.0, 'day' => 365.25, 'hr' => 8766.0, 'mn' => 525960.0, 'sec' => 31557600.0), 'day' => array('yr' => 0.0027378507871321, 'day' => 1.0, 'hr' => 24.0, 'mn' => 1440.0, 'sec' => 86400.0), 'hr' => array('yr' => 0.000114077116130504, 'day' => 0.0416666666666667, 'hr' => 1.0, 'mn' => 60.0, 'sec' => 3600.0), 'mn' => array('yr' => 1.90128526884174E-6, 'day' => 0.000694444444444444, 'hr' => 0.0166666666666667, 'mn' => 1.0, 'sec' => 60.0), 'sec' => array('yr' => 3.16880878140289E-8, 'day' => 1.15740740740741E-5, 'hr' => 0.000277777777777778, 'mn' => 0.0166666666666667, 'sec' => 1.0)), 'Pressure' => array('Pa' => array('Pa' => 1.0, 'p' => 1.0, 'atm' => 9.86923299998193E-6, 'at' => 9.86923299998193E-6, 'mmHg' => 0.00750061707998627), 'p' => array('Pa' => 1.0, 'p' => 1.0, 'atm' => 9.86923299998193E-6, 'at' => 9.86923299998193E-6, 'mmHg' => 0.00750061707998627), 'atm' => array('Pa' => 101324.996583, 'p' => 101324.996583, 'atm' => 1.0, 'at' => 1.0, 'mmHg' => 760.0), 'at' => array('Pa' => 101324.996583, 'p' => 101324.996583, 'atm' => 1.0, 'at' => 1.0, 'mmHg' => 760.0), 'mmHg' => array('Pa' => 133.322363925, 'p' => 133.322363925, 'atm' => 0.00131578947368421, 'at' => 0.00131578947368421, 'mmHg' => 1.0)), 'Force' => array('N' => array('N' => 1.0, 'dyn' => 100000.0, 'dy' => 100000.0, 'lbf' => 0.224808923655339), 'dyn' => array('N' => 1.0E-5, 'dyn' => 1.0, 'dy' => 1.0, 'lbf' => 2.24808923655339E-6), 'dy' => array('N' => 1.0E-5, 'dyn' => 1.0, 'dy' => 1.0, 'lbf' => 2.24808923655339E-6), 'lbf' => array('N' => 4.448222, 'dyn' => 444822.2, 'dy' => 444822.2, 'lbf' => 1.0)), 'Energy' => array('J' => array('J' => 1.0, 'e' => 9999995.193432311, 'c' => 0.239006249473467, 'cal' => 0.238846190642017, 'eV' => 6.241457E+18, 'ev' => 6.241457E+18, 'HPh' => 3.72506430801E-7, 'hh' => 3.72506430801E-7, 'Wh' => 0.000277777916238711, 'wh' => 0.000277777916238711, 'flb' => 23.7304222192651, 'BTU' => 0.000947815067349015, 'btu' => 0.000947815067349015), 'e' => array('J' => 1.000000480657E-7, 'e' => 1.0, 'c' => 2.39006364353494E-8, 'cal' => 2.38846305445111E-8, 'eV' => 624146000000.0, 'ev' => 624146000000.0, 'HPh' => 3.72506609848824E-14, 'hh' => 3.72506609848824E-14, 'Wh' => 2.77778049754611E-11, 'wh' => 2.77778049754611E-11, 'flb' => 2.37304336254586E-6, 'BTU' => 9.47815522922962E-11, 'btu' => 9.47815522922962E-11), 'c' => array('J' => 4.18399101363672, 'e' => 41839890.0257312, 'c' => 1.0, 'cal' => 0.999330315287563, 'eV' => 2.61142E+19, 'ev' => 2.61142E+19, 'HPh' => 1.55856355899327E-6, 'hh' => 1.55856355899327E-6, 'Wh' => 0.0011622203053295, 'wh' => 0.0011622203053295, 'flb' => 99.28787331521021, 'BTU' => 0.00396564972437776, 'btu' => 0.00396564972437776), 'cal' => array('J' => 4.18679484613929, 'e' => 41867928.3372801, 'c' => 1.00067013349059, 'cal' => 1.0, 'eV' => 2.61317E+19, 'ev' => 2.61317E+19, 'HPh' => 1.55960800463137E-6, 'hh' => 1.55960800463137E-6, 'Wh' => 0.00116299914807955, 'wh' => 0.00116299914807955, 'flb' => 99.3544094443283, 'BTU' => 0.00396830723907002, 'btu' => 0.00396830723907002), 'eV' => array('J' => 1.60219000146921E-19, 'e' => 1.60218923136574E-12, 'c' => 3.82933423195043E-20, 'cal' => 3.82676978535648E-20, 'eV' => 1.0, 'ev' => 1.0, 'HPh' => 5.968260789123441E-26, 'hh' => 5.968260789123441E-26, 'Wh' => 4.45053000026614E-23, 'wh' => 4.45053000026614E-23, 'flb' => 3.80206452103492E-18, 'BTU' => 1.51857982414846E-22, 'btu' => 1.51857982414846E-22), 'ev' => array('J' => 1.60219000146921E-19, 'e' => 1.60218923136574E-12, 'c' => 3.82933423195043E-20, 'cal' => 3.82676978535648E-20, 'eV' => 1.0, 'ev' => 1.0, 'HPh' => 5.968260789123441E-26, 'hh' => 5.968260789123441E-26, 'Wh' => 4.45053000026614E-23, 'wh' => 4.45053000026614E-23, 'flb' => 3.80206452103492E-18, 'BTU' => 1.51857982414846E-22, 'btu' => 1.51857982414846E-22), 'HPh' => array('J' => 2684517.4131617, 'e' => 26845161228302.4, 'c' => 641616.438565991, 'cal' => 641186.7578458349, 'eV' => 1.67553E+25, 'ev' => 1.67553E+25, 'HPh' => 1.0, 'hh' => 1.0, 'Wh' => 745.6996531345929, 'wh' => 745.6996531345929, 'flb' => 63704731.6692964, 'BTU' => 2544.42605275546, 'btu' => 2544.42605275546), 'hh' => array('J' => 2684517.4131617, 'e' => 26845161228302.4, 'c' => 641616.438565991, 'cal' => 641186.7578458349, 'eV' => 1.67553E+25, 'ev' => 1.67553E+25, 'HPh' => 1.0, 'hh' => 1.0, 'Wh' => 745.6996531345929, 'wh' => 745.6996531345929, 'flb' => 63704731.6692964, 'BTU' => 2544.42605275546, 'btu' => 2544.42605275546), 'Wh' => array('J' => 3599.9982055472, 'e' => 35999964751.8369, 'c' => 860.422069219046, 'cal' => 859.845857713046, 'eV' => 2.2469234E+22, 'ev' => 2.2469234E+22, 'HPh' => 0.00134102248243839, 'hh' => 0.00134102248243839, 'Wh' => 1.0, 'wh' => 1.0, 'flb' => 85429.4774062316, 'BTU' => 3.41213254164705, 'btu' => 3.41213254164705), 'wh' => array('J' => 3599.9982055472, 'e' => 35999964751.8369, 'c' => 860.422069219046, 'cal' => 859.845857713046, 'eV' => 2.2469234E+22, 'ev' => 2.2469234E+22, 'HPh' => 0.00134102248243839, 'hh' => 0.00134102248243839, 'Wh' => 1.0, 'wh' => 1.0, 'flb' => 85429.4774062316, 'BTU' => 3.41213254164705, 'btu' => 3.41213254164705), 'flb' => array('J' => 0.0421400003236424, 'e' => 421399.80068766, 'c' => 0.0100717234301644, 'cal' => 0.0100649785509554, 'eV' => 2.63015E+17, 'ev' => 2.63015E+17, 'HPh' => 1.5697421114513E-8, 'hh' => 1.5697421114513E-8, 'Wh' => 1.17055614802E-5, 'wh' => 1.17055614802E-5, 'flb' => 1.0, 'BTU' => 3.99409272448406E-5, 'btu' => 3.99409272448406E-5), 'BTU' => array('J' => 1055.05813786749, 'e' => 10550576307.4665, 'c' => 252.165488508168, 'cal' => 251.99661713551, 'eV' => 6.5851E+21, 'ev' => 6.5851E+21, 'HPh' => 0.000393015941224568, 'hh' => 0.000393015941224568, 'Wh' => 0.293071851047526, 'wh' => 0.293071851047526, 'flb' => 25036.9750774671, 'BTU' => 1.0, 'btu' => 1.0), 'btu' => array('J' => 1055.05813786749, 'e' => 10550576307.4665, 'c' => 252.165488508168, 'cal' => 251.99661713551, 'eV' => 6.5851E+21, 'ev' => 6.5851E+21, 'HPh' => 0.000393015941224568, 'hh' => 0.000393015941224568, 'Wh' => 0.293071851047526, 'wh' => 0.293071851047526, 'flb' => 25036.9750774671, 'BTU' => 1.0, 'btu' => 1.0)), 'Power' => array('HP' => array('HP' => 1.0, 'h' => 1.0, 'W' => 745.701, 'w' => 745.701), 'h' => array('HP' => 1.0, 'h' => 1.0, 'W' => 745.701, 'w' => 745.701), 'W' => array('HP' => 0.00134102006031908, 'h' => 0.00134102006031908, 'W' => 1.0, 'w' => 1.0), 'w' => array('HP' => 0.00134102006031908, 'h' => 0.00134102006031908, 'W' => 1.0, 'w' => 1.0)), 'Magnetism' => array('T' => array('T' => 1.0, 'ga' => 10000.0), 'ga' => array('T' => 0.0001, 'ga' => 1.0)), 'Liquid' => array('tsp' => array('tsp' => 1.0, 'tbs' => 0.333333333333333, 'oz' => 0.166666666666667, 'cup' => 0.0208333333333333, 'pt' => 0.0104166666666667, 'us_pt' => 0.0104166666666667, 'uk_pt' => 0.008675585168219599, 'qt' => 0.00520833333333333, 'gal' => 0.00130208333333333, 'l' => 0.0049299940840071, 'lt' => 0.0049299940840071), 'tbs' => array('tsp' => 3.0, 'tbs' => 1.0, 'oz' => 0.5, 'cup' => 0.0625, 'pt' => 0.03125, 'us_pt' => 0.03125, 'uk_pt' => 0.0260267555046588, 'qt' => 0.015625, 'gal' => 0.00390625, 'l' => 0.0147899822520213, 'lt' => 0.0147899822520213), 'oz' => array('tsp' => 6.0, 'tbs' => 2.0, 'oz' => 1.0, 'cup' => 0.125, 'pt' => 0.0625, 'us_pt' => 0.0625, 'uk_pt' => 0.0520535110093176, 'qt' => 0.03125, 'gal' => 0.0078125, 'l' => 0.0295799645040426, 'lt' => 0.0295799645040426), 'cup' => array('tsp' => 48.0, 'tbs' => 16.0, 'oz' => 8.0, 'cup' => 1.0, 'pt' => 0.5, 'us_pt' => 0.5, 'uk_pt' => 0.416428088074541, 'qt' => 0.25, 'gal' => 0.0625, 'l' => 0.236639716032341, 'lt' => 0.236639716032341), 'pt' => array('tsp' => 96.0, 'tbs' => 32.0, 'oz' => 16.0, 'cup' => 2.0, 'pt' => 1.0, 'us_pt' => 1.0, 'uk_pt' => 0.832856176149081, 'qt' => 0.5, 'gal' => 0.125, 'l' => 0.473279432064682, 'lt' => 0.473279432064682), 'us_pt' => array('tsp' => 96.0, 'tbs' => 32.0, 'oz' => 16.0, 'cup' => 2.0, 'pt' => 1.0, 'us_pt' => 1.0, 'uk_pt' => 0.832856176149081, 'qt' => 0.5, 'gal' => 0.125, 'l' => 0.473279432064682, 'lt' => 0.473279432064682), 'uk_pt' => array('tsp' => 115.266, 'tbs' => 38.422, 'oz' => 19.211, 'cup' => 2.401375, 'pt' => 1.2006875, 'us_pt' => 1.2006875, 'uk_pt' => 1.0, 'qt' => 0.60034375, 'gal' => 0.1500859375, 'l' => 0.568260698087162, 'lt' => 0.568260698087162), 'qt' => array('tsp' => 192.0, 'tbs' => 64.0, 'oz' => 32.0, 'cup' => 4.0, 'pt' => 2.0, 'us_pt' => 2.0, 'uk_pt' => 1.66571235229816, 'qt' => 1.0, 'gal' => 0.25, 'l' => 0.946558864129363, 'lt' => 0.946558864129363), 'gal' => array('tsp' => 768.0, 'tbs' => 256.0, 'oz' => 128.0, 'cup' => 16.0, 'pt' => 8.0, 'us_pt' => 8.0, 'uk_pt' => 6.66284940919265, 'qt' => 4.0, 'gal' => 1.0, 'l' => 3.78623545651745, 'lt' => 3.78623545651745), 'l' => array('tsp' => 202.84, 'tbs' => 67.6133333333333, 'oz' => 33.8066666666667, 'cup' => 4.22583333333333, 'pt' => 2.11291666666667, 'us_pt' => 2.11291666666667, 'uk_pt' => 1.75975569552166, 'qt' => 1.05645833333333, 'gal' => 0.264114583333333, 'l' => 1.0, 'lt' => 1.0), 'lt' => array('tsp' => 202.84, 'tbs' => 67.6133333333333, 'oz' => 33.8066666666667, 'cup' => 4.22583333333333, 'pt' => 2.11291666666667, 'us_pt' => 2.11291666666667, 'uk_pt' => 1.75975569552166, 'qt' => 1.05645833333333, 'gal' => 0.264114583333333, 'l' => 1.0, 'lt' => 1.0)));
        /**
         * _parseComplex
         *
         * Parses a complex number into its real and imaginary parts, and an I or J suffix
         *
         * @param	string		$complexNumber	The complex number
         * @return	string[]	Indexed on "real", "imaginary" and "suffix"
         */
        public static function _parseComplex($complexNumber)
        {
        }
        //	function _parseComplex()
        /**
         * Cleans the leading characters in a complex number string
         *
         * @param	string		$complexNumber	The complex number to clean
         * @return	string		The "cleaned" complex number
         */
        private static function _cleanComplex($complexNumber)
        {
        }
        /**
         * Formats a number base string value with leading zeroes
         *
         * @param	string		$xVal		The "number" to pad
         * @param	integer		$places		The length that we want to pad this value
         * @return	string		The padded "number"
         */
        private static function _nbrConversionFormat($xVal, $places)
        {
        }
        //	function _nbrConversionFormat()
        /**
         *	BESSELI
         *
         *	Returns the modified Bessel function In(x), which is equivalent to the Bessel function evaluated
         *		for purely imaginary arguments
         *
         *	Excel Function:
         *		BESSELI(x,ord)
         *
         *	@access	public
         *	@category Engineering Functions
         *	@param	float		$x		The value at which to evaluate the function.
         *								If x is nonnumeric, BESSELI returns the #VALUE! error value.
         *	@param	integer		$ord	The order of the Bessel function.
         *								If ord is not an integer, it is truncated.
         *								If $ord is nonnumeric, BESSELI returns the #VALUE! error value.
         *								If $ord < 0, BESSELI returns the #NUM! error value.
         *	@return	float
         *
         */
        public static function BESSELI($x, $ord)
        {
        }
        //	function BESSELI()
        /**
         *	BESSELJ
         *
         *	Returns the Bessel function
         *
         *	Excel Function:
         *		BESSELJ(x,ord)
         *
         *	@access	public
         *	@category Engineering Functions
         *	@param	float		$x		The value at which to evaluate the function.
         *								If x is nonnumeric, BESSELJ returns the #VALUE! error value.
         *	@param	integer		$ord	The order of the Bessel function. If n is not an integer, it is truncated.
         *								If $ord is nonnumeric, BESSELJ returns the #VALUE! error value.
         *								If $ord < 0, BESSELJ returns the #NUM! error value.
         *	@return	float
         *
         */
        public static function BESSELJ($x, $ord)
        {
        }
        //	function BESSELJ()
        private static function _Besselk0($fNum)
        {
        }
        //	function _Besselk0()
        private static function _Besselk1($fNum)
        {
        }
        //	function _Besselk1()
        /**
         *	BESSELK
         *
         *	Returns the modified Bessel function Kn(x), which is equivalent to the Bessel functions evaluated
         *		for purely imaginary arguments.
         *
         *	Excel Function:
         *		BESSELK(x,ord)
         *
         *	@access	public
         *	@category Engineering Functions
         *	@param	float		$x		The value at which to evaluate the function.
         *								If x is nonnumeric, BESSELK returns the #VALUE! error value.
         *	@param	integer		$ord	The order of the Bessel function. If n is not an integer, it is truncated.
         *								If $ord is nonnumeric, BESSELK returns the #VALUE! error value.
         *								If $ord < 0, BESSELK returns the #NUM! error value.
         *	@return	float
         *
         */
        public static function BESSELK($x, $ord)
        {
        }
        //	function BESSELK()
        private static function _Bessely0($fNum)
        {
        }
        //	function _Bessely0()
        private static function _Bessely1($fNum)
        {
        }
        //	function _Bessely1()
        /**
         *	BESSELY
         *
         *	Returns the Bessel function, which is also called the Weber function or the Neumann function.
         *
         *	Excel Function:
         *		BESSELY(x,ord)
         *
         *	@access	public
         *	@category Engineering Functions
         *	@param	float		$x		The value at which to evaluate the function.
         *								If x is nonnumeric, BESSELK returns the #VALUE! error value.
         *	@param	integer		$ord	The order of the Bessel function. If n is not an integer, it is truncated.
         *								If $ord is nonnumeric, BESSELK returns the #VALUE! error value.
         *								If $ord < 0, BESSELK returns the #NUM! error value.
         *
         *	@return	float
         */
        public static function BESSELY($x, $ord)
        {
        }
        //	function BESSELY()
        /**
         * BINTODEC
         *
         * Return a binary value as decimal.
         *
         * Excel Function:
         *		BIN2DEC(x)
         *
         * @access	public
         * @category Engineering Functions
         * @param	string		$x		The binary number (as a string) that you want to convert. The number
         *								cannot contain more than 10 characters (10 bits). The most significant
         *								bit of number is the sign bit. The remaining 9 bits are magnitude bits.
         *								Negative numbers are represented using two's-complement notation.
         *								If number is not a valid binary number, or if number contains more than
         *								10 characters (10 bits), BIN2DEC returns the #NUM! error value.
         * @return	string
         */
        public static function BINTODEC($x)
        {
        }
        //	function BINTODEC()
        /**
         * BINTOHEX
         *
         * Return a binary value as hex.
         *
         * Excel Function:
         *		BIN2HEX(x[,places])
         *
         * @access	public
         * @category Engineering Functions
         * @param	string		$x		The binary number (as a string) that you want to convert. The number
         *								cannot contain more than 10 characters (10 bits). The most significant
         *								bit of number is the sign bit. The remaining 9 bits are magnitude bits.
         *								Negative numbers are represented using two's-complement notation.
         *								If number is not a valid binary number, or if number contains more than
         *								10 characters (10 bits), BIN2HEX returns the #NUM! error value.
         * @param	integer		$places	The number of characters to use. If places is omitted, BIN2HEX uses the
         *								minimum number of characters necessary. Places is useful for padding the
         *								return value with leading 0s (zeros).
         *								If places is not an integer, it is truncated.
         *								If places is nonnumeric, BIN2HEX returns the #VALUE! error value.
         *								If places is negative, BIN2HEX returns the #NUM! error value.
         * @return	string
         */
        public static function BINTOHEX($x, $places = \NULL)
        {
        }
        //	function BINTOHEX()
        /**
         * BINTOOCT
         *
         * Return a binary value as octal.
         *
         * Excel Function:
         *		BIN2OCT(x[,places])
         *
         * @access	public
         * @category Engineering Functions
         * @param	string		$x		The binary number (as a string) that you want to convert. The number
         *								cannot contain more than 10 characters (10 bits). The most significant
         *								bit of number is the sign bit. The remaining 9 bits are magnitude bits.
         *								Negative numbers are represented using two's-complement notation.
         *								If number is not a valid binary number, or if number contains more than
         *								10 characters (10 bits), BIN2OCT returns the #NUM! error value.
         * @param	integer		$places	The number of characters to use. If places is omitted, BIN2OCT uses the
         *								minimum number of characters necessary. Places is useful for padding the
         *								return value with leading 0s (zeros).
         *								If places is not an integer, it is truncated.
         *								If places is nonnumeric, BIN2OCT returns the #VALUE! error value.
         *								If places is negative, BIN2OCT returns the #NUM! error value.
         * @return	string
         */
        public static function BINTOOCT($x, $places = \NULL)
        {
        }
        //	function BINTOOCT()
        /**
         * DECTOBIN
         *
         * Return a decimal value as binary.
         *
         * Excel Function:
         *		DEC2BIN(x[,places])
         *
         * @access	public
         * @category Engineering Functions
         * @param	string		$x		The decimal integer you want to convert. If number is negative,
         *								valid place values are ignored and DEC2BIN returns a 10-character
         *								(10-bit) binary number in which the most significant bit is the sign
         *								bit. The remaining 9 bits are magnitude bits. Negative numbers are
         *								represented using two's-complement notation.
         *								If number < -512 or if number > 511, DEC2BIN returns the #NUM! error
         *								value.
         *								If number is nonnumeric, DEC2BIN returns the #VALUE! error value.
         *								If DEC2BIN requires more than places characters, it returns the #NUM!
         *								error value.
         * @param	integer		$places	The number of characters to use. If places is omitted, DEC2BIN uses
         *								the minimum number of characters necessary. Places is useful for
         *								padding the return value with leading 0s (zeros).
         *								If places is not an integer, it is truncated.
         *								If places is nonnumeric, DEC2BIN returns the #VALUE! error value.
         *								If places is zero or negative, DEC2BIN returns the #NUM! error value.
         * @return	string
         */
        public static function DECTOBIN($x, $places = \NULL)
        {
        }
        //	function DECTOBIN()
        /**
         * DECTOHEX
         *
         * Return a decimal value as hex.
         *
         * Excel Function:
         *		DEC2HEX(x[,places])
         *
         * @access	public
         * @category Engineering Functions
         * @param	string		$x		The decimal integer you want to convert. If number is negative,
         *								places is ignored and DEC2HEX returns a 10-character (40-bit)
         *								hexadecimal number in which the most significant bit is the sign
         *								bit. The remaining 39 bits are magnitude bits. Negative numbers
         *								are represented using two's-complement notation.
         *								If number < -549,755,813,888 or if number > 549,755,813,887,
         *								DEC2HEX returns the #NUM! error value.
         *								If number is nonnumeric, DEC2HEX returns the #VALUE! error value.
         *								If DEC2HEX requires more than places characters, it returns the
         *								#NUM! error value.
         * @param	integer		$places	The number of characters to use. If places is omitted, DEC2HEX uses
         *								the minimum number of characters necessary. Places is useful for
         *								padding the return value with leading 0s (zeros).
         *								If places is not an integer, it is truncated.
         *								If places is nonnumeric, DEC2HEX returns the #VALUE! error value.
         *								If places is zero or negative, DEC2HEX returns the #NUM! error value.
         * @return	string
         */
        public static function DECTOHEX($x, $places = \null)
        {
        }
        //	function DECTOHEX()
        /**
         * DECTOOCT
         *
         * Return an decimal value as octal.
         *
         * Excel Function:
         *		DEC2OCT(x[,places])
         *
         * @access	public
         * @category Engineering Functions
         * @param	string		$x		The decimal integer you want to convert. If number is negative,
         *								places is ignored and DEC2OCT returns a 10-character (30-bit)
         *								octal number in which the most significant bit is the sign bit.
         *								The remaining 29 bits are magnitude bits. Negative numbers are
         *								represented using two's-complement notation.
         *								If number < -536,870,912 or if number > 536,870,911, DEC2OCT
         *								returns the #NUM! error value.
         *								If number is nonnumeric, DEC2OCT returns the #VALUE! error value.
         *								If DEC2OCT requires more than places characters, it returns the
         *								#NUM! error value.
         * @param	integer		$places	The number of characters to use. If places is omitted, DEC2OCT uses
         *								the minimum number of characters necessary. Places is useful for
         *								padding the return value with leading 0s (zeros).
         *								If places is not an integer, it is truncated.
         *								If places is nonnumeric, DEC2OCT returns the #VALUE! error value.
         *								If places is zero or negative, DEC2OCT returns the #NUM! error value.
         * @return	string
         */
        public static function DECTOOCT($x, $places = \null)
        {
        }
        //	function DECTOOCT()
        /**
         * HEXTOBIN
         *
         * Return a hex value as binary.
         *
         * Excel Function:
         *		HEX2BIN(x[,places])
         *
         * @access	public
         * @category Engineering Functions
         * @param	string		$x			the hexadecimal number you want to convert. Number cannot
         *									contain more than 10 characters. The most significant bit of
         *									number is the sign bit (40th bit from the right). The remaining
         *									9 bits are magnitude bits. Negative numbers are represented
         *									using two's-complement notation.
         *									If number is negative, HEX2BIN ignores places and returns a
         *									10-character binary number.
         *									If number is negative, it cannot be less than FFFFFFFE00, and
         *									if number is positive, it cannot be greater than 1FF.
         *									If number is not a valid hexadecimal number, HEX2BIN returns
         *									the #NUM! error value.
         *									If HEX2BIN requires more than places characters, it returns
         *									the #NUM! error value.
         * @param	integer		$places		The number of characters to use. If places is omitted,
         *									HEX2BIN uses the minimum number of characters necessary. Places
         *									is useful for padding the return value with leading 0s (zeros).
         *									If places is not an integer, it is truncated.
         *									If places is nonnumeric, HEX2BIN returns the #VALUE! error value.
         *									If places is negative, HEX2BIN returns the #NUM! error value.
         * @return	string
         */
        public static function HEXTOBIN($x, $places = \null)
        {
        }
        //	function HEXTOBIN()
        /**
         * HEXTODEC
         *
         * Return a hex value as decimal.
         *
         * Excel Function:
         *		HEX2DEC(x)
         *
         * @access	public
         * @category Engineering Functions
         * @param	string		$x		The hexadecimal number you want to convert. This number cannot
         *								contain more than 10 characters (40 bits). The most significant
         *								bit of number is the sign bit. The remaining 39 bits are magnitude
         *								bits. Negative numbers are represented using two's-complement
         *								notation.
         *								If number is not a valid hexadecimal number, HEX2DEC returns the
         *								#NUM! error value.
         * @return	string
         */
        public static function HEXTODEC($x)
        {
        }
        //	function HEXTODEC()
        /**
         * HEXTOOCT
         *
         * Return a hex value as octal.
         *
         * Excel Function:
         *		HEX2OCT(x[,places])
         *
         * @access	public
         * @category Engineering Functions
         * @param	string		$x			The hexadecimal number you want to convert. Number cannot
         *									contain more than 10 characters. The most significant bit of
         *									number is the sign bit. The remaining 39 bits are magnitude
         *									bits. Negative numbers are represented using two's-complement
         *									notation.
         *									If number is negative, HEX2OCT ignores places and returns a
         *									10-character octal number.
         *									If number is negative, it cannot be less than FFE0000000, and
         *									if number is positive, it cannot be greater than 1FFFFFFF.
         *									If number is not a valid hexadecimal number, HEX2OCT returns
         *									the #NUM! error value.
         *									If HEX2OCT requires more than places characters, it returns
         *									the #NUM! error value.
         * @param	integer		$places		The number of characters to use. If places is omitted, HEX2OCT
         *									uses the minimum number of characters necessary. Places is
         *									useful for padding the return value with leading 0s (zeros).
         *									If places is not an integer, it is truncated.
         *									If places is nonnumeric, HEX2OCT returns the #VALUE! error
         *									value.
         *									If places is negative, HEX2OCT returns the #NUM! error value.
         * @return	string
         */
        public static function HEXTOOCT($x, $places = \null)
        {
        }
        //	function HEXTOOCT()
        /**
         * OCTTOBIN
         *
         * Return an octal value as binary.
         *
         * Excel Function:
         *		OCT2BIN(x[,places])
         *
         * @access	public
         * @category Engineering Functions
         * @param	string		$x			The octal number you want to convert. Number may not
         *									contain more than 10 characters. The most significant
         *									bit of number is the sign bit. The remaining 29 bits
         *									are magnitude bits. Negative numbers are represented
         *									using two's-complement notation.
         *									If number is negative, OCT2BIN ignores places and returns
         *									a 10-character binary number.
         *									If number is negative, it cannot be less than 7777777000,
         *									and if number is positive, it cannot be greater than 777.
         *									If number is not a valid octal number, OCT2BIN returns
         *									the #NUM! error value.
         *									If OCT2BIN requires more than places characters, it
         *									returns the #NUM! error value.
         * @param	integer		$places		The number of characters to use. If places is omitted,
         *									OCT2BIN uses the minimum number of characters necessary.
         *									Places is useful for padding the return value with
         *									leading 0s (zeros).
         *									If places is not an integer, it is truncated.
         *									If places is nonnumeric, OCT2BIN returns the #VALUE!
         *									error value.
         *									If places is negative, OCT2BIN returns the #NUM! error
         *									value.
         * @return	string
         */
        public static function OCTTOBIN($x, $places = \null)
        {
        }
        //	function OCTTOBIN()
        /**
         * OCTTODEC
         *
         * Return an octal value as decimal.
         *
         * Excel Function:
         *		OCT2DEC(x)
         *
         * @access	public
         * @category Engineering Functions
         * @param	string		$x		The octal number you want to convert. Number may not contain
         *								more than 10 octal characters (30 bits). The most significant
         *								bit of number is the sign bit. The remaining 29 bits are
         *								magnitude bits. Negative numbers are represented using
         *								two's-complement notation.
         *								If number is not a valid octal number, OCT2DEC returns the
         *								#NUM! error value.
         * @return	string
         */
        public static function OCTTODEC($x)
        {
        }
        //	function OCTTODEC()
        /**
         * OCTTOHEX
         *
         * Return an octal value as hex.
         *
         * Excel Function:
         *		OCT2HEX(x[,places])
         *
         * @access	public
         * @category Engineering Functions
         * @param	string		$x			The octal number you want to convert. Number may not contain
         *									more than 10 octal characters (30 bits). The most significant
         *									bit of number is the sign bit. The remaining 29 bits are
         *									magnitude bits. Negative numbers are represented using
         *									two's-complement notation.
         *									If number is negative, OCT2HEX ignores places and returns a
         *									10-character hexadecimal number.
         *									If number is not a valid octal number, OCT2HEX returns the
         *									#NUM! error value.
         *									If OCT2HEX requires more than places characters, it returns
         *									the #NUM! error value.
         * @param	integer		$places		The number of characters to use. If places is omitted, OCT2HEX
         *									uses the minimum number of characters necessary. Places is useful
         *									for padding the return value with leading 0s (zeros).
         *									If places is not an integer, it is truncated.
         *									If places is nonnumeric, OCT2HEX returns the #VALUE! error value.
         *									If places is negative, OCT2HEX returns the #NUM! error value.
         * @return	string
         */
        public static function OCTTOHEX($x, $places = \null)
        {
        }
        //	function OCTTOHEX()
        /**
         * COMPLEX
         *
         * Converts real and imaginary coefficients into a complex number of the form x + yi or x + yj.
         *
         * Excel Function:
         *		COMPLEX(realNumber,imaginary[,places])
         *
         * @access	public
         * @category Engineering Functions
         * @param	float		$realNumber		The real coefficient of the complex number.
         * @param	float		$imaginary		The imaginary coefficient of the complex number.
         * @param	string		$suffix			The suffix for the imaginary component of the complex number.
         *										If omitted, the suffix is assumed to be "i".
         * @return	string
         */
        public static function COMPLEX($realNumber = 0.0, $imaginary = 0.0, $suffix = 'i')
        {
        }
        //	function COMPLEX()
        /**
         * IMAGINARY
         *
         * Returns the imaginary coefficient of a complex number in x + yi or x + yj text format.
         *
         * Excel Function:
         *		IMAGINARY(complexNumber)
         *
         * @access	public
         * @category Engineering Functions
         * @param	string		$complexNumber	The complex number for which you want the imaginary
         * 										coefficient.
         * @return	float
         */
        public static function IMAGINARY($complexNumber)
        {
        }
        //	function IMAGINARY()
        /**
         * IMREAL
         *
         * Returns the real coefficient of a complex number in x + yi or x + yj text format.
         *
         * Excel Function:
         *		IMREAL(complexNumber)
         *
         * @access	public
         * @category Engineering Functions
         * @param	string		$complexNumber	The complex number for which you want the real coefficient.
         * @return	float
         */
        public static function IMREAL($complexNumber)
        {
        }
        //	function IMREAL()
        /**
         * IMABS
         *
         * Returns the absolute value (modulus) of a complex number in x + yi or x + yj text format.
         *
         * Excel Function:
         *		IMABS(complexNumber)
         *
         * @param	string		$complexNumber	The complex number for which you want the absolute value.
         * @return	float
         */
        public static function IMABS($complexNumber)
        {
        }
        //	function IMABS()
        /**
         * IMARGUMENT
         *
         * Returns the argument theta of a complex number, i.e. the angle in radians from the real
         * axis to the representation of the number in polar coordinates.
         *
         * Excel Function:
         *		IMARGUMENT(complexNumber)
         *
         * @param	string		$complexNumber	The complex number for which you want the argument theta.
         * @return	float
         */
        public static function IMARGUMENT($complexNumber)
        {
        }
        //	function IMARGUMENT()
        /**
         * IMCONJUGATE
         *
         * Returns the complex conjugate of a complex number in x + yi or x + yj text format.
         *
         * Excel Function:
         *		IMCONJUGATE(complexNumber)
         *
         * @param	string		$complexNumber	The complex number for which you want the conjugate.
         * @return	string
         */
        public static function IMCONJUGATE($complexNumber)
        {
        }
        //	function IMCONJUGATE()
        /**
         * IMCOS
         *
         * Returns the cosine of a complex number in x + yi or x + yj text format.
         *
         * Excel Function:
         *		IMCOS(complexNumber)
         *
         * @param	string		$complexNumber	The complex number for which you want the cosine.
         * @return	string|float
         */
        public static function IMCOS($complexNumber)
        {
        }
        //	function IMCOS()
        /**
         * IMSIN
         *
         * Returns the sine of a complex number in x + yi or x + yj text format.
         *
         * Excel Function:
         *		IMSIN(complexNumber)
         *
         * @param	string		$complexNumber	The complex number for which you want the sine.
         * @return	string|float
         */
        public static function IMSIN($complexNumber)
        {
        }
        //	function IMSIN()
        /**
         * IMSQRT
         *
         * Returns the square root of a complex number in x + yi or x + yj text format.
         *
         * Excel Function:
         *		IMSQRT(complexNumber)
         *
         * @param	string		$complexNumber	The complex number for which you want the square root.
         * @return	string
         */
        public static function IMSQRT($complexNumber)
        {
        }
        //	function IMSQRT()
        /**
         * IMLN
         *
         * Returns the natural logarithm of a complex number in x + yi or x + yj text format.
         *
         * Excel Function:
         *		IMLN(complexNumber)
         *
         * @param	string		$complexNumber	The complex number for which you want the natural logarithm.
         * @return	string
         */
        public static function IMLN($complexNumber)
        {
        }
        //	function IMLN()
        /**
         * IMLOG10
         *
         * Returns the common logarithm (base 10) of a complex number in x + yi or x + yj text format.
         *
         * Excel Function:
         *		IMLOG10(complexNumber)
         *
         * @param	string		$complexNumber	The complex number for which you want the common logarithm.
         * @return	string
         */
        public static function IMLOG10($complexNumber)
        {
        }
        //	function IMLOG10()
        /**
         * IMLOG2
         *
         * Returns the base-2 logarithm of a complex number in x + yi or x + yj text format.
         *
         * Excel Function:
         *		IMLOG2(complexNumber)
         *
         * @param	string		$complexNumber	The complex number for which you want the base-2 logarithm.
         * @return	string
         */
        public static function IMLOG2($complexNumber)
        {
        }
        //	function IMLOG2()
        /**
         * IMEXP
         *
         * Returns the exponential of a complex number in x + yi or x + yj text format.
         *
         * Excel Function:
         *		IMEXP(complexNumber)
         *
         * @param	string		$complexNumber	The complex number for which you want the exponential.
         * @return	string
         */
        public static function IMEXP($complexNumber)
        {
        }
        //	function IMEXP()
        /**
         * IMPOWER
         *
         * Returns a complex number in x + yi or x + yj text format raised to a power.
         *
         * Excel Function:
         *		IMPOWER(complexNumber,realNumber)
         *
         * @param	string		$complexNumber	The complex number you want to raise to a power.
         * @param	float		$realNumber		The power to which you want to raise the complex number.
         * @return	string
         */
        public static function IMPOWER($complexNumber, $realNumber)
        {
        }
        //	function IMPOWER()
        /**
         * IMDIV
         *
         * Returns the quotient of two complex numbers in x + yi or x + yj text format.
         *
         * Excel Function:
         *		IMDIV(complexDividend,complexDivisor)
         *
         * @param	string		$complexDividend	The complex numerator or dividend.
         * @param	string		$complexDivisor		The complex denominator or divisor.
         * @return	string
         */
        public static function IMDIV($complexDividend, $complexDivisor)
        {
        }
        //	function IMDIV()
        /**
         * IMSUB
         *
         * Returns the difference of two complex numbers in x + yi or x + yj text format.
         *
         * Excel Function:
         *		IMSUB(complexNumber1,complexNumber2)
         *
         * @param	string		$complexNumber1		The complex number from which to subtract complexNumber2.
         * @param	string		$complexNumber2		The complex number to subtract from complexNumber1.
         * @return	string
         */
        public static function IMSUB($complexNumber1, $complexNumber2)
        {
        }
        //	function IMSUB()
        /**
         * IMSUM
         *
         * Returns the sum of two or more complex numbers in x + yi or x + yj text format.
         *
         * Excel Function:
         *		IMSUM(complexNumber[,complexNumber[,...]])
         *
         * @param	string		$complexNumber,...	Series of complex numbers to add
         * @return	string
         */
        public static function IMSUM()
        {
        }
        //	function IMSUM()
        /**
         * IMPRODUCT
         *
         * Returns the product of two or more complex numbers in x + yi or x + yj text format.
         *
         * Excel Function:
         *		IMPRODUCT(complexNumber[,complexNumber[,...]])
         *
         * @param	string		$complexNumber,...	Series of complex numbers to multiply
         * @return	string
         */
        public static function IMPRODUCT()
        {
        }
        //	function IMPRODUCT()
        /**
         *	DELTA
         *
         *	Tests whether two values are equal. Returns 1 if number1 = number2; returns 0 otherwise.
         *	Use this function to filter a set of values. For example, by summing several DELTA
         *	functions you calculate the count of equal pairs. This function is also known as the
         *	Kronecker Delta function.
         *
         *	Excel Function:
         *		DELTA(a[,b])
         *
         *	@param	float		$a	The first number.
         *	@param	float		$b	The second number. If omitted, b is assumed to be zero.
         *	@return	int
         */
        public static function DELTA($a, $b = 0)
        {
        }
        //	function DELTA()
        /**
         *	GESTEP
         *
         *	Excel Function:
         *		GESTEP(number[,step])
         *
         *	Returns 1 if number >= step; returns 0 (zero) otherwise
         *	Use this function to filter a set of values. For example, by summing several GESTEP
         *	functions you calculate the count of values that exceed a threshold.
         *
         *	@param	float		$number		The value to test against step.
         *	@param	float		$step		The threshold value.
         *									If you omit a value for step, GESTEP uses zero.
         *	@return	int
         */
        public static function GESTEP($number, $step = 0)
        {
        }
        //	function GESTEP()
        //
        //	Private method to calculate the erf value
        //
        private static $_two_sqrtpi = 1.1283791670955126;
        public static function _erfVal($x)
        {
        }
        //	function _erfVal()
        /**
         *	ERF
         *
         *	Returns the error function integrated between the lower and upper bound arguments.
         *
         *	Note: In Excel 2007 or earlier, if you input a negative value for the upper or lower bound arguments,
         *			the function would return a #NUM! error. However, in Excel 2010, the function algorithm was
         *			improved, so that it can now calculate the function for both positive and negative ranges.
         *			PHPExcel follows Excel 2010 behaviour, and accepts nagative arguments.
         *
         *	Excel Function:
         *		ERF(lower[,upper])
         *
         *	@param	float		$lower	lower bound for integrating ERF
         *	@param	float		$upper	upper bound for integrating ERF.
         *								If omitted, ERF integrates between zero and lower_limit
         *	@return	float
         */
        public static function ERF($lower, $upper = \NULL)
        {
        }
        //	function ERF()
        //
        //	Private method to calculate the erfc value
        //
        private static $_one_sqrtpi = 0.5641895835477563;
        private static function _erfcVal($x)
        {
        }
        //	function _erfcVal()
        /**
         *	ERFC
         *
         *	Returns the complementary ERF function integrated between x and infinity
         *
         *	Note: In Excel 2007 or earlier, if you input a negative value for the lower bound argument,
         *		the function would return a #NUM! error. However, in Excel 2010, the function algorithm was
         *		improved, so that it can now calculate the function for both positive and negative x values.
         *			PHPExcel follows Excel 2010 behaviour, and accepts nagative arguments.
         *
         *	Excel Function:
         *		ERFC(x)
         *
         *	@param	float	$x	The lower bound for integrating ERFC
         *	@return	float
         */
        public static function ERFC($x)
        {
        }
        //	function ERFC()
        /**
         *	getConversionGroups
         *	Returns a list of the different conversion groups for UOM conversions
         *
         *	@return	array
         */
        public static function getConversionGroups()
        {
        }
        //	function getConversionGroups()
        /**
         *	getConversionGroupUnits
         *	Returns an array of units of measure, for a specified conversion group, or for all groups
         *
         *	@param	string	$group	The group whose units of measure you want to retrieve
         *	@return	array
         */
        public static function getConversionGroupUnits($group = \NULL)
        {
        }
        //	function getConversionGroupUnits()
        /**
         *	getConversionGroupUnitDetails
         *
         *	@param	string	$group	The group whose units of measure you want to retrieve
         *	@return	array
         */
        public static function getConversionGroupUnitDetails($group = \NULL)
        {
        }
        //	function getConversionGroupUnitDetails()
        /**
         *	getConversionMultipliers
         *	Returns an array of the Multiplier prefixes that can be used with Units of Measure in CONVERTUOM()
         *
         *	@return	array of mixed
         */
        public static function getConversionMultipliers()
        {
        }
        //	function getConversionGroups()
        /**
         *	CONVERTUOM
         *
         *	Converts a number from one measurement system to another.
         *	For example, CONVERT can translate a table of distances in miles to a table of distances
         *	in kilometers.
         *
         *	Excel Function:
         *		CONVERT(value,fromUOM,toUOM)
         *
         *	@param	float		$value		The value in fromUOM to convert.
         *	@param	string		$fromUOM	The units for value.
         *	@param	string		$toUOM		The units for the result.
         *
         *	@return	float
         */
        public static function CONVERTUOM($value, $fromUOM, $toUOM)
        {
        }
        //	function CONVERTUOM()
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Calculation
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license	http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version	1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Calculation_Token_Stack
     *
     * @category	PHPExcel_Calculation_Token_Stack
     * @package		PHPExcel_Calculation
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Calculation_Token_Stack
    {
        /**
         *  The parser stack for formulae
         *
         *  @var mixed[]
         */
        private $_stack = array();
        /**
         *  Count of entries in the parser stack
         *
         *  @var integer
         */
        private $_count = 0;
        /**
         * Return the number of entries on the stack
         *
         * @return  integer
         */
        public function count()
        {
        }
        //	function count()
        /**
         * Push a new entry onto the stack
         *
         * @param  mixed  $type
         * @param  mixed  $value
         * @param  mixed  $reference
         */
        public function push($type, $value, $reference = \NULL)
        {
        }
        //	function push()
        /**
         * Pop the last entry from the stack
         *
         * @return  mixed
         */
        public function pop()
        {
        }
        //	function pop()
        /**
         * Return an entry from the stack without removing it
         *
         * @param   integer  $n  number indicating how far back in the stack we want to look
         * @return  mixed
         */
        public function last($n = 1)
        {
        }
        //	function last()
        /**
         * Clear the stack
         */
        function clear()
        {
        }
    }
    /**
     * PHPExcel_Calculation_Logical
     *
     * @category	PHPExcel
     * @package		PHPExcel_Calculation
     * @copyright	Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Calculation_Logical
    {
        /**
         * TRUE
         *
         * Returns the boolean TRUE.
         *
         * Excel Function:
         *		=TRUE()
         *
         * @access	public
         * @category Logical Functions
         * @return	boolean		True
         */
        public static function TRUE()
        {
        }
        //	function TRUE()
        /**
         * FALSE
         *
         * Returns the boolean FALSE.
         *
         * Excel Function:
         *		=FALSE()
         *
         * @access	public
         * @category Logical Functions
         * @return	boolean		False
         */
        public static function FALSE()
        {
        }
        //	function FALSE()
        /**
         * LOGICAL_AND
         *
         * Returns boolean TRUE if all its arguments are TRUE; returns FALSE if one or more argument is FALSE.
         *
         * Excel Function:
         *		=AND(logical1[,logical2[, ...]])
         *
         *		The arguments must evaluate to logical values such as TRUE or FALSE, or the arguments must be arrays
         *			or references that contain logical values.
         *
         *		Boolean arguments are treated as True or False as appropriate
         *		Integer or floating point arguments are treated as True, except for 0 or 0.0 which are False
         *		If any argument value is a string, or a Null, the function returns a #VALUE! error, unless the string holds
         *			the value TRUE or FALSE, in which case it is evaluated as the corresponding boolean value
         *
         * @access	public
         * @category Logical Functions
         * @param	mixed		$arg,...		Data values
         * @return	boolean		The logical AND of the arguments.
         */
        public static function LOGICAL_AND()
        {
        }
        //	function LOGICAL_AND()
        /**
         * LOGICAL_OR
         *
         * Returns boolean TRUE if any argument is TRUE; returns FALSE if all arguments are FALSE.
         *
         * Excel Function:
         *		=OR(logical1[,logical2[, ...]])
         *
         *		The arguments must evaluate to logical values such as TRUE or FALSE, or the arguments must be arrays
         *			or references that contain logical values.
         *
         *		Boolean arguments are treated as True or False as appropriate
         *		Integer or floating point arguments are treated as True, except for 0 or 0.0 which are False
         *		If any argument value is a string, or a Null, the function returns a #VALUE! error, unless the string holds
         *			the value TRUE or FALSE, in which case it is evaluated as the corresponding boolean value
         *
         * @access	public
         * @category Logical Functions
         * @param	mixed		$arg,...		Data values
         * @return	boolean		The logical OR of the arguments.
         */
        public static function LOGICAL_OR()
        {
        }
        //	function LOGICAL_OR()
        /**
         * NOT
         *
         * Returns the boolean inverse of the argument.
         *
         * Excel Function:
         *		=NOT(logical)
         *
         *		The argument must evaluate to a logical value such as TRUE or FALSE
         *
         *		Boolean arguments are treated as True or False as appropriate
         *		Integer or floating point arguments are treated as True, except for 0 or 0.0 which are False
         *		If any argument value is a string, or a Null, the function returns a #VALUE! error, unless the string holds
         *			the value TRUE or FALSE, in which case it is evaluated as the corresponding boolean value
         *
         * @access	public
         * @category Logical Functions
         * @param	mixed		$logical	A value or expression that can be evaluated to TRUE or FALSE
         * @return	boolean		The boolean inverse of the argument.
         */
        public static function NOT($logical = \FALSE)
        {
        }
        //	function NOT()
        /**
         * STATEMENT_IF
         *
         * Returns one value if a condition you specify evaluates to TRUE and another value if it evaluates to FALSE.
         *
         * Excel Function:
         *		=IF(condition[,returnIfTrue[,returnIfFalse]])
         *
         *		Condition is any value or expression that can be evaluated to TRUE or FALSE.
         *			For example, A10=100 is a logical expression; if the value in cell A10 is equal to 100,
         *			the expression evaluates to TRUE. Otherwise, the expression evaluates to FALSE.
         *			This argument can use any comparison calculation operator.
         *		ReturnIfTrue is the value that is returned if condition evaluates to TRUE.
         *			For example, if this argument is the text string "Within budget" and the condition argument evaluates to TRUE,
         *			then the IF function returns the text "Within budget"
         *			If condition is TRUE and ReturnIfTrue is blank, this argument returns 0 (zero). To display the word TRUE, use
         *			the logical value TRUE for this argument.
         *			ReturnIfTrue can be another formula.
         *		ReturnIfFalse is the value that is returned if condition evaluates to FALSE.
         *			For example, if this argument is the text string "Over budget" and the condition argument evaluates to FALSE,
         *			then the IF function returns the text "Over budget".
         *			If condition is FALSE and ReturnIfFalse is omitted, then the logical value FALSE is returned.
         *			If condition is FALSE and ReturnIfFalse is blank, then the value 0 (zero) is returned.
         *			ReturnIfFalse can be another formula.
         *
         * @access	public
         * @category Logical Functions
         * @param	mixed	$condition		Condition to evaluate
         * @param	mixed	$returnIfTrue	Value to return when condition is true
         * @param	mixed	$returnIfFalse	Optional value to return when condition is false
         * @return	mixed	The value of returnIfTrue or returnIfFalse determined by condition
         */
        public static function STATEMENT_IF($condition = \TRUE, $returnIfTrue = 0, $returnIfFalse = \FALSE)
        {
        }
        //	function STATEMENT_IF()
        /**
         * IFERROR
         *
         * Excel Function:
         *		=IFERROR(testValue,errorpart)
         *
         * @access	public
         * @category Logical Functions
         * @param	mixed	$testValue	Value to check, is also the value returned when no error
         * @param	mixed	$errorpart	Value to return when testValue is an error condition
         * @return	mixed	The value of errorpart or testValue determined by error condition
         */
        public static function IFERROR($testValue = '', $errorpart = '')
        {
        }
        //	function IFERROR()
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_RichText
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt    LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_RichText
     *
     * @category   PHPExcel
     * @package    PHPExcel_RichText
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_RichText implements \PHPExcel_IComparable
    {
        /**
         * Rich text elements
         *
         * @var PHPExcel_RichText_ITextElement[]
         */
        private $_richTextElements;
        /**
         * Create a new PHPExcel_RichText instance
         *
         * @param PHPExcel_Cell $pCell
         * @throws PHPExcel_Exception
         */
        public function __construct(\PHPExcel_Cell $pCell = \null)
        {
        }
        /**
         * Add text
         *
         * @param PHPExcel_RichText_ITextElement $pText Rich text element
         * @throws PHPExcel_Exception
         * @return PHPExcel_RichText
         */
        public function addText(\PHPExcel_RichText_ITextElement $pText = \null)
        {
        }
        /**
         * Create text
         *
         * @param string $pText Text
         * @return PHPExcel_RichText_TextElement
         * @throws PHPExcel_Exception
         */
        public function createText($pText = '')
        {
        }
        /**
         * Create text run
         *
         * @param string $pText Text
         * @return PHPExcel_RichText_Run
         * @throws PHPExcel_Exception
         */
        public function createTextRun($pText = '')
        {
        }
        /**
         * Get plain text
         *
         * @return string
         */
        public function getPlainText()
        {
        }
        /**
         * Convert to string
         *
         * @return string
         */
        public function __toString()
        {
        }
        /**
         * Get Rich Text elements
         *
         * @return PHPExcel_RichText_ITextElement[]
         */
        public function getRichTextElements()
        {
        }
        /**
         * Set Rich Text elements
         *
         * @param PHPExcel_RichText_ITextElement[] $pElements Array of elements
         * @throws PHPExcel_Exception
         * @return PHPExcel_RichText
         */
        public function setRichTextElements($pElements = \null)
        {
        }
        /**
         * Get hash code
         *
         * @return string    Hash code
         */
        public function getHashCode()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt    LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_WorksheetIterator
     *
     * Used to iterate worksheets in PHPExcel
     *
     * @category   PHPExcel
     * @package    PHPExcel
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_WorksheetIterator implements \Iterator
    {
        /**
         * Spreadsheet to iterate
         *
         * @var PHPExcel
         */
        private $_subject;
        /**
         * Current iterator position
         *
         * @var int
         */
        private $_position = 0;
        /**
         * Create a new worksheet iterator
         *
         * @param PHPExcel         $subject
         */
        public function __construct(\PHPExcel $subject = \null)
        {
        }
        /**
         * Destructor
         */
        public function __destruct()
        {
        }
        /**
         * Rewind iterator
         */
        public function rewind()
        {
        }
        /**
         * Current PHPExcel_Worksheet
         *
         * @return PHPExcel_Worksheet
         */
        public function current()
        {
        }
        /**
         * Current key
         *
         * @return int
         */
        public function key()
        {
        }
        /**
         * Next value
         */
        public function next()
        {
        }
        /**
         * More PHPExcel_Worksheet instances available?
         *
         * @return boolean
         */
        public function valid()
        {
        }
    }
    class PHPExcel_Settings
    {
        /**    constants */
        /**    Available Zip library classes */
        const PCLZIP = 'PHPExcel_Shared_ZipArchive';
        const ZIPARCHIVE = 'ZipArchive';
        /**    Optional Chart Rendering libraries */
        const CHART_RENDERER_JPGRAPH = 'jpgraph';
        /**    Optional PDF Rendering libraries */
        const PDF_RENDERER_TCPDF = 'tcPDF';
        const PDF_RENDERER_DOMPDF = 'DomPDF';
        const PDF_RENDERER_MPDF = 'mPDF';
        private static $_chartRenderers = array(self::CHART_RENDERER_JPGRAPH);
        private static $_pdfRenderers = array(self::PDF_RENDERER_TCPDF, self::PDF_RENDERER_DOMPDF, self::PDF_RENDERER_MPDF);
        /**
         * Name of the class used for Zip file management
         *	e.g.
         *		ZipArchive
         *
         * @var string
         */
        private static $_zipClass = self::ZIPARCHIVE;
        /**
         * Name of the external Library used for rendering charts
         *	e.g.
         *		jpgraph
         *
         * @var string
         */
        private static $_chartRendererName = \NULL;
        /**
         * Directory Path to the external Library used for rendering charts
         *
         * @var string
         */
        private static $_chartRendererPath = \NULL;
        /**
         * Name of the external Library used for rendering PDF files
         *	e.g.
         * 		mPDF
         *
         * @var string
         */
        private static $_pdfRendererName = \NULL;
        /**
         * Directory Path to the external Library used for rendering PDF files
         *
         * @var string
         */
        private static $_pdfRendererPath = \NULL;
        /**
         * Default options for libxml loader
         *
         * @var int
         */
        private static $_libXmlLoaderOptions = \null;
        /**
         * Set the Zip handler Class that PHPExcel should use for Zip file management (PCLZip or ZipArchive)
         *
         * @param string $zipClass	The Zip handler class that PHPExcel should use for Zip file management
         * 	 e.g. PHPExcel_Settings::PCLZip or PHPExcel_Settings::ZipArchive
         * @return	boolean	Success or failure
         */
        public static function setZipClass($zipClass)
        {
        }
        // function setZipClass()
        /**
         * Return the name of the Zip handler Class that PHPExcel is configured to use (PCLZip or ZipArchive)
         *	or Zip file management
         *
         * @return string Name of the Zip handler Class that PHPExcel is configured to use
         *	for Zip file management
         *	e.g. PHPExcel_Settings::PCLZip or PHPExcel_Settings::ZipArchive
         */
        public static function getZipClass()
        {
        }
        // function getZipClass()
        /**
         * Return the name of the method that is currently configured for cell cacheing
         *
         * @return string Name of the cacheing method
         */
        public static function getCacheStorageMethod()
        {
        }
        // function getCacheStorageMethod()
        /**
         * Return the name of the class that is currently being used for cell cacheing
         *
         * @return string Name of the class currently being used for cacheing
         */
        public static function getCacheStorageClass()
        {
        }
        // function getCacheStorageClass()
        /**
         * Set the method that should be used for cell cacheing
         *
         * @param string $method Name of the cacheing method
         * @param array $arguments Optional configuration arguments for the cacheing method
         * @return boolean Success or failure
         */
        public static function setCacheStorageMethod($method = \PHPExcel_CachedObjectStorageFactory::cache_in_memory, $arguments = array())
        {
        }
        // function setCacheStorageMethod()
        /**
         * Set the locale code to use for formula translations and any special formatting
         *
         * @param string $locale The locale code to use (e.g. "fr" or "pt_br" or "en_uk")
         * @return boolean Success or failure
         */
        public static function setLocale($locale = 'en_us')
        {
        }
        // function setLocale()
        /**
         * Set details of the external library that PHPExcel should use for rendering charts
         *
         * @param string $libraryName	Internal reference name of the library
         *	e.g. PHPExcel_Settings::CHART_RENDERER_JPGRAPH
         * @param string $libraryBaseDir Directory path to the library's base folder
         *
         * @return	boolean	Success or failure
         */
        public static function setChartRenderer($libraryName, $libraryBaseDir)
        {
        }
        // function setChartRenderer()
        /**
         * Identify to PHPExcel the external library to use for rendering charts
         *
         * @param string $libraryName	Internal reference name of the library
         *	e.g. PHPExcel_Settings::CHART_RENDERER_JPGRAPH
         *
         * @return	boolean	Success or failure
         */
        public static function setChartRendererName($libraryName)
        {
        }
        // function setChartRendererName()
        /**
         * Tell PHPExcel where to find the external library to use for rendering charts
         *
         * @param string $libraryBaseDir	Directory path to the library's base folder
         * @return	boolean	Success or failure
         */
        public static function setChartRendererPath($libraryBaseDir)
        {
        }
        // function setChartRendererPath()
        /**
         * Return the Chart Rendering Library that PHPExcel is currently configured to use (e.g. jpgraph)
         *
         * @return string|NULL Internal reference name of the Chart Rendering Library that PHPExcel is
         *	currently configured to use
         *	e.g. PHPExcel_Settings::CHART_RENDERER_JPGRAPH
         */
        public static function getChartRendererName()
        {
        }
        // function getChartRendererName()
        /**
         * Return the directory path to the Chart Rendering Library that PHPExcel is currently configured to use
         *
         * @return string|NULL Directory Path to the Chart Rendering Library that PHPExcel is
         * 	currently configured to use
         */
        public static function getChartRendererPath()
        {
        }
        // function getChartRendererPath()
        /**
         * Set details of the external library that PHPExcel should use for rendering PDF files
         *
         * @param string $libraryName Internal reference name of the library
         * 	e.g. PHPExcel_Settings::PDF_RENDERER_TCPDF,
         * 	PHPExcel_Settings::PDF_RENDERER_DOMPDF
         *  or PHPExcel_Settings::PDF_RENDERER_MPDF
         * @param string $libraryBaseDir Directory path to the library's base folder
         *
         * @return boolean Success or failure
         */
        public static function setPdfRenderer($libraryName, $libraryBaseDir)
        {
        }
        // function setPdfRenderer()
        /**
         * Identify to PHPExcel the external library to use for rendering PDF files
         *
         * @param string $libraryName Internal reference name of the library
         * 	e.g. PHPExcel_Settings::PDF_RENDERER_TCPDF,
         *	PHPExcel_Settings::PDF_RENDERER_DOMPDF
         * 	or PHPExcel_Settings::PDF_RENDERER_MPDF
         *
         * @return boolean Success or failure
         */
        public static function setPdfRendererName($libraryName)
        {
        }
        // function setPdfRendererName()
        /**
         * Tell PHPExcel where to find the external library to use for rendering PDF files
         *
         * @param string $libraryBaseDir Directory path to the library's base folder
         * @return boolean Success or failure
         */
        public static function setPdfRendererPath($libraryBaseDir)
        {
        }
        // function setPdfRendererPath()
        /**
         * Return the PDF Rendering Library that PHPExcel is currently configured to use (e.g. dompdf)
         *
         * @return string|NULL Internal reference name of the PDF Rendering Library that PHPExcel is
         * 	currently configured to use
         *  e.g. PHPExcel_Settings::PDF_RENDERER_TCPDF,
         *  PHPExcel_Settings::PDF_RENDERER_DOMPDF
         *  or PHPExcel_Settings::PDF_RENDERER_MPDF
         */
        public static function getPdfRendererName()
        {
        }
        // function getPdfRendererName()
        /**
         * Return the directory path to the PDF Rendering Library that PHPExcel is currently configured to use
         *
         * @return string|NULL Directory Path to the PDF Rendering Library that PHPExcel is
         *		currently configured to use
         */
        public static function getPdfRendererPath()
        {
        }
        // function getPdfRendererPath()
        /**
         * Set default options for libxml loader
         *
         * @param int $options Default options for libxml loader
         */
        public static function setLibXmlLoaderOptions($options = \null)
        {
        }
        // function setLibXmlLoaderOptions
        /**
         * Get default options for libxml loader.
         * Defaults to LIBXML_DTDLOAD | LIBXML_DTDATTR when not set explicitly.
         *
         * @return int Default options for libxml loader
         */
        public static function getLibXmlLoaderOptions()
        {
        }
        // function getLibXmlLoaderOptions
    }
    /* vim: set expandtab tabstop=4 shiftwidth=4: */
    // +----------------------------------------------------------------------+
    // | PHP Version 4                                                        |
    // +----------------------------------------------------------------------+
    // | Copyright (c) 1997-2002 The PHP Group                                |
    // +----------------------------------------------------------------------+
    // | This source file is subject to version 2.02 of the PHP license,      |
    // | that is bundled with this package in the file LICENSE, and is        |
    // | available at through the world-wide-web at                           |
    // | http://www.php.net/license/2_02.txt.                                 |
    // | If you did not receive a copy of the PHP license and are unable to   |
    // | obtain it through the world-wide-web, please send a note to          |
    // | license@php.net so we can mail you a copy immediately.               |
    // +----------------------------------------------------------------------+
    // | Author: Xavier Noguer <xnoguer@php.net>                              |
    // | Based on OLE::Storage_Lite by Kawai, Takanori                        |
    // +----------------------------------------------------------------------+
    //
    // $Id: PPS.php,v 1.7 2007/02/13 21:00:42 schmidt Exp $
    /**
    * Class for creating PPS's for OLE containers
    *
    * @author   Xavier Noguer <xnoguer@php.net>
    * @category PHPExcel
    * @package  PHPExcel_Shared_OLE
    */
    class PHPExcel_Shared_OLE_PPS
    {
        /**
         * The PPS index
         * @var integer
         */
        public $No;
        /**
         * The PPS name (in Unicode)
         * @var string
         */
        public $Name;
        /**
         * The PPS type. Dir, Root or File
         * @var integer
         */
        public $Type;
        /**
         * The index of the previous PPS
         * @var integer
         */
        public $PrevPps;
        /**
         * The index of the next PPS
         * @var integer
         */
        public $NextPps;
        /**
         * The index of it's first child if this is a Dir or Root PPS
         * @var integer
         */
        public $DirPps;
        /**
         * A timestamp
         * @var integer
         */
        public $Time1st;
        /**
         * A timestamp
         * @var integer
         */
        public $Time2nd;
        /**
         * Starting block (small or big) for this PPS's data  inside the container
         * @var integer
         */
        public $_StartBlock;
        /**
         * The size of the PPS's data (in bytes)
         * @var integer
         */
        public $Size;
        /**
         * The PPS's data (only used if it's not using a temporary file)
         * @var string
         */
        public $_data;
        /**
         * Array of child PPS's (only used by Root and Dir PPS's)
         * @var array
         */
        public $children = array();
        /**
         * Pointer to OLE container
         * @var OLE
         */
        public $ole;
        /**
         * The constructor
         *
         * @access public
         * @param integer $No   The PPS index
         * @param string  $name The PPS name
         * @param integer $type The PPS type. Dir, Root or File
         * @param integer $prev The index of the previous PPS
         * @param integer $next The index of the next PPS
         * @param integer $dir  The index of it's first child if this is a Dir or Root PPS
         * @param integer $time_1st A timestamp
         * @param integer $time_2nd A timestamp
         * @param string  $data  The (usually binary) source data of the PPS
         * @param array   $children Array containing children PPS for this PPS
         */
        public function __construct($No, $name, $type, $prev, $next, $dir, $time_1st, $time_2nd, $data, $children)
        {
        }
        /**
         * Returns the amount of data saved for this PPS
         *
         * @access public
         * @return integer The amount of data (in bytes)
         */
        public function _DataLen()
        {
        }
        /**
         * Returns a string with the PPS's WK (What is a WK?)
         *
         * @access public
         * @return string The binary string
         */
        public function _getPpsWk()
        {
        }
        /**
         * Updates index and pointers to previous, next and children PPS's for this
         * PPS. I don't think it'll work with Dir PPS's.
         *
         * @access public
         * @param array &$raList Reference to the array of PPS's for the whole OLE
         *                          container
         * @return integer          The index for this PPS
         */
        public static function _savePpsSetPnt(&$raList, $to_save, $depth = 0)
        {
        }
    }
    /* vim: set expandtab tabstop=4 shiftwidth=4: */
    // +----------------------------------------------------------------------+
    // | PHP Version 4                                                        |
    // +----------------------------------------------------------------------+
    // | Copyright (c) 1997-2002 The PHP Group                                |
    // +----------------------------------------------------------------------+
    // | This source file is subject to version 2.02 of the PHP license,      |
    // | that is bundled with this package in the file LICENSE, and is        |
    // | available at through the world-wide-web at                           |
    // | http://www.php.net/license/2_02.txt.                                 |
    // | If you did not receive a copy of the PHP license and are unable to   |
    // | obtain it through the world-wide-web, please send a note to          |
    // | license@php.net so we can mail you a copy immediately.               |
    // +----------------------------------------------------------------------+
    // | Author: Xavier Noguer <xnoguer@php.net>                              |
    // | Based on OLE::Storage_Lite by Kawai, Takanori                        |
    // +----------------------------------------------------------------------+
    //
    // $Id: Root.php,v 1.9 2005/04/23 21:53:49 dufuz Exp $
    /**
    * Class for creating Root PPS's for OLE containers
    *
    * @author   Xavier Noguer <xnoguer@php.net>
    * @category PHPExcel
    * @package  PHPExcel_Shared_OLE
    */
    class PHPExcel_Shared_OLE_PPS_Root extends \PHPExcel_Shared_OLE_PPS
    {
        /**
         * Directory for temporary files
         * @var string
         */
        protected $_tmp_dir = \NULL;
        /**
         * @param integer $time_1st A timestamp
         * @param integer $time_2nd A timestamp
         */
        public function __construct($time_1st, $time_2nd, $raChild)
        {
        }
        /**
         * Method for saving the whole OLE container (including files).
         * In fact, if called with an empty argument (or '-'), it saves to a
         * temporary file and then outputs it's contents to stdout.
         * If a resource pointer to a stream created by fopen() is passed
         * it will be used, but you have to close such stream by yourself.
         *
         * @param string|resource $filename The name of the file or stream where to save the OLE container.
         * @access public
         * @return mixed true on success
         */
        public function save($filename)
        {
        }
        /**
         * Calculate some numbers
         *
         * @access public
         * @param array $raList Reference to an array of PPS's
         * @return array The array of numbers
         */
        public function _calcSize(&$raList)
        {
        }
        /**
         * Helper function for caculating a magic value for block sizes
         *
         * @access public
         * @param integer $i2 The argument
         * @see save()
         * @return integer
         */
        private static function _adjust2($i2)
        {
        }
        /**
         * Save OLE header
         *
         * @access public
         * @param integer $iSBDcnt
         * @param integer $iBBcnt
         * @param integer $iPPScnt
         */
        public function _saveHeader($iSBDcnt, $iBBcnt, $iPPScnt)
        {
        }
        /**
         * Saving big data (PPS's with data bigger than PHPExcel_Shared_OLE::OLE_DATA_SIZE_SMALL)
         *
         * @access public
         * @param integer $iStBlk
         * @param array &$raList Reference to array of PPS's
         */
        public function _saveBigData($iStBlk, &$raList)
        {
        }
        /**
         * get small data (PPS's with data smaller than PHPExcel_Shared_OLE::OLE_DATA_SIZE_SMALL)
         *
         * @access public
         * @param array &$raList Reference to array of PPS's
         */
        public function _makeSmallData(&$raList)
        {
        }
        /**
         * Saves all the PPS's WKs
         *
         * @access public
         * @param array $raList Reference to an array with all PPS's
         */
        public function _savePps(&$raList)
        {
        }
        /**
         * Saving Big Block Depot
         *
         * @access public
         * @param integer $iSbdSize
         * @param integer $iBsize
         * @param integer $iPpsCnt
         */
        public function _saveBbd($iSbdSize, $iBsize, $iPpsCnt)
        {
        }
    }
    /* vim: set expandtab tabstop=4 shiftwidth=4: */
    // +----------------------------------------------------------------------+
    // | PHP Version 4                                                        |
    // +----------------------------------------------------------------------+
    // | Copyright (c) 1997-2002 The PHP Group                                |
    // +----------------------------------------------------------------------+
    // | This source file is subject to version 2.02 of the PHP license,      |
    // | that is bundled with this package in the file LICENSE, and is        |
    // | available at through the world-wide-web at                           |
    // | http://www.php.net/license/2_02.txt.                                 |
    // | If you did not receive a copy of the PHP license and are unable to   |
    // | obtain it through the world-wide-web, please send a note to          |
    // | license@php.net so we can mail you a copy immediately.               |
    // +----------------------------------------------------------------------+
    // | Author: Xavier Noguer <xnoguer@php.net>                              |
    // | Based on OLE::Storage_Lite by Kawai, Takanori                        |
    // +----------------------------------------------------------------------+
    //
    // $Id: File.php,v 1.11 2007/02/13 21:00:42 schmidt Exp $
    /**
    * Class for creating File PPS's for OLE containers
    *
    * @author   Xavier Noguer <xnoguer@php.net>
    * @category PHPExcel
    * @package  PHPExcel_Shared_OLE
    */
    class PHPExcel_Shared_OLE_PPS_File extends \PHPExcel_Shared_OLE_PPS
    {
        /**
         * The constructor
         *
         * @access public
         * @param string $name The name of the file (in Unicode)
         * @see OLE::Asc2Ucs()
         */
        public function __construct($name)
        {
        }
        /**
         * Initialization method. Has to be called right after OLE_PPS_File().
         *
         * @access public
         * @return mixed true on success
         */
        public function init()
        {
        }
        /**
         * Append data to PPS
         *
         * @access public
         * @param string $data The data to append
         */
        public function append($data)
        {
        }
        /**
         * Returns a stream for reading this file using fread() etc.
         * @return  resource  a read-only stream
         */
        public function getStream()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (C) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared_OLE
     * @copyright  Copyright (c) 2006 - 2007 Christian Schmidt
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version 1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Shared_OLE_ChainedBlockStream
     *
     * Stream wrapper for reading data stored in an OLE file. Implements methods
     * for PHP's stream_wrapper_register(). For creating streams using this
     * wrapper, use PHPExcel_Shared_OLE_PPS_File::getStream().
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared_OLE
     */
    class PHPExcel_Shared_OLE_ChainedBlockStream
    {
        /**
         * The OLE container of the file that is being read.
         * @var OLE
         */
        public $ole;
        /**
         * Parameters specified by fopen().
         * @var array
         */
        public $params;
        /**
         * The binary data of the file.
         * @var  string
         */
        public $data;
        /**
         * The file pointer.
         * @var  int  byte offset
         */
        public $pos;
        /**
         * Implements support for fopen().
         * For creating streams using this wrapper, use OLE_PPS_File::getStream().
         *
         * @param	string	$path			resource name including scheme, e.g.
         *									ole-chainedblockstream://oleInstanceId=1
         * @param	string	$mode			only "r" is supported
         * @param	int		$options		mask of STREAM_REPORT_ERRORS and STREAM_USE_PATH
         * @param	string  &$openedPath	absolute path of the opened stream (out parameter)
         * @return	bool    true on success
         */
        public function stream_open($path, $mode, $options, &$openedPath)
        {
        }
        /**
         * Implements support for fclose().
         *
         */
        public function stream_close()
        {
        }
        /**
         * Implements support for fread(), fgets() etc.
         *
         * @param   int		$count	maximum number of bytes to read
         * @return  string
         */
        public function stream_read($count)
        {
        }
        /**
         * Implements support for feof().
         *
         * @return  bool  TRUE if the file pointer is at EOF; otherwise FALSE
         */
        public function stream_eof()
        {
        }
        /**
         * Returns the position of the file pointer, i.e. its offset into the file
         * stream. Implements support for ftell().
         *
         * @return  int
         */
        public function stream_tell()
        {
        }
        /**
         * Implements support for fseek().
         *
         * @param	int		$offset	byte offset
         * @param	int		$whence	SEEK_SET, SEEK_CUR or SEEK_END
         * @return	bool
         */
        public function stream_seek($offset, $whence)
        {
        }
        /**
         * Implements support for fstat(). Currently the only supported field is
         * "size".
         * @return  array
         */
        public function stream_stat()
        {
        }
        // Methods used by stream_wrapper_register() that are not implemented:
        // bool stream_flush ( void )
        // int stream_write ( string data )
        // bool rename ( string path_from, string path_to )
        // bool mkdir ( string path, int mode, int options )
        // bool rmdir ( string path, int options )
        // bool dir_opendir ( string path, int options )
        // array url_stat ( string path, int flags )
        // string dir_readdir ( void )
        // bool dir_rewinddir ( void )
        // bool dir_closedir ( void )
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Shared_CodePage
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Shared_CodePage
    {
        /**
         * Convert Microsoft Code Page Identifier to Code Page Name which iconv
         * and mbstring understands
         *
         * @param integer $codePage Microsoft Code Page Indentifier
         * @return string Code Page Name
         * @throws PHPExcel_Exception
         */
        public static function NumberToName($codePage = 1252)
        {
        }
    }
    /**
     * PHPExcel_Shared_XMLWriter
     *
     * @category   PHPExcel
     * @package	PHPExcel_Shared
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Shared_XMLWriter extends \XMLWriter
    {
        /** Temporary storage method */
        const STORAGE_MEMORY = 1;
        const STORAGE_DISK = 2;
        /**
         * Temporary filename
         *
         * @var string
         */
        private $_tempFileName = '';
        /**
         * Create a new PHPExcel_Shared_XMLWriter instance
         *
         * @param int		$pTemporaryStorage			Temporary storage location
         * @param string	$pTemporaryStorageFolder	Temporary storage folder
         */
        public function __construct($pTemporaryStorage = self::STORAGE_MEMORY, $pTemporaryStorageFolder = \NULL)
        {
        }
        /**
         * Destructor
         */
        public function __destruct()
        {
        }
        /**
         * Get written data
         *
         * @return $data
         */
        public function getData()
        {
        }
        /**
         * Fallback method for writeRaw, introduced in PHP 5.2
         *
         * @param string $text
         * @return string
         */
        public function writeRawData($text)
        {
        }
    }
    /**
     * PHPExcel_Shared_ZipArchive
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared_ZipArchive
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Shared_ZipArchive
    {
        /**	constants */
        const OVERWRITE = 'OVERWRITE';
        const CREATE = 'CREATE';
        /**
         * Temporary storage directory
         *
         * @var string
         */
        private $_tempDir;
        /**
         * Zip Archive Stream Handle
         *
         * @var string
         */
        private $_zip;
        /**
         * Open a new zip archive
         *
         * @param	string	$fileName	Filename for the zip archive
         * @return	boolean
         */
        public function open($fileName)
        {
        }
        /**
         * Close this zip archive
         *
         */
        public function close()
        {
        }
        /**
         * Add a new file to the zip archive from a string of raw data.
         *
         * @param	string	$localname		Directory/Name of the file to add to the zip archive
         * @param	string	$contents		String of data to add to the zip archive
         */
        public function addFromString($localname, $contents)
        {
        }
        /**
         * Find if given fileName exist in archive (Emulate ZipArchive locateName())
         *
         * @param        string        $fileName        Filename for the file in zip archive
         * @return        boolean
         */
        public function locateName($fileName)
        {
        }
        /**
         * Extract file from archive by given fileName (Emulate ZipArchive getFromName())
         *
         * @param        string        $fileName        Filename for the file in zip archive
         * @return        string  $contents        File string contents
         */
        public function getFromName($fileName)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package	PHPExcel_Shared
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license	http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version	1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Shared_Date
     *
     * @category   PHPExcel
     * @package	PHPExcel_Shared
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Shared_Date
    {
        /** constants */
        const CALENDAR_WINDOWS_1900 = 1900;
        //	Base date of 1st Jan 1900 = 1.0
        const CALENDAR_MAC_1904 = 1904;
        //	Base date of 2nd Jan 1904 = 1.0
        /*
         * Names of the months of the year, indexed by shortname
         * Planned usage for locale settings
         *
         * @public
         * @var	string[]
         */
        public static $_monthNames = array('Jan' => 'January', 'Feb' => 'February', 'Mar' => 'March', 'Apr' => 'April', 'May' => 'May', 'Jun' => 'June', 'Jul' => 'July', 'Aug' => 'August', 'Sep' => 'September', 'Oct' => 'October', 'Nov' => 'November', 'Dec' => 'December');
        /*
         * Names of the months of the year, indexed by shortname
         * Planned usage for locale settings
         *
         * @public
         * @var	string[]
         */
        public static $_numberSuffixes = array('st', 'nd', 'rd', 'th');
        /*
         * Base calendar year to use for calculations
         *
         * @private
         * @var	int
         */
        protected static $_excelBaseDate = self::CALENDAR_WINDOWS_1900;
        /**
         * Set the Excel calendar (Windows 1900 or Mac 1904)
         *
         * @param	 integer	$baseDate			Excel base date (1900 or 1904)
         * @return	 boolean						Success or failure
         */
        public static function setExcelCalendar($baseDate)
        {
        }
        //	function setExcelCalendar()
        /**
         * Return the Excel calendar (Windows 1900 or Mac 1904)
         *
         * @return	 integer	Excel base date (1900 or 1904)
         */
        public static function getExcelCalendar()
        {
        }
        //	function getExcelCalendar()
        /**
         *	Convert a date from Excel to PHP
         *
         *	@param		long		$dateValue			Excel date/time value
         *	@param		boolean		$adjustToTimezone	Flag indicating whether $dateValue should be treated as
         *													a UST timestamp, or adjusted to UST
         *	@param		string	 	$timezone			The timezone for finding the adjustment from UST
         *	@return		long		PHP serialized date/time
         */
        public static function ExcelToPHP($dateValue = 0, $adjustToTimezone = \FALSE, $timezone = \NULL)
        {
        }
        //	function ExcelToPHP()
        /**
         * Convert a date from Excel to a PHP Date/Time object
         *
         * @param	integer		$dateValue		Excel date/time value
         * @return	integer						PHP date/time object
         */
        public static function ExcelToPHPObject($dateValue = 0)
        {
        }
        //	function ExcelToPHPObject()
        /**
         *	Convert a date from PHP to Excel
         *
         *	@param	mixed		$dateValue			PHP serialized date/time or date object
         *	@param	boolean		$adjustToTimezone	Flag indicating whether $dateValue should be treated as
         *													a UST timestamp, or adjusted to UST
         *	@param	string	 	$timezone			The timezone for finding the adjustment from UST
         *	@return	mixed		Excel date/time value
         *							or boolean FALSE on failure
         */
        public static function PHPToExcel($dateValue = 0, $adjustToTimezone = \FALSE, $timezone = \NULL)
        {
        }
        //	function PHPToExcel()
        /**
         * FormattedPHPToExcel
         *
         * @param	long	$year
         * @param	long	$month
         * @param	long	$day
         * @param	long	$hours
         * @param	long	$minutes
         * @param	long	$seconds
         * @return  long				Excel date/time value
         */
        public static function FormattedPHPToExcel($year, $month, $day, $hours = 0, $minutes = 0, $seconds = 0)
        {
        }
        //	function FormattedPHPToExcel()
        /**
         * Is a given cell a date/time?
         *
         * @param	 PHPExcel_Cell	$pCell
         * @return	 boolean
         */
        public static function isDateTime(\PHPExcel_Cell $pCell)
        {
        }
        //	function isDateTime()
        /**
         * Is a given number format a date/time?
         *
         * @param	 PHPExcel_Style_NumberFormat	$pFormat
         * @return	 boolean
         */
        public static function isDateTimeFormat(\PHPExcel_Style_NumberFormat $pFormat)
        {
        }
        //	function isDateTimeFormat()
        private static $possibleDateFormatCharacters = 'eymdHs';
        /**
         * Is a given number format code a date/time?
         *
         * @param	 string	$pFormatCode
         * @return	 boolean
         */
        public static function isDateTimeFormatCode($pFormatCode = '')
        {
        }
        //	function isDateTimeFormatCode()
        /**
         * Convert a date/time string to Excel time
         *
         * @param	string	$dateValue		Examples: '2009-12-31', '2009-12-31 15:59', '2009-12-31 15:59:10'
         * @return	float|FALSE		Excel date/time serial value
         */
        public static function stringToExcel($dateValue = '')
        {
        }
        public static function monthStringToNumber($month)
        {
        }
        public static function dayStringToNumber($day)
        {
        }
    }
    /**
     *	@package JAMA
     *
     *	Class to obtain eigenvalues and eigenvectors of a real matrix.
     *
     *	If A is symmetric, then A = V*D*V' where the eigenvalue matrix D
     *	is diagonal and the eigenvector matrix V is orthogonal (i.e.
     *	A = V.times(D.times(V.transpose())) and V.times(V.transpose())
     *	equals the identity matrix).
     *
     *	If A is not symmetric, then the eigenvalue matrix D is block diagonal
     *	with the real eigenvalues in 1-by-1 blocks and any complex eigenvalues,
     *	lambda + i*mu, in 2-by-2 blocks, [lambda, mu; -mu, lambda].  The
     *	columns of V represent the eigenvectors in the sense that A*V = V*D,
     *	i.e. A.times(V) equals V.times(D).  The matrix V may be badly
     *	conditioned, or even singular, so the validity of the equation
     *	A = V*D*inverse(V) depends upon V.cond().
     *
     *	@author  Paul Meagher
     *	@license PHP v3.0
     *	@version 1.1
     */
    class EigenvalueDecomposition
    {
        /**
         *	Row and column dimension (square matrix).
         *	@var int
         */
        private $n;
        /**
         *	Internal symmetry flag.
         *	@var int
         */
        private $issymmetric;
        /**
         *	Arrays for internal storage of eigenvalues.
         *	@var array
         */
        private $d = array();
        private $e = array();
        /**
         *	Array for internal storage of eigenvectors.
         *	@var array
         */
        private $V = array();
        /**
         *	Array for internal storage of nonsymmetric Hessenberg form.
         *	@var array
         */
        private $H = array();
        /**
         *	Working storage for nonsymmetric algorithm.
         *	@var array
         */
        private $ort;
        /**
         *	Used for complex scalar division.
         *	@var float
         */
        private $cdivr;
        private $cdivi;
        /**
         *	Symmetric Householder reduction to tridiagonal form.
         *
         *	@access private
         */
        private function tred2()
        {
        }
        /**
         *	Symmetric tridiagonal QL algorithm.
         *
         *	This is derived from the Algol procedures tql2, by
         *	Bowdler, Martin, Reinsch, and Wilkinson, Handbook for
         *	Auto. Comp., Vol.ii-Linear Algebra, and the corresponding
         *	Fortran subroutine in EISPACK.
         *
         *	@access private
         */
        private function tql2()
        {
        }
        /**
         *	Nonsymmetric reduction to Hessenberg form.
         *
         *	This is derived from the Algol procedures orthes and ortran,
         *	by Martin and Wilkinson, Handbook for Auto. Comp.,
         *	Vol.ii-Linear Algebra, and the corresponding
         *	Fortran subroutines in EISPACK.
         *
         *	@access private
         */
        private function orthes()
        {
        }
        /**
         *	Performs complex division.
         *
         *	@access private
         */
        private function cdiv($xr, $xi, $yr, $yi)
        {
        }
        /**
         *	Nonsymmetric reduction from Hessenberg to real Schur form.
         *
         *	Code is derived from the Algol procedure hqr2,
         *	by Martin and Wilkinson, Handbook for Auto. Comp.,
         *	Vol.ii-Linear Algebra, and the corresponding
         *	Fortran subroutine in EISPACK.
         *
         *	@access private
         */
        private function hqr2()
        {
        }
        // end hqr2
        /**
         *	Constructor: Check for symmetry, then construct the eigenvalue decomposition
         *
         *	@access public
         *	@param A  Square matrix
         *	@return Structure to access D and V.
         */
        public function __construct($Arg)
        {
        }
        /**
         *	Return the eigenvector matrix
         *
         *	@access public
         *	@return V
         */
        public function getV()
        {
        }
        /**
         *	Return the real parts of the eigenvalues
         *
         *	@access public
         *	@return real(diag(D))
         */
        public function getRealEigenvalues()
        {
        }
        /**
         *	Return the imaginary parts of the eigenvalues
         *
         *	@access public
         *	@return imag(diag(D))
         */
        public function getImagEigenvalues()
        {
        }
        /**
         *	Return the block diagonal eigenvalue matrix
         *
         *	@access public
         *	@return D
         */
        public function getD()
        {
        }
    }
    /**
     *	@package JAMA
     *
     *	For an m-by-n matrix A with m >= n, the singular value decomposition is
     *	an m-by-n orthogonal matrix U, an n-by-n diagonal matrix S, and
     *	an n-by-n orthogonal matrix V so that A = U*S*V'.
     *
     *	The singular values, sigma[$k] = S[$k][$k], are ordered so that
     *	sigma[0] >= sigma[1] >= ... >= sigma[n-1].
     *
     *	The singular value decompostion always exists, so the constructor will
     *	never fail.  The matrix condition number and the effective numerical
     *	rank can be computed from this decomposition.
     *
     *	@author  Paul Meagher
     *	@license PHP v3.0
     *	@version 1.1
     */
    class SingularValueDecomposition
    {
        /**
         *	Internal storage of U.
         *	@var array
         */
        private $U = array();
        /**
         *	Internal storage of V.
         *	@var array
         */
        private $V = array();
        /**
         *	Internal storage of singular values.
         *	@var array
         */
        private $s = array();
        /**
         *	Row dimension.
         *	@var int
         */
        private $m;
        /**
         *	Column dimension.
         *	@var int
         */
        private $n;
        /**
         *	Construct the singular value decomposition
         *
         *	Derived from LINPACK code.
         *
         *	@param $A Rectangular matrix
         *	@return Structure to access U, S and V.
         */
        public function __construct($Arg)
        {
        }
        // end constructor
        /**
         *	Return the left singular vectors
         *
         *	@access public
         *	@return U
         */
        public function getU()
        {
        }
        /**
         *	Return the right singular vectors
         *
         *	@access public
         *	@return V
         */
        public function getV()
        {
        }
        /**
         *	Return the one-dimensional array of singular values
         *
         *	@access public
         *	@return diagonal of S.
         */
        public function getSingularValues()
        {
        }
        /**
         *	Return the diagonal matrix of singular values
         *
         *	@access public
         *	@return S
         */
        public function getS()
        {
        }
        /**
         *	Two norm
         *
         *	@access public
         *	@return max(S)
         */
        public function norm2()
        {
        }
        /**
         *	Two norm condition number
         *
         *	@access public
         *	@return max(S)/min(S)
         */
        public function cond()
        {
        }
        /**
         *	Effective numerical matrix rank
         *
         *	@access public
         *	@return Number of nonnegligible singular values.
         */
        public function rank()
        {
        }
    }
    /*
     *	Matrix class
     *
     *	@author Paul Meagher
     *	@author Michael Bommarito
     *	@author Lukasz Karapuda
     *	@author Bartek Matosiuk
     *	@version 1.8
     *	@license PHP v3.0
     *	@see http://math.nist.gov/javanumerics/jama/
     */
    class PHPExcel_Shared_JAMA_Matrix
    {
        const PolymorphicArgumentException = "Invalid argument pattern for polymorphic function.";
        const ArgumentTypeException = "Invalid argument type.";
        const ArgumentBoundsException = "Invalid argument range.";
        const MatrixDimensionException = "Matrix dimensions are not equal.";
        const ArrayLengthException = "Array length must be a multiple of m.";
        /**
         *	Matrix storage
         *
         *	@var array
         *	@access public
         */
        public $A = array();
        /**
         *	Matrix row dimension
         *
         *	@var int
         *	@access private
         */
        private $m;
        /**
         *	Matrix column dimension
         *
         *	@var int
         *	@access private
         */
        private $n;
        /**
         *	Polymorphic constructor
         *
         *	As PHP has no support for polymorphic constructors, we hack our own sort of polymorphism using func_num_args, func_get_arg, and gettype. In essence, we're just implementing a simple RTTI filter and calling the appropriate constructor.
         */
        public function __construct()
        {
        }
        //	function __construct()
        /**
         *	getArray
         *
         *	@return array Matrix array
         */
        public function getArray()
        {
        }
        //	function getArray()
        /**
         *	getRowDimension
         *
         *	@return int Row dimension
         */
        public function getRowDimension()
        {
        }
        //	function getRowDimension()
        /**
         *	getColumnDimension
         *
         *	@return int Column dimension
         */
        public function getColumnDimension()
        {
        }
        //	function getColumnDimension()
        /**
         *	get
         *
         *	Get the i,j-th element of the matrix.
         *	@param int $i Row position
         *	@param int $j Column position
         *	@return mixed Element (int/float/double)
         */
        public function get($i = \null, $j = \null)
        {
        }
        //	function get()
        /**
         *	getMatrix
         *
         *	Get a submatrix
         *	@param int $i0 Initial row index
         *	@param int $iF Final row index
         *	@param int $j0 Initial column index
         *	@param int $jF Final column index
         *	@return Matrix Submatrix
         */
        public function getMatrix()
        {
        }
        //	function getMatrix()
        /**
         *	checkMatrixDimensions
         *
         *	Is matrix B the same size?
         *	@param Matrix $B Matrix B
         *	@return boolean
         */
        public function checkMatrixDimensions($B = \null)
        {
        }
        //	function checkMatrixDimensions()
        /**
         *	set
         *
         *	Set the i,j-th element of the matrix.
         *	@param int $i Row position
         *	@param int $j Column position
         *	@param mixed $c Int/float/double value
         *	@return mixed Element (int/float/double)
         */
        public function set($i = \null, $j = \null, $c = \null)
        {
        }
        //	function set()
        /**
         *	identity
         *
         *	Generate an identity matrix.
         *	@param int $m Row dimension
         *	@param int $n Column dimension
         *	@return Matrix Identity matrix
         */
        public function identity($m = \null, $n = \null)
        {
        }
        //	function identity()
        /**
         *	diagonal
         *
         *	Generate a diagonal matrix
         *	@param int $m Row dimension
         *	@param int $n Column dimension
         *	@param mixed $c Diagonal value
         *	@return Matrix Diagonal matrix
         */
        public function diagonal($m = \null, $n = \null, $c = 1)
        {
        }
        //	function diagonal()
        /**
         *	getMatrixByRow
         *
         *	Get a submatrix by row index/range
         *	@param int $i0 Initial row index
         *	@param int $iF Final row index
         *	@return Matrix Submatrix
         */
        public function getMatrixByRow($i0 = \null, $iF = \null)
        {
        }
        //	function getMatrixByRow()
        /**
         *	getMatrixByCol
         *
         *	Get a submatrix by column index/range
         *	@param int $i0 Initial column index
         *	@param int $iF Final column index
         *	@return Matrix Submatrix
         */
        public function getMatrixByCol($j0 = \null, $jF = \null)
        {
        }
        //	function getMatrixByCol()
        /**
         *	transpose
         *
         *	Tranpose matrix
         *	@return Matrix Transposed matrix
         */
        public function transpose()
        {
        }
        //	function transpose()
        /**
         *	trace
         *
         *	Sum of diagonal elements
         *	@return float Sum of diagonal elements
         */
        public function trace()
        {
        }
        //	function trace()
        /**
         *	uminus
         *
         *	Unary minus matrix -A
         *	@return Matrix Unary minus matrix
         */
        public function uminus()
        {
        }
        //	function uminus()
        /**
         *	plus
         *
         *	A + B
         *	@param mixed $B Matrix/Array
         *	@return Matrix Sum
         */
        public function plus()
        {
        }
        //	function plus()
        /**
         *	plusEquals
         *
         *	A = A + B
         *	@param mixed $B Matrix/Array
         *	@return Matrix Sum
         */
        public function plusEquals()
        {
        }
        //	function plusEquals()
        /**
         *	minus
         *
         *	A - B
         *	@param mixed $B Matrix/Array
         *	@return Matrix Sum
         */
        public function minus()
        {
        }
        //	function minus()
        /**
         *	minusEquals
         *
         *	A = A - B
         *	@param mixed $B Matrix/Array
         *	@return Matrix Sum
         */
        public function minusEquals()
        {
        }
        //	function minusEquals()
        /**
         *	arrayTimes
         *
         *	Element-by-element multiplication
         *	Cij = Aij * Bij
         *	@param mixed $B Matrix/Array
         *	@return Matrix Matrix Cij
         */
        public function arrayTimes()
        {
        }
        //	function arrayTimes()
        /**
         *	arrayTimesEquals
         *
         *	Element-by-element multiplication
         *	Aij = Aij * Bij
         *	@param mixed $B Matrix/Array
         *	@return Matrix Matrix Aij
         */
        public function arrayTimesEquals()
        {
        }
        //	function arrayTimesEquals()
        /**
         *	arrayRightDivide
         *
         *	Element-by-element right division
         *	A / B
         *	@param Matrix $B Matrix B
         *	@return Matrix Division result
         */
        public function arrayRightDivide()
        {
        }
        //	function arrayRightDivide()
        /**
         *	arrayRightDivideEquals
         *
         *	Element-by-element right division
         *	Aij = Aij / Bij
         *	@param mixed $B Matrix/Array
         *	@return Matrix Matrix Aij
         */
        public function arrayRightDivideEquals()
        {
        }
        //	function arrayRightDivideEquals()
        /**
         *	arrayLeftDivide
         *
         *	Element-by-element Left division
         *	A / B
         *	@param Matrix $B Matrix B
         *	@return Matrix Division result
         */
        public function arrayLeftDivide()
        {
        }
        //	function arrayLeftDivide()
        /**
         *	arrayLeftDivideEquals
         *
         *	Element-by-element Left division
         *	Aij = Aij / Bij
         *	@param mixed $B Matrix/Array
         *	@return Matrix Matrix Aij
         */
        public function arrayLeftDivideEquals()
        {
        }
        //	function arrayLeftDivideEquals()
        /**
         *	times
         *
         *	Matrix multiplication
         *	@param mixed $n Matrix/Array/Scalar
         *	@return Matrix Product
         */
        public function times()
        {
        }
        //	function times()
        /**
         *	power
         *
         *	A = A ^ B
         *	@param mixed $B Matrix/Array
         *	@return Matrix Sum
         */
        public function power()
        {
        }
        //	function power()
        /**
         *	concat
         *
         *	A = A & B
         *	@param mixed $B Matrix/Array
         *	@return Matrix Sum
         */
        public function concat()
        {
        }
        //	function concat()
        /**
         *	Solve A*X = B.
         *
         *	@param Matrix $B Right hand side
         *	@return Matrix ... Solution if A is square, least squares solution otherwise
         */
        public function solve($B)
        {
        }
        //	function solve()
        /**
         *	Matrix inverse or pseudoinverse.
         *
         *	@return Matrix ... Inverse(A) if A is square, pseudoinverse otherwise.
         */
        public function inverse()
        {
        }
        //	function inverse()
        /**
         *	det
         *
         *	Calculate determinant
         *	@return float Determinant
         */
        public function det()
        {
        }
        //	function det()
    }
    /**
     *	@package JAMA
     *
     *	For an m-by-n matrix A with m >= n, the LU decomposition is an m-by-n
     *	unit lower triangular matrix L, an n-by-n upper triangular matrix U,
     *	and a permutation vector piv of length m so that A(piv,:) = L*U.
     *	If m < n, then L is m-by-m and U is m-by-n.
     *
     *	The LU decompostion with pivoting always exists, even if the matrix is
     *	singular, so the constructor will never fail. The primary use of the
     *	LU decomposition is in the solution of square systems of simultaneous
     *	linear equations. This will fail if isNonsingular() returns false.
     *
     *	@author Paul Meagher
     *	@author Bartosz Matosiuk
     *	@author Michael Bommarito
     *	@version 1.1
     *	@license PHP v3.0
     */
    class PHPExcel_Shared_JAMA_LUDecomposition
    {
        const MatrixSingularException = "Can only perform operation on singular matrix.";
        const MatrixSquareException = "Mismatched Row dimension";
        /**
         *	Decomposition storage
         *	@var array
         */
        private $LU = array();
        /**
         *	Row dimension.
         *	@var int
         */
        private $m;
        /**
         *	Column dimension.
         *	@var int
         */
        private $n;
        /**
         *	Pivot sign.
         *	@var int
         */
        private $pivsign;
        /**
         *	Internal storage of pivot vector.
         *	@var array
         */
        private $piv = array();
        /**
         *	LU Decomposition constructor.
         *
         *	@param $A Rectangular matrix
         *	@return Structure to access L, U and piv.
         */
        public function __construct($A)
        {
        }
        //	function __construct()
        /**
         *	Get lower triangular factor.
         *
         *	@return array Lower triangular factor
         */
        public function getL()
        {
        }
        //	function getL()
        /**
         *	Get upper triangular factor.
         *
         *	@return array Upper triangular factor
         */
        public function getU()
        {
        }
        //	function getU()
        /**
         *	Return pivot permutation vector.
         *
         *	@return array Pivot vector
         */
        public function getPivot()
        {
        }
        //	function getPivot()
        /**
         *	Alias for getPivot
         *
         *	@see getPivot
         */
        public function getDoublePivot()
        {
        }
        //	function getDoublePivot()
        /**
         *	Is the matrix nonsingular?
         *
         *	@return true if U, and hence A, is nonsingular.
         */
        public function isNonsingular()
        {
        }
        //	function isNonsingular()
        /**
         *	Count determinants
         *
         *	@return array d matrix deterninat
         */
        public function det()
        {
        }
        //	function det()
        /**
         *	Solve A*X = B
         *
         *	@param  $B  A Matrix with as many rows as A and any number of columns.
         *	@return  X so that L*U*X = B(piv,:)
         *	@PHPExcel_Calculation_Exception  IllegalArgumentException Matrix row dimensions must agree.
         *	@PHPExcel_Calculation_Exception  RuntimeException  Matrix is singular.
         */
        public function solve($B)
        {
        }
        //	function solve()
    }
    /**
     *	@package JAMA
     *
     *	For an m-by-n matrix A with m >= n, the QR decomposition is an m-by-n
     *	orthogonal matrix Q and an n-by-n upper triangular matrix R so that
     *	A = Q*R.
     *
     *	The QR decompostion always exists, even if the matrix does not have
     *	full rank, so the constructor will never fail.  The primary use of the
     *	QR decomposition is in the least squares solution of nonsquare systems
     *	of simultaneous linear equations.  This will fail if isFullRank()
     *	returns false.
     *
     *	@author  Paul Meagher
     *	@license PHP v3.0
     *	@version 1.1
     */
    class PHPExcel_Shared_JAMA_QRDecomposition
    {
        const MatrixRankException = "Can only perform operation on full-rank matrix.";
        /**
         *	Array for internal storage of decomposition.
         *	@var array
         */
        private $QR = array();
        /**
         *	Row dimension.
         *	@var integer
         */
        private $m;
        /**
         *	Column dimension.
         *	@var integer
         */
        private $n;
        /**
         *	Array for internal storage of diagonal of R.
         *	@var  array
         */
        private $Rdiag = array();
        /**
         *	QR Decomposition computed by Householder reflections.
         *
         *	@param matrix $A Rectangular matrix
         *	@return Structure to access R and the Householder vectors and compute Q.
         */
        public function __construct($A)
        {
        }
        //	function __construct()
        /**
         *	Is the matrix full rank?
         *
         *	@return boolean true if R, and hence A, has full rank, else false.
         */
        public function isFullRank()
        {
        }
        //	function isFullRank()
        /**
         *	Return the Householder vectors
         *
         *	@return Matrix Lower trapezoidal matrix whose columns define the reflections
         */
        public function getH()
        {
        }
        //	function getH()
        /**
         *	Return the upper triangular factor
         *
         *	@return Matrix upper triangular factor
         */
        public function getR()
        {
        }
        //	function getR()
        /**
         *	Generate and return the (economy-sized) orthogonal factor
         *
         *	@return Matrix orthogonal factor
         */
        public function getQ()
        {
        }
        //	function getQ()
        /**
         *	Least squares solution of A*X = B
         *
         *	@param Matrix $B A Matrix with as many rows as A and any number of columns.
         *	@return Matrix Matrix that minimizes the two norm of Q*R*X-B.
         */
        public function solve($B)
        {
        }
        //	function solve()
    }
    /**
     *	@package JAMA
     *
     *	Cholesky decomposition class
     *
     *	For a symmetric, positive definite matrix A, the Cholesky decomposition
     *	is an lower triangular matrix L so that A = L*L'.
     *
     *	If the matrix is not symmetric or positive definite, the constructor
     *	returns a partial decomposition and sets an internal flag that may
     *	be queried by the isSPD() method.
     *
     *	@author Paul Meagher
     *	@author Michael Bommarito
     *	@version 1.2
     */
    class CholeskyDecomposition
    {
        /**
         *	Decomposition storage
         *	@var array
         *	@access private
         */
        private $L = array();
        /**
         *	Matrix row and column dimension
         *	@var int
         *	@access private
         */
        private $m;
        /**
         *	Symmetric positive definite flag
         *	@var boolean
         *	@access private
         */
        private $isspd = \true;
        /**
         *	CholeskyDecomposition
         *
         *	Class constructor - decomposes symmetric positive definite matrix
         *	@param mixed Matrix square symmetric positive definite matrix
         */
        public function __construct($A = \null)
        {
        }
        //	function __construct()
        /**
         *	Is the matrix symmetric and positive definite?
         *
         *	@return boolean
         */
        public function isSPD()
        {
        }
        //	function isSPD()
        /**
         *	getL
         *
         *	Return triangular factor.
         *	@return Matrix Lower triangular matrix
         */
        public function getL()
        {
        }
        //	function getL()
        /**
         *	Solve A*X = B
         *
         *	@param $B Row-equal matrix
         *	@return Matrix L * L' * X = B
         */
        public function solve($B = \null)
        {
        }
        //	function solve()
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Shared_Excel5
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Shared_Excel5
    {
        /**
         * Get the width of a column in pixels. We use the relationship y = ceil(7x) where
         * x is the width in intrinsic Excel units (measuring width in number of normal characters)
         * This holds for Arial 10
         *
         * @param PHPExcel_Worksheet $sheet The sheet
         * @param string $col The column
         * @return integer The width in pixels
         */
        public static function sizeCol($sheet, $col = 'A')
        {
        }
        /**
         * Convert the height of a cell from user's units to pixels. By interpolation
         * the relationship is: y = 4/3x. If the height hasn't been set by the user we
         * use the default value. If the row is hidden we use a value of zero.
         *
         * @param PHPExcel_Worksheet $sheet The sheet
         * @param integer $row The row index (1-based)
         * @return integer The width in pixels
         */
        public static function sizeRow($sheet, $row = 1)
        {
        }
        /**
         * Get the horizontal distance in pixels between two anchors
         * The distanceX is found as sum of all the spanning columns widths minus correction for the two offsets
         *
         * @param PHPExcel_Worksheet $sheet
         * @param string $startColumn
         * @param integer $startOffsetX Offset within start cell measured in 1/1024 of the cell width
         * @param string $endColumn
         * @param integer $endOffsetX Offset within end cell measured in 1/1024 of the cell width
         * @return integer Horizontal measured in pixels
         */
        public static function getDistanceX(\PHPExcel_Worksheet $sheet, $startColumn = 'A', $startOffsetX = 0, $endColumn = 'A', $endOffsetX = 0)
        {
        }
        /**
         * Get the vertical distance in pixels between two anchors
         * The distanceY is found as sum of all the spanning rows minus two offsets
         *
         * @param PHPExcel_Worksheet $sheet
         * @param integer $startRow (1-based)
         * @param integer $startOffsetY Offset within start cell measured in 1/256 of the cell height
         * @param integer $endRow (1-based)
         * @param integer $endOffsetY Offset within end cell measured in 1/256 of the cell height
         * @return integer Vertical distance measured in pixels
         */
        public static function getDistanceY(\PHPExcel_Worksheet $sheet, $startRow = 1, $startOffsetY = 0, $endRow = 1, $endOffsetY = 0)
        {
        }
        /**
         * Convert 1-cell anchor coordinates to 2-cell anchor coordinates
         * This function is ported from PEAR Spreadsheet_Writer_Excel with small modifications
         *
         * Calculate the vertices that define the position of the image as required by
         * the OBJ record.
         *
         *		 +------------+------------+
         *		 |	 A	  |	  B	 |
         *   +-----+------------+------------+
         *   |	 |(x1,y1)	 |			|
         *   |  1  |(A1)._______|______	  |
         *   |	 |	|			  |	 |
         *   |	 |	|			  |	 |
         *   +-----+----|	BITMAP	|-----+
         *   |	 |	|			  |	 |
         *   |  2  |	|______________.	 |
         *   |	 |			|		(B2)|
         *   |	 |			|	 (x2,y2)|
         *   +---- +------------+------------+
         *
         * Example of a bitmap that covers some of the area from cell A1 to cell B2.
         *
         * Based on the width and height of the bitmap we need to calculate 8 vars:
         *	 $col_start, $row_start, $col_end, $row_end, $x1, $y1, $x2, $y2.
         * The width and height of the cells are also variable and have to be taken into
         * account.
         * The values of $col_start and $row_start are passed in from the calling
         * function. The values of $col_end and $row_end are calculated by subtracting
         * the width and height of the bitmap from the width and height of the
         * underlying cells.
         * The vertices are expressed as a percentage of the underlying cell width as
         * follows (rhs values are in pixels):
         *
         *	   x1 = X / W *1024
         *	   y1 = Y / H *256
         *	   x2 = (X-1) / W *1024
         *	   y2 = (Y-1) / H *256
         *
         *	   Where:  X is distance from the left side of the underlying cell
         *			   Y is distance from the top of the underlying cell
         *			   W is the width of the cell
         *			   H is the height of the cell
         *
         * @param PHPExcel_Worksheet $sheet
         * @param string $coordinates E.g. 'A1'
         * @param integer $offsetX Horizontal offset in pixels
         * @param integer $offsetY Vertical offset in pixels
         * @param integer $width Width in pixels
         * @param integer $height Height in pixels
         * @return array
         */
        public static function oneAnchor2twoAnchor($sheet, $coordinates, $offsetX, $offsetY, $width, $height)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package	PHPExcel_Shared
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license	http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version	1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Shared_TimeZone
     *
     * @category   PHPExcel
     * @package	PHPExcel_Shared
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Shared_TimeZone
    {
        /*
         * Default Timezone used for date/time conversions
         *
         * @private
         * @var	string
         */
        protected static $_timezone = 'UTC';
        /**
         * Validate a Timezone name
         *
         * @param	 string		$timezone			Time zone (e.g. 'Europe/London')
         * @return	 boolean						Success or failure
         */
        public static function _validateTimeZone($timezone)
        {
        }
        /**
         * Set the Default Timezone used for date/time conversions
         *
         * @param	 string		$timezone			Time zone (e.g. 'Europe/London')
         * @return	 boolean						Success or failure
         */
        public static function setTimeZone($timezone)
        {
        }
        //	function setTimezone()
        /**
         * Return the Default Timezone used for date/time conversions
         *
         * @return	 string		Timezone (e.g. 'Europe/London')
         */
        public static function getTimeZone()
        {
        }
        //	function getTimezone()
        /**
         *	Return the Timezone transition for the specified timezone and timestamp
         *
         *	@param		DateTimeZone	 	$objTimezone	The timezone for finding the transitions
         *	@param		integer	 			$timestamp		PHP date/time value for finding the current transition
         *	@return	 	array				The current transition details
         */
        private static function _getTimezoneTransitions($objTimezone, $timestamp)
        {
        }
        /**
         *	Return the Timezone offset used for date/time conversions to/from UST
         *	This requires both the timezone and the calculated date/time to allow for local DST
         *
         *	@param		string	 			$timezone		The timezone for finding the adjustment to UST
         *	@param		integer	 			$timestamp		PHP date/time value
         *	@return	 	integer				Number of seconds for timezone adjustment
         *	@throws		PHPExcel_Exception
         */
        public static function getTimeZoneAdjustment($timezone, $timestamp)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Shared_ZipStreamWrapper
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Shared_ZipStreamWrapper
    {
        /**
         * Internal ZipAcrhive
         *
         * @var ZipAcrhive
         */
        private $_archive;
        /**
         * Filename in ZipAcrhive
         *
         * @var string
         */
        private $_fileNameInArchive = '';
        /**
         * Position in file
         *
         * @var int
         */
        private $_position = 0;
        /**
         * Data
         *
         * @var mixed
         */
        private $_data = '';
        /**
         * Register wrapper
         */
        public static function register()
        {
        }
        /**
         * Implements support for fopen().
         *
         * @param	string	$path			resource name including scheme, e.g.
         * @param	string	$mode			only "r" is supported
         * @param	int		$options		mask of STREAM_REPORT_ERRORS and STREAM_USE_PATH
         * @param	string  &$openedPath	absolute path of the opened stream (out parameter)
         * @return	bool    true on success
         */
        public function stream_open($path, $mode, $options, &$opened_path)
        {
        }
        /**
         * Implements support for fstat().
         *
         * @return  boolean
         */
        public function statName()
        {
        }
        /**
         * Implements support for fstat().
         *
         * @return  boolean
         */
        public function url_stat()
        {
        }
        /**
         * Implements support for fstat().
         *
         * @return  boolean
         */
        public function stream_stat()
        {
        }
        /**
         * Implements support for fread(), fgets() etc.
         *
         * @param   int		$count	maximum number of bytes to read
         * @return  string
         */
        function stream_read($count)
        {
        }
        /**
         * Returns the position of the file pointer, i.e. its offset into the file
         * stream. Implements support for ftell().
         *
         * @return  int
         */
        public function stream_tell()
        {
        }
        /**
         * EOF stream
         *
         * @return	bool
         */
        public function stream_eof()
        {
        }
        /**
         * Seek stream
         *
         * @param	int		$offset	byte offset
         * @param	int		$whence	SEEK_SET, SEEK_CUR or SEEK_END
         * @return	bool
         */
        public function stream_seek($offset, $whence)
        {
        }
    }
    /**
    * OLE package base class.
    *
    * @author   Xavier Noguer <xnoguer@php.net>
    * @author   Christian Schmidt <schmidt@php.net>
    * @category   PHPExcel
    * @package    PHPExcel_Shared_OLE
    */
    class PHPExcel_Shared_OLE
    {
        const OLE_PPS_TYPE_ROOT = 5;
        const OLE_PPS_TYPE_DIR = 1;
        const OLE_PPS_TYPE_FILE = 2;
        const OLE_DATA_SIZE_SMALL = 0x1000;
        const OLE_LONG_INT_SIZE = 4;
        const OLE_PPS_SIZE = 0x80;
        /**
         * The file handle for reading an OLE container
         * @var resource
         */
        public $_file_handle;
        /**
         * Array of PPS's found on the OLE container
         * @var array
         */
        public $_list = array();
        /**
         * Root directory of OLE container
         * @var OLE_PPS_Root
         */
        public $root;
        /**
         * Big Block Allocation Table
         * @var array  (blockId => nextBlockId)
         */
        public $bbat;
        /**
         * Short Block Allocation Table
         * @var array  (blockId => nextBlockId)
         */
        public $sbat;
        /**
         * Size of big blocks. This is usually 512.
         * @var  int  number of octets per block.
         */
        public $bigBlockSize;
        /**
         * Size of small blocks. This is usually 64.
         * @var  int  number of octets per block
         */
        public $smallBlockSize;
        /**
         * Reads an OLE container from the contents of the file given.
         *
         * @acces public
         * @param string $file
         * @return mixed true on success, PEAR_Error on failure
         */
        public function read($file)
        {
        }
        /**
         * @param  int  block id
         * @param  int  byte offset from beginning of file
         * @access public
         */
        public function _getBlockOffset($blockId)
        {
        }
        /**
         * Returns a stream for use with fread() etc. External callers should
         * use PHPExcel_Shared_OLE_PPS_File::getStream().
         * @param   int|PPS   block id or PPS
         * @return  resource  read-only stream
         */
        public function getStream($blockIdOrPps)
        {
        }
        /**
         * Reads a signed char.
         * @param   resource  file handle
         * @return  int
         * @access public
         */
        private static function _readInt1($fh)
        {
        }
        /**
         * Reads an unsigned short (2 octets).
         * @param   resource  file handle
         * @return  int
         * @access public
         */
        private static function _readInt2($fh)
        {
        }
        /**
         * Reads an unsigned long (4 octets).
         * @param   resource  file handle
         * @return  int
         * @access public
         */
        private static function _readInt4($fh)
        {
        }
        /**
         * Gets information about all PPS's on the OLE container from the PPS WK's
         * creates an OLE_PPS object for each one.
         *
         * @access public
         * @param  integer  the block id of the first block
         * @return mixed true on success, PEAR_Error on failure
         */
        public function _readPpsWks($blockId)
        {
        }
        /**
         * It checks whether the PPS tree is complete (all PPS's read)
         * starting with the given PPS (not necessarily root)
         *
         * @access public
         * @param integer $index The index of the PPS from which we are checking
         * @return boolean Whether the PPS tree for the given PPS is complete
         */
        public function _ppsTreeComplete($index)
        {
        }
        /**
         * Checks whether a PPS is a File PPS or not.
         * If there is no PPS for the index given, it will return false.
         *
         * @access public
         * @param integer $index The index for the PPS
         * @return bool true if it's a File PPS, false otherwise
         */
        public function isFile($index)
        {
        }
        /**
         * Checks whether a PPS is a Root PPS or not.
         * If there is no PPS for the index given, it will return false.
         *
         * @access public
         * @param integer $index The index for the PPS.
         * @return bool true if it's a Root PPS, false otherwise
         */
        public function isRoot($index)
        {
        }
        /**
         * Gives the total number of PPS's found in the OLE container.
         *
         * @access public
         * @return integer The total number of PPS's found in the OLE container
         */
        public function ppsTotal()
        {
        }
        /**
         * Gets data from a PPS
         * If there is no PPS for the index given, it will return an empty string.
         *
         * @access public
         * @param integer $index    The index for the PPS
         * @param integer $position The position from which to start reading
         *                          (relative to the PPS)
         * @param integer $length   The amount of bytes to read (at most)
         * @return string The binary string containing the data requested
         * @see OLE_PPS_File::getStream()
         */
        public function getData($index, $position, $length)
        {
        }
        /**
         * Gets the data length from a PPS
         * If there is no PPS for the index given, it will return 0.
         *
         * @access public
         * @param integer $index    The index for the PPS
         * @return integer The amount of bytes in data the PPS has
         */
        public function getDataLength($index)
        {
        }
        /**
         * Utility function to transform ASCII text to Unicode
         *
         * @access public
         * @static
         * @param string $ascii The ASCII string to transform
         * @return string The string in Unicode
         */
        public static function Asc2Ucs($ascii)
        {
        }
        /**
         * Utility function
         * Returns a string for the OLE container with the date given
         *
         * @access public
         * @static
         * @param integer $date A timestamp
         * @return string The string for the OLE container
         */
        public static function LocalDate2OLE($date = \null)
        {
        }
        /**
         * Returns a timestamp from an OLE container's date
         *
         * @access public
         * @static
         * @param integer $string A binary string with the encoded date
         * @return string The timestamp corresponding to the string
         */
        public static function OLE2LocalDate($string)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Shared_File
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Shared_File
    {
        /*
         * Use Temp or File Upload Temp for temporary files
         *
         * @protected
         * @var	boolean
         */
        protected static $_useUploadTempDirectory = \FALSE;
        /**
         * Set the flag indicating whether the File Upload Temp directory should be used for temporary files
         *
         * @param	 boolean	$useUploadTempDir		Use File Upload Temporary directory (true or false)
         */
        public static function setUseUploadTempDirectory($useUploadTempDir = \FALSE)
        {
        }
        //	function setUseUploadTempDirectory()
        /**
         * Get the flag indicating whether the File Upload Temp directory should be used for temporary files
         *
         * @return	 boolean	Use File Upload Temporary directory (true or false)
         */
        public static function getUseUploadTempDirectory()
        {
        }
        //	function getUseUploadTempDirectory()
        /**
         * Verify if a file exists
         *
         * @param 	string	$pFilename	Filename
         * @return bool
         */
        public static function file_exists($pFilename)
        {
        }
        /**
         * Returns canonicalized absolute pathname, also for ZIP archives
         *
         * @param string $pFilename
         * @return string
         */
        public static function realpath($pFilename)
        {
        }
        /**
         * Get the systems temporary directory.
         *
         * @return string
         */
        public static function sys_get_temp_dir()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared_Escher
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Shared_Escher_DgContainer
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared_Escher
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Shared_Escher_DgContainer
    {
        /**
         * Drawing index, 1-based.
         *
         * @var int
         */
        private $_dgId;
        /**
         * Last shape index in this drawing
         *
         * @var int
         */
        private $_lastSpId;
        private $_spgrContainer = \null;
        public function getDgId()
        {
        }
        public function setDgId($value)
        {
        }
        public function getLastSpId()
        {
        }
        public function setLastSpId($value)
        {
        }
        public function getSpgrContainer()
        {
        }
        public function setSpgrContainer($spgrContainer)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared_Escher
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Shared_Escher_DggContainer
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared_Escher
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Shared_Escher_DggContainer
    {
        /**
         * Maximum shape index of all shapes in all drawings increased by one
         *
         * @var int
         */
        private $_spIdMax;
        /**
         * Total number of drawings saved
         *
         * @var int
         */
        private $_cDgSaved;
        /**
         * Total number of shapes saved (including group shapes)
         *
         * @var int
         */
        private $_cSpSaved;
        /**
         * BLIP Store Container
         *
         * @var PHPExcel_Shared_Escher_DggContainer_BstoreContainer
         */
        private $_bstoreContainer;
        /**
         * Array of options for the drawing group
         *
         * @var array
         */
        private $_OPT = array();
        /**
         * Array of identifier clusters containg information about the maximum shape identifiers
         *
         * @var array
         */
        private $_IDCLs = array();
        /**
         * Get maximum shape index of all shapes in all drawings (plus one)
         *
         * @return int
         */
        public function getSpIdMax()
        {
        }
        /**
         * Set maximum shape index of all shapes in all drawings (plus one)
         *
         * @param int
         */
        public function setSpIdMax($value)
        {
        }
        /**
         * Get total number of drawings saved
         *
         * @return int
         */
        public function getCDgSaved()
        {
        }
        /**
         * Set total number of drawings saved
         *
         * @param int
         */
        public function setCDgSaved($value)
        {
        }
        /**
         * Get total number of shapes saved (including group shapes)
         *
         * @return int
         */
        public function getCSpSaved()
        {
        }
        /**
         * Set total number of shapes saved (including group shapes)
         *
         * @param int
         */
        public function setCSpSaved($value)
        {
        }
        /**
         * Get BLIP Store Container
         *
         * @return PHPExcel_Shared_Escher_DggContainer_BstoreContainer
         */
        public function getBstoreContainer()
        {
        }
        /**
         * Set BLIP Store Container
         *
         * @param PHPExcel_Shared_Escher_DggContainer_BstoreContainer $bstoreContainer
         */
        public function setBstoreContainer($bstoreContainer)
        {
        }
        /**
         * Set an option for the drawing group
         *
         * @param int $property The number specifies the option
         * @param mixed $value
         */
        public function setOPT($property, $value)
        {
        }
        /**
         * Get an option for the drawing group
         *
         * @param int $property The number specifies the option
         * @return mixed
         */
        public function getOPT($property)
        {
        }
        /**
         * Get identifier clusters
         *
         * @return array
         */
        public function getIDCLs()
        {
        }
        /**
         * Set identifier clusters. array(<drawingId> => <max shape id>, ...)
         *
         * @param array $pValue
         */
        public function setIDCLs($pValue)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared_Escher
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Shared_Escher_DggContainer_BstoreContainer
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared_Escher
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Shared_Escher_DggContainer_BstoreContainer
    {
        /**
         * BLIP Store Entries. Each of them holds one BLIP (Big Large Image or Picture)
         *
         * @var array
         */
        private $_BSECollection = array();
        /**
         * Add a BLIP Store Entry
         *
         * @param PHPExcel_Shared_Escher_DggContainer_BstoreContainer_BSE $BSE
         */
        public function addBSE($BSE)
        {
        }
        /**
         * Get the collection of BLIP Store Entries
         *
         * @return PHPExcel_Shared_Escher_DggContainer_BstoreContainer_BSE[]
         */
        public function getBSECollection()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared_Escher
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Shared_Escher_DggContainer_BstoreContainer_BSE
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared_Escher
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Shared_Escher_DggContainer_BstoreContainer_BSE
    {
        const BLIPTYPE_ERROR = 0x0;
        const BLIPTYPE_UNKNOWN = 0x1;
        const BLIPTYPE_EMF = 0x2;
        const BLIPTYPE_WMF = 0x3;
        const BLIPTYPE_PICT = 0x4;
        const BLIPTYPE_JPEG = 0x5;
        const BLIPTYPE_PNG = 0x6;
        const BLIPTYPE_DIB = 0x7;
        const BLIPTYPE_TIFF = 0x11;
        const BLIPTYPE_CMYKJPEG = 0x12;
        /**
         * The parent BLIP Store Entry Container
         *
         * @var PHPExcel_Shared_Escher_DggContainer_BstoreContainer
         */
        private $_parent;
        /**
         * The BLIP (Big Large Image or Picture)
         *
         * @var PHPExcel_Shared_Escher_DggContainer_BstoreContainer_BSE_Blip
         */
        private $_blip;
        /**
         * The BLIP type
         *
         * @var int
         */
        private $_blipType;
        /**
         * Set parent BLIP Store Entry Container
         *
         * @param PHPExcel_Shared_Escher_DggContainer_BstoreContainer $parent
         */
        public function setParent($parent)
        {
        }
        /**
         * Get the BLIP
         *
         * @return PHPExcel_Shared_Escher_DggContainer_BstoreContainer_BSE_Blip
         */
        public function getBlip()
        {
        }
        /**
         * Set the BLIP
         *
         * @param PHPExcel_Shared_Escher_DggContainer_BstoreContainer_BSE_Blip $blip
         */
        public function setBlip($blip)
        {
        }
        /**
         * Get the BLIP type
         *
         * @return int
         */
        public function getBlipType()
        {
        }
        /**
         * Set the BLIP type
         *
         * @param int
         */
        public function setBlipType($blipType)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared_Escher
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Shared_Escher_DggContainer_BstoreContainer_BSE_Blip
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared_Escher
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Shared_Escher_DggContainer_BstoreContainer_BSE_Blip
    {
        /**
         * The parent BSE
         *
         * @var PHPExcel_Shared_Escher_DggContainer_BstoreContainer_BSE
         */
        private $_parent;
        /**
         * Raw image data
         *
         * @var string
         */
        private $_data;
        /**
         * Get the raw image data
         *
         * @return string
         */
        public function getData()
        {
        }
        /**
         * Set the raw image data
         *
         * @param string
         */
        public function setData($data)
        {
        }
        /**
         * Set parent BSE
         *
         * @param PHPExcel_Shared_Escher_DggContainer_BstoreContainer_BSE $parent
         */
        public function setParent($parent)
        {
        }
        /**
         * Get parent BSE
         *
         * @return PHPExcel_Shared_Escher_DggContainer_BstoreContainer_BSE $parent
         */
        public function getParent()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared_Escher
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Shared_Escher_DgContainer_SpgrContainer_SpContainer
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared_Escher
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Shared_Escher_DgContainer_SpgrContainer_SpContainer
    {
        /**
         * Parent Shape Group Container
         *
         * @var PHPExcel_Shared_Escher_DgContainer_SpgrContainer
         */
        private $_parent;
        /**
         * Is this a group shape?
         *
         * @var boolean
         */
        private $_spgr = \false;
        /**
         * Shape type
         *
         * @var int
         */
        private $_spType;
        /**
         * Shape flag
         *
         * @var int
         */
        private $_spFlag;
        /**
         * Shape index (usually group shape has index 0, and the rest: 1,2,3...)
         *
         * @var boolean
         */
        private $_spId;
        /**
         * Array of options
         *
         * @var array
         */
        private $_OPT;
        /**
         * Cell coordinates of upper-left corner of shape, e.g. 'A1'
         *
         * @var string
         */
        private $_startCoordinates;
        /**
         * Horizontal offset of upper-left corner of shape measured in 1/1024 of column width
         *
         * @var int
         */
        private $_startOffsetX;
        /**
         * Vertical offset of upper-left corner of shape measured in 1/256 of row height
         *
         * @var int
         */
        private $_startOffsetY;
        /**
         * Cell coordinates of bottom-right corner of shape, e.g. 'B2'
         *
         * @var string
         */
        private $_endCoordinates;
        /**
         * Horizontal offset of bottom-right corner of shape measured in 1/1024 of column width
         *
         * @var int
         */
        private $_endOffsetX;
        /**
         * Vertical offset of bottom-right corner of shape measured in 1/256 of row height
         *
         * @var int
         */
        private $_endOffsetY;
        /**
         * Set parent Shape Group Container
         *
         * @param PHPExcel_Shared_Escher_DgContainer_SpgrContainer $parent
         */
        public function setParent($parent)
        {
        }
        /**
         * Get the parent Shape Group Container
         *
         * @return PHPExcel_Shared_Escher_DgContainer_SpgrContainer
         */
        public function getParent()
        {
        }
        /**
         * Set whether this is a group shape
         *
         * @param boolean $value
         */
        public function setSpgr($value = \false)
        {
        }
        /**
         * Get whether this is a group shape
         *
         * @return boolean
         */
        public function getSpgr()
        {
        }
        /**
         * Set the shape type
         *
         * @param int $value
         */
        public function setSpType($value)
        {
        }
        /**
         * Get the shape type
         *
         * @return int
         */
        public function getSpType()
        {
        }
        /**
         * Set the shape flag
         *
         * @param int $value
         */
        public function setSpFlag($value)
        {
        }
        /**
         * Get the shape flag
         *
         * @return int
         */
        public function getSpFlag()
        {
        }
        /**
         * Set the shape index
         *
         * @param int $value
         */
        public function setSpId($value)
        {
        }
        /**
         * Get the shape index
         *
         * @return int
         */
        public function getSpId()
        {
        }
        /**
         * Set an option for the Shape Group Container
         *
         * @param int $property The number specifies the option
         * @param mixed $value
         */
        public function setOPT($property, $value)
        {
        }
        /**
         * Get an option for the Shape Group Container
         *
         * @param int $property The number specifies the option
         * @return mixed
         */
        public function getOPT($property)
        {
        }
        /**
         * Get the collection of options
         *
         * @return array
         */
        public function getOPTCollection()
        {
        }
        /**
         * Set cell coordinates of upper-left corner of shape
         *
         * @param string $value
         */
        public function setStartCoordinates($value = 'A1')
        {
        }
        /**
         * Get cell coordinates of upper-left corner of shape
         *
         * @return string
         */
        public function getStartCoordinates()
        {
        }
        /**
         * Set offset in x-direction of upper-left corner of shape measured in 1/1024 of column width
         *
         * @param int $startOffsetX
         */
        public function setStartOffsetX($startOffsetX = 0)
        {
        }
        /**
         * Get offset in x-direction of upper-left corner of shape measured in 1/1024 of column width
         *
         * @return int
         */
        public function getStartOffsetX()
        {
        }
        /**
         * Set offset in y-direction of upper-left corner of shape measured in 1/256 of row height
         *
         * @param int $startOffsetY
         */
        public function setStartOffsetY($startOffsetY = 0)
        {
        }
        /**
         * Get offset in y-direction of upper-left corner of shape measured in 1/256 of row height
         *
         * @return int
         */
        public function getStartOffsetY()
        {
        }
        /**
         * Set cell coordinates of bottom-right corner of shape
         *
         * @param string $value
         */
        public function setEndCoordinates($value = 'A1')
        {
        }
        /**
         * Get cell coordinates of bottom-right corner of shape
         *
         * @return string
         */
        public function getEndCoordinates()
        {
        }
        /**
         * Set offset in x-direction of bottom-right corner of shape measured in 1/1024 of column width
         *
         * @param int $startOffsetX
         */
        public function setEndOffsetX($endOffsetX = 0)
        {
        }
        /**
         * Get offset in x-direction of bottom-right corner of shape measured in 1/1024 of column width
         *
         * @return int
         */
        public function getEndOffsetX()
        {
        }
        /**
         * Set offset in y-direction of bottom-right corner of shape measured in 1/256 of row height
         *
         * @param int $endOffsetY
         */
        public function setEndOffsetY($endOffsetY = 0)
        {
        }
        /**
         * Get offset in y-direction of bottom-right corner of shape measured in 1/256 of row height
         *
         * @return int
         */
        public function getEndOffsetY()
        {
        }
        /**
         * Get the nesting level of this spContainer. This is the number of spgrContainers between this spContainer and
         * the dgContainer. A value of 1 = immediately within first spgrContainer
         * Higher nesting level occurs if and only if spContainer is part of a shape group
         *
         * @return int Nesting level
         */
        public function getNestingLevel()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared_Escher
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Shared_Escher_DgContainer_SpgrContainer
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared_Escher
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Shared_Escher_DgContainer_SpgrContainer
    {
        /**
         * Parent Shape Group Container
         *
         * @var PHPExcel_Shared_Escher_DgContainer_SpgrContainer
         */
        private $_parent;
        /**
         * Shape Container collection
         *
         * @var array
         */
        private $_children = array();
        /**
         * Set parent Shape Group Container
         *
         * @param PHPExcel_Shared_Escher_DgContainer_SpgrContainer $parent
         */
        public function setParent($parent)
        {
        }
        /**
         * Get the parent Shape Group Container if any
         *
         * @return PHPExcel_Shared_Escher_DgContainer_SpgrContainer|null
         */
        public function getParent()
        {
        }
        /**
         * Add a child. This will be either spgrContainer or spContainer
         *
         * @param mixed $child
         */
        public function addChild($child)
        {
        }
        /**
         * Get collection of Shape Containers
         */
        public function getChildren()
        {
        }
        /**
         * Recursively get all spContainers within this spgrContainer
         *
         * @return PHPExcel_Shared_Escher_DgContainer_SpgrContainer_SpContainer[]
         */
        public function getAllSpContainers()
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Shared_String
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Shared_String
    {
        /**	Constants				*/
        /**	Regular Expressions		*/
        //	Fraction
        const STRING_REGEXP_FRACTION = '(-?)(\\d+)\\s+(\\d+\\/\\d+)';
        /**
         * Control characters array
         *
         * @var string[]
         */
        private static $_controlCharacters = array();
        /**
         * SYLK Characters array
         *
         * $var array
         */
        private static $_SYLKCharacters = array();
        /**
         * Decimal separator
         *
         * @var string
         */
        private static $_decimalSeparator;
        /**
         * Thousands separator
         *
         * @var string
         */
        private static $_thousandsSeparator;
        /**
         * Currency code
         *
         * @var string
         */
        private static $_currencyCode;
        /**
         * Is mbstring extension avalable?
         *
         * @var boolean
         */
        private static $_isMbstringEnabled;
        /**
         * Is iconv extension avalable?
         *
         * @var boolean
         */
        private static $_isIconvEnabled;
        /**
         * Build control characters array
         */
        private static function _buildControlCharacters()
        {
        }
        /**
         * Build SYLK characters array
         */
        private static function _buildSYLKCharacters()
        {
        }
        /**
         * Get whether mbstring extension is available
         *
         * @return boolean
         */
        public static function getIsMbstringEnabled()
        {
        }
        /**
         * Get whether iconv extension is available
         *
         * @return boolean
         */
        public static function getIsIconvEnabled()
        {
        }
        public static function buildCharacterSets()
        {
        }
        /**
         * Convert from OpenXML escaped control character to PHP control character
         *
         * Excel 2007 team:
         * ----------------
         * That's correct, control characters are stored directly in the shared-strings table.
         * We do encode characters that cannot be represented in XML using the following escape sequence:
         * _xHHHH_ where H represents a hexadecimal character in the character's value...
         * So you could end up with something like _x0008_ in a string (either in a cell value (<v>)
         * element or in the shared string <t> element.
         *
         * @param 	string	$value	Value to unescape
         * @return 	string
         */
        public static function ControlCharacterOOXML2PHP($value = '')
        {
        }
        /**
         * Convert from PHP control character to OpenXML escaped control character
         *
         * Excel 2007 team:
         * ----------------
         * That's correct, control characters are stored directly in the shared-strings table.
         * We do encode characters that cannot be represented in XML using the following escape sequence:
         * _xHHHH_ where H represents a hexadecimal character in the character's value...
         * So you could end up with something like _x0008_ in a string (either in a cell value (<v>)
         * element or in the shared string <t> element.
         *
         * @param 	string	$value	Value to escape
         * @return 	string
         */
        public static function ControlCharacterPHP2OOXML($value = '')
        {
        }
        /**
         * Try to sanitize UTF8, stripping invalid byte sequences. Not perfect. Does not surrogate characters.
         *
         * @param string $value
         * @return string
         */
        public static function SanitizeUTF8($value)
        {
        }
        /**
         * Check if a string contains UTF8 data
         *
         * @param string $value
         * @return boolean
         */
        public static function IsUTF8($value = '')
        {
        }
        /**
         * Formats a numeric value as a string for output in various output writers forcing
         * point as decimal separator in case locale is other than English.
         *
         * @param mixed $value
         * @return string
         */
        public static function FormatNumber($value)
        {
        }
        /**
         * Converts a UTF-8 string into BIFF8 Unicode string data (8-bit string length)
         * Writes the string using uncompressed notation, no rich text, no Asian phonetics
         * If mbstring extension is not available, ASCII is assumed, and compressed notation is used
         * although this will give wrong results for non-ASCII strings
         * see OpenOffice.org's Documentation of the Microsoft Excel File Format, sect. 2.5.3
         *
         * @param string  $value    UTF-8 encoded string
         * @param mixed[] $arrcRuns Details of rich text runs in $value
         * @return string
         */
        public static function UTF8toBIFF8UnicodeShort($value, $arrcRuns = array())
        {
        }
        /**
         * Converts a UTF-8 string into BIFF8 Unicode string data (16-bit string length)
         * Writes the string using uncompressed notation, no rich text, no Asian phonetics
         * If mbstring extension is not available, ASCII is assumed, and compressed notation is used
         * although this will give wrong results for non-ASCII strings
         * see OpenOffice.org's Documentation of the Microsoft Excel File Format, sect. 2.5.3
         *
         * @param string $value UTF-8 encoded string
         * @return string
         */
        public static function UTF8toBIFF8UnicodeLong($value)
        {
        }
        /**
         * Convert string from one encoding to another. First try mbstring, then iconv, finally strlen
         *
         * @param string $value
         * @param string $to Encoding to convert to, e.g. 'UTF-8'
         * @param string $from Encoding to convert from, e.g. 'UTF-16LE'
         * @return string
         */
        public static function ConvertEncoding($value, $to, $from)
        {
        }
        /**
         * Decode UTF-16 encoded strings.
         *
         * Can handle both BOM'ed data and un-BOM'ed data.
         * Assumes Big-Endian byte order if no BOM is available.
         * This function was taken from http://php.net/manual/en/function.utf8-decode.php
         * and $bom_be parameter added.
         *
         * @param   string  $str  UTF-16 encoded data to decode.
         * @return  string  UTF-8 / ISO encoded data.
         * @access  public
         * @version 0.2 / 2010-05-13
         * @author  Rasmus Andersson {@link http://rasmusandersson.se/}
         * @author vadik56
         */
        public static function utf16_decode($str, $bom_be = \TRUE)
        {
        }
        /**
         * Get character count. First try mbstring, then iconv, finally strlen
         *
         * @param string $value
         * @param string $enc Encoding
         * @return int Character count
         */
        public static function CountCharacters($value, $enc = 'UTF-8')
        {
        }
        /**
         * Get a substring of a UTF-8 encoded string. First try mbstring, then iconv, finally strlen
         *
         * @param string $pValue UTF-8 encoded string
         * @param int $pStart Start offset
         * @param int $pLength Maximum number of characters in substring
         * @return string
         */
        public static function Substring($pValue = '', $pStart = 0, $pLength = 0)
        {
        }
        /**
         * Convert a UTF-8 encoded string to upper case
         *
         * @param string $pValue UTF-8 encoded string
         * @return string
         */
        public static function StrToUpper($pValue = '')
        {
        }
        /**
         * Convert a UTF-8 encoded string to lower case
         *
         * @param string $pValue UTF-8 encoded string
         * @return string
         */
        public static function StrToLower($pValue = '')
        {
        }
        /**
         * Convert a UTF-8 encoded string to title/proper case
         *    (uppercase every first character in each word, lower case all other characters)
         *
         * @param string $pValue UTF-8 encoded string
         * @return string
         */
        public static function StrToTitle($pValue = '')
        {
        }
        /**
         * Identify whether a string contains a fractional numeric value,
         *    and convert it to a numeric if it is
         *
         * @param string &$operand string value to test
         * @return boolean
         */
        public static function convertToNumberIfFraction(&$operand)
        {
        }
        //	function convertToNumberIfFraction()
        /**
         * Get the decimal separator. If it has not yet been set explicitly, try to obtain number
         * formatting information from locale.
         *
         * @return string
         */
        public static function getDecimalSeparator()
        {
        }
        /**
         * Set the decimal separator. Only used by PHPExcel_Style_NumberFormat::toFormattedString()
         * to format output by PHPExcel_Writer_HTML and PHPExcel_Writer_PDF
         *
         * @param string $pValue Character for decimal separator
         */
        public static function setDecimalSeparator($pValue = '.')
        {
        }
        /**
         * Get the thousands separator. If it has not yet been set explicitly, try to obtain number
         * formatting information from locale.
         *
         * @return string
         */
        public static function getThousandsSeparator()
        {
        }
        /**
         * Set the thousands separator. Only used by PHPExcel_Style_NumberFormat::toFormattedString()
         * to format output by PHPExcel_Writer_HTML and PHPExcel_Writer_PDF
         *
         * @param string $pValue Character for thousands separator
         */
        public static function setThousandsSeparator($pValue = ',')
        {
        }
        /**
         *	Get the currency code. If it has not yet been set explicitly, try to obtain the
         *		symbol information from locale.
         *
         * @return string
         */
        public static function getCurrencyCode()
        {
        }
        /**
         * Set the currency code. Only used by PHPExcel_Style_NumberFormat::toFormattedString()
         *		to format output by PHPExcel_Writer_HTML and PHPExcel_Writer_PDF
         *
         * @param string $pValue Character for currency code
         */
        public static function setCurrencyCode($pValue = '$')
        {
        }
        /**
         * Convert SYLK encoded string to UTF-8
         *
         * @param string $pValue
         * @return string UTF-8 encoded string
         */
        public static function SYLKtoUTF8($pValue = '')
        {
        }
        /**
         * Retrieve any leading numeric part of a string, or return the full string if no leading numeric
         *	(handles basic integer or float, but not exponent or non decimal)
         *
         * @param	string	$value
         * @return	mixed	string or only the leading numeric part of the string
         */
        public static function testStringAsNumeric($value)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared_Trend
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Best_Fit
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared_Trend
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Best_Fit
    {
        /**
         * Indicator flag for a calculation error
         *
         * @var	boolean
         **/
        protected $_error = \False;
        /**
         * Algorithm type to use for best-fit
         *
         * @var	string
         **/
        protected $_bestFitType = 'undetermined';
        /**
         * Number of entries in the sets of x- and y-value arrays
         *
         * @var	int
         **/
        protected $_valueCount = 0;
        /**
         * X-value dataseries of values
         *
         * @var	float[]
         **/
        protected $_xValues = array();
        /**
         * Y-value dataseries of values
         *
         * @var	float[]
         **/
        protected $_yValues = array();
        /**
         * Flag indicating whether values should be adjusted to Y=0
         *
         * @var	boolean
         **/
        protected $_adjustToZero = \False;
        /**
         * Y-value series of best-fit values
         *
         * @var	float[]
         **/
        protected $_yBestFitValues = array();
        protected $_goodnessOfFit = 1;
        protected $_stdevOfResiduals = 0;
        protected $_covariance = 0;
        protected $_correlation = 0;
        protected $_SSRegression = 0;
        protected $_SSResiduals = 0;
        protected $_DFResiduals = 0;
        protected $_F = 0;
        protected $_slope = 0;
        protected $_slopeSE = 0;
        protected $_intersect = 0;
        protected $_intersectSE = 0;
        protected $_Xoffset = 0;
        protected $_Yoffset = 0;
        public function getError()
        {
        }
        //	function getBestFitType()
        public function getBestFitType()
        {
        }
        //	function getBestFitType()
        /**
         * Return the Y-Value for a specified value of X
         *
         * @param	 float		$xValue			X-Value
         * @return	 float						Y-Value
         */
        public function getValueOfYForX($xValue)
        {
        }
        //	function getValueOfYForX()
        /**
         * Return the X-Value for a specified value of Y
         *
         * @param	 float		$yValue			Y-Value
         * @return	 float						X-Value
         */
        public function getValueOfXForY($yValue)
        {
        }
        //	function getValueOfXForY()
        /**
         * Return the original set of X-Values
         *
         * @return	 float[]				X-Values
         */
        public function getXValues()
        {
        }
        //	function getValueOfXForY()
        /**
         * Return the Equation of the best-fit line
         *
         * @param	 int		$dp		Number of places of decimal precision to display
         * @return	 string
         */
        public function getEquation($dp = 0)
        {
        }
        //	function getEquation()
        /**
         * Return the Slope of the line
         *
         * @param	 int		$dp		Number of places of decimal precision to display
         * @return	 string
         */
        public function getSlope($dp = 0)
        {
        }
        //	function getSlope()
        /**
         * Return the standard error of the Slope
         *
         * @param	 int		$dp		Number of places of decimal precision to display
         * @return	 string
         */
        public function getSlopeSE($dp = 0)
        {
        }
        //	function getSlopeSE()
        /**
         * Return the Value of X where it intersects Y = 0
         *
         * @param	 int		$dp		Number of places of decimal precision to display
         * @return	 string
         */
        public function getIntersect($dp = 0)
        {
        }
        //	function getIntersect()
        /**
         * Return the standard error of the Intersect
         *
         * @param	 int		$dp		Number of places of decimal precision to display
         * @return	 string
         */
        public function getIntersectSE($dp = 0)
        {
        }
        //	function getIntersectSE()
        /**
         * Return the goodness of fit for this regression
         *
         * @param	 int		$dp		Number of places of decimal precision to return
         * @return	 float
         */
        public function getGoodnessOfFit($dp = 0)
        {
        }
        //	function getGoodnessOfFit()
        public function getGoodnessOfFitPercent($dp = 0)
        {
        }
        //	function getGoodnessOfFitPercent()
        /**
         * Return the standard deviation of the residuals for this regression
         *
         * @param	 int		$dp		Number of places of decimal precision to return
         * @return	 float
         */
        public function getStdevOfResiduals($dp = 0)
        {
        }
        //	function getStdevOfResiduals()
        public function getSSRegression($dp = 0)
        {
        }
        //	function getSSRegression()
        public function getSSResiduals($dp = 0)
        {
        }
        //	function getSSResiduals()
        public function getDFResiduals($dp = 0)
        {
        }
        //	function getDFResiduals()
        public function getF($dp = 0)
        {
        }
        //	function getF()
        public function getCovariance($dp = 0)
        {
        }
        //	function getCovariance()
        public function getCorrelation($dp = 0)
        {
        }
        //	function getCorrelation()
        public function getYBestFitValues()
        {
        }
        //	function getYBestFitValues()
        protected function _calculateGoodnessOfFit($sumX, $sumY, $sumX2, $sumY2, $sumXY, $meanX, $meanY, $const)
        {
        }
        //	function _calculateGoodnessOfFit()
        protected function _leastSquareFit($yValues, $xValues, $const)
        {
        }
        //	function _leastSquareFit()
        /**
         * Define the regression
         *
         * @param	float[]		$yValues	The set of Y-values for this regression
         * @param	float[]		$xValues	The set of X-values for this regression
         * @param	boolean		$const
         */
        function __construct($yValues, $xValues = array(), $const = \True)
        {
        }
        //	function __construct()
    }
    /**
     * PHPExcel_Polynomial_Best_Fit
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared_Trend
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Polynomial_Best_Fit extends \PHPExcel_Best_Fit
    {
        /**
         * Algorithm type to use for best-fit
         * (Name of this trend class)
         *
         * @var	string
         **/
        protected $_bestFitType = 'polynomial';
        /**
         * Polynomial order
         *
         * @protected
         * @var	int
         **/
        protected $_order = 0;
        /**
         * Return the order of this polynomial
         *
         * @return	 int
         **/
        public function getOrder()
        {
        }
        //	function getOrder()
        /**
         * Return the Y-Value for a specified value of X
         *
         * @param	 float		$xValue			X-Value
         * @return	 float						Y-Value
         **/
        public function getValueOfYForX($xValue)
        {
        }
        //	function getValueOfYForX()
        /**
         * Return the X-Value for a specified value of Y
         *
         * @param	 float		$yValue			Y-Value
         * @return	 float						X-Value
         **/
        public function getValueOfXForY($yValue)
        {
        }
        //	function getValueOfXForY()
        /**
         * Return the Equation of the best-fit line
         *
         * @param	 int		$dp		Number of places of decimal precision to display
         * @return	 string
         **/
        public function getEquation($dp = 0)
        {
        }
        //	function getEquation()
        /**
         * Return the Slope of the line
         *
         * @param	 int		$dp		Number of places of decimal precision to display
         * @return	 string
         **/
        public function getSlope($dp = 0)
        {
        }
        //	function getSlope()
        public function getCoefficients($dp = 0)
        {
        }
        //	function getCoefficients()
        /**
         * Execute the regression and calculate the goodness of fit for a set of X and Y data values
         *
         * @param	int			$order		Order of Polynomial for this regression
         * @param	float[]		$yValues	The set of Y-values for this regression
         * @param	float[]		$xValues	The set of X-values for this regression
         * @param	boolean		$const
         */
        private function _polynomial_regression($order, $yValues, $xValues, $const)
        {
        }
        //	function _polynomial_regression()
        /**
         * Define the regression and calculate the goodness of fit for a set of X and Y data values
         *
         * @param	int			$order		Order of Polynomial for this regression
         * @param	float[]		$yValues	The set of Y-values for this regression
         * @param	float[]		$xValues	The set of X-values for this regression
         * @param	boolean		$const
         */
        function __construct($order, $yValues, $xValues = array(), $const = \True)
        {
        }
        //	function __construct()
    }
    /**
     * PHPExcel_Exponential_Best_Fit
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared_Trend
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Exponential_Best_Fit extends \PHPExcel_Best_Fit
    {
        /**
         * Algorithm type to use for best-fit
         * (Name of this trend class)
         *
         * @var	string
         **/
        protected $_bestFitType = 'exponential';
        /**
         * Return the Y-Value for a specified value of X
         *
         * @param	 float		$xValue			X-Value
         * @return	 float						Y-Value
         **/
        public function getValueOfYForX($xValue)
        {
        }
        //	function getValueOfYForX()
        /**
         * Return the X-Value for a specified value of Y
         *
         * @param	 float		$yValue			Y-Value
         * @return	 float						X-Value
         **/
        public function getValueOfXForY($yValue)
        {
        }
        //	function getValueOfXForY()
        /**
         * Return the Equation of the best-fit line
         *
         * @param	 int		$dp		Number of places of decimal precision to display
         * @return	 string
         **/
        public function getEquation($dp = 0)
        {
        }
        //	function getEquation()
        /**
         * Return the Slope of the line
         *
         * @param	 int		$dp		Number of places of decimal precision to display
         * @return	 string
         **/
        public function getSlope($dp = 0)
        {
        }
        //	function getSlope()
        /**
         * Return the Value of X where it intersects Y = 0
         *
         * @param	 int		$dp		Number of places of decimal precision to display
         * @return	 string
         **/
        public function getIntersect($dp = 0)
        {
        }
        //	function getIntersect()
        /**
         * Execute the regression and calculate the goodness of fit for a set of X and Y data values
         *
         * @param	 float[]	$yValues	The set of Y-values for this regression
         * @param	 float[]	$xValues	The set of X-values for this regression
         * @param	 boolean	$const
         */
        private function _exponential_regression($yValues, $xValues, $const)
        {
        }
        //	function _exponential_regression()
        /**
         * Define the regression and calculate the goodness of fit for a set of X and Y data values
         *
         * @param	float[]		$yValues	The set of Y-values for this regression
         * @param	float[]		$xValues	The set of X-values for this regression
         * @param	boolean		$const
         */
        function __construct($yValues, $xValues = array(), $const = \True)
        {
        }
        //	function __construct()
    }
    /**
     * PHPExcel_Linear_Best_Fit
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared_Trend
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Linear_Best_Fit extends \PHPExcel_Best_Fit
    {
        /**
         * Algorithm type to use for best-fit
         * (Name of this trend class)
         *
         * @var	string
         **/
        protected $_bestFitType = 'linear';
        /**
         * Return the Y-Value for a specified value of X
         *
         * @param	 float		$xValue			X-Value
         * @return	 float						Y-Value
         **/
        public function getValueOfYForX($xValue)
        {
        }
        //	function getValueOfYForX()
        /**
         * Return the X-Value for a specified value of Y
         *
         * @param	 float		$yValue			Y-Value
         * @return	 float						X-Value
         **/
        public function getValueOfXForY($yValue)
        {
        }
        //	function getValueOfXForY()
        /**
         * Return the Equation of the best-fit line
         *
         * @param	 int		$dp		Number of places of decimal precision to display
         * @return	 string
         **/
        public function getEquation($dp = 0)
        {
        }
        //	function getEquation()
        /**
         * Execute the regression and calculate the goodness of fit for a set of X and Y data values
         *
         * @param	 float[]	$yValues	The set of Y-values for this regression
         * @param	 float[]	$xValues	The set of X-values for this regression
         * @param	 boolean	$const
         */
        private function _linear_regression($yValues, $xValues, $const)
        {
        }
        //	function _linear_regression()
        /**
         * Define the regression and calculate the goodness of fit for a set of X and Y data values
         *
         * @param	float[]		$yValues	The set of Y-values for this regression
         * @param	float[]		$xValues	The set of X-values for this regression
         * @param	boolean		$const
         */
        function __construct($yValues, $xValues = array(), $const = \True)
        {
        }
        //	function __construct()
    }
    /**
     * PHPExcel_Logarithmic_Best_Fit
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared_Trend
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Logarithmic_Best_Fit extends \PHPExcel_Best_Fit
    {
        /**
         * Algorithm type to use for best-fit
         * (Name of this trend class)
         *
         * @var	string
         **/
        protected $_bestFitType = 'logarithmic';
        /**
         * Return the Y-Value for a specified value of X
         *
         * @param	 float		$xValue			X-Value
         * @return	 float						Y-Value
         **/
        public function getValueOfYForX($xValue)
        {
        }
        //	function getValueOfYForX()
        /**
         * Return the X-Value for a specified value of Y
         *
         * @param	 float		$yValue			Y-Value
         * @return	 float						X-Value
         **/
        public function getValueOfXForY($yValue)
        {
        }
        //	function getValueOfXForY()
        /**
         * Return the Equation of the best-fit line
         *
         * @param	 int		$dp		Number of places of decimal precision to display
         * @return	 string
         **/
        public function getEquation($dp = 0)
        {
        }
        //	function getEquation()
        /**
         * Execute the regression and calculate the goodness of fit for a set of X and Y data values
         *
         * @param	 float[]	$yValues	The set of Y-values for this regression
         * @param	 float[]	$xValues	The set of X-values for this regression
         * @param	 boolean	$const
         */
        private function _logarithmic_regression($yValues, $xValues, $const)
        {
        }
        //	function _logarithmic_regression()
        /**
         * Define the regression and calculate the goodness of fit for a set of X and Y data values
         *
         * @param	float[]		$yValues	The set of Y-values for this regression
         * @param	float[]		$xValues	The set of X-values for this regression
         * @param	boolean		$const
         */
        function __construct($yValues, $xValues = array(), $const = \True)
        {
        }
        //	function __construct()
    }
    /**
     * PHPExcel_trendClass
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared_Trend
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class trendClass
    {
        const TREND_LINEAR = 'Linear';
        const TREND_LOGARITHMIC = 'Logarithmic';
        const TREND_EXPONENTIAL = 'Exponential';
        const TREND_POWER = 'Power';
        const TREND_POLYNOMIAL_2 = 'Polynomial_2';
        const TREND_POLYNOMIAL_3 = 'Polynomial_3';
        const TREND_POLYNOMIAL_4 = 'Polynomial_4';
        const TREND_POLYNOMIAL_5 = 'Polynomial_5';
        const TREND_POLYNOMIAL_6 = 'Polynomial_6';
        const TREND_BEST_FIT = 'Bestfit';
        const TREND_BEST_FIT_NO_POLY = 'Bestfit_no_Polynomials';
        /**
         * Names of the best-fit trend analysis methods
         *
         * @var string[]
         **/
        private static $_trendTypes = array(self::TREND_LINEAR, self::TREND_LOGARITHMIC, self::TREND_EXPONENTIAL, self::TREND_POWER);
        /**
         * Names of the best-fit trend polynomial orders
         *
         * @var string[]
         **/
        private static $_trendTypePolyOrders = array(self::TREND_POLYNOMIAL_2, self::TREND_POLYNOMIAL_3, self::TREND_POLYNOMIAL_4, self::TREND_POLYNOMIAL_5, self::TREND_POLYNOMIAL_6);
        /**
         * Cached results for each method when trying to identify which provides the best fit
         *
         * @var PHPExcel_Best_Fit[]
         **/
        private static $_trendCache = array();
        public static function calculate($trendType = self::TREND_BEST_FIT, $yValues, $xValues = array(), $const = \True)
        {
        }
        //	function calculate()
    }
    /**
     * PHPExcel_Power_Best_Fit
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared_Trend
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Power_Best_Fit extends \PHPExcel_Best_Fit
    {
        /**
         * Algorithm type to use for best-fit
         * (Name of this trend class)
         *
         * @var	string
         **/
        protected $_bestFitType = 'power';
        /**
         * Return the Y-Value for a specified value of X
         *
         * @param	 float		$xValue			X-Value
         * @return	 float						Y-Value
         **/
        public function getValueOfYForX($xValue)
        {
        }
        //	function getValueOfYForX()
        /**
         * Return the X-Value for a specified value of Y
         *
         * @param	 float		$yValue			Y-Value
         * @return	 float						X-Value
         **/
        public function getValueOfXForY($yValue)
        {
        }
        //	function getValueOfXForY()
        /**
         * Return the Equation of the best-fit line
         *
         * @param	 int		$dp		Number of places of decimal precision to display
         * @return	 string
         **/
        public function getEquation($dp = 0)
        {
        }
        //	function getEquation()
        /**
         * Return the Value of X where it intersects Y = 0
         *
         * @param	 int		$dp		Number of places of decimal precision to display
         * @return	 string
         **/
        public function getIntersect($dp = 0)
        {
        }
        //	function getIntersect()
        /**
         * Execute the regression and calculate the goodness of fit for a set of X and Y data values
         *
         * @param	 float[]	$yValues	The set of Y-values for this regression
         * @param	 float[]	$xValues	The set of X-values for this regression
         * @param	 boolean	$const
         */
        private function _power_regression($yValues, $xValues, $const)
        {
        }
        //	function _power_regression()
        /**
         * Define the regression and calculate the goodness of fit for a set of X and Y data values
         *
         * @param	 float[]	$yValues	The set of Y-values for this regression
         * @param	 float[]	$xValues	The set of X-values for this regression
         * @param	 boolean	$const
         */
        function __construct($yValues, $xValues = array(), $const = \True)
        {
        }
        //	function __construct()
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Shared_Font
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Shared_Font
    {
        /* Methods for resolving autosize value */
        const AUTOSIZE_METHOD_APPROX = 'approx';
        const AUTOSIZE_METHOD_EXACT = 'exact';
        private static $_autoSizeMethods = array(self::AUTOSIZE_METHOD_APPROX, self::AUTOSIZE_METHOD_EXACT);
        /** Character set codes used by BIFF5-8 in Font records */
        const CHARSET_ANSI_LATIN = 0x0;
        const CHARSET_SYSTEM_DEFAULT = 0x1;
        const CHARSET_SYMBOL = 0x2;
        const CHARSET_APPLE_ROMAN = 0x4d;
        const CHARSET_ANSI_JAPANESE_SHIFTJIS = 0x80;
        const CHARSET_ANSI_KOREAN_HANGUL = 0x81;
        const CHARSET_ANSI_KOREAN_JOHAB = 0x82;
        const CHARSET_ANSI_CHINESE_SIMIPLIFIED = 0x86;
        //	gb2312
        const CHARSET_ANSI_CHINESE_TRADITIONAL = 0x88;
        //	big5
        const CHARSET_ANSI_GREEK = 0xa1;
        const CHARSET_ANSI_TURKISH = 0xa2;
        const CHARSET_ANSI_VIETNAMESE = 0xa3;
        const CHARSET_ANSI_HEBREW = 0xb1;
        const CHARSET_ANSI_ARABIC = 0xb2;
        const CHARSET_ANSI_BALTIC = 0xba;
        const CHARSET_ANSI_CYRILLIC = 0xcc;
        const CHARSET_ANSI_THAI = 0xdd;
        const CHARSET_ANSI_LATIN_II = 0xee;
        const CHARSET_OEM_LATIN_I = 0xff;
        //  XXX: Constants created!
        /** Font filenames */
        const ARIAL = 'arial.ttf';
        const ARIAL_BOLD = 'arialbd.ttf';
        const ARIAL_ITALIC = 'ariali.ttf';
        const ARIAL_BOLD_ITALIC = 'arialbi.ttf';
        const CALIBRI = 'CALIBRI.TTF';
        const CALIBRI_BOLD = 'CALIBRIB.TTF';
        const CALIBRI_ITALIC = 'CALIBRII.TTF';
        const CALIBRI_BOLD_ITALIC = 'CALIBRIZ.TTF';
        const COMIC_SANS_MS = 'comic.ttf';
        const COMIC_SANS_MS_BOLD = 'comicbd.ttf';
        const COURIER_NEW = 'cour.ttf';
        const COURIER_NEW_BOLD = 'courbd.ttf';
        const COURIER_NEW_ITALIC = 'couri.ttf';
        const COURIER_NEW_BOLD_ITALIC = 'courbi.ttf';
        const GEORGIA = 'georgia.ttf';
        const GEORGIA_BOLD = 'georgiab.ttf';
        const GEORGIA_ITALIC = 'georgiai.ttf';
        const GEORGIA_BOLD_ITALIC = 'georgiaz.ttf';
        const IMPACT = 'impact.ttf';
        const LIBERATION_SANS = 'LiberationSans-Regular.ttf';
        const LIBERATION_SANS_BOLD = 'LiberationSans-Bold.ttf';
        const LIBERATION_SANS_ITALIC = 'LiberationSans-Italic.ttf';
        const LIBERATION_SANS_BOLD_ITALIC = 'LiberationSans-BoldItalic.ttf';
        const LUCIDA_CONSOLE = 'lucon.ttf';
        const LUCIDA_SANS_UNICODE = 'l_10646.ttf';
        const MICROSOFT_SANS_SERIF = 'micross.ttf';
        const PALATINO_LINOTYPE = 'pala.ttf';
        const PALATINO_LINOTYPE_BOLD = 'palab.ttf';
        const PALATINO_LINOTYPE_ITALIC = 'palai.ttf';
        const PALATINO_LINOTYPE_BOLD_ITALIC = 'palabi.ttf';
        const SYMBOL = 'symbol.ttf';
        const TAHOMA = 'tahoma.ttf';
        const TAHOMA_BOLD = 'tahomabd.ttf';
        const TIMES_NEW_ROMAN = 'times.ttf';
        const TIMES_NEW_ROMAN_BOLD = 'timesbd.ttf';
        const TIMES_NEW_ROMAN_ITALIC = 'timesi.ttf';
        const TIMES_NEW_ROMAN_BOLD_ITALIC = 'timesbi.ttf';
        const TREBUCHET_MS = 'trebuc.ttf';
        const TREBUCHET_MS_BOLD = 'trebucbd.ttf';
        const TREBUCHET_MS_ITALIC = 'trebucit.ttf';
        const TREBUCHET_MS_BOLD_ITALIC = 'trebucbi.ttf';
        const VERDANA = 'verdana.ttf';
        const VERDANA_BOLD = 'verdanab.ttf';
        const VERDANA_ITALIC = 'verdanai.ttf';
        const VERDANA_BOLD_ITALIC = 'verdanaz.ttf';
        /**
         * AutoSize method
         *
         * @var string
         */
        private static $autoSizeMethod = self::AUTOSIZE_METHOD_APPROX;
        /**
         * Path to folder containing TrueType font .ttf files
         *
         * @var string
         */
        private static $trueTypeFontPath = \null;
        /**
         * How wide is a default column for a given default font and size?
         * Empirical data found by inspecting real Excel files and reading off the pixel width
         * in Microsoft Office Excel 2007.
         *
         * @var array
         */
        public static $defaultColumnWidths = array('Arial' => array(1 => array('px' => 24, 'width' => 12.0), 2 => array('px' => 24, 'width' => 12.0), 3 => array('px' => 32, 'width' => 10.6640625), 4 => array('px' => 32, 'width' => 10.6640625), 5 => array('px' => 40, 'width' => 10.0), 6 => array('px' => 48, 'width' => 9.59765625), 7 => array('px' => 48, 'width' => 9.59765625), 8 => array('px' => 56, 'width' => 9.33203125), 9 => array('px' => 64, 'width' => 9.140625), 10 => array('px' => 64, 'width' => 9.140625)), 'Calibri' => array(1 => array('px' => 24, 'width' => 12.0), 2 => array('px' => 24, 'width' => 12.0), 3 => array('px' => 32, 'width' => 10.6640625), 4 => array('px' => 32, 'width' => 10.6640625), 5 => array('px' => 40, 'width' => 10.0), 6 => array('px' => 48, 'width' => 9.59765625), 7 => array('px' => 48, 'width' => 9.59765625), 8 => array('px' => 56, 'width' => 9.33203125), 9 => array('px' => 56, 'width' => 9.33203125), 10 => array('px' => 64, 'width' => 9.140625), 11 => array('px' => 64, 'width' => 9.140625)), 'Verdana' => array(1 => array('px' => 24, 'width' => 12.0), 2 => array('px' => 24, 'width' => 12.0), 3 => array('px' => 32, 'width' => 10.6640625), 4 => array('px' => 32, 'width' => 10.6640625), 5 => array('px' => 40, 'width' => 10.0), 6 => array('px' => 48, 'width' => 9.59765625), 7 => array('px' => 48, 'width' => 9.59765625), 8 => array('px' => 64, 'width' => 9.140625), 9 => array('px' => 72, 'width' => 9.0), 10 => array('px' => 72, 'width' => 9.0)));
        /**
         * Set autoSize method
         *
         * @param string $pValue
         * @return	 boolean					Success or failure
         */
        public static function setAutoSizeMethod($pValue = self::AUTOSIZE_METHOD_APPROX)
        {
        }
        /**
         * Get autoSize method
         *
         * @return string
         */
        public static function getAutoSizeMethod()
        {
        }
        /**
         * Set the path to the folder containing .ttf files. There should be a trailing slash.
         * Typical locations on variout some platforms:
         *	<ul>
         *		<li>C:/Windows/Fonts/</li>
         *		<li>/usr/share/fonts/truetype/</li>
         *		<li>~/.fonts/</li>
         *	</ul>
         *
         * @param string $pValue
         */
        public static function setTrueTypeFontPath($pValue = '')
        {
        }
        /**
         * Get the path to the folder containing .ttf files.
         *
         * @return string
         */
        public static function getTrueTypeFontPath()
        {
        }
        /**
         * Calculate an (approximate) OpenXML column width, based on font size and text contained
         *
         * @param 	PHPExcel_Style_Font			$font			Font object
         * @param 	PHPExcel_RichText|string	$cellText		Text to calculate width
         * @param 	integer						$rotation		Rotation angle
         * @param 	PHPExcel_Style_Font|NULL	$defaultFont	Font object
         * @return 	integer		Column width
         */
        public static function calculateColumnWidth(\PHPExcel_Style_Font $font, $cellText = '', $rotation = 0, \PHPExcel_Style_Font $defaultFont = \null)
        {
        }
        /**
         * Get GD text width in pixels for a string of text in a certain font at a certain rotation angle
         *
         * @param string $text
         * @param PHPExcel_Style_Font
         * @param int $rotation
         * @return int
         * @throws PHPExcel_Exception
         */
        public static function getTextWidthPixelsExact($text, \PHPExcel_Style_Font $font, $rotation = 0)
        {
        }
        /**
         * Get approximate width in pixels for a string of text in a certain font at a certain rotation angle
         *
         * @param string $columnText
         * @param PHPExcel_Style_Font $font
         * @param int $rotation
         * @return int Text width in pixels (no padding added)
         */
        public static function getTextWidthPixelsApprox($columnText, \PHPExcel_Style_Font $font = \null, $rotation = 0)
        {
        }
        /**
         * Calculate an (approximate) pixel size, based on a font points size
         *
         * @param 	int		$fontSizeInPoints	Font size (in points)
         * @return 	int		Font size (in pixels)
         */
        public static function fontSizeToPixels($fontSizeInPoints = 11)
        {
        }
        /**
         * Calculate an (approximate) pixel size, based on inch size
         *
         * @param 	int		$sizeInInch	Font size (in inch)
         * @return 	int		Size (in pixels)
         */
        public static function inchSizeToPixels($sizeInInch = 1)
        {
        }
        /**
         * Calculate an (approximate) pixel size, based on centimeter size
         *
         * @param 	int		$sizeInCm	Font size (in centimeters)
         * @return 	int		Size (in pixels)
         */
        public static function centimeterSizeToPixels($sizeInCm = 1)
        {
        }
        /**
         * Returns the font path given the font
         *
         * @param PHPExcel_Style_Font
         * @return string Path to TrueType font file
         */
        public static function getTrueTypeFontFileFromFont($font)
        {
        }
        /**
         * Returns the associated charset for the font name.
         *
         * @param string $name Font name
         * @return int Character set code
         */
        public static function getCharsetFromFontName($name)
        {
        }
        /**
         * Get the effective column width for columns without a column dimension or column with width -1
         * For example, for Calibri 11 this is 9.140625 (64 px)
         *
         * @param PHPExcel_Style_Font $font The workbooks default font
         * @param boolean $pPixels true = return column width in pixels, false = return in OOXML units
         * @return mixed Column width
         */
        public static function getDefaultColumnWidthByFont(\PHPExcel_Style_Font $font, $pPixels = \false)
        {
        }
        /**
         * Get the effective row height for rows without a row dimension or rows with height -1
         * For example, for Calibri 11 this is 15 points
         *
         * @param PHPExcel_Style_Font $font The workbooks default font
         * @return float Row height in points
         */
        public static function getDefaultRowHeightByFont(\PHPExcel_Style_Font $font)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Shared_Drawing
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Shared_Drawing
    {
        /**
         * Convert pixels to EMU
         *
         * @param 	int $pValue	Value in pixels
         * @return 	int			Value in EMU
         */
        public static function pixelsToEMU($pValue = 0)
        {
        }
        /**
         * Convert EMU to pixels
         *
         * @param 	int $pValue	Value in EMU
         * @return 	int			Value in pixels
         */
        public static function EMUToPixels($pValue = 0)
        {
        }
        /**
         * Convert pixels to column width. Exact algorithm not known.
         * By inspection of a real Excel file using Calibri 11, one finds 1000px ~ 142.85546875
         * This gives a conversion factor of 7. Also, we assume that pixels and font size are proportional.
         *
         * @param 	int $pValue	Value in pixels
         * @param 	PHPExcel_Style_Font $pDefaultFont	Default font of the workbook
         * @return 	int			Value in cell dimension
         */
        public static function pixelsToCellDimension($pValue = 0, \PHPExcel_Style_Font $pDefaultFont)
        {
        }
        /**
         * Convert column width from (intrinsic) Excel units to pixels
         *
         * @param 	float	$pValue		Value in cell dimension
         * @param 	PHPExcel_Style_Font $pDefaultFont	Default font of the workbook
         * @return 	int		Value in pixels
         */
        public static function cellDimensionToPixels($pValue = 0, \PHPExcel_Style_Font $pDefaultFont)
        {
        }
        /**
         * Convert pixels to points
         *
         * @param 	int $pValue	Value in pixels
         * @return 	int			Value in points
         */
        public static function pixelsToPoints($pValue = 0)
        {
        }
        /**
         * Convert points to pixels
         *
         * @param 	int $pValue	Value in points
         * @return 	int			Value in pixels
         */
        public static function pointsToPixels($pValue = 0)
        {
        }
        /**
         * Convert degrees to angle
         *
         * @param 	int $pValue	Degrees
         * @return 	int			Angle
         */
        public static function degreesToAngle($pValue = 0)
        {
        }
        /**
         * Convert angle to degrees
         *
         * @param 	int $pValue	Angle
         * @return 	int			Degrees
         */
        public static function angleToDegrees($pValue = 0)
        {
        }
        /**
         * Create a new image from file. By alexander at alexauto dot nl
         *
         * @link http://www.php.net/manual/en/function.imagecreatefromwbmp.php#86214
         * @param string $filename Path to Windows DIB (BMP) image
         * @return resource
         */
        public static function imagecreatefrombmp($p_sFile)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared_Escher
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Shared_Escher
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared_Escher
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Shared_Escher
    {
        /**
         * Drawing Group Container
         *
         * @var PHPExcel_Shared_Escher_DggContainer
         */
        private $_dggContainer;
        /**
         * Drawing Container
         *
         * @var PHPExcel_Shared_Escher_DgContainer
         */
        private $_dgContainer;
        /**
         * Get Drawing Group Container
         *
         * @return PHPExcel_Shared_Escher_DgContainer
         */
        public function getDggContainer()
        {
        }
        /**
         * Set Drawing Group Container
         *
         * @param PHPExcel_Shared_Escher_DggContainer $dggContainer
         */
        public function setDggContainer($dggContainer)
        {
        }
        /**
         * Get Drawing Container
         *
         * @return PHPExcel_Shared_Escher_DgContainer
         */
        public function getDgContainer()
        {
        }
        /**
         * Set Drawing Container
         *
         * @param PHPExcel_Shared_Escher_DgContainer $dgContainer
         */
        public function setDgContainer($dgContainer)
        {
        }
    }
    class PHPExcel_Shared_OLERead
    {
        private $data = '';
        // OLE identifier
        const IDENTIFIER_OLE = \IDENTIFIER_OLE;
        // Size of a sector = 512 bytes
        const BIG_BLOCK_SIZE = 0x200;
        // Size of a short sector = 64 bytes
        const SMALL_BLOCK_SIZE = 0x40;
        // Size of a directory entry always = 128 bytes
        const PROPERTY_STORAGE_BLOCK_SIZE = 0x80;
        // Minimum size of a standard stream = 4096 bytes, streams smaller than this are stored as short streams
        const SMALL_BLOCK_THRESHOLD = 0x1000;
        // header offsets
        const NUM_BIG_BLOCK_DEPOT_BLOCKS_POS = 0x2c;
        const ROOT_START_BLOCK_POS = 0x30;
        const SMALL_BLOCK_DEPOT_BLOCK_POS = 0x3c;
        const EXTENSION_BLOCK_POS = 0x44;
        const NUM_EXTENSION_BLOCK_POS = 0x48;
        const BIG_BLOCK_DEPOT_BLOCKS_POS = 0x4c;
        // property storage offsets (directory offsets)
        const SIZE_OF_NAME_POS = 0x40;
        const TYPE_POS = 0x42;
        const START_BLOCK_POS = 0x74;
        const SIZE_POS = 0x78;
        public $wrkbook = \null;
        public $summaryInformation = \null;
        public $documentSummaryInformation = \null;
        /**
         * Read the file
         *
         * @param $sFileName string Filename
         * @throws PHPExcel_Reader_Exception
         */
        public function read($sFileName)
        {
        }
        /**
         * Extract binary stream data
         *
         * @return string
         */
        public function getStream($stream)
        {
        }
        /**
         * Read a standard stream (by joining sectors using information from SAT)
         *
         * @param int $bl Sector ID where the stream starts
         * @return string Data for standard stream
         */
        private function _readData($bl)
        {
        }
        /**
         * Read entries in the directory stream.
         */
        private function _readPropertySets()
        {
        }
        /**
         * Read 4 bytes of data at specified position
         *
         * @param string $data
         * @param int $pos
         * @return int
         */
        private static function _GetInt4d($data, $pos)
        {
        }
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt	LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_Shared_PasswordHasher
     *
     * @category   PHPExcel
     * @package    PHPExcel_Shared
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Shared_PasswordHasher
    {
        /**
         * Create a password hash from a given string.
         *
         * This method is based on the algorithm provided by
         * Daniel Rentz of OpenOffice and the PEAR package
         * Spreadsheet_Excel_Writer by Xavier Noguer <xnoguer@rezebra.com>.
         *
         * @param 	string	$pPassword	Password to hash
         * @return 	string				Hashed password
         */
        public static function hashPassword($pPassword = '')
        {
        }
    }
    /* For futur use
      define( 'PCLZIP_CB_PRE_LIST', 78005 );
      define( 'PCLZIP_CB_POST_LIST', 78006 );
      define( 'PCLZIP_CB_PRE_DELETE', 78007 );
      define( 'PCLZIP_CB_POST_DELETE', 78008 );
      */
    // --------------------------------------------------------------------------------
    // Class : PclZip
    // Description :
    //   PclZip is the class that represent a Zip archive.
    //   The public methods allow the manipulation of the archive.
    // Attributes :
    //   Attributes must not be accessed directly.
    // Methods :
    //   PclZip() : Object creator
    //   create() : Creates the Zip archive
    //   listContent() : List the content of the Zip archive
    //   extract() : Extract the content of the archive
    //   properties() : List the properties of the archive
    // --------------------------------------------------------------------------------
    class PclZip
    {
        // ----- Filename of the zip file
        var $zipname = '';
        // ----- File descriptor of the zip file
        var $zip_fd = 0;
        // ----- Internal error handling
        var $error_code = 1;
        var $error_string = '';
        // ----- Current status of the magic_quotes_runtime
        // This value store the php configuration for magic_quotes
        // The class can then disable the magic_quotes and reset it after
        var $magic_quotes_status;
        // --------------------------------------------------------------------------------
        // Function : PclZip()
        // Description :
        //   Creates a PclZip object and set the name of the associated Zip archive
        //   filename.
        //   Note that no real action is taken, if the archive does not exist it is not
        //   created. Use create() for that.
        // --------------------------------------------------------------------------------
        function PclZip($p_zipname)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function :
        //   create($p_filelist, $p_add_dir="", $p_remove_dir="")
        //   create($p_filelist, $p_option, $p_option_value, ...)
        // Description :
        //   This method supports two different synopsis. The first one is historical.
        //   This method creates a Zip Archive. The Zip file is created in the
        //   filesystem. The files and directories indicated in $p_filelist
        //   are added in the archive. See the parameters description for the
        //   supported format of $p_filelist.
        //   When a directory is in the list, the directory and its content is added
        //   in the archive.
        //   In this synopsis, the function takes an optional variable list of
        //   options. See bellow the supported options.
        // Parameters :
        //   $p_filelist : An array containing file or directory names, or
        //                 a string containing one filename or one directory name, or
        //                 a string containing a list of filenames and/or directory
        //                 names separated by spaces.
        //   $p_add_dir : A path to add before the real path of the archived file,
        //                in order to have it memorized in the archive.
        //   $p_remove_dir : A path to remove from the real path of the file to archive,
        //                   in order to have a shorter path memorized in the archive.
        //                   When $p_add_dir and $p_remove_dir are set, $p_remove_dir
        //                   is removed first, before $p_add_dir is added.
        // Options :
        //   PCLZIP_OPT_ADD_PATH :
        //   PCLZIP_OPT_REMOVE_PATH :
        //   PCLZIP_OPT_REMOVE_ALL_PATH :
        //   PCLZIP_OPT_COMMENT :
        //   PCLZIP_CB_PRE_ADD :
        //   PCLZIP_CB_POST_ADD :
        // Return Values :
        //   0 on failure,
        //   The list of the added files, with a status of the add action.
        //   (see PclZip::listContent() for list entry format)
        // --------------------------------------------------------------------------------
        function create($p_filelist)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function :
        //   add($p_filelist, $p_add_dir="", $p_remove_dir="")
        //   add($p_filelist, $p_option, $p_option_value, ...)
        // Description :
        //   This method supports two synopsis. The first one is historical.
        //   This methods add the list of files in an existing archive.
        //   If a file with the same name already exists, it is added at the end of the
        //   archive, the first one is still present.
        //   If the archive does not exist, it is created.
        // Parameters :
        //   $p_filelist : An array containing file or directory names, or
        //                 a string containing one filename or one directory name, or
        //                 a string containing a list of filenames and/or directory
        //                 names separated by spaces.
        //   $p_add_dir : A path to add before the real path of the archived file,
        //                in order to have it memorized in the archive.
        //   $p_remove_dir : A path to remove from the real path of the file to archive,
        //                   in order to have a shorter path memorized in the archive.
        //                   When $p_add_dir and $p_remove_dir are set, $p_remove_dir
        //                   is removed first, before $p_add_dir is added.
        // Options :
        //   PCLZIP_OPT_ADD_PATH :
        //   PCLZIP_OPT_REMOVE_PATH :
        //   PCLZIP_OPT_REMOVE_ALL_PATH :
        //   PCLZIP_OPT_COMMENT :
        //   PCLZIP_OPT_ADD_COMMENT :
        //   PCLZIP_OPT_PREPEND_COMMENT :
        //   PCLZIP_CB_PRE_ADD :
        //   PCLZIP_CB_POST_ADD :
        // Return Values :
        //   0 on failure,
        //   The list of the added files, with a status of the add action.
        //   (see PclZip::listContent() for list entry format)
        // --------------------------------------------------------------------------------
        function add($p_filelist)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : listContent()
        // Description :
        //   This public method, gives the list of the files and directories, with their
        //   properties.
        //   The properties of each entries in the list are (used also in other functions) :
        //     filename : Name of the file. For a create or add action it is the filename
        //                given by the user. For an extract function it is the filename
        //                of the extracted file.
        //     stored_filename : Name of the file / directory stored in the archive.
        //     size : Size of the stored file.
        //     compressed_size : Size of the file's data compressed in the archive
        //                       (without the headers overhead)
        //     mtime : Last known modification date of the file (UNIX timestamp)
        //     comment : Comment associated with the file
        //     folder : true | false
        //     index : index of the file in the archive
        //     status : status of the action (depending of the action) :
        //              Values are :
        //                ok : OK !
        //                filtered : the file / dir is not extracted (filtered by user)
        //                already_a_directory : the file can not be extracted because a
        //                                      directory with the same name already exists
        //                write_protected : the file can not be extracted because a file
        //                                  with the same name already exists and is
        //                                  write protected
        //                newer_exist : the file was not extracted because a newer file exists
        //                path_creation_fail : the file is not extracted because the folder
        //                                     does not exist and can not be created
        //                write_error : the file was not extracted because there was a
        //                              error while writing the file
        //                read_error : the file was not extracted because there was a error
        //                             while reading the file
        //                invalid_header : the file was not extracted because of an archive
        //                                 format error (bad file header)
        //   Note that each time a method can continue operating when there
        //   is an action error on a file, the error is only logged in the file status.
        // Return Values :
        //   0 on an unrecoverable failure,
        //   The list of the files in the archive.
        // --------------------------------------------------------------------------------
        function listContent()
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function :
        //   extract($p_path="./", $p_remove_path="")
        //   extract([$p_option, $p_option_value, ...])
        // Description :
        //   This method supports two synopsis. The first one is historical.
        //   This method extract all the files / directories from the archive to the
        //   folder indicated in $p_path.
        //   If you want to ignore the 'root' part of path of the memorized files
        //   you can indicate this in the optional $p_remove_path parameter.
        //   By default, if a newer file with the same name already exists, the
        //   file is not extracted.
        //
        //   If both PCLZIP_OPT_PATH and PCLZIP_OPT_ADD_PATH aoptions
        //   are used, the path indicated in PCLZIP_OPT_ADD_PATH is append
        //   at the end of the path value of PCLZIP_OPT_PATH.
        // Parameters :
        //   $p_path : Path where the files and directories are to be extracted
        //   $p_remove_path : First part ('root' part) of the memorized path
        //                    (if any similar) to remove while extracting.
        // Options :
        //   PCLZIP_OPT_PATH :
        //   PCLZIP_OPT_ADD_PATH :
        //   PCLZIP_OPT_REMOVE_PATH :
        //   PCLZIP_OPT_REMOVE_ALL_PATH :
        //   PCLZIP_CB_PRE_EXTRACT :
        //   PCLZIP_CB_POST_EXTRACT :
        // Return Values :
        //   0 or a negative value on failure,
        //   The list of the extracted files, with a status of the action.
        //   (see PclZip::listContent() for list entry format)
        // --------------------------------------------------------------------------------
        function extract()
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function :
        //   extractByIndex($p_index, $p_path="./", $p_remove_path="")
        //   extractByIndex($p_index, [$p_option, $p_option_value, ...])
        // Description :
        //   This method supports two synopsis. The first one is historical.
        //   This method is doing a partial extract of the archive.
        //   The extracted files or folders are identified by their index in the
        //   archive (from 0 to n).
        //   Note that if the index identify a folder, only the folder entry is
        //   extracted, not all the files included in the archive.
        // Parameters :
        //   $p_index : A single index (integer) or a string of indexes of files to
        //              extract. The form of the string is "0,4-6,8-12" with only numbers
        //              and '-' for range or ',' to separate ranges. No spaces or ';'
        //              are allowed.
        //   $p_path : Path where the files and directories are to be extracted
        //   $p_remove_path : First part ('root' part) of the memorized path
        //                    (if any similar) to remove while extracting.
        // Options :
        //   PCLZIP_OPT_PATH :
        //   PCLZIP_OPT_ADD_PATH :
        //   PCLZIP_OPT_REMOVE_PATH :
        //   PCLZIP_OPT_REMOVE_ALL_PATH :
        //   PCLZIP_OPT_EXTRACT_AS_STRING : The files are extracted as strings and
        //     not as files.
        //     The resulting content is in a new field 'content' in the file
        //     structure.
        //     This option must be used alone (any other options are ignored).
        //   PCLZIP_CB_PRE_EXTRACT :
        //   PCLZIP_CB_POST_EXTRACT :
        // Return Values :
        //   0 on failure,
        //   The list of the extracted files, with a status of the action.
        //   (see PclZip::listContent() for list entry format)
        // --------------------------------------------------------------------------------
        //function extractByIndex($p_index, options...)
        function extractByIndex($p_index)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function :
        //   delete([$p_option, $p_option_value, ...])
        // Description :
        //   This method removes files from the archive.
        //   If no parameters are given, then all the archive is emptied.
        // Parameters :
        //   None or optional arguments.
        // Options :
        //   PCLZIP_OPT_BY_INDEX :
        //   PCLZIP_OPT_BY_NAME :
        //   PCLZIP_OPT_BY_EREG :
        //   PCLZIP_OPT_BY_PREG :
        // Return Values :
        //   0 on failure,
        //   The list of the files which are still present in the archive.
        //   (see PclZip::listContent() for list entry format)
        // --------------------------------------------------------------------------------
        function delete()
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : deleteByIndex()
        // Description :
        //   ***** Deprecated *****
        //   delete(PCLZIP_OPT_BY_INDEX, $p_index) should be prefered.
        // --------------------------------------------------------------------------------
        function deleteByIndex($p_index)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : properties()
        // Description :
        //   This method gives the properties of the archive.
        //   The properties are :
        //     nb : Number of files in the archive
        //     comment : Comment associated with the archive file
        //     status : not_exist, ok
        // Parameters :
        //   None
        // Return Values :
        //   0 on failure,
        //   An array with the archive properties.
        // --------------------------------------------------------------------------------
        function properties()
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : duplicate()
        // Description :
        //   This method creates an archive by copying the content of an other one. If
        //   the archive already exist, it is replaced by the new one without any warning.
        // Parameters :
        //   $p_archive : The filename of a valid archive, or
        //                a valid PclZip object.
        // Return Values :
        //   1 on success.
        //   0 or a negative value on error (error code).
        // --------------------------------------------------------------------------------
        function duplicate($p_archive)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : merge()
        // Description :
        //   This method merge the $p_archive_to_add archive at the end of the current
        //   one ($this).
        //   If the archive ($this) does not exist, the merge becomes a duplicate.
        //   If the $p_archive_to_add archive does not exist, the merge is a success.
        // Parameters :
        //   $p_archive_to_add : It can be directly the filename of a valid zip archive,
        //                       or a PclZip object archive.
        // Return Values :
        //   1 on success,
        //   0 or negative values on error (see below).
        // --------------------------------------------------------------------------------
        function merge($p_archive_to_add)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : errorCode()
        // Description :
        // Parameters :
        // --------------------------------------------------------------------------------
        function errorCode()
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : errorName()
        // Description :
        // Parameters :
        // --------------------------------------------------------------------------------
        function errorName($p_with_code = \false)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : errorInfo()
        // Description :
        // Parameters :
        // --------------------------------------------------------------------------------
        function errorInfo($p_full = \false)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // ***** UNDER THIS LINE ARE DEFINED PRIVATE INTERNAL FUNCTIONS *****
        // *****                                                        *****
        // *****       THESES FUNCTIONS MUST NOT BE USED DIRECTLY       *****
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privCheckFormat()
        // Description :
        //   This method check that the archive exists and is a valid zip archive.
        //   Several level of check exists. (futur)
        // Parameters :
        //   $p_level : Level of check. Default 0.
        //              0 : Check the first bytes (magic codes) (default value))
        //              1 : 0 + Check the central directory (futur)
        //              2 : 1 + Check each file header (futur)
        // Return Values :
        //   true on success,
        //   false on error, the error code is set.
        // --------------------------------------------------------------------------------
        function privCheckFormat($p_level = 0)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privParseOptions()
        // Description :
        //   This internal methods reads the variable list of arguments ($p_options_list,
        //   $p_size) and generate an array with the options and values ($v_result_list).
        //   $v_requested_options contains the options that can be present and those that
        //   must be present.
        //   $v_requested_options is an array, with the option value as key, and 'optional',
        //   or 'mandatory' as value.
        // Parameters :
        //   See above.
        // Return Values :
        //   1 on success.
        //   0 on failure.
        // --------------------------------------------------------------------------------
        function privParseOptions(&$p_options_list, $p_size, &$v_result_list, $v_requested_options = \false)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privOptionDefaultThreshold()
        // Description :
        // Parameters :
        // Return Values :
        // --------------------------------------------------------------------------------
        function privOptionDefaultThreshold(&$p_options)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privFileDescrParseAtt()
        // Description :
        // Parameters :
        // Return Values :
        //   1 on success.
        //   0 on failure.
        // --------------------------------------------------------------------------------
        function privFileDescrParseAtt(&$p_file_list, &$p_filedescr, $v_options, $v_requested_options = \false)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privFileDescrExpand()
        // Description :
        //   This method look for each item of the list to see if its a file, a folder
        //   or a string to be added as file. For any other type of files (link, other)
        //   just ignore the item.
        //   Then prepare the information that will be stored for that file.
        //   When its a folder, expand the folder with all the files that are in that
        //   folder (recursively).
        // Parameters :
        // Return Values :
        //   1 on success.
        //   0 on failure.
        // --------------------------------------------------------------------------------
        function privFileDescrExpand(&$p_filedescr_list, &$p_options)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privCreate()
        // Description :
        // Parameters :
        // Return Values :
        // --------------------------------------------------------------------------------
        function privCreate($p_filedescr_list, &$p_result_list, &$p_options)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privAdd()
        // Description :
        // Parameters :
        // Return Values :
        // --------------------------------------------------------------------------------
        function privAdd($p_filedescr_list, &$p_result_list, &$p_options)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privOpenFd()
        // Description :
        // Parameters :
        // --------------------------------------------------------------------------------
        function privOpenFd($p_mode)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privCloseFd()
        // Description :
        // Parameters :
        // --------------------------------------------------------------------------------
        function privCloseFd()
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privAddList()
        // Description :
        //   $p_add_dir and $p_remove_dir will give the ability to memorize a path which is
        //   different from the real path of the file. This is usefull if you want to have PclTar
        //   running in any directory, and memorize relative path from an other directory.
        // Parameters :
        //   $p_list : An array containing the file or directory names to add in the tar
        //   $p_result_list : list of added files with their properties (specially the status field)
        //   $p_add_dir : Path to add in the filename path archived
        //   $p_remove_dir : Path to remove in the filename path archived
        // Return Values :
        // --------------------------------------------------------------------------------
        //  function privAddList($p_list, &$p_result_list, $p_add_dir, $p_remove_dir, $p_remove_all_dir, &$p_options)
        function privAddList($p_filedescr_list, &$p_result_list, &$p_options)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privAddFileList()
        // Description :
        // Parameters :
        //   $p_filedescr_list : An array containing the file description
        //                      or directory names to add in the zip
        //   $p_result_list : list of added files with their properties (specially the status field)
        // Return Values :
        // --------------------------------------------------------------------------------
        function privAddFileList($p_filedescr_list, &$p_result_list, &$p_options)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privAddFile()
        // Description :
        // Parameters :
        // Return Values :
        // --------------------------------------------------------------------------------
        function privAddFile($p_filedescr, &$p_header, &$p_options)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privAddFileUsingTempFile()
        // Description :
        // Parameters :
        // Return Values :
        // --------------------------------------------------------------------------------
        function privAddFileUsingTempFile($p_filedescr, &$p_header, &$p_options)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privCalculateStoredFilename()
        // Description :
        //   Based on file descriptor properties and global options, this method
        //   calculate the filename that will be stored in the archive.
        // Parameters :
        // Return Values :
        // --------------------------------------------------------------------------------
        function privCalculateStoredFilename(&$p_filedescr, &$p_options)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privWriteFileHeader()
        // Description :
        // Parameters :
        // Return Values :
        // --------------------------------------------------------------------------------
        function privWriteFileHeader(&$p_header)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privWriteCentralFileHeader()
        // Description :
        // Parameters :
        // Return Values :
        // --------------------------------------------------------------------------------
        function privWriteCentralFileHeader(&$p_header)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privWriteCentralHeader()
        // Description :
        // Parameters :
        // Return Values :
        // --------------------------------------------------------------------------------
        function privWriteCentralHeader($p_nb_entries, $p_size, $p_offset, $p_comment)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privList()
        // Description :
        // Parameters :
        // Return Values :
        // --------------------------------------------------------------------------------
        function privList(&$p_list)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privConvertHeader2FileInfo()
        // Description :
        //   This function takes the file informations from the central directory
        //   entries and extract the interesting parameters that will be given back.
        //   The resulting file infos are set in the array $p_info
        //     $p_info['filename'] : Filename with full path. Given by user (add),
        //                           extracted in the filesystem (extract).
        //     $p_info['stored_filename'] : Stored filename in the archive.
        //     $p_info['size'] = Size of the file.
        //     $p_info['compressed_size'] = Compressed size of the file.
        //     $p_info['mtime'] = Last modification date of the file.
        //     $p_info['comment'] = Comment associated with the file.
        //     $p_info['folder'] = true/false : indicates if the entry is a folder or not.
        //     $p_info['status'] = status of the action on the file.
        //     $p_info['crc'] = CRC of the file content.
        // Parameters :
        // Return Values :
        // --------------------------------------------------------------------------------
        function privConvertHeader2FileInfo($p_header, &$p_info)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privExtractByRule()
        // Description :
        //   Extract a file or directory depending of rules (by index, by name, ...)
        // Parameters :
        //   $p_file_list : An array where will be placed the properties of each
        //                  extracted file
        //   $p_path : Path to add while writing the extracted files
        //   $p_remove_path : Path to remove (from the file memorized path) while writing the
        //                    extracted files. If the path does not match the file path,
        //                    the file is extracted with its memorized path.
        //                    $p_remove_path does not apply to 'list' mode.
        //                    $p_path and $p_remove_path are commulative.
        // Return Values :
        //   1 on success,0 or less on error (see error code list)
        // --------------------------------------------------------------------------------
        function privExtractByRule(&$p_file_list, $p_path, $p_remove_path, $p_remove_all_path, &$p_options)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privExtractFile()
        // Description :
        // Parameters :
        // Return Values :
        //
        // 1 : ... ?
        // PCLZIP_ERR_USER_ABORTED(2) : User ask for extraction stop in callback
        // --------------------------------------------------------------------------------
        function privExtractFile(&$p_entry, $p_path, $p_remove_path, $p_remove_all_path, &$p_options)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privExtractFileUsingTempFile()
        // Description :
        // Parameters :
        // Return Values :
        // --------------------------------------------------------------------------------
        function privExtractFileUsingTempFile(&$p_entry, &$p_options)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privExtractFileInOutput()
        // Description :
        // Parameters :
        // Return Values :
        // --------------------------------------------------------------------------------
        function privExtractFileInOutput(&$p_entry, &$p_options)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privExtractFileAsString()
        // Description :
        // Parameters :
        // Return Values :
        // --------------------------------------------------------------------------------
        function privExtractFileAsString(&$p_entry, &$p_string, &$p_options)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privReadFileHeader()
        // Description :
        // Parameters :
        // Return Values :
        // --------------------------------------------------------------------------------
        function privReadFileHeader(&$p_header)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privReadCentralFileHeader()
        // Description :
        // Parameters :
        // Return Values :
        // --------------------------------------------------------------------------------
        function privReadCentralFileHeader(&$p_header)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privCheckFileHeaders()
        // Description :
        // Parameters :
        // Return Values :
        //   1 on success,
        //   0 on error;
        // --------------------------------------------------------------------------------
        function privCheckFileHeaders(&$p_local_header, &$p_central_header)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privReadEndCentralDir()
        // Description :
        // Parameters :
        // Return Values :
        // --------------------------------------------------------------------------------
        function privReadEndCentralDir(&$p_central_dir)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privDeleteByRule()
        // Description :
        // Parameters :
        // Return Values :
        // --------------------------------------------------------------------------------
        function privDeleteByRule(&$p_result_list, &$p_options)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privDirCheck()
        // Description :
        //   Check if a directory exists, if not it creates it and all the parents directory
        //   which may be useful.
        // Parameters :
        //   $p_dir : Directory path to check.
        // Return Values :
        //    1 : OK
        //   -1 : Unable to create directory
        // --------------------------------------------------------------------------------
        function privDirCheck($p_dir, $p_is_dir = \false)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privMerge()
        // Description :
        //   If $p_archive_to_add does not exist, the function exit with a success result.
        // Parameters :
        // Return Values :
        // --------------------------------------------------------------------------------
        function privMerge(&$p_archive_to_add)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privDuplicate()
        // Description :
        // Parameters :
        // Return Values :
        // --------------------------------------------------------------------------------
        function privDuplicate($p_archive_filename)
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privErrorLog()
        // Description :
        // Parameters :
        // --------------------------------------------------------------------------------
        function privErrorLog($p_error_code = 0, $p_error_string = '')
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privErrorReset()
        // Description :
        // Parameters :
        // --------------------------------------------------------------------------------
        function privErrorReset()
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privDisableMagicQuotes()
        // Description :
        // Parameters :
        // Return Values :
        // --------------------------------------------------------------------------------
        function privDisableMagicQuotes()
        {
        }
        // --------------------------------------------------------------------------------
        // --------------------------------------------------------------------------------
        // Function : privSwapBackMagicQuotes()
        // Description :
        // Parameters :
        // Return Values :
        // --------------------------------------------------------------------------------
        function privSwapBackMagicQuotes()
        {
        }
        // --------------------------------------------------------------------------------
    }
    /**
     * PHPExcel
     *
     * Copyright (c) 2006 - 2014 PHPExcel
     *
     * This library is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * This library is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with this library; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     * @category    PHPExcel
     * @package    PHPExcel
     * @copyright    Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     * @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt    LGPL
     * @version    1.8.0, 2014-03-02
     */
    /**
     * PHPExcel_DocumentProperties
     *
     * @category    PHPExcel
     * @package        PHPExcel
     * @copyright    Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_DocumentProperties
    {
        /** constants */
        const PROPERTY_TYPE_BOOLEAN = 'b';
        const PROPERTY_TYPE_INTEGER = 'i';
        const PROPERTY_TYPE_FLOAT = 'f';
        const PROPERTY_TYPE_DATE = 'd';
        const PROPERTY_TYPE_STRING = 's';
        const PROPERTY_TYPE_UNKNOWN = 'u';
        /**
         * Creator
         *
         * @var string
         */
        private $_creator = 'Unknown Creator';
        /**
         * LastModifiedBy
         *
         * @var string
         */
        private $_lastModifiedBy;
        /**
         * Created
         *
         * @var datetime
         */
        private $_created;
        /**
         * Modified
         *
         * @var datetime
         */
        private $_modified;
        /**
         * Title
         *
         * @var string
         */
        private $_title = 'Untitled Spreadsheet';
        /**
         * Description
         *
         * @var string
         */
        private $_description = '';
        /**
         * Subject
         *
         * @var string
         */
        private $_subject = '';
        /**
         * Keywords
         *
         * @var string
         */
        private $_keywords = '';
        /**
         * Category
         *
         * @var string
         */
        private $_category = '';
        /**
         * Manager
         *
         * @var string
         */
        private $_manager = '';
        /**
         * Company
         *
         * @var string
         */
        private $_company = 'Microsoft Corporation';
        /**
         * Custom Properties
         *
         * @var string
         */
        private $_customProperties = array();
        /**
         * Create a new PHPExcel_DocumentProperties
         */
        public function __construct()
        {
        }
        /**
         * Get Creator
         *
         * @return string
         */
        public function getCreator()
        {
        }
        /**
         * Set Creator
         *
         * @param string $pValue
         * @return PHPExcel_DocumentProperties
         */
        public function setCreator($pValue = '')
        {
        }
        /**
         * Get Last Modified By
         *
         * @return string
         */
        public function getLastModifiedBy()
        {
        }
        /**
         * Set Last Modified By
         *
         * @param string $pValue
         * @return PHPExcel_DocumentProperties
         */
        public function setLastModifiedBy($pValue = '')
        {
        }
        /**
         * Get Created
         *
         * @return datetime
         */
        public function getCreated()
        {
        }
        /**
         * Set Created
         *
         * @param datetime $pValue
         * @return PHPExcel_DocumentProperties
         */
        public function setCreated($pValue = \null)
        {
        }
        /**
         * Get Modified
         *
         * @return datetime
         */
        public function getModified()
        {
        }
        /**
         * Set Modified
         *
         * @param datetime $pValue
         * @return PHPExcel_DocumentProperties
         */
        public function setModified($pValue = \null)
        {
        }
        /**
         * Get Title
         *
         * @return string
         */
        public function getTitle()
        {
        }
        /**
         * Set Title
         *
         * @param string $pValue
         * @return PHPExcel_DocumentProperties
         */
        public function setTitle($pValue = '')
        {
        }
        /**
         * Get Description
         *
         * @return string
         */
        public function getDescription()
        {
        }
        /**
         * Set Description
         *
         * @param string $pValue
         * @return PHPExcel_DocumentProperties
         */
        public function setDescription($pValue = '')
        {
        }
        /**
         * Get Subject
         *
         * @return string
         */
        public function getSubject()
        {
        }
        /**
         * Set Subject
         *
         * @param string $pValue
         * @return PHPExcel_DocumentProperties
         */
        public function setSubject($pValue = '')
        {
        }
        /**
         * Get Keywords
         *
         * @return string
         */
        public function getKeywords()
        {
        }
        /**
         * Set Keywords
         *
         * @param string $pValue
         * @return PHPExcel_DocumentProperties
         */
        public function setKeywords($pValue = '')
        {
        }
        /**
         * Get Category
         *
         * @return string
         */
        public function getCategory()
        {
        }
        /**
         * Set Category
         *
         * @param string $pValue
         * @return PHPExcel_DocumentProperties
         */
        public function setCategory($pValue = '')
        {
        }
        /**
         * Get Company
         *
         * @return string
         */
        public function getCompany()
        {
        }
        /**
         * Set Company
         *
         * @param string $pValue
         * @return PHPExcel_DocumentProperties
         */
        public function setCompany($pValue = '')
        {
        }
        /**
         * Get Manager
         *
         * @return string
         */
        public function getManager()
        {
        }
        /**
         * Set Manager
         *
         * @param string $pValue
         * @return PHPExcel_DocumentProperties
         */
        public function setManager($pValue = '')
        {
        }
        /**
         * Get a List of Custom Property Names
         *
         * @return array of string
         */
        public function getCustomProperties()
        {
        }
        /**
         * Check if a Custom Property is defined
         *
         * @param string $propertyName
         * @return boolean
         */
        public function isCustomPropertySet($propertyName)
        {
        }
        /**
         * Get a Custom Property Value
         *
         * @param string $propertyName
         * @return string
         */
        public function getCustomPropertyValue($propertyName)
        {
        }
        /**
         * Get a Custom Property Type
         *
         * @param string $propertyName
         * @return string
         */
        public function getCustomPropertyType($propertyName)
        {
        }
        /**
         * Set a Custom Property
         *
         * @param string $propertyName
         * @param mixed $propertyValue
         * @param string $propertyType
         * 	 'i'    : Integer
         *   'f' : Floating Point
         *   's' : String
         *   'd' : Date/Time
         *   'b' : Boolean
         * @return PHPExcel_DocumentProperties
         */
        public function setCustomProperty($propertyName, $propertyValue = '', $propertyType = \NULL)
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
        public static function convertProperty($propertyValue, $propertyType)
        {
        }
        public static function convertPropertyType($propertyType)
        {
        }
    }
    /**
     * PHPExcel_Autoloader
     *
     * @category    PHPExcel
     * @package     PHPExcel
     * @copyright   Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel_Autoloader
    {
        /**
         * Register the Autoloader with SPL
         *
         */
        public static function Register()
        {
        }
        //    function Register()
        /**
         * Autoload a class identified by name
         *
         * @param    string    $pClassName        Name of the object to load
         */
        public static function Load($pClassName)
        {
        }
        //    function Load()
    }
    /**
     * PHPExcel
     *
     * @category   PHPExcel
     * @package    PHPExcel
     * @copyright  Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     */
    class PHPExcel
    {
        /**
         * Unique ID
         *
         * @var string
         */
        private $_uniqueID;
        /**
         * Document properties
         *
         * @var PHPExcel_DocumentProperties
         */
        private $_properties;
        /**
         * Document security
         *
         * @var PHPExcel_DocumentSecurity
         */
        private $_security;
        /**
         * Collection of Worksheet objects
         *
         * @var PHPExcel_Worksheet[]
         */
        private $_workSheetCollection = array();
        /**
         * Calculation Engine
         *
         * @var PHPExcel_Calculation
         */
        private $_calculationEngine = \NULL;
        /**
         * Active sheet index
         *
         * @var int
         */
        private $_activeSheetIndex = 0;
        /**
         * Named ranges
         *
         * @var PHPExcel_NamedRange[]
         */
        private $_namedRanges = array();
        /**
         * CellXf supervisor
         *
         * @var PHPExcel_Style
         */
        private $_cellXfSupervisor;
        /**
         * CellXf collection
         *
         * @var PHPExcel_Style[]
         */
        private $_cellXfCollection = array();
        /**
         * CellStyleXf collection
         *
         * @var PHPExcel_Style[]
         */
        private $_cellStyleXfCollection = array();
        /**
         * _hasMacros : this workbook have macros ?
         *
         * @var bool
         */
        private $_hasMacros = \FALSE;
        /**
         * _macrosCode : all macros code (the vbaProject.bin file, this include form, code,  etc.), NULL if no macro
         *
         * @var binary
         */
        private $_macrosCode = \NULL;
        /**
         * _macrosCertificate : if macros are signed, contains vbaProjectSignature.bin file, NULL if not signed
         *
         * @var binary
         */
        private $_macrosCertificate = \NULL;
        /**
         * _ribbonXMLData : NULL if workbook is'nt Excel 2007 or not contain a customized UI
         *
         * @var NULL|string
         */
        private $_ribbonXMLData = \NULL;
        /**
         * _ribbonBinObjects : NULL if workbook is'nt Excel 2007 or not contain embedded objects (picture(s)) for Ribbon Elements
         * ignored if $_ribbonXMLData is null
         *
         * @var NULL|array
         */
        private $_ribbonBinObjects = \NULL;
        /**
         * The workbook has macros ?
         *
         * @return true if workbook has macros, false if not
         */
        public function hasMacros()
        {
        }
        /**
         * Define if a workbook has macros
         *
         * @param true|false
         */
        public function setHasMacros($hasMacros = \false)
        {
        }
        /**
         * Set the macros code
         *
         * @param binary string|null
         */
        public function setMacrosCode($MacrosCode)
        {
        }
        /**
         * Return the macros code
         *
         * @return binary|null
         */
        public function getMacrosCode()
        {
        }
        /**
         * Set the macros certificate
         *
         * @param binary|null
         */
        public function setMacrosCertificate($Certificate = \NULL)
        {
        }
        /**
         * Is the project signed ?
         *
         * @return true|false
         */
        public function hasMacrosCertificate()
        {
        }
        /**
         * Return the macros certificate
         *
         * @return binary|null
         */
        public function getMacrosCertificate()
        {
        }
        /**
         * Remove all macros, certificate from spreadsheet
         *
         * @param none
         * @return void
         */
        public function discardMacros()
        {
        }
        /**
         * set ribbon XML data
         *
         */
        public function setRibbonXMLData($Target = \NULL, $XMLData = \NULL)
        {
        }
        /**
         * retrieve ribbon XML Data
         *
         * return string|null|array
         */
        public function getRibbonXMLData($What = 'all')
        {
        }
        /**
         * store binaries ribbon objects (pictures)
         *
         */
        public function setRibbonBinObjects($BinObjectsNames = \NULL, $BinObjectsData = \NULL)
        {
        }
        /**
         * return the extension of a filename. Internal use for a array_map callback (php<5.3 don't like lambda function)
         *
         */
        private function _getExtensionOnly($ThePath)
        {
        }
        /**
         * retrieve Binaries Ribbon Objects
         *
         */
        public function getRibbonBinObjects($What = 'all')
        {
        }
        /**
         * This workbook have a custom UI ?
         *
         * @return true|false
         */
        public function hasRibbon()
        {
        }
        /**
         * This workbook have additionnal object for the ribbon ?
         *
         * @return true|false
         */
        public function hasRibbonBinObjects()
        {
        }
        /**
         * Check if a sheet with a specified code name already exists
         *
         * @param string $pSheetCodeName  Name of the worksheet to check
         * @return boolean
         */
        public function sheetCodeNameExists($pSheetCodeName)
        {
        }
        /**
         * Get sheet by code name. Warning : sheet don't have always a code name !
         *
         * @param string $pName Sheet name
         * @return PHPExcel_Worksheet
         */
        public function getSheetByCodeName($pName = '')
        {
        }
        /**
         * Create a new PHPExcel with one Worksheet
         */
        public function __construct()
        {
        }
        /**
         * Code to execute when this worksheet is unset()
         *
         */
        public function __destruct()
        {
        }
        //    function __destruct()
        /**
         * Disconnect all worksheets from this PHPExcel workbook object,
         *    typically so that the PHPExcel object can be unset
         *
         */
        public function disconnectWorksheets()
        {
        }
        /**
         * Return the calculation engine for this worksheet
         *
         * @return PHPExcel_Calculation
         */
        public function getCalculationEngine()
        {
        }
        //	function getCellCacheController()
        /**
         * Get properties
         *
         * @return PHPExcel_DocumentProperties
         */
        public function getProperties()
        {
        }
        /**
         * Set properties
         *
         * @param PHPExcel_DocumentProperties    $pValue
         */
        public function setProperties(\PHPExcel_DocumentProperties $pValue)
        {
        }
        /**
         * Get security
         *
         * @return PHPExcel_DocumentSecurity
         */
        public function getSecurity()
        {
        }
        /**
         * Set security
         *
         * @param PHPExcel_DocumentSecurity    $pValue
         */
        public function setSecurity(\PHPExcel_DocumentSecurity $pValue)
        {
        }
        /**
         * Get active sheet
         *
         * @return PHPExcel_Worksheet
         */
        public function getActiveSheet()
        {
        }
        /**
         * Create sheet and add it to this workbook
         *
         * @param  int|null $iSheetIndex Index where sheet should go (0,1,..., or null for last)
         * @return PHPExcel_Worksheet
         * @throws PHPExcel_Exception
         */
        public function createSheet($iSheetIndex = \NULL)
        {
        }
        /**
         * Check if a sheet with a specified name already exists
         *
         * @param  string $pSheetName  Name of the worksheet to check
         * @return boolean
         */
        public function sheetNameExists($pSheetName)
        {
        }
        /**
         * Add sheet
         *
         * @param  PHPExcel_Worksheet $pSheet
         * @param  int|null $iSheetIndex Index where sheet should go (0,1,..., or null for last)
         * @return PHPExcel_Worksheet
         * @throws PHPExcel_Exception
         */
        public function addSheet(\PHPExcel_Worksheet $pSheet, $iSheetIndex = \NULL)
        {
        }
        /**
         * Remove sheet by index
         *
         * @param  int $pIndex Active sheet index
         * @throws PHPExcel_Exception
         */
        public function removeSheetByIndex($pIndex = 0)
        {
        }
        /**
         * Get sheet by index
         *
         * @param  int $pIndex Sheet index
         * @return PHPExcel_Worksheet
         * @throws PHPExcel_Exception
         */
        public function getSheet($pIndex = 0)
        {
        }
        /**
         * Get all sheets
         *
         * @return PHPExcel_Worksheet[]
         */
        public function getAllSheets()
        {
        }
        /**
         * Get sheet by name
         *
         * @param  string $pName Sheet name
         * @return PHPExcel_Worksheet
         */
        public function getSheetByName($pName = '')
        {
        }
        /**
         * Get index for sheet
         *
         * @param  PHPExcel_Worksheet $pSheet
         * @return Sheet index
         * @throws PHPExcel_Exception
         */
        public function getIndex(\PHPExcel_Worksheet $pSheet)
        {
        }
        /**
         * Set index for sheet by sheet name.
         *
         * @param  string $sheetName Sheet name to modify index for
         * @param  int $newIndex New index for the sheet
         * @return New sheet index
         * @throws PHPExcel_Exception
         */
        public function setIndexByName($sheetName, $newIndex)
        {
        }
        /**
         * Get sheet count
         *
         * @return int
         */
        public function getSheetCount()
        {
        }
        /**
         * Get active sheet index
         *
         * @return int Active sheet index
         */
        public function getActiveSheetIndex()
        {
        }
        /**
         * Set active sheet index
         *
         * @param  int $pIndex Active sheet index
         * @throws PHPExcel_Exception
         * @return PHPExcel_Worksheet
         */
        public function setActiveSheetIndex($pIndex = 0)
        {
        }
        /**
         * Set active sheet index by name
         *
         * @param  string $pValue Sheet title
         * @return PHPExcel_Worksheet
         * @throws PHPExcel_Exception
         */
        public function setActiveSheetIndexByName($pValue = '')
        {
        }
        /**
         * Get sheet names
         *
         * @return string[]
         */
        public function getSheetNames()
        {
        }
        /**
         * Add external sheet
         *
         * @param  PHPExcel_Worksheet $pSheet External sheet to add
         * @param  int|null $iSheetIndex Index where sheet should go (0,1,..., or null for last)
         * @throws PHPExcel_Exception
         * @return PHPExcel_Worksheet
         */
        public function addExternalSheet(\PHPExcel_Worksheet $pSheet, $iSheetIndex = \null)
        {
        }
        /**
         * Get named ranges
         *
         * @return PHPExcel_NamedRange[]
         */
        public function getNamedRanges()
        {
        }
        /**
         * Add named range
         *
         * @param  PHPExcel_NamedRange $namedRange
         * @return PHPExcel
         */
        public function addNamedRange(\PHPExcel_NamedRange $namedRange)
        {
        }
        /**
         * Get named range
         *
         * @param  string $namedRange
         * @param  PHPExcel_Worksheet|null $pSheet Scope. Use null for global scope
         * @return PHPExcel_NamedRange|null
         */
        public function getNamedRange($namedRange, \PHPExcel_Worksheet $pSheet = \null)
        {
        }
        /**
         * Remove named range
         *
         * @param  string  $namedRange
         * @param  PHPExcel_Worksheet|null  $pSheet  Scope: use null for global scope.
         * @return PHPExcel
         */
        public function removeNamedRange($namedRange, \PHPExcel_Worksheet $pSheet = \null)
        {
        }
        /**
         * Get worksheet iterator
         *
         * @return PHPExcel_WorksheetIterator
         */
        public function getWorksheetIterator()
        {
        }
        /**
         * Copy workbook (!= clone!)
         *
         * @return PHPExcel
         */
        public function copy()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
        /**
         * Get the workbook collection of cellXfs
         *
         * @return PHPExcel_Style[]
         */
        public function getCellXfCollection()
        {
        }
        /**
         * Get cellXf by index
         *
         * @param  int $pIndex
         * @return PHPExcel_Style
         */
        public function getCellXfByIndex($pIndex = 0)
        {
        }
        /**
         * Get cellXf by hash code
         *
         * @param  string $pValue
         * @return PHPExcel_Style|false
         */
        public function getCellXfByHashCode($pValue = '')
        {
        }
        /**
         * Check if style exists in style collection
         *
         * @param  PHPExcel_Style $pCellStyle
         * @return boolean
         */
        public function cellXfExists($pCellStyle = \null)
        {
        }
        /**
         * Get default style
         *
         * @return PHPExcel_Style
         * @throws PHPExcel_Exception
         */
        public function getDefaultStyle()
        {
        }
        /**
         * Add a cellXf to the workbook
         *
         * @param PHPExcel_Style $style
         */
        public function addCellXf(\PHPExcel_Style $style)
        {
        }
        /**
         * Remove cellXf by index. It is ensured that all cells get their xf index updated.
         *
         * @param  int $pIndex Index to cellXf
         * @throws PHPExcel_Exception
         */
        public function removeCellXfByIndex($pIndex = 0)
        {
        }
        /**
         * Get the cellXf supervisor
         *
         * @return PHPExcel_Style
         */
        public function getCellXfSupervisor()
        {
        }
        /**
         * Get the workbook collection of cellStyleXfs
         *
         * @return PHPExcel_Style[]
         */
        public function getCellStyleXfCollection()
        {
        }
        /**
         * Get cellStyleXf by index
         *
         * @param  int $pIndex
         * @return PHPExcel_Style
         */
        public function getCellStyleXfByIndex($pIndex = 0)
        {
        }
        /**
         * Get cellStyleXf by hash code
         *
         * @param  string $pValue
         * @return PHPExcel_Style|false
         */
        public function getCellStyleXfByHashCode($pValue = '')
        {
        }
        /**
         * Add a cellStyleXf to the workbook
         *
         * @param PHPExcel_Style $pStyle
         */
        public function addCellStyleXf(\PHPExcel_Style $pStyle)
        {
        }
        /**
         * Remove cellStyleXf by index
         *
         * @param int $pIndex
         * @throws PHPExcel_Exception
         */
        public function removeCellStyleXfByIndex($pIndex = 0)
        {
        }
        /**
         * Eliminate all unneeded cellXf and afterwards update the xfIndex for all cells
         * and columns in the workbook
         */
        public function garbageCollect()
        {
        }
        /**
         * Return the unique ID value assigned to this spreadsheet workbook
         *
         * @return string
         */
        public function getID()
        {
        }
    }
}
namespace Psr\Http\Message {
    /**
     * Describes a data stream.
     *
     * Typically, an instance will wrap a PHP stream; this interface provides
     * a wrapper around the most common operations, including serialization of
     * the entire stream to a string.
     */
    interface StreamInterface
    {
        /**
         * Reads all data from the stream into a string, from the beginning to end.
         *
         * This method MUST attempt to seek to the beginning of the stream before
         * reading data and read the stream until the end is reached.
         *
         * Warning: This could attempt to load a large amount of data into memory.
         *
         * This method MUST NOT raise an exception in order to conform with PHP's
         * string casting operations.
         *
         * @see http://php.net/manual/en/language.oop5.magic.php#object.tostring
         * @return string
         */
        public function __toString();
        /**
         * Closes the stream and any underlying resources.
         *
         * @return void
         */
        public function close();
        /**
         * Separates any underlying resources from the stream.
         *
         * After the stream has been detached, the stream is in an unusable state.
         *
         * @return resource|null Underlying PHP stream, if any
         */
        public function detach();
        /**
         * Get the size of the stream if known.
         *
         * @return int|null Returns the size in bytes if known, or null if unknown.
         */
        public function getSize();
        /**
         * Returns the current position of the file read/write pointer
         *
         * @return int Position of the file pointer
         * @throws \RuntimeException on error.
         */
        public function tell();
        /**
         * Returns true if the stream is at the end of the stream.
         *
         * @return bool
         */
        public function eof();
        /**
         * Returns whether or not the stream is seekable.
         *
         * @return bool
         */
        public function isSeekable();
        /**
         * Seek to a position in the stream.
         *
         * @link http://www.php.net/manual/en/function.fseek.php
         * @param int $offset Stream offset
         * @param int $whence Specifies how the cursor position will be calculated
         *     based on the seek offset. Valid values are identical to the built-in
         *     PHP $whence values for `fseek()`.  SEEK_SET: Set position equal to
         *     offset bytes SEEK_CUR: Set position to current location plus offset
         *     SEEK_END: Set position to end-of-stream plus offset.
         * @throws \RuntimeException on failure.
         */
        public function seek($offset, $whence = SEEK_SET);
        /**
         * Seek to the beginning of the stream.
         *
         * If the stream is not seekable, this method will raise an exception;
         * otherwise, it will perform a seek(0).
         *
         * @see seek()
         * @link http://www.php.net/manual/en/function.fseek.php
         * @throws \RuntimeException on failure.
         */
        public function rewind();
        /**
         * Returns whether or not the stream is writable.
         *
         * @return bool
         */
        public function isWritable();
        /**
         * Write data to the stream.
         *
         * @param string $string The string that is to be written.
         * @return int Returns the number of bytes written to the stream.
         * @throws \RuntimeException on failure.
         */
        public function write($string);
        /**
         * Returns whether or not the stream is readable.
         *
         * @return bool
         */
        public function isReadable();
        /**
         * Read data from the stream.
         *
         * @param int $length Read up to $length bytes from the object and return
         *     them. Fewer than $length bytes may be returned if underlying stream
         *     call returns fewer bytes.
         * @return string Returns the data read from the stream, or an empty string
         *     if no bytes are available.
         * @throws \RuntimeException if an error occurs.
         */
        public function read($length);
        /**
         * Returns the remaining contents in a string
         *
         * @return string
         * @throws \RuntimeException if unable to read or an error occurs while
         *     reading.
         */
        public function getContents();
        /**
         * Get stream metadata as an associative array or retrieve a specific key.
         *
         * The keys returned are identical to the keys returned from PHP's
         * stream_get_meta_data() function.
         *
         * @link http://php.net/manual/en/function.stream-get-meta-data.php
         * @param string $key Specific metadata to retrieve.
         * @return array|mixed|null Returns an associative array if no key is
         *     provided. Returns a specific key value if a key is provided and the
         *     value is found, or null if the key is not found.
         */
        public function getMetadata($key = null);
    }
    /**
     * Value object representing a file uploaded through an HTTP request.
     *
     * Instances of this interface are considered immutable; all methods that
     * might change state MUST be implemented such that they retain the internal
     * state of the current instance and return an instance that contains the
     * changed state.
     */
    interface UploadedFileInterface
    {
        /**
         * Retrieve a stream representing the uploaded file.
         *
         * This method MUST return a StreamInterface instance, representing the
         * uploaded file. The purpose of this method is to allow utilizing native PHP
         * stream functionality to manipulate the file upload, such as
         * stream_copy_to_stream() (though the result will need to be decorated in a
         * native PHP stream wrapper to work with such functions).
         *
         * If the moveTo() method has been called previously, this method MUST raise
         * an exception.
         *
         * @return StreamInterface Stream representation of the uploaded file.
         * @throws \RuntimeException in cases when no stream is available or can be
         *     created.
         */
        public function getStream();
        /**
         * Move the uploaded file to a new location.
         *
         * Use this method as an alternative to move_uploaded_file(). This method is
         * guaranteed to work in both SAPI and non-SAPI environments.
         * Implementations must determine which environment they are in, and use the
         * appropriate method (move_uploaded_file(), rename(), or a stream
         * operation) to perform the operation.
         *
         * $targetPath may be an absolute path, or a relative path. If it is a
         * relative path, resolution should be the same as used by PHP's rename()
         * function.
         *
         * The original file or stream MUST be removed on completion.
         *
         * If this method is called more than once, any subsequent calls MUST raise
         * an exception.
         *
         * When used in an SAPI environment where $_FILES is populated, when writing
         * files via moveTo(), is_uploaded_file() and move_uploaded_file() SHOULD be
         * used to ensure permissions and upload status are verified correctly.
         *
         * If you wish to move to a stream, use getStream(), as SAPI operations
         * cannot guarantee writing to stream destinations.
         *
         * @see http://php.net/is_uploaded_file
         * @see http://php.net/move_uploaded_file
         * @param string $targetPath Path to which to move the uploaded file.
         * @throws \InvalidArgumentException if the $targetPath specified is invalid.
         * @throws \RuntimeException on any error during the move operation, or on
         *     the second or subsequent call to the method.
         */
        public function moveTo($targetPath);
        /**
         * Retrieve the file size.
         *
         * Implementations SHOULD return the value stored in the "size" key of
         * the file in the $_FILES array if available, as PHP calculates this based
         * on the actual size transmitted.
         *
         * @return int|null The file size in bytes or null if unknown.
         */
        public function getSize();
        /**
         * Retrieve the error associated with the uploaded file.
         *
         * The return value MUST be one of PHP's UPLOAD_ERR_XXX constants.
         *
         * If the file was uploaded successfully, this method MUST return
         * UPLOAD_ERR_OK.
         *
         * Implementations SHOULD return the value stored in the "error" key of
         * the file in the $_FILES array.
         *
         * @see http://php.net/manual/en/features.file-upload.errors.php
         * @return int One of PHP's UPLOAD_ERR_XXX constants.
         */
        public function getError();
        /**
         * Retrieve the filename sent by the client.
         *
         * Do not trust the value returned by this method. A client could send
         * a malicious filename with the intention to corrupt or hack your
         * application.
         *
         * Implementations SHOULD return the value stored in the "name" key of
         * the file in the $_FILES array.
         *
         * @return string|null The filename sent by the client or null if none
         *     was provided.
         */
        public function getClientFilename();
        /**
         * Retrieve the media type sent by the client.
         *
         * Do not trust the value returned by this method. A client could send
         * a malicious media type with the intention to corrupt or hack your
         * application.
         *
         * Implementations SHOULD return the value stored in the "type" key of
         * the file in the $_FILES array.
         *
         * @return string|null The media type sent by the client or null if none
         *     was provided.
         */
        public function getClientMediaType();
    }
    /**
     * HTTP messages consist of requests from a client to a server and responses
     * from a server to a client. This interface defines the methods common to
     * each.
     *
     * Messages are considered immutable; all methods that might change state MUST
     * be implemented such that they retain the internal state of the current
     * message and return an instance that contains the changed state.
     *
     * @link http://www.ietf.org/rfc/rfc7230.txt
     * @link http://www.ietf.org/rfc/rfc7231.txt
     */
    interface MessageInterface
    {
        /**
         * Retrieves the HTTP protocol version as a string.
         *
         * The string MUST contain only the HTTP version number (e.g., "1.1", "1.0").
         *
         * @return string HTTP protocol version.
         */
        public function getProtocolVersion();
        /**
         * Return an instance with the specified HTTP protocol version.
         *
         * The version string MUST contain only the HTTP version number (e.g.,
         * "1.1", "1.0").
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that has the
         * new protocol version.
         *
         * @param string $version HTTP protocol version
         * @return static
         */
        public function withProtocolVersion($version);
        /**
         * Retrieves all message header values.
         *
         * The keys represent the header name as it will be sent over the wire, and
         * each value is an array of strings associated with the header.
         *
         *     // Represent the headers as a string
         *     foreach ($message->getHeaders() as $name => $values) {
         *         echo $name . ": " . implode(", ", $values);
         *     }
         *
         *     // Emit headers iteratively:
         *     foreach ($message->getHeaders() as $name => $values) {
         *         foreach ($values as $value) {
         *             header(sprintf('%s: %s', $name, $value), false);
         *         }
         *     }
         *
         * While header names are not case-sensitive, getHeaders() will preserve the
         * exact case in which headers were originally specified.
         *
         * @return string[][] Returns an associative array of the message's headers. Each
         *     key MUST be a header name, and each value MUST be an array of strings
         *     for that header.
         */
        public function getHeaders();
        /**
         * Checks if a header exists by the given case-insensitive name.
         *
         * @param string $name Case-insensitive header field name.
         * @return bool Returns true if any header names match the given header
         *     name using a case-insensitive string comparison. Returns false if
         *     no matching header name is found in the message.
         */
        public function hasHeader($name);
        /**
         * Retrieves a message header value by the given case-insensitive name.
         *
         * This method returns an array of all the header values of the given
         * case-insensitive header name.
         *
         * If the header does not appear in the message, this method MUST return an
         * empty array.
         *
         * @param string $name Case-insensitive header field name.
         * @return string[] An array of string values as provided for the given
         *    header. If the header does not appear in the message, this method MUST
         *    return an empty array.
         */
        public function getHeader($name);
        /**
         * Retrieves a comma-separated string of the values for a single header.
         *
         * This method returns all of the header values of the given
         * case-insensitive header name as a string concatenated together using
         * a comma.
         *
         * NOTE: Not all header values may be appropriately represented using
         * comma concatenation. For such headers, use getHeader() instead
         * and supply your own delimiter when concatenating.
         *
         * If the header does not appear in the message, this method MUST return
         * an empty string.
         *
         * @param string $name Case-insensitive header field name.
         * @return string A string of values as provided for the given header
         *    concatenated together using a comma. If the header does not appear in
         *    the message, this method MUST return an empty string.
         */
        public function getHeaderLine($name);
        /**
         * Return an instance with the provided value replacing the specified header.
         *
         * While header names are case-insensitive, the casing of the header will
         * be preserved by this function, and returned from getHeaders().
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that has the
         * new and/or updated header and value.
         *
         * @param string $name Case-insensitive header field name.
         * @param string|string[] $value Header value(s).
         * @return static
         * @throws \InvalidArgumentException for invalid header names or values.
         */
        public function withHeader($name, $value);
        /**
         * Return an instance with the specified header appended with the given value.
         *
         * Existing values for the specified header will be maintained. The new
         * value(s) will be appended to the existing list. If the header did not
         * exist previously, it will be added.
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that has the
         * new header and/or value.
         *
         * @param string $name Case-insensitive header field name to add.
         * @param string|string[] $value Header value(s).
         * @return static
         * @throws \InvalidArgumentException for invalid header names or values.
         */
        public function withAddedHeader($name, $value);
        /**
         * Return an instance without the specified header.
         *
         * Header resolution MUST be done without case-sensitivity.
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that removes
         * the named header.
         *
         * @param string $name Case-insensitive header field name to remove.
         * @return static
         */
        public function withoutHeader($name);
        /**
         * Gets the body of the message.
         *
         * @return StreamInterface Returns the body as a stream.
         */
        public function getBody();
        /**
         * Return an instance with the specified message body.
         *
         * The body MUST be a StreamInterface object.
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return a new instance that has the
         * new body stream.
         *
         * @param StreamInterface $body Body.
         * @return static
         * @throws \InvalidArgumentException When the body is not valid.
         */
        public function withBody(\Psr\Http\Message\StreamInterface $body);
    }
    /**
     * Representation of an outgoing, server-side response.
     *
     * Per the HTTP specification, this interface includes properties for
     * each of the following:
     *
     * - Protocol version
     * - Status code and reason phrase
     * - Headers
     * - Message body
     *
     * Responses are considered immutable; all methods that might change state MUST
     * be implemented such that they retain the internal state of the current
     * message and return an instance that contains the changed state.
     */
    interface ResponseInterface extends \Psr\Http\Message\MessageInterface
    {
        /**
         * Gets the response status code.
         *
         * The status code is a 3-digit integer result code of the server's attempt
         * to understand and satisfy the request.
         *
         * @return int Status code.
         */
        public function getStatusCode();
        /**
         * Return an instance with the specified status code and, optionally, reason phrase.
         *
         * If no reason phrase is specified, implementations MAY choose to default
         * to the RFC 7231 or IANA recommended reason phrase for the response's
         * status code.
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that has the
         * updated status and reason phrase.
         *
         * @link http://tools.ietf.org/html/rfc7231#section-6
         * @link http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
         * @param int $code The 3-digit integer result code to set.
         * @param string $reasonPhrase The reason phrase to use with the
         *     provided status code; if none is provided, implementations MAY
         *     use the defaults as suggested in the HTTP specification.
         * @return static
         * @throws \InvalidArgumentException For invalid status code arguments.
         */
        public function withStatus($code, $reasonPhrase = '');
        /**
         * Gets the response reason phrase associated with the status code.
         *
         * Because a reason phrase is not a required element in a response
         * status line, the reason phrase value MAY be null. Implementations MAY
         * choose to return the default RFC 7231 recommended reason phrase (or those
         * listed in the IANA HTTP Status Code Registry) for the response's
         * status code.
         *
         * @link http://tools.ietf.org/html/rfc7231#section-6
         * @link http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
         * @return string Reason phrase; must return an empty string if none present.
         */
        public function getReasonPhrase();
    }
    /**
     * Representation of an outgoing, client-side request.
     *
     * Per the HTTP specification, this interface includes properties for
     * each of the following:
     *
     * - Protocol version
     * - HTTP method
     * - URI
     * - Headers
     * - Message body
     *
     * During construction, implementations MUST attempt to set the Host header from
     * a provided URI if no Host header is provided.
     *
     * Requests are considered immutable; all methods that might change state MUST
     * be implemented such that they retain the internal state of the current
     * message and return an instance that contains the changed state.
     */
    interface RequestInterface extends \Psr\Http\Message\MessageInterface
    {
        /**
         * Retrieves the message's request target.
         *
         * Retrieves the message's request-target either as it will appear (for
         * clients), as it appeared at request (for servers), or as it was
         * specified for the instance (see withRequestTarget()).
         *
         * In most cases, this will be the origin-form of the composed URI,
         * unless a value was provided to the concrete implementation (see
         * withRequestTarget() below).
         *
         * If no URI is available, and no request-target has been specifically
         * provided, this method MUST return the string "/".
         *
         * @return string
         */
        public function getRequestTarget();
        /**
         * Return an instance with the specific request-target.
         *
         * If the request needs a non-origin-form request-target  e.g., for
         * specifying an absolute-form, authority-form, or asterisk-form 
         * this method may be used to create an instance with the specified
         * request-target, verbatim.
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that has the
         * changed request target.
         *
         * @link http://tools.ietf.org/html/rfc7230#section-5.3 (for the various
         *     request-target forms allowed in request messages)
         * @param mixed $requestTarget
         * @return static
         */
        public function withRequestTarget($requestTarget);
        /**
         * Retrieves the HTTP method of the request.
         *
         * @return string Returns the request method.
         */
        public function getMethod();
        /**
         * Return an instance with the provided HTTP method.
         *
         * While HTTP method names are typically all uppercase characters, HTTP
         * method names are case-sensitive and thus implementations SHOULD NOT
         * modify the given string.
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that has the
         * changed request method.
         *
         * @param string $method Case-sensitive method.
         * @return static
         * @throws \InvalidArgumentException for invalid HTTP methods.
         */
        public function withMethod($method);
        /**
         * Retrieves the URI instance.
         *
         * This method MUST return a UriInterface instance.
         *
         * @link http://tools.ietf.org/html/rfc3986#section-4.3
         * @return UriInterface Returns a UriInterface instance
         *     representing the URI of the request.
         */
        public function getUri();
        /**
         * Returns an instance with the provided URI.
         *
         * This method MUST update the Host header of the returned request by
         * default if the URI contains a host component. If the URI does not
         * contain a host component, any pre-existing Host header MUST be carried
         * over to the returned request.
         *
         * You can opt-in to preserving the original state of the Host header by
         * setting `$preserveHost` to `true`. When `$preserveHost` is set to
         * `true`, this method interacts with the Host header in the following ways:
         *
         * - If the Host header is missing or empty, and the new URI contains
         *   a host component, this method MUST update the Host header in the returned
         *   request.
         * - If the Host header is missing or empty, and the new URI does not contain a
         *   host component, this method MUST NOT update the Host header in the returned
         *   request.
         * - If a Host header is present and non-empty, this method MUST NOT update
         *   the Host header in the returned request.
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that has the
         * new UriInterface instance.
         *
         * @link http://tools.ietf.org/html/rfc3986#section-4.3
         * @param UriInterface $uri New request URI to use.
         * @param bool $preserveHost Preserve the original state of the Host header.
         * @return static
         */
        public function withUri(\Psr\Http\Message\UriInterface $uri, $preserveHost = false);
    }
    /**
     * Representation of an incoming, server-side HTTP request.
     *
     * Per the HTTP specification, this interface includes properties for
     * each of the following:
     *
     * - Protocol version
     * - HTTP method
     * - URI
     * - Headers
     * - Message body
     *
     * Additionally, it encapsulates all data as it has arrived to the
     * application from the CGI and/or PHP environment, including:
     *
     * - The values represented in $_SERVER.
     * - Any cookies provided (generally via $_COOKIE)
     * - Query string arguments (generally via $_GET, or as parsed via parse_str())
     * - Upload files, if any (as represented by $_FILES)
     * - Deserialized body parameters (generally from $_POST)
     *
     * $_SERVER values MUST be treated as immutable, as they represent application
     * state at the time of request; as such, no methods are provided to allow
     * modification of those values. The other values provide such methods, as they
     * can be restored from $_SERVER or the request body, and may need treatment
     * during the application (e.g., body parameters may be deserialized based on
     * content type).
     *
     * Additionally, this interface recognizes the utility of introspecting a
     * request to derive and match additional parameters (e.g., via URI path
     * matching, decrypting cookie values, deserializing non-form-encoded body
     * content, matching authorization headers to users, etc). These parameters
     * are stored in an "attributes" property.
     *
     * Requests are considered immutable; all methods that might change state MUST
     * be implemented such that they retain the internal state of the current
     * message and return an instance that contains the changed state.
     */
    interface ServerRequestInterface extends \Psr\Http\Message\RequestInterface
    {
        /**
         * Retrieve server parameters.
         *
         * Retrieves data related to the incoming request environment,
         * typically derived from PHP's $_SERVER superglobal. The data IS NOT
         * REQUIRED to originate from $_SERVER.
         *
         * @return array
         */
        public function getServerParams();
        /**
         * Retrieve cookies.
         *
         * Retrieves cookies sent by the client to the server.
         *
         * The data MUST be compatible with the structure of the $_COOKIE
         * superglobal.
         *
         * @return array
         */
        public function getCookieParams();
        /**
         * Return an instance with the specified cookies.
         *
         * The data IS NOT REQUIRED to come from the $_COOKIE superglobal, but MUST
         * be compatible with the structure of $_COOKIE. Typically, this data will
         * be injected at instantiation.
         *
         * This method MUST NOT update the related Cookie header of the request
         * instance, nor related values in the server params.
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that has the
         * updated cookie values.
         *
         * @param array $cookies Array of key/value pairs representing cookies.
         * @return static
         */
        public function withCookieParams(array $cookies);
        /**
         * Retrieve query string arguments.
         *
         * Retrieves the deserialized query string arguments, if any.
         *
         * Note: the query params might not be in sync with the URI or server
         * params. If you need to ensure you are only getting the original
         * values, you may need to parse the query string from `getUri()->getQuery()`
         * or from the `QUERY_STRING` server param.
         *
         * @return array
         */
        public function getQueryParams();
        /**
         * Return an instance with the specified query string arguments.
         *
         * These values SHOULD remain immutable over the course of the incoming
         * request. They MAY be injected during instantiation, such as from PHP's
         * $_GET superglobal, or MAY be derived from some other value such as the
         * URI. In cases where the arguments are parsed from the URI, the data
         * MUST be compatible with what PHP's parse_str() would return for
         * purposes of how duplicate query parameters are handled, and how nested
         * sets are handled.
         *
         * Setting query string arguments MUST NOT change the URI stored by the
         * request, nor the values in the server params.
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that has the
         * updated query string arguments.
         *
         * @param array $query Array of query string arguments, typically from
         *     $_GET.
         * @return static
         */
        public function withQueryParams(array $query);
        /**
         * Retrieve normalized file upload data.
         *
         * This method returns upload metadata in a normalized tree, with each leaf
         * an instance of Psr\Http\Message\UploadedFileInterface.
         *
         * These values MAY be prepared from $_FILES or the message body during
         * instantiation, or MAY be injected via withUploadedFiles().
         *
         * @return array An array tree of UploadedFileInterface instances; an empty
         *     array MUST be returned if no data is present.
         */
        public function getUploadedFiles();
        /**
         * Create a new instance with the specified uploaded files.
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that has the
         * updated body parameters.
         *
         * @param array $uploadedFiles An array tree of UploadedFileInterface instances.
         * @return static
         * @throws \InvalidArgumentException if an invalid structure is provided.
         */
        public function withUploadedFiles(array $uploadedFiles);
        /**
         * Retrieve any parameters provided in the request body.
         *
         * If the request Content-Type is either application/x-www-form-urlencoded
         * or multipart/form-data, and the request method is POST, this method MUST
         * return the contents of $_POST.
         *
         * Otherwise, this method may return any results of deserializing
         * the request body content; as parsing returns structured content, the
         * potential types MUST be arrays or objects only. A null value indicates
         * the absence of body content.
         *
         * @return null|array|object The deserialized body parameters, if any.
         *     These will typically be an array or object.
         */
        public function getParsedBody();
        /**
         * Return an instance with the specified body parameters.
         *
         * These MAY be injected during instantiation.
         *
         * If the request Content-Type is either application/x-www-form-urlencoded
         * or multipart/form-data, and the request method is POST, use this method
         * ONLY to inject the contents of $_POST.
         *
         * The data IS NOT REQUIRED to come from $_POST, but MUST be the results of
         * deserializing the request body content. Deserialization/parsing returns
         * structured data, and, as such, this method ONLY accepts arrays or objects,
         * or a null value if nothing was available to parse.
         *
         * As an example, if content negotiation determines that the request data
         * is a JSON payload, this method could be used to create a request
         * instance with the deserialized parameters.
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that has the
         * updated body parameters.
         *
         * @param null|array|object $data The deserialized body data. This will
         *     typically be in an array or object.
         * @return static
         * @throws \InvalidArgumentException if an unsupported argument type is
         *     provided.
         */
        public function withParsedBody($data);
        /**
         * Retrieve attributes derived from the request.
         *
         * The request "attributes" may be used to allow injection of any
         * parameters derived from the request: e.g., the results of path
         * match operations; the results of decrypting cookies; the results of
         * deserializing non-form-encoded message bodies; etc. Attributes
         * will be application and request specific, and CAN be mutable.
         *
         * @return array Attributes derived from the request.
         */
        public function getAttributes();
        /**
         * Retrieve a single derived request attribute.
         *
         * Retrieves a single derived request attribute as described in
         * getAttributes(). If the attribute has not been previously set, returns
         * the default value as provided.
         *
         * This method obviates the need for a hasAttribute() method, as it allows
         * specifying a default value to return if the attribute is not found.
         *
         * @see getAttributes()
         * @param string $name The attribute name.
         * @param mixed $default Default value to return if the attribute does not exist.
         * @return mixed
         */
        public function getAttribute($name, $default = null);
        /**
         * Return an instance with the specified derived request attribute.
         *
         * This method allows setting a single derived request attribute as
         * described in getAttributes().
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that has the
         * updated attribute.
         *
         * @see getAttributes()
         * @param string $name The attribute name.
         * @param mixed $value The value of the attribute.
         * @return static
         */
        public function withAttribute($name, $value);
        /**
         * Return an instance that removes the specified derived request attribute.
         *
         * This method allows removing a single derived request attribute as
         * described in getAttributes().
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that removes
         * the attribute.
         *
         * @see getAttributes()
         * @param string $name The attribute name.
         * @return static
         */
        public function withoutAttribute($name);
    }
    /**
     * Value object representing a URI.
     *
     * This interface is meant to represent URIs according to RFC 3986 and to
     * provide methods for most common operations. Additional functionality for
     * working with URIs can be provided on top of the interface or externally.
     * Its primary use is for HTTP requests, but may also be used in other
     * contexts.
     *
     * Instances of this interface are considered immutable; all methods that
     * might change state MUST be implemented such that they retain the internal
     * state of the current instance and return an instance that contains the
     * changed state.
     *
     * Typically the Host header will be also be present in the request message.
     * For server-side requests, the scheme will typically be discoverable in the
     * server parameters.
     *
     * @link http://tools.ietf.org/html/rfc3986 (the URI specification)
     */
    interface UriInterface
    {
        /**
         * Retrieve the scheme component of the URI.
         *
         * If no scheme is present, this method MUST return an empty string.
         *
         * The value returned MUST be normalized to lowercase, per RFC 3986
         * Section 3.1.
         *
         * The trailing ":" character is not part of the scheme and MUST NOT be
         * added.
         *
         * @see https://tools.ietf.org/html/rfc3986#section-3.1
         * @return string The URI scheme.
         */
        public function getScheme();
        /**
         * Retrieve the authority component of the URI.
         *
         * If no authority information is present, this method MUST return an empty
         * string.
         *
         * The authority syntax of the URI is:
         *
         * <pre>
         * [user-info@]host[:port]
         * </pre>
         *
         * If the port component is not set or is the standard port for the current
         * scheme, it SHOULD NOT be included.
         *
         * @see https://tools.ietf.org/html/rfc3986#section-3.2
         * @return string The URI authority, in "[user-info@]host[:port]" format.
         */
        public function getAuthority();
        /**
         * Retrieve the user information component of the URI.
         *
         * If no user information is present, this method MUST return an empty
         * string.
         *
         * If a user is present in the URI, this will return that value;
         * additionally, if the password is also present, it will be appended to the
         * user value, with a colon (":") separating the values.
         *
         * The trailing "@" character is not part of the user information and MUST
         * NOT be added.
         *
         * @return string The URI user information, in "username[:password]" format.
         */
        public function getUserInfo();
        /**
         * Retrieve the host component of the URI.
         *
         * If no host is present, this method MUST return an empty string.
         *
         * The value returned MUST be normalized to lowercase, per RFC 3986
         * Section 3.2.2.
         *
         * @see http://tools.ietf.org/html/rfc3986#section-3.2.2
         * @return string The URI host.
         */
        public function getHost();
        /**
         * Retrieve the port component of the URI.
         *
         * If a port is present, and it is non-standard for the current scheme,
         * this method MUST return it as an integer. If the port is the standard port
         * used with the current scheme, this method SHOULD return null.
         *
         * If no port is present, and no scheme is present, this method MUST return
         * a null value.
         *
         * If no port is present, but a scheme is present, this method MAY return
         * the standard port for that scheme, but SHOULD return null.
         *
         * @return null|int The URI port.
         */
        public function getPort();
        /**
         * Retrieve the path component of the URI.
         *
         * The path can either be empty or absolute (starting with a slash) or
         * rootless (not starting with a slash). Implementations MUST support all
         * three syntaxes.
         *
         * Normally, the empty path "" and absolute path "/" are considered equal as
         * defined in RFC 7230 Section 2.7.3. But this method MUST NOT automatically
         * do this normalization because in contexts with a trimmed base path, e.g.
         * the front controller, this difference becomes significant. It's the task
         * of the user to handle both "" and "/".
         *
         * The value returned MUST be percent-encoded, but MUST NOT double-encode
         * any characters. To determine what characters to encode, please refer to
         * RFC 3986, Sections 2 and 3.3.
         *
         * As an example, if the value should include a slash ("/") not intended as
         * delimiter between path segments, that value MUST be passed in encoded
         * form (e.g., "%2F") to the instance.
         *
         * @see https://tools.ietf.org/html/rfc3986#section-2
         * @see https://tools.ietf.org/html/rfc3986#section-3.3
         * @return string The URI path.
         */
        public function getPath();
        /**
         * Retrieve the query string of the URI.
         *
         * If no query string is present, this method MUST return an empty string.
         *
         * The leading "?" character is not part of the query and MUST NOT be
         * added.
         *
         * The value returned MUST be percent-encoded, but MUST NOT double-encode
         * any characters. To determine what characters to encode, please refer to
         * RFC 3986, Sections 2 and 3.4.
         *
         * As an example, if a value in a key/value pair of the query string should
         * include an ampersand ("&") not intended as a delimiter between values,
         * that value MUST be passed in encoded form (e.g., "%26") to the instance.
         *
         * @see https://tools.ietf.org/html/rfc3986#section-2
         * @see https://tools.ietf.org/html/rfc3986#section-3.4
         * @return string The URI query string.
         */
        public function getQuery();
        /**
         * Retrieve the fragment component of the URI.
         *
         * If no fragment is present, this method MUST return an empty string.
         *
         * The leading "#" character is not part of the fragment and MUST NOT be
         * added.
         *
         * The value returned MUST be percent-encoded, but MUST NOT double-encode
         * any characters. To determine what characters to encode, please refer to
         * RFC 3986, Sections 2 and 3.5.
         *
         * @see https://tools.ietf.org/html/rfc3986#section-2
         * @see https://tools.ietf.org/html/rfc3986#section-3.5
         * @return string The URI fragment.
         */
        public function getFragment();
        /**
         * Return an instance with the specified scheme.
         *
         * This method MUST retain the state of the current instance, and return
         * an instance that contains the specified scheme.
         *
         * Implementations MUST support the schemes "http" and "https" case
         * insensitively, and MAY accommodate other schemes if required.
         *
         * An empty scheme is equivalent to removing the scheme.
         *
         * @param string $scheme The scheme to use with the new instance.
         * @return static A new instance with the specified scheme.
         * @throws \InvalidArgumentException for invalid or unsupported schemes.
         */
        public function withScheme($scheme);
        /**
         * Return an instance with the specified user information.
         *
         * This method MUST retain the state of the current instance, and return
         * an instance that contains the specified user information.
         *
         * Password is optional, but the user information MUST include the
         * user; an empty string for the user is equivalent to removing user
         * information.
         *
         * @param string $user The user name to use for authority.
         * @param null|string $password The password associated with $user.
         * @return static A new instance with the specified user information.
         */
        public function withUserInfo($user, $password = null);
        /**
         * Return an instance with the specified host.
         *
         * This method MUST retain the state of the current instance, and return
         * an instance that contains the specified host.
         *
         * An empty host value is equivalent to removing the host.
         *
         * @param string $host The hostname to use with the new instance.
         * @return static A new instance with the specified host.
         * @throws \InvalidArgumentException for invalid hostnames.
         */
        public function withHost($host);
        /**
         * Return an instance with the specified port.
         *
         * This method MUST retain the state of the current instance, and return
         * an instance that contains the specified port.
         *
         * Implementations MUST raise an exception for ports outside the
         * established TCP and UDP port ranges.
         *
         * A null value provided for the port is equivalent to removing the port
         * information.
         *
         * @param null|int $port The port to use with the new instance; a null value
         *     removes the port information.
         * @return static A new instance with the specified port.
         * @throws \InvalidArgumentException for invalid ports.
         */
        public function withPort($port);
        /**
         * Return an instance with the specified path.
         *
         * This method MUST retain the state of the current instance, and return
         * an instance that contains the specified path.
         *
         * The path can either be empty or absolute (starting with a slash) or
         * rootless (not starting with a slash). Implementations MUST support all
         * three syntaxes.
         *
         * If the path is intended to be domain-relative rather than path relative then
         * it must begin with a slash ("/"). Paths not starting with a slash ("/")
         * are assumed to be relative to some base path known to the application or
         * consumer.
         *
         * Users can provide both encoded and decoded path characters.
         * Implementations ensure the correct encoding as outlined in getPath().
         *
         * @param string $path The path to use with the new instance.
         * @return static A new instance with the specified path.
         * @throws \InvalidArgumentException for invalid paths.
         */
        public function withPath($path);
        /**
         * Return an instance with the specified query string.
         *
         * This method MUST retain the state of the current instance, and return
         * an instance that contains the specified query string.
         *
         * Users can provide both encoded and decoded query characters.
         * Implementations ensure the correct encoding as outlined in getQuery().
         *
         * An empty query string value is equivalent to removing the query string.
         *
         * @param string $query The query string to use with the new instance.
         * @return static A new instance with the specified query string.
         * @throws \InvalidArgumentException for invalid query strings.
         */
        public function withQuery($query);
        /**
         * Return an instance with the specified URI fragment.
         *
         * This method MUST retain the state of the current instance, and return
         * an instance that contains the specified URI fragment.
         *
         * Users can provide both encoded and decoded fragment characters.
         * Implementations ensure the correct encoding as outlined in getFragment().
         *
         * An empty fragment value is equivalent to removing the fragment.
         *
         * @param string $fragment The fragment to use with the new instance.
         * @return static A new instance with the specified fragment.
         */
        public function withFragment($fragment);
        /**
         * Return the string representation as a URI reference.
         *
         * Depending on which components of the URI are present, the resulting
         * string is either a full URI or relative reference according to RFC 3986,
         * Section 4.1. The method concatenates the various components of the URI,
         * using the appropriate delimiters:
         *
         * - If a scheme is present, it MUST be suffixed by ":".
         * - If an authority is present, it MUST be prefixed by "//".
         * - The path can be concatenated without delimiters. But there are two
         *   cases where the path has to be adjusted to make the URI reference
         *   valid as PHP does not allow to throw an exception in __toString():
         *     - If the path is rootless and an authority is present, the path MUST
         *       be prefixed by "/".
         *     - If the path is starting with more than one "/" and no authority is
         *       present, the starting slashes MUST be reduced to one.
         * - If a query is present, it MUST be prefixed by "?".
         * - If a fragment is present, it MUST be prefixed by "#".
         *
         * @see http://tools.ietf.org/html/rfc3986#section-4.1
         * @return string
         */
        public function __toString();
    }
}
namespace Psr\SimpleCache {
    interface CacheInterface
    {
        /**
         * Fetches a value from the cache.
         *
         * @param string $key     The unique key of this item in the cache.
         * @param mixed  $default Default value to return if the key does not exist.
         *
         * @return mixed The value of the item from the cache, or $default in case of cache miss.
         *
         * @throws \Psr\SimpleCache\InvalidArgumentException
         *   MUST be thrown if the $key string is not a legal value.
         */
        public function get($key, $default = null);
        /**
         * Persists data in the cache, uniquely referenced by a key with an optional expiration TTL time.
         *
         * @param string                 $key   The key of the item to store.
         * @param mixed                  $value The value of the item to store, must be serializable.
         * @param null|int|\DateInterval $ttl   Optional. The TTL value of this item. If no value is sent and
         *                                      the driver supports TTL then the library may set a default value
         *                                      for it or let the driver take care of that.
         *
         * @return bool True on success and false on failure.
         *
         * @throws \Psr\SimpleCache\InvalidArgumentException
         *   MUST be thrown if the $key string is not a legal value.
         */
        public function set($key, $value, $ttl = null);
        /**
         * Delete an item from the cache by its unique key.
         *
         * @param string $key The unique cache key of the item to delete.
         *
         * @return bool True if the item was successfully removed. False if there was an error.
         *
         * @throws \Psr\SimpleCache\InvalidArgumentException
         *   MUST be thrown if the $key string is not a legal value.
         */
        public function delete($key);
        /**
         * Wipes clean the entire cache's keys.
         *
         * @return bool True on success and false on failure.
         */
        public function clear();
        /**
         * Obtains multiple cache items by their unique keys.
         *
         * @param iterable $keys    A list of keys that can obtained in a single operation.
         * @param mixed    $default Default value to return for keys that do not exist.
         *
         * @return iterable A list of key => value pairs. Cache keys that do not exist or are stale will have $default as value.
         *
         * @throws \Psr\SimpleCache\InvalidArgumentException
         *   MUST be thrown if $keys is neither an array nor a Traversable,
         *   or if any of the $keys are not a legal value.
         */
        public function getMultiple($keys, $default = null);
        /**
         * Persists a set of key => value pairs in the cache, with an optional TTL.
         *
         * @param iterable               $values A list of key => value pairs for a multiple-set operation.
         * @param null|int|\DateInterval $ttl    Optional. The TTL value of this item. If no value is sent and
         *                                       the driver supports TTL then the library may set a default value
         *                                       for it or let the driver take care of that.
         *
         * @return bool True on success and false on failure.
         *
         * @throws \Psr\SimpleCache\InvalidArgumentException
         *   MUST be thrown if $values is neither an array nor a Traversable,
         *   or if any of the $values are not a legal value.
         */
        public function setMultiple($values, $ttl = null);
        /**
         * Deletes multiple cache items in a single operation.
         *
         * @param iterable $keys A list of string-based keys to be deleted.
         *
         * @return bool True if the items were successfully removed. False if there was an error.
         *
         * @throws \Psr\SimpleCache\InvalidArgumentException
         *   MUST be thrown if $keys is neither an array nor a Traversable,
         *   or if any of the $keys are not a legal value.
         */
        public function deleteMultiple($keys);
        /**
         * Determines whether an item is present in the cache.
         *
         * NOTE: It is recommended that has() is only to be used for cache warming type purposes
         * and not to be used within your live applications operations for get/set, as this method
         * is subject to a race condition where your has() will return true and immediately after,
         * another script can remove it making the state of your app out of date.
         *
         * @param string $key The cache item key.
         *
         * @return bool
         *
         * @throws \Psr\SimpleCache\InvalidArgumentException
         *   MUST be thrown if the $key string is not a legal value.
         */
        public function has($key);
    }
    /**
     * Interface used for all types of exceptions thrown by the implementing library.
     */
    interface CacheException
    {
    }
    /**
     * Exception interface for invalid cache arguments.
     *
     * When an invalid argument is passed it must throw an exception which implements
     * this interface
     */
    interface InvalidArgumentException extends \Psr\SimpleCache\CacheException
    {
    }
}
namespace {
    // autoload_real.php @generated by Composer
    class ComposerAutoloaderInitd0a6b755e903507f6d27cbf0b1de92d3
    {
        private static $loader;
        public static function loadClassLoader($class)
        {
        }
        public static function getLoader()
        {
        }
    }
}
namespace Composer\Autoload {
    class ComposerStaticInitd0a6b755e903507f6d27cbf0b1de92d3
    {
        public static $files = array('0e6d7bf4a5811bfa5cf40c5ccd6fae6a' => __DIR__ . '/..' . '/symfony/polyfill-mbstring/bootstrap.php', 'abede361264e2ae69ec1eee813a101af' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/abs.php', '21a5860fbef5be28db5ddfbc3cca67c4' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/acos.php', '1546e3f9d127f2a9bb2d1b6c31c26ef1' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/acosh.php', 'd2516f7f4fba5ea5905f494b4a8262e0' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/acot.php', '4511163d560956219b96882c0980b65e' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/acoth.php', 'c361f5616dc2a8da4fa3e137077cd4ea' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/acsc.php', '02d68920fc98da71991ce569c91df0f6' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/acsch.php', '88e19525eae308b4a6aa3419364875d3' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/argument.php', '60e8e2d0827b58bfc904f13957e51849' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/asec.php', '13d2f040713999eab66c359b4d79871d' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/asech.php', '838ab38beb32c68a79d3cd2c007d5a04' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/asin.php', 'bb28eccd0f8f008333a1b3c163d604ac' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/asinh.php', '9e483de83558c98f7d3feaa402c78cb3' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/atan.php', '36b74b5b765ded91ee58c8ee3c0e85e3' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/atanh.php', '05c15ee9510da7fd6bf6136f436500c0' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/conjugate.php', 'd3208dfbce2505e370788f9f22f6785f' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/cos.php', '141cf1fb3a3046f8b64534b0ebab33ca' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/cosh.php', 'be660df75fd0dbe7fa7c03b7434b3294' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/cot.php', '01e31ea298a51bc9e91517e3ce6b9e76' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/coth.php', '803ddd97f7b1da68982a7b087c3476f6' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/csc.php', '3001cdfd101ec3c32da34ee43c2e149b' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/csch.php', '77b2d7629ef2a93fabb8c56754a91051' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/exp.php', '4a4471296dec796c21d4f4b6552396a9' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/inverse.php', 'c3e9897e1744b88deb56fcdc39d34d85' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/ln.php', 'a83cacf2de942cff288de15a83afd26d' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/log2.php', '6a861dacc9ee2f3061241d4c7772fa21' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/log10.php', '4d2522d968c8ba78d6c13548a1b4200e' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/negative.php', 'fd587ca933fc0447fa5ab4843bdd97f7' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/pow.php', '383ef01c62028fc78cd4388082fce3c2' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/rho.php', '150fbd1b95029dc47292da97ecab9375' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/sec.php', '549abd9bae174286d660bdaa07407c68' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/sech.php', '6bfbf5eaea6b17a0ed85cb21ba80370c' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/sin.php', '22efe13f1a497b8e199540ae2d9dc59c' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/sinh.php', 'e90135ab8e787795a509ed7147de207d' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/sqrt.php', 'bb0a7923ffc6a90919cd64ec54ff06bc' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/tan.php', '2d302f32ce0fd4e433dd91c5bb404a28' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/tanh.php', '24dd4658a952171a4ee79218c4f9fd06' => __DIR__ . '/..' . '/markbaker/complex/classes/src/functions/theta.php', 'e49b7876281d6f5bc39536dde96d1f4a' => __DIR__ . '/..' . '/markbaker/complex/classes/src/operations/add.php', '47596e02b43cd6da7700134fd08f88cf' => __DIR__ . '/..' . '/markbaker/complex/classes/src/operations/subtract.php', '883af48563631547925fa4c3b48ead07' => __DIR__ . '/..' . '/markbaker/complex/classes/src/operations/multiply.php', 'f190e3308e6ca23234a2875edc985c03' => __DIR__ . '/..' . '/markbaker/complex/classes/src/operations/divideby.php', 'ac9e33ce6841aa5bf5d16d465a2f03a7' => __DIR__ . '/..' . '/markbaker/complex/classes/src/operations/divideinto.php', '9d8e013a5160a09477beb8e44f8ae97b' => __DIR__ . '/..' . '/markbaker/matrix/classes/src/functions/adjoint.php', '6e78d1bdea6248d6aa117229efae50f2' => __DIR__ . '/..' . '/markbaker/matrix/classes/src/functions/antidiagonal.php', '4623d87924d94f5412fe5afbf1cef31d' => __DIR__ . '/..' . '/markbaker/matrix/classes/src/functions/cofactors.php', '901fd1f6950a637ca85f66b701a45e13' => __DIR__ . '/..' . '/markbaker/matrix/classes/src/functions/determinant.php', '83057abc0e4acc99ba80154ee5d02a49' => __DIR__ . '/..' . '/markbaker/matrix/classes/src/functions/diagonal.php', '07b7fd7a434451149b4fd477fca0ce06' => __DIR__ . '/..' . '/markbaker/matrix/classes/src/functions/identity.php', 'c8d43b340583e07ae89f2a3baef2cf89' => __DIR__ . '/..' . '/markbaker/matrix/classes/src/functions/inverse.php', '499bb10ed7a3aee2ba4c09a31a85e8d1' => __DIR__ . '/..' . '/markbaker/matrix/classes/src/functions/minors.php', '1cad2e6414d652e8b1c64e8967f6f37d' => __DIR__ . '/..' . '/markbaker/matrix/classes/src/functions/trace.php', '95a7f134ac17161d07def442b3b737e8' => __DIR__ . '/..' . '/markbaker/matrix/classes/src/functions/transpose.php', 'b3a6bc628377118d4b4b8ba08d1eb949' => __DIR__ . '/..' . '/markbaker/matrix/classes/src/operations/add.php', '5fef6d0e407f3f8887266dfa4a6c534c' => __DIR__ . '/..' . '/markbaker/matrix/classes/src/operations/directsum.php', '684ba247e1385946e3babdaa054119de' => __DIR__ . '/..' . '/markbaker/matrix/classes/src/operations/subtract.php', 'aa53dcba601214d17ad405b7c291b7e8' => __DIR__ . '/..' . '/markbaker/matrix/classes/src/operations/multiply.php', '75c79eb1b25749b05a47976f32b0d8a2' => __DIR__ . '/..' . '/markbaker/matrix/classes/src/operations/divideby.php', '6ab8ad87a734f276a6bcd5a0fe1289be' => __DIR__ . '/..' . '/markbaker/matrix/classes/src/operations/divideinto.php');
        public static $prefixLengthsPsr4 = array('Z' => array('ZipStream\\' => 10), 'S' => array('Symfony\\Polyfill\\Mbstring\\' => 26), 'P' => array('Psr\\SimpleCache\\' => 16, 'Psr\\Http\\Message\\' => 17, 'PhpOffice\\PhpSpreadsheet\\' => 25), 'M' => array('MyCLabs\\Enum\\' => 13, 'Matrix\\' => 7), 'C' => array('Complex\\' => 8));
        public static $prefixDirsPsr4 = array('ZipStream\\' => array(0 => __DIR__ . '/..' . '/maennchen/zipstream-php/src'), 'Symfony\\Polyfill\\Mbstring\\' => array(0 => __DIR__ . '/..' . '/symfony/polyfill-mbstring'), 'Psr\\SimpleCache\\' => array(0 => __DIR__ . '/..' . '/psr/simple-cache/src'), 'Psr\\Http\\Message\\' => array(0 => __DIR__ . '/..' . '/psr/http-message/src'), 'PhpOffice\\PhpSpreadsheet\\' => array(0 => __DIR__ . '/..' . '/phpoffice/phpspreadsheet/src/PhpSpreadsheet'), 'MyCLabs\\Enum\\' => array(0 => __DIR__ . '/..' . '/myclabs/php-enum/src'), 'Matrix\\' => array(0 => __DIR__ . '/..' . '/markbaker/matrix/classes/src'), 'Complex\\' => array(0 => __DIR__ . '/..' . '/markbaker/complex/classes/src'));
        public static function getInitializer(\Composer\Autoload\ClassLoader $loader)
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet {
    class Exception extends \Exception
    {
    }
}
namespace PhpOffice\PhpSpreadsheet\Reader {
    interface IReader
    {
        /**
         * IReader constructor.
         */
        public function __construct();
        /**
         * Can the current IReader read the file?
         *
         * @param string $pFilename
         *
         * @return bool
         */
        public function canRead($pFilename);
        /**
         * Read data only?
         *        If this is true, then the Reader will only read data values for cells, it will not read any formatting information.
         *        If false (the default) it will read data and formatting.
         *
         * @return bool
         */
        public function getReadDataOnly();
        /**
         * Set read data only
         *        Set to true, to advise the Reader only to read data values for cells, and to ignore any formatting information.
         *        Set to false (the default) to advise the Reader to read both data and formatting for cells.
         *
         * @param bool $pValue
         *
         * @return IReader
         */
        public function setReadDataOnly($pValue);
        /**
         * Read empty cells?
         *        If this is true (the default), then the Reader will read data values for all cells, irrespective of value.
         *        If false it will not read data for cells containing a null value or an empty string.
         *
         * @return bool
         */
        public function getReadEmptyCells();
        /**
         * Set read empty cells
         *        Set to true (the default) to advise the Reader read data values for all cells, irrespective of value.
         *        Set to false to advise the Reader to ignore cells containing a null value or an empty string.
         *
         * @param bool $pValue
         *
         * @return IReader
         */
        public function setReadEmptyCells($pValue);
        /**
         * Read charts in workbook?
         *        If this is true, then the Reader will include any charts that exist in the workbook.
         *      Note that a ReadDataOnly value of false overrides, and charts won't be read regardless of the IncludeCharts value.
         *        If false (the default) it will ignore any charts defined in the workbook file.
         *
         * @return bool
         */
        public function getIncludeCharts();
        /**
         * Set read charts in workbook
         *        Set to true, to advise the Reader to include any charts that exist in the workbook.
         *      Note that a ReadDataOnly value of false overrides, and charts won't be read regardless of the IncludeCharts value.
         *        Set to false (the default) to discard charts.
         *
         * @param bool $pValue
         *
         * @return IReader
         */
        public function setIncludeCharts($pValue);
        /**
         * Get which sheets to load
         * Returns either an array of worksheet names (the list of worksheets that should be loaded), or a null
         *        indicating that all worksheets in the workbook should be loaded.
         *
         * @return mixed
         */
        public function getLoadSheetsOnly();
        /**
         * Set which sheets to load.
         *
         * @param mixed $value
         *        This should be either an array of worksheet names to be loaded, or a string containing a single worksheet name.
         *        If NULL, then it tells the Reader to read all worksheets in the workbook
         *
         * @return IReader
         */
        public function setLoadSheetsOnly($value);
        /**
         * Set all sheets to load
         *        Tells the Reader to load all worksheets from the workbook.
         *
         * @return IReader
         */
        public function setLoadAllSheets();
        /**
         * Read filter.
         *
         * @return IReadFilter
         */
        public function getReadFilter();
        /**
         * Set read filter.
         *
         * @return IReader
         */
        public function setReadFilter(\PhpOffice\PhpSpreadsheet\Reader\IReadFilter $pValue);
        /**
         * Loads PhpSpreadsheet from file.
         *
         * @param string $pFilename
         *
         * @return \PhpOffice\PhpSpreadsheet\Spreadsheet
         */
        public function load($pFilename);
    }
    abstract class BaseReader implements \PhpOffice\PhpSpreadsheet\Reader\IReader
    {
        /**
         * Read data only?
         * Identifies whether the Reader should only read data values for cells, and ignore any formatting information;
         *        or whether it should read both data and formatting.
         *
         * @var bool
         */
        protected $readDataOnly = false;
        /**
         * Read empty cells?
         * Identifies whether the Reader should read data values for cells all cells, or should ignore cells containing
         *         null value or empty string.
         *
         * @var bool
         */
        protected $readEmptyCells = true;
        /**
         * Read charts that are defined in the workbook?
         * Identifies whether the Reader should read the definitions for any charts that exist in the workbook;.
         *
         * @var bool
         */
        protected $includeCharts = false;
        /**
         * Restrict which sheets should be loaded?
         * This property holds an array of worksheet names to be loaded. If null, then all worksheets will be loaded.
         *
         * @var array of string
         */
        protected $loadSheetsOnly;
        /**
         * IReadFilter instance.
         *
         * @var IReadFilter
         */
        protected $readFilter;
        protected $fileHandle;
        /**
         * @var XmlScanner
         */
        protected $securityScanner;
        public function __construct()
        {
        }
        public function getReadDataOnly()
        {
        }
        public function setReadDataOnly($pValue)
        {
        }
        public function getReadEmptyCells()
        {
        }
        public function setReadEmptyCells($pValue)
        {
        }
        public function getIncludeCharts()
        {
        }
        public function setIncludeCharts($pValue)
        {
        }
        public function getLoadSheetsOnly()
        {
        }
        public function setLoadSheetsOnly($value)
        {
        }
        public function setLoadAllSheets()
        {
        }
        public function getReadFilter()
        {
        }
        public function setReadFilter(\PhpOffice\PhpSpreadsheet\Reader\IReadFilter $pValue)
        {
        }
        public function getSecurityScanner()
        {
        }
        /**
         * Open file for reading.
         *
         * @param string $pFilename
         */
        protected function openFile($pFilename) : void
        {
        }
    }
    /**
     * Reader for SpreadsheetML, the XML schema for Microsoft Office Excel 2003.
     */
    class Xml extends \PhpOffice\PhpSpreadsheet\Reader\BaseReader
    {
        /**
         * Formats.
         *
         * @var array
         */
        protected $styles = [];
        /**
         * Character set used in the file.
         *
         * @var string
         */
        protected $charSet = 'UTF-8';
        /**
         * Create a new Excel2003XML Reader instance.
         */
        public function __construct()
        {
        }
        /**
         * Can the current IReader read the file?
         *
         * @param string $pFilename
         *
         * @return bool
         */
        public function canRead($pFilename)
        {
        }
        /**
         * Check if the file is a valid SimpleXML.
         *
         * @param string $pFilename
         *
         * @return false|SimpleXMLElement
         */
        public function trySimpleXMLLoadString($pFilename)
        {
        }
        /**
         * Reads names of the worksheets from a file, without parsing the whole file to a Spreadsheet object.
         *
         * @param string $pFilename
         *
         * @return array
         */
        public function listWorksheetNames($pFilename)
        {
        }
        /**
         * Return worksheet info (Name, Last Column Letter, Last Column Index, Total Rows, Total Columns).
         *
         * @param string $pFilename
         *
         * @return array
         */
        public function listWorksheetInfo($pFilename)
        {
        }
        /**
         * Loads Spreadsheet from file.
         *
         * @param string $pFilename
         *
         * @return Spreadsheet
         */
        public function load($pFilename)
        {
        }
        private static function identifyFixedStyleValue($styleList, &$styleAttributeValue)
        {
        }
        /**
         * pixel units to excel width units(units of 1/256th of a character width).
         *
         * @param float $pxs
         *
         * @return float
         */
        protected static function pixel2WidthUnits($pxs)
        {
        }
        /**
         * excel width units(units of 1/256th of a character width) to pixel units.
         *
         * @param float $widthUnits
         *
         * @return float
         */
        protected static function widthUnits2Pixel($widthUnits)
        {
        }
        protected static function hex2str($hex)
        {
        }
        /**
         * Loads from file into Spreadsheet instance.
         *
         * @param string $pFilename
         *
         * @return Spreadsheet
         */
        public function loadIntoExisting($pFilename, \PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
        protected static function convertStringEncoding($string, $charset)
        {
        }
        protected function parseRichText($is)
        {
        }
        private function parseStyles(\SimpleXMLElement $xml, array $namespaces) : void
        {
        }
        /**
         * @param string $styleID
         */
        private function parseStyleAlignment($styleID, \SimpleXMLElement $styleAttributes) : void
        {
        }
        /**
         * @param $styleID
         */
        private function parseStyleBorders($styleID, \SimpleXMLElement $styleData, array $namespaces) : void
        {
        }
        /**
         * @param $styleID
         */
        private function parseStyleFont($styleID, \SimpleXMLElement $styleAttributes) : void
        {
        }
        /**
         * @param $styleID
         */
        private function parseStyleInterior($styleID, \SimpleXMLElement $styleAttributes) : void
        {
        }
        /**
         * @param $styleID
         */
        private function parseStyleNumberFormat($styleID, \SimpleXMLElement $styleAttributes) : void
        {
        }
    }
    class Exception extends \PhpOffice\PhpSpreadsheet\Exception
    {
    }
    /** PhpSpreadsheet root directory */
    class Html extends \PhpOffice\PhpSpreadsheet\Reader\BaseReader
    {
        /**
         * Sample size to read to determine if it's HTML or not.
         */
        const TEST_SAMPLE_SIZE = 2048;
        /**
         * Input encoding.
         *
         * @var string
         */
        protected $inputEncoding = 'ANSI';
        /**
         * Sheet index to read.
         *
         * @var int
         */
        protected $sheetIndex = 0;
        /**
         * Formats.
         *
         * @var array
         */
        protected $formats = [
            'h1' => ['font' => ['bold' => true, 'size' => 24]],
            //    Bold, 24pt
            'h2' => ['font' => ['bold' => true, 'size' => 18]],
            //    Bold, 18pt
            'h3' => ['font' => ['bold' => true, 'size' => 13.5]],
            //    Bold, 13.5pt
            'h4' => ['font' => ['bold' => true, 'size' => 12]],
            //    Bold, 12pt
            'h5' => ['font' => ['bold' => true, 'size' => 10]],
            //    Bold, 10pt
            'h6' => ['font' => ['bold' => true, 'size' => 7.5]],
            //    Bold, 7.5pt
            'a' => ['font' => ['underline' => true, 'color' => ['argb' => \PhpOffice\PhpSpreadsheet\Style\Color::COLOR_BLUE]]],
            //    Blue underlined
            'hr' => ['borders' => ['bottom' => ['borderStyle' => \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_THIN, 'color' => [\PhpOffice\PhpSpreadsheet\Style\Color::COLOR_BLACK]]]],
            //    Bottom border
            'strong' => ['font' => ['bold' => true]],
            //    Bold
            'b' => ['font' => ['bold' => true]],
            //    Bold
            'i' => ['font' => ['italic' => true]],
            //    Italic
            'em' => ['font' => ['italic' => true]],
        ];
        protected $rowspan = [];
        /**
         * Create a new HTML Reader instance.
         */
        public function __construct()
        {
        }
        /**
         * Validate that the current file is an HTML file.
         *
         * @param string $pFilename
         *
         * @return bool
         */
        public function canRead($pFilename)
        {
        }
        private function readBeginning()
        {
        }
        private function readEnding()
        {
        }
        private static function startsWithTag($data)
        {
        }
        private static function endsWithTag($data)
        {
        }
        private static function containsTags($data)
        {
        }
        /**
         * Loads Spreadsheet from file.
         *
         * @param string $pFilename
         *
         * @return Spreadsheet
         */
        public function load($pFilename)
        {
        }
        /**
         * Set input encoding.
         *
         * @param string $pValue Input encoding, eg: 'ANSI'
         *
         * @return $this
         */
        public function setInputEncoding($pValue)
        {
        }
        /**
         * Get input encoding.
         *
         * @return string
         */
        public function getInputEncoding()
        {
        }
        //    Data Array used for testing only, should write to Spreadsheet object on completion of tests
        protected $dataArray = [];
        protected $tableLevel = 0;
        protected $nestedColumn = ['A'];
        protected function setTableStartColumn($column)
        {
        }
        protected function getTableStartColumn()
        {
        }
        protected function releaseTableStartColumn()
        {
        }
        protected function flushCell(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $sheet, $column, $row, &$cellContent) : void
        {
        }
        /**
         * @param int $row
         * @param string $column
         * @param string $cellContent
         */
        protected function processDomElement(\DOMNode $element, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $sheet, &$row, &$column, &$cellContent) : void
        {
        }
        /**
         * Loads PhpSpreadsheet from file into PhpSpreadsheet instance.
         *
         * @param string $pFilename
         *
         * @return Spreadsheet
         */
        public function loadIntoExisting($pFilename, \PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
        /**
         * Spreadsheet from content.
         *
         * @param string $content
         */
        public function loadFromString($content, ?\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet = null) : \PhpOffice\PhpSpreadsheet\Spreadsheet
        {
        }
        /**
         * Loads PhpSpreadsheet from DOMDocument into PhpSpreadsheet instance.
         */
        private function loadDocument(\DOMDocument $document, \PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet) : \PhpOffice\PhpSpreadsheet\Spreadsheet
        {
        }
        /**
         * Get sheet index.
         *
         * @return int
         */
        public function getSheetIndex()
        {
        }
        /**
         * Set sheet index.
         *
         * @param int $pValue Sheet index
         *
         * @return $this
         */
        public function setSheetIndex($pValue)
        {
        }
        /**
         * Apply inline css inline style.
         *
         * NOTES :
         * Currently only intended for td & th element,
         * and only takes 'background-color' and 'color'; property with HEX color
         *
         * TODO :
         * - Implement to other propertie, such as border
         *
         * @param Worksheet $sheet
         * @param int $row
         * @param string $column
         * @param array $attributeArray
         */
        private function applyInlineStyle(&$sheet, $row, $column, $attributeArray) : void
        {
        }
        /**
         * Check if has #, so we can get clean hex.
         *
         * @param $value
         *
         * @return null|string
         */
        public function getStyleColor($value)
        {
        }
        /**
         * @param string    $column
         * @param int       $row
         */
        private function insertImage(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $sheet, $column, $row, array $attributes) : void
        {
        }
        /**
         * Map html border style to PhpSpreadsheet border style.
         *
         * @param  string $style
         *
         * @return null|string
         */
        public function getBorderStyle($style)
        {
        }
        /**
         * @param string $styleValue
         * @param string $type
         */
        private function setBorderStyle(\PhpOffice\PhpSpreadsheet\Style\Style $cellStyle, $styleValue, $type) : void
        {
        }
    }
    interface IReadFilter
    {
        /**
         * Should this cell be read?
         *
         * @param string $column Column address (as a string value like "A", or "IV")
         * @param int $row Row number
         * @param string $worksheetName Optional worksheet name
         *
         * @return bool
         */
        public function readCell($column, $row, $worksheetName = '');
    }
    class DefaultReadFilter implements \PhpOffice\PhpSpreadsheet\Reader\IReadFilter
    {
        /**
         * Should this cell be read?
         *
         * @param string $column Column address (as a string value like "A", or "IV")
         * @param int $row Row number
         * @param string $worksheetName Optional worksheet name
         *
         * @return bool
         */
        public function readCell($column, $row, $worksheetName = '')
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Reader\Xlsx {
    class Chart
    {
        /**
         * @param string $name
         * @param string $format
         *
         * @return null|bool|float|int|string
         */
        private static function getAttribute(\SimpleXMLElement $component, $name, $format)
        {
        }
        private static function readColor($color, $background = false)
        {
        }
        /**
         * @param string $chartName
         *
         * @return \PhpOffice\PhpSpreadsheet\Chart\Chart
         */
        public static function readChart(\SimpleXMLElement $chartElements, $chartName)
        {
        }
        private static function chartTitle(\SimpleXMLElement $titleDetails, array $namespacesChartMeta)
        {
        }
        private static function chartLayoutDetails($chartDetail, $namespacesChartMeta)
        {
        }
        private static function chartDataSeries($chartDetail, $namespacesChartMeta, $plotType)
        {
        }
        private static function chartDataSeriesValueSet($seriesDetail, $namespacesChartMeta, $marker = null)
        {
        }
        private static function chartDataSeriesValues($seriesValueSet, $dataType = 'n')
        {
        }
        private static function chartDataSeriesValuesMultiLevel($seriesValueSet, $dataType = 'n')
        {
        }
        private static function parseRichText(\SimpleXMLElement $titleDetailPart)
        {
        }
        private static function readChartAttributes($chartDetail)
        {
        }
        /**
         * @param mixed $plotAttributes
         */
        private static function setChartAttributes(\PhpOffice\PhpSpreadsheet\Chart\Layout $plotArea, $plotAttributes) : void
        {
        }
    }
    class ConditionalStyles
    {
        private $worksheet;
        private $worksheetXml;
        private $dxfs;
        public function __construct(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $workSheet, \SimpleXMLElement $worksheetXml, array $dxfs = [])
        {
        }
        public function load() : void
        {
        }
        private function readConditionalStyles($xmlSheet)
        {
        }
        private function setConditionalStyles(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $worksheet, array $conditionals) : void
        {
        }
        private function readStyleRules($cfRules)
        {
        }
    }
    class DataValidations
    {
        private $worksheet;
        private $worksheetXml;
        public function __construct(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $workSheet, \SimpleXMLElement $worksheetXml)
        {
        }
        public function load() : void
        {
        }
    }
    class AutoFilter
    {
        private $worksheet;
        private $worksheetXml;
        public function __construct(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $workSheet, \SimpleXMLElement $worksheetXml)
        {
        }
        public function load() : void
        {
        }
        private function readAutoFilter($autoFilterRange, $xmlSheet) : void
        {
        }
        private function readDateRangeAutoFilter(\SimpleXMLElement $filters, \PhpOffice\PhpSpreadsheet\Worksheet\AutoFilter\Column $column) : void
        {
        }
        private function readCustomAutoFilter(\SimpleXMLElement $filterColumn, \PhpOffice\PhpSpreadsheet\Worksheet\AutoFilter\Column $column) : void
        {
        }
        private function readDynamicAutoFilter(\SimpleXMLElement $filterColumn, \PhpOffice\PhpSpreadsheet\Worksheet\AutoFilter\Column $column) : void
        {
        }
        private function readTopTenAutoFilter(\SimpleXMLElement $filterColumn, \PhpOffice\PhpSpreadsheet\Worksheet\AutoFilter\Column $column) : void
        {
        }
    }
    class BaseParserClass
    {
        protected static function boolean($value)
        {
        }
    }
    class SheetViews extends \PhpOffice\PhpSpreadsheet\Reader\Xlsx\BaseParserClass
    {
        private $sheetViewXml;
        private $worksheet;
        public function __construct(\SimpleXMLElement $sheetViewXml, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $workSheet)
        {
        }
        public function load() : void
        {
        }
        private function zoomScale() : void
        {
        }
        private function view() : void
        {
        }
        private function gridLines() : void
        {
        }
        private function headers() : void
        {
        }
        private function direction() : void
        {
        }
        private function showZeros() : void
        {
        }
        private function pane() : void
        {
        }
        private function selection() : void
        {
        }
    }
    class Hyperlinks
    {
        private $worksheet;
        private $hyperlinks = [];
        public function __construct(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $workSheet)
        {
        }
        public function readHyperlinks(\SimpleXMLElement $relsWorksheet) : void
        {
        }
        public function setHyperlinks(\SimpleXMLElement $worksheetXml) : void
        {
        }
        private function setHyperlink(\SimpleXMLElement $hyperlink, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $worksheet) : void
        {
        }
    }
    class Properties
    {
        private $securityScanner;
        private $docProps;
        public function __construct(\PhpOffice\PhpSpreadsheet\Reader\Security\XmlScanner $securityScanner, \PhpOffice\PhpSpreadsheet\Document\Properties $docProps)
        {
        }
        private function extractPropertyData($propertyData)
        {
        }
        public function readCoreProperties($propertyData) : void
        {
        }
        public function readExtendedProperties($propertyData) : void
        {
        }
        public function readCustomProperties($propertyData) : void
        {
        }
        private static function getArrayItem(array $array, $key = 0)
        {
        }
    }
    class SheetViewOptions extends \PhpOffice\PhpSpreadsheet\Reader\Xlsx\BaseParserClass
    {
        private $worksheet;
        private $worksheetXml;
        public function __construct(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $workSheet, ?\SimpleXMLElement $worksheetXml = null)
        {
        }
        /**
         * @param bool $readDataOnly
         */
        public function load($readDataOnly = false) : void
        {
        }
        private function tabColor(\SimpleXMLElement $sheetPr) : void
        {
        }
        private function codeName(\SimpleXMLElement $sheetPr) : void
        {
        }
        private function outlines(\SimpleXMLElement $sheetPr) : void
        {
        }
        private function pageSetup(\SimpleXMLElement $sheetPr) : void
        {
        }
        private function sheetFormat(\SimpleXMLElement $sheetFormatPr) : void
        {
        }
        private function printOptions(\SimpleXMLElement $printOptions) : void
        {
        }
    }
    class Theme
    {
        /**
         * Theme Name.
         *
         * @var string
         */
        private $themeName;
        /**
         * Colour Scheme Name.
         *
         * @var string
         */
        private $colourSchemeName;
        /**
         * Colour Map.
         *
         * @var array of string
         */
        private $colourMap;
        /**
         * Create a new Theme.
         *
         * @param mixed $themeName
         * @param mixed $colourSchemeName
         * @param mixed $colourMap
         */
        public function __construct($themeName, $colourSchemeName, $colourMap)
        {
        }
        /**
         * Get Theme Name.
         *
         * @return string
         */
        public function getThemeName()
        {
        }
        /**
         * Get colour Scheme Name.
         *
         * @return string
         */
        public function getColourSchemeName()
        {
        }
        /**
         * Get colour Map Value by Position.
         *
         * @param mixed $index
         *
         * @return string
         */
        public function getColourByIndex($index)
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    class ColumnAndRowAttributes extends \PhpOffice\PhpSpreadsheet\Reader\Xlsx\BaseParserClass
    {
        private $worksheet;
        private $worksheetXml;
        public function __construct(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $workSheet, ?\SimpleXMLElement $worksheetXml = null)
        {
        }
        /**
         * Set Worksheet column attributes by attributes array passed.
         *
         * @param string $columnAddress A, B, ... DX, ...
         * @param array $columnAttributes array of attributes (indexes are attribute name, values are value)
         *                               'xfIndex', 'visible', 'collapsed', 'outlineLevel', 'width', ... ?
         */
        private function setColumnAttributes($columnAddress, array $columnAttributes) : void
        {
        }
        /**
         * Set Worksheet row attributes by attributes array passed.
         *
         * @param int $rowNumber 1, 2, 3, ... 99, ...
         * @param array $rowAttributes array of attributes (indexes are attribute name, values are value)
         *                               'xfIndex', 'visible', 'collapsed', 'outlineLevel', 'rowHeight', ... ?
         */
        private function setRowAttributes($rowNumber, array $rowAttributes) : void
        {
        }
        /**
         * @param IReadFilter $readFilter
         * @param bool $readDataOnly
         */
        public function load(?\PhpOffice\PhpSpreadsheet\Reader\IReadFilter $readFilter = null, $readDataOnly = false) : void
        {
        }
        private function isFilteredColumn(\PhpOffice\PhpSpreadsheet\Reader\IReadFilter $readFilter, $columnCoordinate, array $rowsAttributes)
        {
        }
        private function readColumnAttributes(\SimpleXMLElement $worksheetCols, $readDataOnly)
        {
        }
        private function readColumnRangeAttributes(\SimpleXMLElement $column, $readDataOnly)
        {
        }
        private function isFilteredRow(\PhpOffice\PhpSpreadsheet\Reader\IReadFilter $readFilter, $rowCoordinate, array $columnsAttributes)
        {
        }
        private function readRowAttributes(\SimpleXMLElement $worksheetRow, $readDataOnly)
        {
        }
    }
    class PageSetup extends \PhpOffice\PhpSpreadsheet\Reader\Xlsx\BaseParserClass
    {
        private $worksheet;
        private $worksheetXml;
        public function __construct(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $workSheet, ?\SimpleXMLElement $worksheetXml = null)
        {
        }
        public function load(array $unparsedLoadedData)
        {
        }
        private function margins(\SimpleXMLElement $xmlSheet, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $worksheet) : void
        {
        }
        private function pageSetup(\SimpleXMLElement $xmlSheet, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $worksheet, array $unparsedLoadedData)
        {
        }
        private function headerFooter(\SimpleXMLElement $xmlSheet, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $worksheet) : void
        {
        }
        private function pageBreaks(\SimpleXMLElement $xmlSheet, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $worksheet) : void
        {
        }
        private function rowBreaks(\SimpleXMLElement $xmlSheet, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $worksheet) : void
        {
        }
        private function columnBreaks(\SimpleXMLElement $xmlSheet, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $worksheet) : void
        {
        }
    }
    class Styles extends \PhpOffice\PhpSpreadsheet\Reader\Xlsx\BaseParserClass
    {
        /**
         * Theme instance.
         *
         * @var Theme
         */
        private static $theme = null;
        private $styles = [];
        private $cellStyles = [];
        private $styleXml;
        public function __construct(\SimpleXMLElement $styleXml)
        {
        }
        public function setStyleBaseData(?\PhpOffice\PhpSpreadsheet\Reader\Xlsx\Theme $theme = null, $styles = [], $cellStyles = []) : void
        {
        }
        private static function readFontStyle(\PhpOffice\PhpSpreadsheet\Style\Font $fontStyle, \SimpleXMLElement $fontStyleXml) : void
        {
        }
        private static function readNumberFormat(\PhpOffice\PhpSpreadsheet\Style\NumberFormat $numfmtStyle, \SimpleXMLElement $numfmtStyleXml) : void
        {
        }
        private static function readFillStyle(\PhpOffice\PhpSpreadsheet\Style\Fill $fillStyle, \SimpleXMLElement $fillStyleXml) : void
        {
        }
        private static function readBorderStyle(\PhpOffice\PhpSpreadsheet\Style\Borders $borderStyle, \SimpleXMLElement $borderStyleXml) : void
        {
        }
        private static function readBorder(\PhpOffice\PhpSpreadsheet\Style\Border $border, \SimpleXMLElement $borderXml) : void
        {
        }
        private static function readAlignmentStyle(\PhpOffice\PhpSpreadsheet\Style\Alignment $alignment, \SimpleXMLElement $alignmentXml) : void
        {
        }
        private function readStyle(\PhpOffice\PhpSpreadsheet\Style\Style $docStyle, $style) : void
        {
        }
        private function readProtectionLocked(\PhpOffice\PhpSpreadsheet\Style\Style $docStyle, $style) : void
        {
        }
        private function readProtectionHidden(\PhpOffice\PhpSpreadsheet\Style\Style $docStyle, $style) : void
        {
        }
        private static function readColor($color, $background = false)
        {
        }
        public function dxfs($readDataOnly = false)
        {
        }
        public function styles()
        {
        }
        private static function getArrayItem($array, $key = 0)
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Reader\Ods {
    class Properties
    {
        private $spreadsheet;
        public function __construct(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
        public function load(\SimpleXMLElement $xml, $namespacesMeta) : void
        {
        }
        private function setCoreProperties(\PhpOffice\PhpSpreadsheet\Document\Properties $docProps, \SimpleXMLElement $officePropertyDC) : void
        {
        }
        private function setMetaProperties($namespacesMeta, \SimpleXMLElement $propertyValue, $propertyName, \PhpOffice\PhpSpreadsheet\Document\Properties $docProps) : void
        {
        }
        private function setUserDefinedProperty($propertyValueAttributes, $propertyValue, \PhpOffice\PhpSpreadsheet\Document\Properties $docProps) : void
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Reader {
    class Csv extends \PhpOffice\PhpSpreadsheet\Reader\BaseReader
    {
        /**
         * Input encoding.
         *
         * @var string
         */
        private $inputEncoding = 'UTF-8';
        /**
         * Delimiter.
         *
         * @var string
         */
        private $delimiter;
        /**
         * Enclosure.
         *
         * @var string
         */
        private $enclosure = '"';
        /**
         * Sheet index to read.
         *
         * @var int
         */
        private $sheetIndex = 0;
        /**
         * Load rows contiguously.
         *
         * @var bool
         */
        private $contiguous = false;
        /**
         * The character that can escape the enclosure.
         *
         * @var string
         */
        private $escapeCharacter = '\\';
        /**
         * Create a new CSV Reader instance.
         */
        public function __construct()
        {
        }
        /**
         * Set input encoding.
         *
         * @param string $pValue Input encoding, eg: 'UTF-8'
         *
         * @return $this
         */
        public function setInputEncoding($pValue)
        {
        }
        /**
         * Get input encoding.
         *
         * @return string
         */
        public function getInputEncoding()
        {
        }
        /**
         * Move filepointer past any BOM marker.
         */
        protected function skipBOM() : void
        {
        }
        /**
         * Identify any separator that is explicitly set in the file.
         */
        protected function checkSeparator() : void
        {
        }
        /**
         * Infer the separator if it isn't explicitly set in the file or specified by the user.
         */
        protected function inferSeparator() : void
        {
        }
        /**
         * Get the next full line from the file.
         *
         * @return false|string
         */
        private function getNextLine()
        {
        }
        /**
         * Return worksheet info (Name, Last Column Letter, Last Column Index, Total Rows, Total Columns).
         *
         * @param string $pFilename
         *
         * @return array
         */
        public function listWorksheetInfo($pFilename)
        {
        }
        /**
         * Loads Spreadsheet from file.
         *
         * @param string $pFilename
         *
         * @return Spreadsheet
         */
        public function load($pFilename)
        {
        }
        private function openFileOrMemory($pFilename) : void
        {
        }
        /**
         * Loads PhpSpreadsheet from file into PhpSpreadsheet instance.
         *
         * @param string $pFilename
         *
         * @return Spreadsheet
         */
        public function loadIntoExisting($pFilename, \PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
        /**
         * Get delimiter.
         *
         * @return string
         */
        public function getDelimiter()
        {
        }
        /**
         * Set delimiter.
         *
         * @param string $delimiter Delimiter, eg: ','
         *
         * @return $this
         */
        public function setDelimiter($delimiter)
        {
        }
        /**
         * Get enclosure.
         *
         * @return string
         */
        public function getEnclosure()
        {
        }
        /**
         * Set enclosure.
         *
         * @param string $enclosure Enclosure, defaults to "
         *
         * @return $this
         */
        public function setEnclosure($enclosure)
        {
        }
        /**
         * Get sheet index.
         *
         * @return int
         */
        public function getSheetIndex()
        {
        }
        /**
         * Set sheet index.
         *
         * @param int $pValue Sheet index
         *
         * @return $this
         */
        public function setSheetIndex($pValue)
        {
        }
        /**
         * Set Contiguous.
         *
         * @param bool $contiguous
         *
         * @return $this
         */
        public function setContiguous($contiguous)
        {
        }
        /**
         * Get Contiguous.
         *
         * @return bool
         */
        public function getContiguous()
        {
        }
        /**
         * Set escape backslashes.
         *
         * @param string $escapeCharacter
         *
         * @return $this
         */
        public function setEscapeCharacter($escapeCharacter)
        {
        }
        /**
         * Get escape backslashes.
         *
         * @return string
         */
        public function getEscapeCharacter()
        {
        }
        /**
         * Can the current IReader read the file?
         *
         * @param string $pFilename
         *
         * @return bool
         */
        public function canRead($pFilename)
        {
        }
    }
    class Slk extends \PhpOffice\PhpSpreadsheet\Reader\BaseReader
    {
        /**
         * Input encoding.
         *
         * @var string
         */
        private $inputEncoding = 'ANSI';
        /**
         * Sheet index to read.
         *
         * @var int
         */
        private $sheetIndex = 0;
        /**
         * Formats.
         *
         * @var array
         */
        private $formats = [];
        /**
         * Format Count.
         *
         * @var int
         */
        private $format = 0;
        /**
         * Create a new SYLK Reader instance.
         */
        public function __construct()
        {
        }
        /**
         * Validate that the current file is a SYLK file.
         *
         * @param string $pFilename
         *
         * @return bool
         */
        public function canRead($pFilename)
        {
        }
        /**
         * Set input encoding.
         *
         * @param string $pValue Input encoding, eg: 'ANSI'
         *
         * @return $this
         */
        public function setInputEncoding($pValue)
        {
        }
        /**
         * Get input encoding.
         *
         * @return string
         */
        public function getInputEncoding()
        {
        }
        /**
         * Return worksheet info (Name, Last Column Letter, Last Column Index, Total Rows, Total Columns).
         *
         * @param string $pFilename
         *
         * @return array
         */
        public function listWorksheetInfo($pFilename)
        {
        }
        /**
         * Loads PhpSpreadsheet from file.
         *
         * @param string $pFilename
         *
         * @return Spreadsheet
         */
        public function load($pFilename)
        {
        }
        /**
         * Loads PhpSpreadsheet from file into PhpSpreadsheet instance.
         *
         * @param string $pFilename
         *
         * @return Spreadsheet
         */
        public function loadIntoExisting($pFilename, \PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
        /**
         * Get sheet index.
         *
         * @return int
         */
        public function getSheetIndex()
        {
        }
        /**
         * Set sheet index.
         *
         * @param int $pValue Sheet index
         *
         * @return $this
         */
        public function setSheetIndex($pValue)
        {
        }
    }
    class Ods extends \PhpOffice\PhpSpreadsheet\Reader\BaseReader
    {
        /**
         * Create a new Ods Reader instance.
         */
        public function __construct()
        {
        }
        /**
         * Can the current IReader read the file?
         *
         * @param string $pFilename
         *
         * @return bool
         */
        public function canRead($pFilename)
        {
        }
        /**
         * Reads names of the worksheets from a file, without parsing the whole file to a PhpSpreadsheet object.
         *
         * @param string $pFilename
         *
         * @return string[]
         */
        public function listWorksheetNames($pFilename)
        {
        }
        /**
         * Return worksheet info (Name, Last Column Letter, Last Column Index, Total Rows, Total Columns).
         *
         * @param string $pFilename
         *
         * @return array
         */
        public function listWorksheetInfo($pFilename)
        {
        }
        /**
         * Loads PhpSpreadsheet from file.
         *
         * @param string $pFilename
         *
         * @return Spreadsheet
         */
        public function load($pFilename)
        {
        }
        /**
         * Loads PhpSpreadsheet from file into PhpSpreadsheet instance.
         *
         * @param string $pFilename
         *
         * @return Spreadsheet
         */
        public function loadIntoExisting($pFilename, \PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
        /**
         * Recursively scan element.
         *
         * @return string
         */
        protected function scanElementForText(\DOMNode $element)
        {
        }
        /**
         * @param string $is
         *
         * @return RichText
         */
        private function parseRichText($is)
        {
        }
    }
    class Xlsx extends \PhpOffice\PhpSpreadsheet\Reader\BaseReader
    {
        /**
         * ReferenceHelper instance.
         *
         * @var ReferenceHelper
         */
        private $referenceHelper;
        /**
         * Xlsx\Theme instance.
         *
         * @var Xlsx\Theme
         */
        private static $theme = null;
        /**
         * Create a new Xlsx Reader instance.
         */
        public function __construct()
        {
        }
        /**
         * Can the current IReader read the file?
         *
         * @param string $pFilename
         *
         * @return bool
         */
        public function canRead($pFilename)
        {
        }
        /**
         * Reads names of the worksheets from a file, without parsing the whole file to a Spreadsheet object.
         *
         * @param string $pFilename
         *
         * @return array
         */
        public function listWorksheetNames($pFilename)
        {
        }
        /**
         * Return worksheet info (Name, Last Column Letter, Last Column Index, Total Rows, Total Columns).
         *
         * @param string $pFilename
         *
         * @return array
         */
        public function listWorksheetInfo($pFilename)
        {
        }
        private static function castToBoolean($c)
        {
        }
        private static function castToError($c)
        {
        }
        private static function castToString($c)
        {
        }
        private function castToFormula($c, $r, &$cellDataType, &$value, &$calculatedValue, &$sharedFormulas, $castBaseType) : void
        {
        }
        /**
         * @param string $fileName
         *
         * @return string
         */
        private function getFromZipArchive(\ZipArchive $archive, $fileName = '')
        {
        }
        /**
         * Loads Spreadsheet from file.
         *
         * @param string $pFilename
         *
         * @return Spreadsheet
         */
        public function load($pFilename)
        {
        }
        private static function readColor($color, $background = false)
        {
        }
        /**
         * @param SimpleXMLElement|stdClass $style
         */
        private static function readStyle(\PhpOffice\PhpSpreadsheet\Style\Style $docStyle, $style) : void
        {
        }
        /**
         * @param SimpleXMLElement $eleBorder
         */
        private static function readBorder(\PhpOffice\PhpSpreadsheet\Style\Border $docBorder, $eleBorder) : void
        {
        }
        /**
         * @param SimpleXMLElement | null $is
         *
         * @return RichText
         */
        private function parseRichText($is)
        {
        }
        /**
         * @param mixed $customUITarget
         * @param mixed $zip
         */
        private function readRibbon(\PhpOffice\PhpSpreadsheet\Spreadsheet $excel, $customUITarget, $zip) : void
        {
        }
        private static function getArrayItem($array, $key = 0)
        {
        }
        private static function dirAdd($base, $add)
        {
        }
        private static function toCSSArray($style)
        {
        }
        public static function stripWhiteSpaceFromStyleString($string)
        {
        }
        private static function boolean($value)
        {
        }
        /**
         * @param \PhpOffice\PhpSpreadsheet\Worksheet\Drawing $objDrawing
         * @param SimpleXMLElement $cellAnchor
         * @param array $hyperlinks
         */
        private function readHyperLinkDrawing($objDrawing, $cellAnchor, $hyperlinks) : void
        {
        }
        private function readProtection(\PhpOffice\PhpSpreadsheet\Spreadsheet $excel, \SimpleXMLElement $xmlWorkbook) : void
        {
        }
        private function readFormControlProperties(\PhpOffice\PhpSpreadsheet\Spreadsheet $excel, \ZipArchive $zip, $dir, $fileWorksheet, $docSheet, array &$unparsedLoadedData) : void
        {
        }
        private function readPrinterSettings(\PhpOffice\PhpSpreadsheet\Spreadsheet $excel, \ZipArchive $zip, $dir, $fileWorksheet, $docSheet, array &$unparsedLoadedData) : void
        {
        }
        /**
         * Convert an 'xsd:boolean' XML value to a PHP boolean value.
         * A valid 'xsd:boolean' XML value can be one of the following
         * four values: 'true', 'false', '1', '0'.  It is case sensitive.
         *
         * Note that just doing '(bool) $xsdBoolean' is not safe,
         * since '(bool) "false"' returns true.
         *
         * @see https://www.w3.org/TR/xmlschema11-2/#boolean
         *
         * @param string $xsdBoolean An XML string value of type 'xsd:boolean'
         *
         * @return bool  Boolean value
         */
        private function castXsdBooleanToBool($xsdBoolean)
        {
        }
        /**
         * @param ZipArchive $zip Opened zip archive
         *
         * @return string basename of the used excel workbook
         */
        private function getWorkbookBaseName(\ZipArchive $zip)
        {
        }
        private function readSheetProtection(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $docSheet, \SimpleXMLElement $xmlSheet) : void
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Reader\Xls {
    class ErrorCode
    {
        protected static $map = [0x0 => '#NULL!', 0x7 => '#DIV/0!', 0xf => '#VALUE!', 0x17 => '#REF!', 0x1d => '#NAME?', 0x24 => '#NUM!', 0x2a => '#N/A'];
        /**
         * Map error code, e.g. '#N/A'.
         *
         * @param int $code
         *
         * @return bool|string
         */
        public static function lookup($code)
        {
        }
    }
    class Color
    {
        /**
         * Read color.
         *
         * @param int $color Indexed color
         * @param array $palette Color palette
         * @param int $version
         *
         * @return array RGB color value, example: ['rgb' => 'FF0000']
         */
        public static function map($color, $palette, $version)
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Reader\Xls\Color {
    class BuiltIn
    {
        protected static $map = [
            0x0 => '000000',
            0x1 => 'FFFFFF',
            0x2 => 'FF0000',
            0x3 => '00FF00',
            0x4 => '0000FF',
            0x5 => 'FFFF00',
            0x6 => 'FF00FF',
            0x7 => '00FFFF',
            0x40 => '000000',
            // system window text color
            0x41 => 'FFFFFF',
        ];
        /**
         * Map built-in color to RGB value.
         *
         * @param int $color Indexed color
         *
         * @return array
         */
        public static function lookup($color)
        {
        }
    }
    class BIFF8
    {
        protected static $map = [0x8 => '000000', 0x9 => 'FFFFFF', 0xa => 'FF0000', 0xb => '00FF00', 0xc => '0000FF', 0xd => 'FFFF00', 0xe => 'FF00FF', 0xf => '00FFFF', 0x10 => '800000', 0x11 => '008000', 0x12 => '000080', 0x13 => '808000', 0x14 => '800080', 0x15 => '008080', 0x16 => 'C0C0C0', 0x17 => '808080', 0x18 => '9999FF', 0x19 => '993366', 0x1a => 'FFFFCC', 0x1b => 'CCFFFF', 0x1c => '660066', 0x1d => 'FF8080', 0x1e => '0066CC', 0x1f => 'CCCCFF', 0x20 => '000080', 0x21 => 'FF00FF', 0x22 => 'FFFF00', 0x23 => '00FFFF', 0x24 => '800080', 0x25 => '800000', 0x26 => '008080', 0x27 => '0000FF', 0x28 => '00CCFF', 0x29 => 'CCFFFF', 0x2a => 'CCFFCC', 0x2b => 'FFFF99', 0x2c => '99CCFF', 0x2d => 'FF99CC', 0x2e => 'CC99FF', 0x2f => 'FFCC99', 0x30 => '3366FF', 0x31 => '33CCCC', 0x32 => '99CC00', 0x33 => 'FFCC00', 0x34 => 'FF9900', 0x35 => 'FF6600', 0x36 => '666699', 0x37 => '969696', 0x38 => '003366', 0x39 => '339966', 0x3a => '003300', 0x3b => '333300', 0x3c => '993300', 0x3d => '993366', 0x3e => '333399', 0x3f => '333333'];
        /**
         * Map color array from BIFF8 built-in color index.
         *
         * @param int $color
         *
         * @return array
         */
        public static function lookup($color)
        {
        }
    }
    class BIFF5
    {
        protected static $map = [0x8 => '000000', 0x9 => 'FFFFFF', 0xa => 'FF0000', 0xb => '00FF00', 0xc => '0000FF', 0xd => 'FFFF00', 0xe => 'FF00FF', 0xf => '00FFFF', 0x10 => '800000', 0x11 => '008000', 0x12 => '000080', 0x13 => '808000', 0x14 => '800080', 0x15 => '008080', 0x16 => 'C0C0C0', 0x17 => '808080', 0x18 => '8080FF', 0x19 => '802060', 0x1a => 'FFFFC0', 0x1b => 'A0E0F0', 0x1c => '600080', 0x1d => 'FF8080', 0x1e => '0080C0', 0x1f => 'C0C0FF', 0x20 => '000080', 0x21 => 'FF00FF', 0x22 => 'FFFF00', 0x23 => '00FFFF', 0x24 => '800080', 0x25 => '800000', 0x26 => '008080', 0x27 => '0000FF', 0x28 => '00CFFF', 0x29 => '69FFFF', 0x2a => 'E0FFE0', 0x2b => 'FFFF80', 0x2c => 'A6CAF0', 0x2d => 'DD9CB3', 0x2e => 'B38FEE', 0x2f => 'E3E3E3', 0x30 => '2A6FF9', 0x31 => '3FB8CD', 0x32 => '488436', 0x33 => '958C41', 0x34 => '8E5E42', 0x35 => 'A0627A', 0x36 => '624FAC', 0x37 => '969696', 0x38 => '1D2FBE', 0x39 => '286676', 0x3a => '004500', 0x3b => '453E01', 0x3c => '6A2813', 0x3d => '85396A', 0x3e => '4A3285', 0x3f => '424242'];
        /**
         * Map color array from BIFF5 built-in color index.
         *
         * @param int $color
         *
         * @return array
         */
        public static function lookup($color)
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Reader\Xls {
    class MD5
    {
        // Context
        private $a;
        private $b;
        private $c;
        private $d;
        /**
         * MD5 stream constructor.
         */
        public function __construct()
        {
        }
        /**
         * Reset the MD5 stream context.
         */
        public function reset() : void
        {
        }
        /**
         * Get MD5 stream context.
         *
         * @return string
         */
        public function getContext()
        {
        }
        /**
         * Add data to context.
         *
         * @param string $data Data to add
         */
        public function add($data) : void
        {
        }
        private static function f($X, $Y, $Z)
        {
        }
        private static function g($X, $Y, $Z)
        {
        }
        private static function h($X, $Y, $Z)
        {
        }
        private static function i($X, $Y, $Z)
        {
        }
        private static function step($func, &$A, $B, $C, $D, $M, $s, $t) : void
        {
        }
        private static function rotate($decimal, $bits)
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Reader\Xls\Style {
    class FillPattern
    {
        protected static $map = [0x0 => \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_NONE, 0x1 => \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_SOLID, 0x2 => \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_MEDIUMGRAY, 0x3 => \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_DARKGRAY, 0x4 => \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_LIGHTGRAY, 0x5 => \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_DARKHORIZONTAL, 0x6 => \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_DARKVERTICAL, 0x7 => \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_DARKDOWN, 0x8 => \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_DARKUP, 0x9 => \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_DARKGRID, 0xa => \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_DARKTRELLIS, 0xb => \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_LIGHTHORIZONTAL, 0xc => \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_LIGHTVERTICAL, 0xd => \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_LIGHTDOWN, 0xe => \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_LIGHTUP, 0xf => \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_LIGHTGRID, 0x10 => \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_LIGHTTRELLIS, 0x11 => \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_GRAY125, 0x12 => \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_GRAY0625];
        /**
         * Get fill pattern from index
         * OpenOffice documentation: 2.5.12.
         *
         * @param int $index
         *
         * @return string
         */
        public static function lookup($index)
        {
        }
    }
    class Border
    {
        protected static $map = [0x0 => \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_NONE, 0x1 => \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_THIN, 0x2 => \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_MEDIUM, 0x3 => \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_DASHED, 0x4 => \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_DOTTED, 0x5 => \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_THICK, 0x6 => \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_DOUBLE, 0x7 => \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_HAIR, 0x8 => \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_MEDIUMDASHED, 0x9 => \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_DASHDOT, 0xa => \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_MEDIUMDASHDOT, 0xb => \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_DASHDOTDOT, 0xc => \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_MEDIUMDASHDOTDOT, 0xd => \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_SLANTDASHDOT];
        /**
         * Map border style
         * OpenOffice documentation: 2.5.11.
         *
         * @param int $index
         *
         * @return string
         */
        public static function lookup($index)
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Reader\Xls {
    class RC4
    {
        // Context
        protected $s = [];
        protected $i = 0;
        protected $j = 0;
        /**
         * RC4 stream decryption/encryption constrcutor.
         *
         * @param string $key Encryption key/passphrase
         */
        public function __construct($key)
        {
        }
        /**
         * Symmetric decryption/encryption function.
         *
         * @param string $data Data to encrypt/decrypt
         *
         * @return string
         */
        public function RC4($data)
        {
        }
    }
    class Escher
    {
        const DGGCONTAINER = 0xf000;
        const BSTORECONTAINER = 0xf001;
        const DGCONTAINER = 0xf002;
        const SPGRCONTAINER = 0xf003;
        const SPCONTAINER = 0xf004;
        const DGG = 0xf006;
        const BSE = 0xf007;
        const DG = 0xf008;
        const SPGR = 0xf009;
        const SP = 0xf00a;
        const OPT = 0xf00b;
        const CLIENTTEXTBOX = 0xf00d;
        const CLIENTANCHOR = 0xf010;
        const CLIENTDATA = 0xf011;
        const BLIPJPEG = 0xf01d;
        const BLIPPNG = 0xf01e;
        const SPLITMENUCOLORS = 0xf11e;
        const TERTIARYOPT = 0xf122;
        /**
         * Escher stream data (binary).
         *
         * @var string
         */
        private $data;
        /**
         * Size in bytes of the Escher stream data.
         *
         * @var int
         */
        private $dataSize;
        /**
         * Current position of stream pointer in Escher stream data.
         *
         * @var int
         */
        private $pos;
        /**
         * The object to be returned by the reader. Modified during load.
         *
         * @var BSE|BstoreContainer|DgContainer|DggContainer|\PhpOffice\PhpSpreadsheet\Shared\Escher|SpContainer|SpgrContainer
         */
        private $object;
        /**
         * Create a new Escher instance.
         *
         * @param mixed $object
         */
        public function __construct($object)
        {
        }
        /**
         * Load Escher stream data. May be a partial Escher stream.
         *
         * @param string $data
         *
         * @return BSE|BstoreContainer|DgContainer|DggContainer|\PhpOffice\PhpSpreadsheet\Shared\Escher|SpContainer|SpgrContainer
         */
        public function load($data)
        {
        }
        /**
         * Read a generic record.
         */
        private function readDefault() : void
        {
        }
        /**
         * Read DggContainer record (Drawing Group Container).
         */
        private function readDggContainer() : void
        {
        }
        /**
         * Read Dgg record (Drawing Group).
         */
        private function readDgg() : void
        {
        }
        /**
         * Read BstoreContainer record (Blip Store Container).
         */
        private function readBstoreContainer() : void
        {
        }
        /**
         * Read BSE record.
         */
        private function readBSE() : void
        {
        }
        /**
         * Read BlipJPEG record. Holds raw JPEG image data.
         */
        private function readBlipJPEG() : void
        {
        }
        /**
         * Read BlipPNG record. Holds raw PNG image data.
         */
        private function readBlipPNG() : void
        {
        }
        /**
         * Read OPT record. This record may occur within DggContainer record or SpContainer.
         */
        private function readOPT() : void
        {
        }
        /**
         * Read TertiaryOPT record.
         */
        private function readTertiaryOPT() : void
        {
        }
        /**
         * Read SplitMenuColors record.
         */
        private function readSplitMenuColors() : void
        {
        }
        /**
         * Read DgContainer record (Drawing Container).
         */
        private function readDgContainer() : void
        {
        }
        /**
         * Read Dg record (Drawing).
         */
        private function readDg() : void
        {
        }
        /**
         * Read SpgrContainer record (Shape Group Container).
         */
        private function readSpgrContainer() : void
        {
        }
        /**
         * Read SpContainer record (Shape Container).
         */
        private function readSpContainer() : void
        {
        }
        /**
         * Read Spgr record (Shape Group).
         */
        private function readSpgr() : void
        {
        }
        /**
         * Read Sp record (Shape).
         */
        private function readSp() : void
        {
        }
        /**
         * Read ClientTextbox record.
         */
        private function readClientTextbox() : void
        {
        }
        /**
         * Read ClientAnchor record. This record holds information about where the shape is anchored in worksheet.
         */
        private function readClientAnchor() : void
        {
        }
        /**
         * Read ClientData record.
         */
        private function readClientData() : void
        {
        }
        /**
         * Read OfficeArtRGFOPTE table of property-value pairs.
         *
         * @param string $data Binary data
         * @param int $n Number of properties
         */
        private function readOfficeArtRGFOPTE($data, $n) : void
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Reader {
    class Gnumeric extends \PhpOffice\PhpSpreadsheet\Reader\BaseReader
    {
        /**
         * Shared Expressions.
         *
         * @var array
         */
        private $expressions = [];
        private $referenceHelper;
        /**
         * Create a new Gnumeric.
         */
        public function __construct()
        {
        }
        /**
         * Can the current IReader read the file?
         *
         * @param string $pFilename
         *
         * @return bool
         */
        public function canRead($pFilename)
        {
        }
        /**
         * Reads names of the worksheets from a file, without parsing the whole file to a Spreadsheet object.
         *
         * @param string $pFilename
         *
         * @return array
         */
        public function listWorksheetNames($pFilename)
        {
        }
        /**
         * Return worksheet info (Name, Last Column Letter, Last Column Index, Total Rows, Total Columns).
         *
         * @param string $pFilename
         *
         * @return array
         */
        public function listWorksheetInfo($pFilename)
        {
        }
        /**
         * @param string $filename
         *
         * @return string
         */
        private function gzfileGetContents($filename)
        {
        }
        /**
         * Loads Spreadsheet from file.
         *
         * @param string $pFilename
         *
         * @return Spreadsheet
         */
        public function load($pFilename)
        {
        }
        /**
         * Loads from file into Spreadsheet instance.
         *
         * @param string $pFilename
         *
         * @return Spreadsheet
         */
        public function loadIntoExisting($pFilename, \PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
        private static function parseBorderAttributes($borderAttributes)
        {
        }
        private function parseRichText($is)
        {
        }
        private static function parseGnumericColour($gnmColour)
        {
        }
    }
    // Original file header of ParseXL (used as the base for this class):
    // --------------------------------------------------------------------------------
    // Adapted from Excel_Spreadsheet_Reader developed by users bizon153,
    // trex005, and mmp11 (SourceForge.net)
    // https://sourceforge.net/projects/phpexcelreader/
    // Primary changes made by canyoncasa (dvc) for ParseXL 1.00 ...
    //     Modelled moreso after Perl Excel Parse/Write modules
    //     Added Parse_Excel_Spreadsheet object
    //         Reads a whole worksheet or tab as row,column array or as
    //         associated hash of indexed rows and named column fields
    //     Added variables for worksheet (tab) indexes and names
    //     Added an object call for loading individual woorksheets
    //     Changed default indexing defaults to 0 based arrays
    //     Fixed date/time and percent formats
    //     Includes patches found at SourceForge...
    //         unicode patch by nobody
    //         unpack("d") machine depedency patch by matchy
    //         boundsheet utf16 patch by bjaenichen
    //     Renamed functions for shorter names
    //     General code cleanup and rigor, including <80 column width
    //     Included a testcase Excel file and PHP example calls
    //     Code works for PHP 5.x
    // Primary changes made by canyoncasa (dvc) for ParseXL 1.10 ...
    // http://sourceforge.net/tracker/index.php?func=detail&aid=1466964&group_id=99160&atid=623334
    //     Decoding of formula conditions, results, and tokens.
    //     Support for user-defined named cells added as an array "namedcells"
    //         Patch code for user-defined named cells supports single cells only.
    //         NOTE: this patch only works for BIFF8 as BIFF5-7 use a different
    //         external sheet reference structure
    class Xls extends \PhpOffice\PhpSpreadsheet\Reader\BaseReader
    {
        // ParseXL definitions
        const XLS_BIFF8 = 0x600;
        const XLS_BIFF7 = 0x500;
        const XLS_WORKBOOKGLOBALS = 0x5;
        const XLS_WORKSHEET = 0x10;
        // record identifiers
        const XLS_TYPE_FORMULA = 0x6;
        const XLS_TYPE_EOF = 0xa;
        const XLS_TYPE_PROTECT = 0x12;
        const XLS_TYPE_OBJECTPROTECT = 0x63;
        const XLS_TYPE_SCENPROTECT = 0xdd;
        const XLS_TYPE_PASSWORD = 0x13;
        const XLS_TYPE_HEADER = 0x14;
        const XLS_TYPE_FOOTER = 0x15;
        const XLS_TYPE_EXTERNSHEET = 0x17;
        const XLS_TYPE_DEFINEDNAME = 0x18;
        const XLS_TYPE_VERTICALPAGEBREAKS = 0x1a;
        const XLS_TYPE_HORIZONTALPAGEBREAKS = 0x1b;
        const XLS_TYPE_NOTE = 0x1c;
        const XLS_TYPE_SELECTION = 0x1d;
        const XLS_TYPE_DATEMODE = 0x22;
        const XLS_TYPE_EXTERNNAME = 0x23;
        const XLS_TYPE_LEFTMARGIN = 0x26;
        const XLS_TYPE_RIGHTMARGIN = 0x27;
        const XLS_TYPE_TOPMARGIN = 0x28;
        const XLS_TYPE_BOTTOMMARGIN = 0x29;
        const XLS_TYPE_PRINTGRIDLINES = 0x2b;
        const XLS_TYPE_FILEPASS = 0x2f;
        const XLS_TYPE_FONT = 0x31;
        const XLS_TYPE_CONTINUE = 0x3c;
        const XLS_TYPE_PANE = 0x41;
        const XLS_TYPE_CODEPAGE = 0x42;
        const XLS_TYPE_DEFCOLWIDTH = 0x55;
        const XLS_TYPE_OBJ = 0x5d;
        const XLS_TYPE_COLINFO = 0x7d;
        const XLS_TYPE_IMDATA = 0x7f;
        const XLS_TYPE_SHEETPR = 0x81;
        const XLS_TYPE_HCENTER = 0x83;
        const XLS_TYPE_VCENTER = 0x84;
        const XLS_TYPE_SHEET = 0x85;
        const XLS_TYPE_PALETTE = 0x92;
        const XLS_TYPE_SCL = 0xa0;
        const XLS_TYPE_PAGESETUP = 0xa1;
        const XLS_TYPE_MULRK = 0xbd;
        const XLS_TYPE_MULBLANK = 0xbe;
        const XLS_TYPE_DBCELL = 0xd7;
        const XLS_TYPE_XF = 0xe0;
        const XLS_TYPE_MERGEDCELLS = 0xe5;
        const XLS_TYPE_MSODRAWINGGROUP = 0xeb;
        const XLS_TYPE_MSODRAWING = 0xec;
        const XLS_TYPE_SST = 0xfc;
        const XLS_TYPE_LABELSST = 0xfd;
        const XLS_TYPE_EXTSST = 0xff;
        const XLS_TYPE_EXTERNALBOOK = 0x1ae;
        const XLS_TYPE_DATAVALIDATIONS = 0x1b2;
        const XLS_TYPE_TXO = 0x1b6;
        const XLS_TYPE_HYPERLINK = 0x1b8;
        const XLS_TYPE_DATAVALIDATION = 0x1be;
        const XLS_TYPE_DIMENSION = 0x200;
        const XLS_TYPE_BLANK = 0x201;
        const XLS_TYPE_NUMBER = 0x203;
        const XLS_TYPE_LABEL = 0x204;
        const XLS_TYPE_BOOLERR = 0x205;
        const XLS_TYPE_STRING = 0x207;
        const XLS_TYPE_ROW = 0x208;
        const XLS_TYPE_INDEX = 0x20b;
        const XLS_TYPE_ARRAY = 0x221;
        const XLS_TYPE_DEFAULTROWHEIGHT = 0x225;
        const XLS_TYPE_WINDOW2 = 0x23e;
        const XLS_TYPE_RK = 0x27e;
        const XLS_TYPE_STYLE = 0x293;
        const XLS_TYPE_FORMAT = 0x41e;
        const XLS_TYPE_SHAREDFMLA = 0x4bc;
        const XLS_TYPE_BOF = 0x809;
        const XLS_TYPE_SHEETPROTECTION = 0x867;
        const XLS_TYPE_RANGEPROTECTION = 0x868;
        const XLS_TYPE_SHEETLAYOUT = 0x862;
        const XLS_TYPE_XFEXT = 0x87d;
        const XLS_TYPE_PAGELAYOUTVIEW = 0x88b;
        const XLS_TYPE_UNKNOWN = 0xffff;
        // Encryption type
        const MS_BIFF_CRYPTO_NONE = 0;
        const MS_BIFF_CRYPTO_XOR = 1;
        const MS_BIFF_CRYPTO_RC4 = 2;
        // Size of stream blocks when using RC4 encryption
        const REKEY_BLOCK = 0x400;
        /**
         * Summary Information stream data.
         *
         * @var string
         */
        private $summaryInformation;
        /**
         * Extended Summary Information stream data.
         *
         * @var string
         */
        private $documentSummaryInformation;
        /**
         * Workbook stream data. (Includes workbook globals substream as well as sheet substreams).
         *
         * @var string
         */
        private $data;
        /**
         * Size in bytes of $this->data.
         *
         * @var int
         */
        private $dataSize;
        /**
         * Current position in stream.
         *
         * @var int
         */
        private $pos;
        /**
         * Workbook to be returned by the reader.
         *
         * @var Spreadsheet
         */
        private $spreadsheet;
        /**
         * Worksheet that is currently being built by the reader.
         *
         * @var Worksheet
         */
        private $phpSheet;
        /**
         * BIFF version.
         *
         * @var int
         */
        private $version;
        /**
         * Codepage set in the Excel file being read. Only important for BIFF5 (Excel 5.0 - Excel 95)
         * For BIFF8 (Excel 97 - Excel 2003) this will always have the value 'UTF-16LE'.
         *
         * @var string
         */
        private $codepage;
        /**
         * Shared formats.
         *
         * @var array
         */
        private $formats;
        /**
         * Shared fonts.
         *
         * @var array
         */
        private $objFonts;
        /**
         * Color palette.
         *
         * @var array
         */
        private $palette;
        /**
         * Worksheets.
         *
         * @var array
         */
        private $sheets;
        /**
         * External books.
         *
         * @var array
         */
        private $externalBooks;
        /**
         * REF structures. Only applies to BIFF8.
         *
         * @var array
         */
        private $ref;
        /**
         * External names.
         *
         * @var array
         */
        private $externalNames;
        /**
         * Defined names.
         *
         * @var array
         */
        private $definedname;
        /**
         * Shared strings. Only applies to BIFF8.
         *
         * @var array
         */
        private $sst;
        /**
         * Panes are frozen? (in sheet currently being read). See WINDOW2 record.
         *
         * @var bool
         */
        private $frozen;
        /**
         * Fit printout to number of pages? (in sheet currently being read). See SHEETPR record.
         *
         * @var bool
         */
        private $isFitToPages;
        /**
         * Objects. One OBJ record contributes with one entry.
         *
         * @var array
         */
        private $objs;
        /**
         * Text Objects. One TXO record corresponds with one entry.
         *
         * @var array
         */
        private $textObjects;
        /**
         * Cell Annotations (BIFF8).
         *
         * @var array
         */
        private $cellNotes;
        /**
         * The combined MSODRAWINGGROUP data.
         *
         * @var string
         */
        private $drawingGroupData;
        /**
         * The combined MSODRAWING data (per sheet).
         *
         * @var string
         */
        private $drawingData;
        /**
         * Keep track of XF index.
         *
         * @var int
         */
        private $xfIndex;
        /**
         * Mapping of XF index (that is a cell XF) to final index in cellXf collection.
         *
         * @var array
         */
        private $mapCellXfIndex;
        /**
         * Mapping of XF index (that is a style XF) to final index in cellStyleXf collection.
         *
         * @var array
         */
        private $mapCellStyleXfIndex;
        /**
         * The shared formulas in a sheet. One SHAREDFMLA record contributes with one value.
         *
         * @var array
         */
        private $sharedFormulas;
        /**
         * The shared formula parts in a sheet. One FORMULA record contributes with one value if it
         * refers to a shared formula.
         *
         * @var array
         */
        private $sharedFormulaParts;
        /**
         * The type of encryption in use.
         *
         * @var int
         */
        private $encryption = 0;
        /**
         * The position in the stream after which contents are encrypted.
         *
         * @var int
         */
        private $encryptionStartPos = false;
        /**
         * The current RC4 decryption object.
         *
         * @var Xls\RC4
         */
        private $rc4Key;
        /**
         * The position in the stream that the RC4 decryption object was left at.
         *
         * @var int
         */
        private $rc4Pos = 0;
        /**
         * The current MD5 context state.
         *
         * @var string
         */
        private $md5Ctxt;
        /**
         * @var int
         */
        private $textObjRef;
        /**
         * @var string
         */
        private $baseCell;
        /**
         * Create a new Xls Reader instance.
         */
        public function __construct()
        {
        }
        /**
         * Can the current IReader read the file?
         *
         * @param string $pFilename
         *
         * @return bool
         */
        public function canRead($pFilename)
        {
        }
        /**
         * Reads names of the worksheets from a file, without parsing the whole file to a PhpSpreadsheet object.
         *
         * @param string $pFilename
         *
         * @return array
         */
        public function listWorksheetNames($pFilename)
        {
        }
        /**
         * Return worksheet info (Name, Last Column Letter, Last Column Index, Total Rows, Total Columns).
         *
         * @param string $pFilename
         *
         * @return array
         */
        public function listWorksheetInfo($pFilename)
        {
        }
        /**
         * Loads PhpSpreadsheet from file.
         *
         * @param string $pFilename
         *
         * @return Spreadsheet
         */
        public function load($pFilename)
        {
        }
        /**
         * Read record data from stream, decrypting as required.
         *
         * @param string $data Data stream to read from
         * @param int $pos Position to start reading from
         * @param int $len Record data length
         *
         * @return string Record data
         */
        private function readRecordData($data, $pos, $len)
        {
        }
        /**
         * Use OLE reader to extract the relevant data streams from the OLE file.
         *
         * @param string $pFilename
         */
        private function loadOLE($pFilename) : void
        {
        }
        /**
         * Read summary information.
         */
        private function readSummaryInformation() : void
        {
        }
        /**
         * Read additional document summary information.
         */
        private function readDocumentSummaryInformation() : void
        {
        }
        /**
         * Reads a general type of BIFF record. Does nothing except for moving stream pointer forward to next record.
         */
        private function readDefault() : void
        {
        }
        /**
         *    The NOTE record specifies a comment associated with a particular cell. In Excel 95 (BIFF7) and earlier versions,
         *        this record stores a note (cell note). This feature was significantly enhanced in Excel 97.
         */
        private function readNote() : void
        {
        }
        /**
         * The TEXT Object record contains the text associated with a cell annotation.
         */
        private function readTextObject() : void
        {
        }
        /**
         * Read BOF.
         */
        private function readBof() : void
        {
        }
        /**
         * FILEPASS.
         *
         * This record is part of the File Protection Block. It
         * contains information about the read/write password of the
         * file. All record contents following this record will be
         * encrypted.
         *
         * --    "OpenOffice.org's Documentation of the Microsoft
         *         Excel File Format"
         *
         * The decryption functions and objects used from here on in
         * are based on the source of Spreadsheet-ParseExcel:
         * https://metacpan.org/release/Spreadsheet-ParseExcel
         */
        private function readFilepass() : void
        {
        }
        /**
         * Make an RC4 decryptor for the given block.
         *
         * @param int $block Block for which to create decrypto
         * @param string $valContext MD5 context state
         *
         * @return Xls\RC4
         */
        private function makeKey($block, $valContext)
        {
        }
        /**
         * Verify RC4 file password.
         *
         * @param string $password Password to check
         * @param string $docid Document id
         * @param string $salt_data Salt data
         * @param string $hashedsalt_data Hashed salt data
         * @param string $valContext Set to the MD5 context of the value
         *
         * @return bool Success
         */
        private function verifyPassword($password, $docid, $salt_data, $hashedsalt_data, &$valContext)
        {
        }
        /**
         * CODEPAGE.
         *
         * This record stores the text encoding used to write byte
         * strings, stored as MS Windows code page identifier.
         *
         * --    "OpenOffice.org's Documentation of the Microsoft
         *         Excel File Format"
         */
        private function readCodepage() : void
        {
        }
        /**
         * DATEMODE.
         *
         * This record specifies the base date for displaying date
         * values. All dates are stored as count of days past this
         * base date. In BIFF2-BIFF4 this record is part of the
         * Calculation Settings Block. In BIFF5-BIFF8 it is
         * stored in the Workbook Globals Substream.
         *
         * --    "OpenOffice.org's Documentation of the Microsoft
         *         Excel File Format"
         */
        private function readDateMode() : void
        {
        }
        /**
         * Read a FONT record.
         */
        private function readFont() : void
        {
        }
        /**
         * FORMAT.
         *
         * This record contains information about a number format.
         * All FORMAT records occur together in a sequential list.
         *
         * In BIFF2-BIFF4 other records referencing a FORMAT record
         * contain a zero-based index into this list. From BIFF5 on
         * the FORMAT record contains the index itself that will be
         * used by other records.
         *
         * --    "OpenOffice.org's Documentation of the Microsoft
         *         Excel File Format"
         */
        private function readFormat() : void
        {
        }
        /**
         * XF - Extended Format.
         *
         * This record contains formatting information for cells, rows, columns or styles.
         * According to https://support.microsoft.com/en-us/help/147732 there are always at least 15 cell style XF
         * and 1 cell XF.
         * Inspection of Excel files generated by MS Office Excel shows that XF records 0-14 are cell style XF
         * and XF record 15 is a cell XF
         * We only read the first cell style XF and skip the remaining cell style XF records
         * We read all cell XF records.
         *
         * --    "OpenOffice.org's Documentation of the Microsoft
         *         Excel File Format"
         */
        private function readXf() : void
        {
        }
        private function readXfExt() : void
        {
        }
        /**
         * Read STYLE record.
         */
        private function readStyle() : void
        {
        }
        /**
         * Read PALETTE record.
         */
        private function readPalette() : void
        {
        }
        /**
         * SHEET.
         *
         * This record is  located in the  Workbook Globals
         * Substream  and represents a sheet inside the workbook.
         * One SHEET record is written for each sheet. It stores the
         * sheet name and a stream offset to the BOF record of the
         * respective Sheet Substream within the Workbook Stream.
         *
         * --    "OpenOffice.org's Documentation of the Microsoft
         *         Excel File Format"
         */
        private function readSheet() : void
        {
        }
        /**
         * Read EXTERNALBOOK record.
         */
        private function readExternalBook() : void
        {
        }
        /**
         * Read EXTERNNAME record.
         */
        private function readExternName() : void
        {
        }
        /**
         * Read EXTERNSHEET record.
         */
        private function readExternSheet() : void
        {
        }
        /**
         * DEFINEDNAME.
         *
         * This record is part of a Link Table. It contains the name
         * and the token array of an internal defined name. Token
         * arrays of defined names contain tokens with aberrant
         * token classes.
         *
         * --    "OpenOffice.org's Documentation of the Microsoft
         *         Excel File Format"
         */
        private function readDefinedName() : void
        {
        }
        /**
         * Read MSODRAWINGGROUP record.
         */
        private function readMsoDrawingGroup() : void
        {
        }
        /**
         * SST - Shared String Table.
         *
         * This record contains a list of all strings used anywhere
         * in the workbook. Each string occurs only once. The
         * workbook uses indexes into the list to reference the
         * strings.
         *
         * --    "OpenOffice.org's Documentation of the Microsoft
         *         Excel File Format"
         */
        private function readSst() : void
        {
        }
        /**
         * Read PRINTGRIDLINES record.
         */
        private function readPrintGridlines() : void
        {
        }
        /**
         * Read DEFAULTROWHEIGHT record.
         */
        private function readDefaultRowHeight() : void
        {
        }
        /**
         * Read SHEETPR record.
         */
        private function readSheetPr() : void
        {
        }
        /**
         * Read HORIZONTALPAGEBREAKS record.
         */
        private function readHorizontalPageBreaks() : void
        {
        }
        /**
         * Read VERTICALPAGEBREAKS record.
         */
        private function readVerticalPageBreaks() : void
        {
        }
        /**
         * Read HEADER record.
         */
        private function readHeader() : void
        {
        }
        /**
         * Read FOOTER record.
         */
        private function readFooter() : void
        {
        }
        /**
         * Read HCENTER record.
         */
        private function readHcenter() : void
        {
        }
        /**
         * Read VCENTER record.
         */
        private function readVcenter() : void
        {
        }
        /**
         * Read LEFTMARGIN record.
         */
        private function readLeftMargin() : void
        {
        }
        /**
         * Read RIGHTMARGIN record.
         */
        private function readRightMargin() : void
        {
        }
        /**
         * Read TOPMARGIN record.
         */
        private function readTopMargin() : void
        {
        }
        /**
         * Read BOTTOMMARGIN record.
         */
        private function readBottomMargin() : void
        {
        }
        /**
         * Read PAGESETUP record.
         */
        private function readPageSetup() : void
        {
        }
        /**
         * PROTECT - Sheet protection (BIFF2 through BIFF8)
         *   if this record is omitted, then it also means no sheet protection.
         */
        private function readProtect() : void
        {
        }
        /**
         * SCENPROTECT.
         */
        private function readScenProtect() : void
        {
        }
        /**
         * OBJECTPROTECT.
         */
        private function readObjectProtect() : void
        {
        }
        /**
         * PASSWORD - Sheet protection (hashed) password (BIFF2 through BIFF8).
         */
        private function readPassword() : void
        {
        }
        /**
         * Read DEFCOLWIDTH record.
         */
        private function readDefColWidth() : void
        {
        }
        /**
         * Read COLINFO record.
         */
        private function readColInfo() : void
        {
        }
        /**
         * ROW.
         *
         * This record contains the properties of a single row in a
         * sheet. Rows and cells in a sheet are divided into blocks
         * of 32 rows.
         *
         * --    "OpenOffice.org's Documentation of the Microsoft
         *         Excel File Format"
         */
        private function readRow() : void
        {
        }
        /**
         * Read RK record
         * This record represents a cell that contains an RK value
         * (encoded integer or floating-point value). If a
         * floating-point value cannot be encoded to an RK value,
         * a NUMBER record will be written. This record replaces the
         * record INTEGER written in BIFF2.
         *
         * --    "OpenOffice.org's Documentation of the Microsoft
         *         Excel File Format"
         */
        private function readRk() : void
        {
        }
        /**
         * Read LABELSST record
         * This record represents a cell that contains a string. It
         * replaces the LABEL record and RSTRING record used in
         * BIFF2-BIFF5.
         *
         * --    "OpenOffice.org's Documentation of the Microsoft
         *         Excel File Format"
         */
        private function readLabelSst() : void
        {
        }
        /**
         * Read MULRK record
         * This record represents a cell range containing RK value
         * cells. All cells are located in the same row.
         *
         * --    "OpenOffice.org's Documentation of the Microsoft
         *         Excel File Format"
         */
        private function readMulRk() : void
        {
        }
        /**
         * Read NUMBER record
         * This record represents a cell that contains a
         * floating-point value.
         *
         * --    "OpenOffice.org's Documentation of the Microsoft
         *         Excel File Format"
         */
        private function readNumber() : void
        {
        }
        /**
         * Read FORMULA record + perhaps a following STRING record if formula result is a string
         * This record contains the token array and the result of a
         * formula cell.
         *
         * --    "OpenOffice.org's Documentation of the Microsoft
         *         Excel File Format"
         */
        private function readFormula() : void
        {
        }
        /**
         * Read a SHAREDFMLA record. This function just stores the binary shared formula in the reader,
         * which usually contains relative references.
         * These will be used to construct the formula in each shared formula part after the sheet is read.
         */
        private function readSharedFmla() : void
        {
        }
        /**
         * Read a STRING record from current stream position and advance the stream pointer to next record
         * This record is used for storing result from FORMULA record when it is a string, and
         * it occurs directly after the FORMULA record.
         *
         * @return string The string contents as UTF-8
         */
        private function readString()
        {
        }
        /**
         * Read BOOLERR record
         * This record represents a Boolean value or error value
         * cell.
         *
         * --    "OpenOffice.org's Documentation of the Microsoft
         *         Excel File Format"
         */
        private function readBoolErr() : void
        {
        }
        /**
         * Read MULBLANK record
         * This record represents a cell range of empty cells. All
         * cells are located in the same row.
         *
         * --    "OpenOffice.org's Documentation of the Microsoft
         *         Excel File Format"
         */
        private function readMulBlank() : void
        {
        }
        /**
         * Read LABEL record
         * This record represents a cell that contains a string. In
         * BIFF8 it is usually replaced by the LABELSST record.
         * Excel still uses this record, if it copies unformatted
         * text cells to the clipboard.
         *
         * --    "OpenOffice.org's Documentation of the Microsoft
         *         Excel File Format"
         */
        private function readLabel() : void
        {
        }
        /**
         * Read BLANK record.
         */
        private function readBlank() : void
        {
        }
        /**
         * Read MSODRAWING record.
         */
        private function readMsoDrawing() : void
        {
        }
        /**
         * Read OBJ record.
         */
        private function readObj() : void
        {
        }
        /**
         * Read WINDOW2 record.
         */
        private function readWindow2() : void
        {
        }
        /**
         * Read PLV Record(Created by Excel2007 or upper).
         */
        private function readPageLayoutView() : void
        {
        }
        /**
         * Read SCL record.
         */
        private function readScl() : void
        {
        }
        /**
         * Read PANE record.
         */
        private function readPane() : void
        {
        }
        /**
         * Read SELECTION record. There is one such record for each pane in the sheet.
         */
        private function readSelection() : void
        {
        }
        private function includeCellRangeFiltered($cellRangeAddress)
        {
        }
        /**
         * MERGEDCELLS.
         *
         * This record contains the addresses of merged cell ranges
         * in the current sheet.
         *
         * --    "OpenOffice.org's Documentation of the Microsoft
         *         Excel File Format"
         */
        private function readMergedCells() : void
        {
        }
        /**
         * Read HYPERLINK record.
         */
        private function readHyperLink() : void
        {
        }
        /**
         * Read DATAVALIDATIONS record.
         */
        private function readDataValidations() : void
        {
        }
        /**
         * Read DATAVALIDATION record.
         */
        private function readDataValidation() : void
        {
        }
        /**
         * Read SHEETLAYOUT record. Stores sheet tab color information.
         */
        private function readSheetLayout() : void
        {
        }
        /**
         * Read SHEETPROTECTION record (FEATHEADR).
         */
        private function readSheetProtection() : void
        {
        }
        /**
         * Read RANGEPROTECTION record
         * Reading of this record is based on Microsoft Office Excel 97-2000 Binary File Format Specification,
         * where it is referred to as FEAT record.
         */
        private function readRangeProtection() : void
        {
        }
        /**
         * Read a free CONTINUE record. Free CONTINUE record may be a camouflaged MSODRAWING record
         * When MSODRAWING data on a sheet exceeds 8224 bytes, CONTINUE records are used instead. Undocumented.
         * In this case, we must treat the CONTINUE record as a MSODRAWING record.
         */
        private function readContinue() : void
        {
        }
        /**
         * Reads a record from current position in data stream and continues reading data as long as CONTINUE
         * records are found. Splices the record data pieces and returns the combined string as if record data
         * is in one piece.
         * Moves to next current position in data stream to start of next record different from a CONtINUE record.
         *
         * @return array
         */
        private function getSplicedRecordData()
        {
        }
        /**
         * Convert formula structure into human readable Excel formula like 'A3+A5*5'.
         *
         * @param string $formulaStructure The complete binary data for the formula
         * @param string $baseCell Base cell, only needed when formula contains tRefN tokens, e.g. with shared formulas
         *
         * @return string Human readable formula
         */
        private function getFormulaFromStructure($formulaStructure, $baseCell = 'A1')
        {
        }
        /**
         * Take formula data and additional data for formula and return human readable formula.
         *
         * @param string $formulaData The binary data for the formula itself
         * @param string $additionalData Additional binary data going with the formula
         * @param string $baseCell Base cell, only needed when formula contains tRefN tokens, e.g. with shared formulas
         *
         * @return string Human readable formula
         */
        private function getFormulaFromData($formulaData, $additionalData = '', $baseCell = 'A1')
        {
        }
        /**
         * Take array of tokens together with additional data for formula and return human readable formula.
         *
         * @param array $tokens
         * @param string $additionalData Additional binary data going with the formula
         *
         * @return string Human readable formula
         */
        private function createFormulaFromTokens($tokens, $additionalData)
        {
        }
        /**
         * Fetch next token from binary formula data.
         *
         * @param string $formulaData Formula data
         * @param string $baseCell Base cell, only needed when formula contains tRefN tokens, e.g. with shared formulas
         *
         * @return array
         */
        private function getNextToken($formulaData, $baseCell = 'A1')
        {
        }
        /**
         * Reads a cell address in BIFF8 e.g. 'A2' or '$A$2'
         * section 3.3.4.
         *
         * @param string $cellAddressStructure
         *
         * @return string
         */
        private function readBIFF8CellAddress($cellAddressStructure)
        {
        }
        /**
         * Reads a cell address in BIFF8 for shared formulas. Uses positive and negative values for row and column
         * to indicate offsets from a base cell
         * section 3.3.4.
         *
         * @param string $cellAddressStructure
         * @param string $baseCell Base cell, only needed when formula contains tRefN tokens, e.g. with shared formulas
         *
         * @return string
         */
        private function readBIFF8CellAddressB($cellAddressStructure, $baseCell = 'A1')
        {
        }
        /**
         * Reads a cell range address in BIFF5 e.g. 'A2:B6' or 'A1'
         * always fixed range
         * section 2.5.14.
         *
         * @param string $subData
         *
         * @return string
         */
        private function readBIFF5CellRangeAddressFixed($subData)
        {
        }
        /**
         * Reads a cell range address in BIFF8 e.g. 'A2:B6' or 'A1'
         * always fixed range
         * section 2.5.14.
         *
         * @param string $subData
         *
         * @return string
         */
        private function readBIFF8CellRangeAddressFixed($subData)
        {
        }
        /**
         * Reads a cell range address in BIFF8 e.g. 'A2:B6' or '$A$2:$B$6'
         * there are flags indicating whether column/row index is relative
         * section 3.3.4.
         *
         * @param string $subData
         *
         * @return string
         */
        private function readBIFF8CellRangeAddress($subData)
        {
        }
        /**
         * Reads a cell range address in BIFF8 for shared formulas. Uses positive and negative values for row and column
         * to indicate offsets from a base cell
         * section 3.3.4.
         *
         * @param string $subData
         * @param string $baseCell Base cell
         *
         * @return string Cell range address
         */
        private function readBIFF8CellRangeAddressB($subData, $baseCell = 'A1')
        {
        }
        /**
         * Read BIFF8 cell range address list
         * section 2.5.15.
         *
         * @param string $subData
         *
         * @return array
         */
        private function readBIFF8CellRangeAddressList($subData)
        {
        }
        /**
         * Read BIFF5 cell range address list
         * section 2.5.15.
         *
         * @param string $subData
         *
         * @return array
         */
        private function readBIFF5CellRangeAddressList($subData)
        {
        }
        /**
         * Get a sheet range like Sheet1:Sheet3 from REF index
         * Note: If there is only one sheet in the range, one gets e.g Sheet1
         * It can also happen that the REF structure uses the -1 (FFFF) code to indicate deleted sheets,
         * in which case an Exception is thrown.
         *
         * @param int $index
         *
         * @return false|string
         */
        private function readSheetRangeByRefIndex($index)
        {
        }
        /**
         * read BIFF8 constant value array from array data
         * returns e.g. ['value' => '{1,2;3,4}', 'size' => 40]
         * section 2.5.8.
         *
         * @param string $arrayData
         *
         * @return array
         */
        private static function readBIFF8ConstantArray($arrayData)
        {
        }
        /**
         * read BIFF8 constant value which may be 'Empty Value', 'Number', 'String Value', 'Boolean Value', 'Error Value'
         * section 2.5.7
         * returns e.g. ['value' => '5', 'size' => 9].
         *
         * @param string $valueData
         *
         * @return array
         */
        private static function readBIFF8Constant($valueData)
        {
        }
        /**
         * Extract RGB color
         * OpenOffice.org's Documentation of the Microsoft Excel File Format, section 2.5.4.
         *
         * @param string $rgb Encoded RGB value (4 bytes)
         *
         * @return array
         */
        private static function readRGB($rgb)
        {
        }
        /**
         * Read byte string (8-bit string length)
         * OpenOffice documentation: 2.5.2.
         *
         * @param string $subData
         *
         * @return array
         */
        private function readByteStringShort($subData)
        {
        }
        /**
         * Read byte string (16-bit string length)
         * OpenOffice documentation: 2.5.2.
         *
         * @param string $subData
         *
         * @return array
         */
        private function readByteStringLong($subData)
        {
        }
        /**
         * Extracts an Excel Unicode short string (8-bit string length)
         * OpenOffice documentation: 2.5.3
         * function will automatically find out where the Unicode string ends.
         *
         * @param string $subData
         *
         * @return array
         */
        private static function readUnicodeStringShort($subData)
        {
        }
        /**
         * Extracts an Excel Unicode long string (16-bit string length)
         * OpenOffice documentation: 2.5.3
         * this function is under construction, needs to support rich text, and Asian phonetic settings.
         *
         * @param string $subData
         *
         * @return array
         */
        private static function readUnicodeStringLong($subData)
        {
        }
        /**
         * Read Unicode string with no string length field, but with known character count
         * this function is under construction, needs to support rich text, and Asian phonetic settings
         * OpenOffice.org's Documentation of the Microsoft Excel File Format, section 2.5.3.
         *
         * @param string $subData
         * @param int $characterCount
         *
         * @return array
         */
        private static function readUnicodeString($subData, $characterCount)
        {
        }
        /**
         * Convert UTF-8 string to string surounded by double quotes. Used for explicit string tokens in formulas.
         * Example:  hello"world  -->  "hello""world".
         *
         * @param string $value UTF-8 encoded string
         *
         * @return string
         */
        private static function UTF8toExcelDoubleQuoted($value)
        {
        }
        /**
         * Reads first 8 bytes of a string and return IEEE 754 float.
         *
         * @param string $data Binary string that is at least 8 bytes long
         *
         * @return float
         */
        private static function extractNumber($data)
        {
        }
        /**
         * @param int $rknum
         *
         * @return float
         */
        private static function getIEEE754($rknum)
        {
        }
        /**
         * Get UTF-8 string from (compressed or uncompressed) UTF-16 string.
         *
         * @param string $string
         * @param bool $compressed
         *
         * @return string
         */
        private static function encodeUTF16($string, $compressed = false)
        {
        }
        /**
         * Convert UTF-16 string in compressed notation to uncompressed form. Only used for BIFF8.
         *
         * @param string $string
         *
         * @return string
         */
        private static function uncompressByteString($string)
        {
        }
        /**
         * Convert string to UTF-8. Only used for BIFF5.
         *
         * @param string $string
         *
         * @return string
         */
        private function decodeCodepage($string)
        {
        }
        /**
         * Read 16-bit unsigned integer.
         *
         * @param string $data
         * @param int $pos
         *
         * @return int
         */
        public static function getUInt2d($data, $pos)
        {
        }
        /**
         * Read 16-bit signed integer.
         *
         * @param string $data
         * @param int $pos
         *
         * @return int
         */
        public static function getInt2d($data, $pos)
        {
        }
        /**
         * Read 32-bit signed integer.
         *
         * @param string $data
         * @param int $pos
         *
         * @return int
         */
        public static function getInt4d($data, $pos)
        {
        }
        private function parseRichText($is)
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Reader\Security {
    class XmlScanner
    {
        /**
         * String used to identify risky xml elements.
         *
         * @var string
         */
        private $pattern;
        private $callback;
        private static $libxmlDisableEntityLoaderValue;
        public function __construct($pattern = '<!DOCTYPE')
        {
        }
        public static function getInstance(\PhpOffice\PhpSpreadsheet\Reader\IReader $reader)
        {
        }
        public static function threadSafeLibxmlDisableEntityLoaderAvailability()
        {
        }
        private function disableEntityLoaderCheck() : void
        {
        }
        public static function shutdown() : void
        {
        }
        public function __destruct()
        {
        }
        public function setAdditionalCallback(callable $callback) : void
        {
        }
        private function toUtf8($xml)
        {
        }
        /**
         * Scan the XML for use of <!ENTITY to prevent XXE/XEE attacks.
         *
         * @param mixed $xml
         *
         * @return string
         */
        public function scan($xml)
        {
        }
        /**
         * Scan theXML for use of <!ENTITY to prevent XXE/XEE attacks.
         *
         * @param string $filestream
         *
         * @return string
         */
        public function scanFile($filestream)
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Collection {
    /**
     * This is the default implementation for in-memory cell collection.
     *
     * Alternatives implementation should leverage off-memory, non-volatile storage
     * to reduce overall memory usage.
     */
    class Memory implements \Psr\SimpleCache\CacheInterface
    {
        private $cache = [];
        public function clear()
        {
        }
        public function delete($key)
        {
        }
        public function deleteMultiple($keys)
        {
        }
        public function get($key, $default = null)
        {
        }
        public function getMultiple($keys, $default = null)
        {
        }
        public function has($key)
        {
        }
        public function set($key, $value, $ttl = null)
        {
        }
        public function setMultiple($values, $ttl = null)
        {
        }
    }
    class Cells
    {
        /**
         * @var \Psr\SimpleCache\CacheInterface
         */
        private $cache;
        /**
         * Parent worksheet.
         *
         * @var Worksheet
         */
        private $parent;
        /**
         * The currently active Cell.
         *
         * @var Cell
         */
        private $currentCell;
        /**
         * Coordinate of the currently active Cell.
         *
         * @var string
         */
        private $currentCoordinate;
        /**
         * Flag indicating whether the currently active Cell requires saving.
         *
         * @var bool
         */
        private $currentCellIsDirty = false;
        /**
         * An index of existing cells. Booleans indexed by their coordinate.
         *
         * @var bool[]
         */
        private $index = [];
        /**
         * Prefix used to uniquely identify cache data for this worksheet.
         *
         * @var string
         */
        private $cachePrefix;
        /**
         * Initialise this new cell collection.
         *
         * @param Worksheet $parent The worksheet for this cell collection
         */
        public function __construct(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $parent, \Psr\SimpleCache\CacheInterface $cache)
        {
        }
        /**
         * Return the parent worksheet for this cell collection.
         *
         * @return Worksheet
         */
        public function getParent()
        {
        }
        /**
         * Whether the collection holds a cell for the given coordinate.
         *
         * @param string $pCoord Coordinate of the cell to check
         *
         * @return bool
         */
        public function has($pCoord)
        {
        }
        /**
         * Add or update a cell in the collection.
         *
         * @param Cell $cell Cell to update
         *
         * @return Cell
         */
        public function update(\PhpOffice\PhpSpreadsheet\Cell\Cell $cell)
        {
        }
        /**
         * Delete a cell in cache identified by coordinate.
         *
         * @param string $pCoord Coordinate of the cell to delete
         */
        public function delete($pCoord) : void
        {
        }
        /**
         * Get a list of all cell coordinates currently held in the collection.
         *
         * @return string[]
         */
        public function getCoordinates()
        {
        }
        /**
         * Get a sorted list of all cell coordinates currently held in the collection by row and column.
         *
         * @return string[]
         */
        public function getSortedCoordinates()
        {
        }
        /**
         * Get highest worksheet column and highest row that have cell records.
         *
         * @return array Highest column name and highest row number
         */
        public function getHighestRowAndColumn()
        {
        }
        /**
         * Return the cell coordinate of the currently active cell object.
         *
         * @return string
         */
        public function getCurrentCoordinate()
        {
        }
        /**
         * Return the column coordinate of the currently active cell object.
         *
         * @return string
         */
        public function getCurrentColumn()
        {
        }
        /**
         * Return the row coordinate of the currently active cell object.
         *
         * @return int
         */
        public function getCurrentRow()
        {
        }
        /**
         * Get highest worksheet column.
         *
         * @param string $row Return the highest column for the specified row,
         *                    or the highest column of any row if no row number is passed
         *
         * @return string Highest column name
         */
        public function getHighestColumn($row = null)
        {
        }
        /**
         * Get highest worksheet row.
         *
         * @param string $column Return the highest row for the specified column,
         *                       or the highest row of any column if no column letter is passed
         *
         * @return int Highest row number
         */
        public function getHighestRow($column = null)
        {
        }
        /**
         * Generate a unique ID for cache referencing.
         *
         * @return string Unique Reference
         */
        private function getUniqueID()
        {
        }
        /**
         * Clone the cell collection.
         *
         * @param Worksheet $parent The new worksheet that we're copying to
         *
         * @return self
         */
        public function cloneCellCollection(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $parent)
        {
        }
        /**
         * Remove a row, deleting all cells in that row.
         *
         * @param string $row Row number to remove
         */
        public function removeRow($row) : void
        {
        }
        /**
         * Remove a column, deleting all cells in that column.
         *
         * @param string $column Column ID to remove
         */
        public function removeColumn($column) : void
        {
        }
        /**
         * Store cell data in cache for the current cell object if it's "dirty",
         * and the 'nullify' the current cell object.
         */
        private function storeCurrentCell() : void
        {
        }
        /**
         * Add or update a cell identified by its coordinate into the collection.
         *
         * @param string $pCoord Coordinate of the cell to update
         * @param Cell $cell Cell to update
         *
         * @return \PhpOffice\PhpSpreadsheet\Cell\Cell
         */
        public function add($pCoord, \PhpOffice\PhpSpreadsheet\Cell\Cell $cell)
        {
        }
        /**
         * Get cell at a specific coordinate.
         *
         * @param string $pCoord Coordinate of the cell
         *
         * @return null|\PhpOffice\PhpSpreadsheet\Cell\Cell Cell that was found, or null if not found
         */
        public function get($pCoord)
        {
        }
        /**
         * Clear the cell collection and disconnect from our parent.
         */
        public function unsetWorksheetCells() : void
        {
        }
        /**
         * Destroy this cell collection.
         */
        public function __destruct()
        {
        }
        /**
         * Returns all known cache keys.
         *
         * @return Generator|string[]
         */
        private function getAllCacheKeys()
        {
        }
    }
    abstract class CellsFactory
    {
        /**
         * Initialise the cache storage.
         *
         * @param Worksheet $parent Enable cell caching for this worksheet
         *
         * @return Cells
         * */
        public static function getInstance(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $parent)
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Chart {
    class Chart
    {
        /**
         * Chart Name.
         *
         * @var string
         */
        private $name = '';
        /**
         * Worksheet.
         *
         * @var Worksheet
         */
        private $worksheet;
        /**
         * Chart Title.
         *
         * @var Title
         */
        private $title;
        /**
         * Chart Legend.
         *
         * @var Legend
         */
        private $legend;
        /**
         * X-Axis Label.
         *
         * @var Title
         */
        private $xAxisLabel;
        /**
         * Y-Axis Label.
         *
         * @var Title
         */
        private $yAxisLabel;
        /**
         * Chart Plot Area.
         *
         * @var PlotArea
         */
        private $plotArea;
        /**
         * Plot Visible Only.
         *
         * @var bool
         */
        private $plotVisibleOnly = true;
        /**
         * Display Blanks as.
         *
         * @var string
         */
        private $displayBlanksAs = \PhpOffice\PhpSpreadsheet\Chart\DataSeries::EMPTY_AS_GAP;
        /**
         * Chart Asix Y as.
         *
         * @var Axis
         */
        private $yAxis;
        /**
         * Chart Asix X as.
         *
         * @var Axis
         */
        private $xAxis;
        /**
         * Chart Major Gridlines as.
         *
         * @var GridLines
         */
        private $majorGridlines;
        /**
         * Chart Minor Gridlines as.
         *
         * @var GridLines
         */
        private $minorGridlines;
        /**
         * Top-Left Cell Position.
         *
         * @var string
         */
        private $topLeftCellRef = 'A1';
        /**
         * Top-Left X-Offset.
         *
         * @var int
         */
        private $topLeftXOffset = 0;
        /**
         * Top-Left Y-Offset.
         *
         * @var int
         */
        private $topLeftYOffset = 0;
        /**
         * Bottom-Right Cell Position.
         *
         * @var string
         */
        private $bottomRightCellRef = 'A1';
        /**
         * Bottom-Right X-Offset.
         *
         * @var int
         */
        private $bottomRightXOffset = 10;
        /**
         * Bottom-Right Y-Offset.
         *
         * @var int
         */
        private $bottomRightYOffset = 10;
        /**
         * Create a new Chart.
         *
         * @param mixed $name
         * @param mixed $plotVisibleOnly
         * @param string $displayBlanksAs
         */
        public function __construct($name, ?\PhpOffice\PhpSpreadsheet\Chart\Title $title = null, ?\PhpOffice\PhpSpreadsheet\Chart\Legend $legend = null, ?\PhpOffice\PhpSpreadsheet\Chart\PlotArea $plotArea = null, $plotVisibleOnly = true, $displayBlanksAs = \PhpOffice\PhpSpreadsheet\Chart\DataSeries::EMPTY_AS_GAP, ?\PhpOffice\PhpSpreadsheet\Chart\Title $xAxisLabel = null, ?\PhpOffice\PhpSpreadsheet\Chart\Title $yAxisLabel = null, ?\PhpOffice\PhpSpreadsheet\Chart\Axis $xAxis = null, ?\PhpOffice\PhpSpreadsheet\Chart\Axis $yAxis = null, ?\PhpOffice\PhpSpreadsheet\Chart\GridLines $majorGridlines = null, ?\PhpOffice\PhpSpreadsheet\Chart\GridLines $minorGridlines = null)
        {
        }
        /**
         * Get Name.
         *
         * @return string
         */
        public function getName()
        {
        }
        /**
         * Get Worksheet.
         *
         * @return Worksheet
         */
        public function getWorksheet()
        {
        }
        /**
         * Set Worksheet.
         *
         * @param Worksheet $pValue
         *
         * @return $this
         */
        public function setWorksheet(?\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pValue = null)
        {
        }
        /**
         * Get Title.
         *
         * @return Title
         */
        public function getTitle()
        {
        }
        /**
         * Set Title.
         *
         * @return $this
         */
        public function setTitle(\PhpOffice\PhpSpreadsheet\Chart\Title $title)
        {
        }
        /**
         * Get Legend.
         *
         * @return Legend
         */
        public function getLegend()
        {
        }
        /**
         * Set Legend.
         *
         * @return $this
         */
        public function setLegend(\PhpOffice\PhpSpreadsheet\Chart\Legend $legend)
        {
        }
        /**
         * Get X-Axis Label.
         *
         * @return Title
         */
        public function getXAxisLabel()
        {
        }
        /**
         * Set X-Axis Label.
         *
         * @return $this
         */
        public function setXAxisLabel(\PhpOffice\PhpSpreadsheet\Chart\Title $label)
        {
        }
        /**
         * Get Y-Axis Label.
         *
         * @return Title
         */
        public function getYAxisLabel()
        {
        }
        /**
         * Set Y-Axis Label.
         *
         * @return $this
         */
        public function setYAxisLabel(\PhpOffice\PhpSpreadsheet\Chart\Title $label)
        {
        }
        /**
         * Get Plot Area.
         *
         * @return PlotArea
         */
        public function getPlotArea()
        {
        }
        /**
         * Get Plot Visible Only.
         *
         * @return bool
         */
        public function getPlotVisibleOnly()
        {
        }
        /**
         * Set Plot Visible Only.
         *
         * @param bool $plotVisibleOnly
         *
         * @return $this
         */
        public function setPlotVisibleOnly($plotVisibleOnly)
        {
        }
        /**
         * Get Display Blanks as.
         *
         * @return string
         */
        public function getDisplayBlanksAs()
        {
        }
        /**
         * Set Display Blanks as.
         *
         * @param string $displayBlanksAs
         *
         * @return $this
         */
        public function setDisplayBlanksAs($displayBlanksAs)
        {
        }
        /**
         * Get yAxis.
         *
         * @return Axis
         */
        public function getChartAxisY()
        {
        }
        /**
         * Get xAxis.
         *
         * @return Axis
         */
        public function getChartAxisX()
        {
        }
        /**
         * Get Major Gridlines.
         *
         * @return GridLines
         */
        public function getMajorGridlines()
        {
        }
        /**
         * Get Minor Gridlines.
         *
         * @return GridLines
         */
        public function getMinorGridlines()
        {
        }
        /**
         * Set the Top Left position for the chart.
         *
         * @param string $cell
         * @param int $xOffset
         * @param int $yOffset
         *
         * @return $this
         */
        public function setTopLeftPosition($cell, $xOffset = null, $yOffset = null)
        {
        }
        /**
         * Get the top left position of the chart.
         *
         * @return array an associative array containing the cell address, X-Offset and Y-Offset from the top left of that cell
         */
        public function getTopLeftPosition()
        {
        }
        /**
         * Get the cell address where the top left of the chart is fixed.
         *
         * @return string
         */
        public function getTopLeftCell()
        {
        }
        /**
         * Set the Top Left cell position for the chart.
         *
         * @param string $cell
         *
         * @return $this
         */
        public function setTopLeftCell($cell)
        {
        }
        /**
         * Set the offset position within the Top Left cell for the chart.
         *
         * @param int $xOffset
         * @param int $yOffset
         *
         * @return $this
         */
        public function setTopLeftOffset($xOffset, $yOffset)
        {
        }
        /**
         * Get the offset position within the Top Left cell for the chart.
         *
         * @return int[]
         */
        public function getTopLeftOffset()
        {
        }
        public function setTopLeftXOffset($xOffset)
        {
        }
        public function getTopLeftXOffset()
        {
        }
        public function setTopLeftYOffset($yOffset)
        {
        }
        public function getTopLeftYOffset()
        {
        }
        /**
         * Set the Bottom Right position of the chart.
         *
         * @param string $cell
         * @param int $xOffset
         * @param int $yOffset
         *
         * @return $this
         */
        public function setBottomRightPosition($cell, $xOffset = null, $yOffset = null)
        {
        }
        /**
         * Get the bottom right position of the chart.
         *
         * @return array an associative array containing the cell address, X-Offset and Y-Offset from the top left of that cell
         */
        public function getBottomRightPosition()
        {
        }
        public function setBottomRightCell($cell)
        {
        }
        /**
         * Get the cell address where the bottom right of the chart is fixed.
         *
         * @return string
         */
        public function getBottomRightCell()
        {
        }
        /**
         * Set the offset position within the Bottom Right cell for the chart.
         *
         * @param int $xOffset
         * @param int $yOffset
         *
         * @return $this
         */
        public function setBottomRightOffset($xOffset, $yOffset)
        {
        }
        /**
         * Get the offset position within the Bottom Right cell for the chart.
         *
         * @return int[]
         */
        public function getBottomRightOffset()
        {
        }
        public function setBottomRightXOffset($xOffset)
        {
        }
        public function getBottomRightXOffset()
        {
        }
        public function setBottomRightYOffset($yOffset)
        {
        }
        public function getBottomRightYOffset()
        {
        }
        public function refresh() : void
        {
        }
        /**
         * Render the chart to given file (or stream).
         *
         * @param string $outputDestination Name of the file render to
         *
         * @return bool true on success
         */
        public function render($outputDestination = null)
        {
        }
    }
    class Exception extends \PhpOffice\PhpSpreadsheet\Exception
    {
    }
    class Layout
    {
        /**
         * layoutTarget.
         *
         * @var string
         */
        private $layoutTarget;
        /**
         * X Mode.
         *
         * @var string
         */
        private $xMode;
        /**
         * Y Mode.
         *
         * @var string
         */
        private $yMode;
        /**
         * X-Position.
         *
         * @var float
         */
        private $xPos;
        /**
         * Y-Position.
         *
         * @var float
         */
        private $yPos;
        /**
         * width.
         *
         * @var float
         */
        private $width;
        /**
         * height.
         *
         * @var float
         */
        private $height;
        /**
         * show legend key
         * Specifies that legend keys should be shown in data labels.
         *
         * @var bool
         */
        private $showLegendKey;
        /**
         * show value
         * Specifies that the value should be shown in a data label.
         *
         * @var bool
         */
        private $showVal;
        /**
         * show category name
         * Specifies that the category name should be shown in the data label.
         *
         * @var bool
         */
        private $showCatName;
        /**
         * show data series name
         * Specifies that the series name should be shown in the data label.
         *
         * @var bool
         */
        private $showSerName;
        /**
         * show percentage
         * Specifies that the percentage should be shown in the data label.
         *
         * @var bool
         */
        private $showPercent;
        /**
         * show bubble size.
         *
         * @var bool
         */
        private $showBubbleSize;
        /**
         * show leader lines
         * Specifies that leader lines should be shown for the data label.
         *
         * @var bool
         */
        private $showLeaderLines;
        /**
         * Create a new Layout.
         */
        public function __construct(array $layout = [])
        {
        }
        /**
         * Get Layout Target.
         *
         * @return string
         */
        public function getLayoutTarget()
        {
        }
        /**
         * Set Layout Target.
         *
         * @param string $value
         *
         * @return $this
         */
        public function setLayoutTarget($value)
        {
        }
        /**
         * Get X-Mode.
         *
         * @return string
         */
        public function getXMode()
        {
        }
        /**
         * Set X-Mode.
         *
         * @param string $value
         *
         * @return $this
         */
        public function setXMode($value)
        {
        }
        /**
         * Get Y-Mode.
         *
         * @return string
         */
        public function getYMode()
        {
        }
        /**
         * Set Y-Mode.
         *
         * @param string $value
         *
         * @return $this
         */
        public function setYMode($value)
        {
        }
        /**
         * Get X-Position.
         *
         * @return number
         */
        public function getXPosition()
        {
        }
        /**
         * Set X-Position.
         *
         * @param float $value
         *
         * @return $this
         */
        public function setXPosition($value)
        {
        }
        /**
         * Get Y-Position.
         *
         * @return number
         */
        public function getYPosition()
        {
        }
        /**
         * Set Y-Position.
         *
         * @param float $value
         *
         * @return $this
         */
        public function setYPosition($value)
        {
        }
        /**
         * Get Width.
         *
         * @return number
         */
        public function getWidth()
        {
        }
        /**
         * Set Width.
         *
         * @param float $value
         *
         * @return $this
         */
        public function setWidth($value)
        {
        }
        /**
         * Get Height.
         *
         * @return number
         */
        public function getHeight()
        {
        }
        /**
         * Set Height.
         *
         * @param float $value
         *
         * @return $this
         */
        public function setHeight($value)
        {
        }
        /**
         * Get show legend key.
         *
         * @return bool
         */
        public function getShowLegendKey()
        {
        }
        /**
         * Set show legend key
         * Specifies that legend keys should be shown in data labels.
         *
         * @param bool $value Show legend key
         *
         * @return $this
         */
        public function setShowLegendKey($value)
        {
        }
        /**
         * Get show value.
         *
         * @return bool
         */
        public function getShowVal()
        {
        }
        /**
         * Set show val
         * Specifies that the value should be shown in data labels.
         *
         * @param bool $value Show val
         *
         * @return $this
         */
        public function setShowVal($value)
        {
        }
        /**
         * Get show category name.
         *
         * @return bool
         */
        public function getShowCatName()
        {
        }
        /**
         * Set show cat name
         * Specifies that the category name should be shown in data labels.
         *
         * @param bool $value Show cat name
         *
         * @return $this
         */
        public function setShowCatName($value)
        {
        }
        /**
         * Get show data series name.
         *
         * @return bool
         */
        public function getShowSerName()
        {
        }
        /**
         * Set show ser name
         * Specifies that the series name should be shown in data labels.
         *
         * @param bool $value Show series name
         *
         * @return $this
         */
        public function setShowSerName($value)
        {
        }
        /**
         * Get show percentage.
         *
         * @return bool
         */
        public function getShowPercent()
        {
        }
        /**
         * Set show percentage
         * Specifies that the percentage should be shown in data labels.
         *
         * @param bool $value Show percentage
         *
         * @return $this
         */
        public function setShowPercent($value)
        {
        }
        /**
         * Get show bubble size.
         *
         * @return bool
         */
        public function getShowBubbleSize()
        {
        }
        /**
         * Set show bubble size
         * Specifies that the bubble size should be shown in data labels.
         *
         * @param bool $value Show bubble size
         *
         * @return $this
         */
        public function setShowBubbleSize($value)
        {
        }
        /**
         * Get show leader lines.
         *
         * @return bool
         */
        public function getShowLeaderLines()
        {
        }
        /**
         * Set show leader lines
         * Specifies that leader lines should be shown in data labels.
         *
         * @param bool $value Show leader lines
         *
         * @return $this
         */
        public function setShowLeaderLines($value)
        {
        }
    }
    /**
     * Created by PhpStorm.
     * User: nhw2h8s
     * Date: 7/2/14
     * Time: 5:45 PM.
     */
    abstract class Properties
    {
        const EXCEL_COLOR_TYPE_STANDARD = 'prstClr';
        const EXCEL_COLOR_TYPE_SCHEME = 'schemeClr';
        const EXCEL_COLOR_TYPE_ARGB = 'srgbClr';
        const AXIS_LABELS_LOW = 'low';
        const AXIS_LABELS_HIGH = 'high';
        const AXIS_LABELS_NEXT_TO = 'nextTo';
        const AXIS_LABELS_NONE = 'none';
        const TICK_MARK_NONE = 'none';
        const TICK_MARK_INSIDE = 'in';
        const TICK_MARK_OUTSIDE = 'out';
        const TICK_MARK_CROSS = 'cross';
        const HORIZONTAL_CROSSES_AUTOZERO = 'autoZero';
        const HORIZONTAL_CROSSES_MAXIMUM = 'max';
        const FORMAT_CODE_GENERAL = 'General';
        const FORMAT_CODE_NUMBER = '#,##0.00';
        const FORMAT_CODE_CURRENCY = '$#,##0.00';
        const FORMAT_CODE_ACCOUNTING = '_($* #,##0.00_);_($* (#,##0.00);_($* "-"??_);_(@_)';
        const FORMAT_CODE_DATE = 'm/d/yyyy';
        const FORMAT_CODE_TIME = '[$-F400]h:mm:ss AM/PM';
        const FORMAT_CODE_PERCENTAGE = '0.00%';
        const FORMAT_CODE_FRACTION = '# ?/?';
        const FORMAT_CODE_SCIENTIFIC = '0.00E+00';
        const FORMAT_CODE_TEXT = '@';
        const FORMAT_CODE_SPECIAL = '00000';
        const ORIENTATION_NORMAL = 'minMax';
        const ORIENTATION_REVERSED = 'maxMin';
        const LINE_STYLE_COMPOUND_SIMPLE = 'sng';
        const LINE_STYLE_COMPOUND_DOUBLE = 'dbl';
        const LINE_STYLE_COMPOUND_THICKTHIN = 'thickThin';
        const LINE_STYLE_COMPOUND_THINTHICK = 'thinThick';
        const LINE_STYLE_COMPOUND_TRIPLE = 'tri';
        const LINE_STYLE_DASH_SOLID = 'solid';
        const LINE_STYLE_DASH_ROUND_DOT = 'sysDot';
        const LINE_STYLE_DASH_SQUERE_DOT = 'sysDash';
        const LINE_STYPE_DASH_DASH = 'dash';
        const LINE_STYLE_DASH_DASH_DOT = 'dashDot';
        const LINE_STYLE_DASH_LONG_DASH = 'lgDash';
        const LINE_STYLE_DASH_LONG_DASH_DOT = 'lgDashDot';
        const LINE_STYLE_DASH_LONG_DASH_DOT_DOT = 'lgDashDotDot';
        const LINE_STYLE_CAP_SQUARE = 'sq';
        const LINE_STYLE_CAP_ROUND = 'rnd';
        const LINE_STYLE_CAP_FLAT = 'flat';
        const LINE_STYLE_JOIN_ROUND = 'bevel';
        const LINE_STYLE_JOIN_MITER = 'miter';
        const LINE_STYLE_JOIN_BEVEL = 'bevel';
        const LINE_STYLE_ARROW_TYPE_NOARROW = null;
        const LINE_STYLE_ARROW_TYPE_ARROW = 'triangle';
        const LINE_STYLE_ARROW_TYPE_OPEN = 'arrow';
        const LINE_STYLE_ARROW_TYPE_STEALTH = 'stealth';
        const LINE_STYLE_ARROW_TYPE_DIAMOND = 'diamond';
        const LINE_STYLE_ARROW_TYPE_OVAL = 'oval';
        const LINE_STYLE_ARROW_SIZE_1 = 1;
        const LINE_STYLE_ARROW_SIZE_2 = 2;
        const LINE_STYLE_ARROW_SIZE_3 = 3;
        const LINE_STYLE_ARROW_SIZE_4 = 4;
        const LINE_STYLE_ARROW_SIZE_5 = 5;
        const LINE_STYLE_ARROW_SIZE_6 = 6;
        const LINE_STYLE_ARROW_SIZE_7 = 7;
        const LINE_STYLE_ARROW_SIZE_8 = 8;
        const LINE_STYLE_ARROW_SIZE_9 = 9;
        const SHADOW_PRESETS_NOSHADOW = null;
        const SHADOW_PRESETS_OUTER_BOTTTOM_RIGHT = 1;
        const SHADOW_PRESETS_OUTER_BOTTOM = 2;
        const SHADOW_PRESETS_OUTER_BOTTOM_LEFT = 3;
        const SHADOW_PRESETS_OUTER_RIGHT = 4;
        const SHADOW_PRESETS_OUTER_CENTER = 5;
        const SHADOW_PRESETS_OUTER_LEFT = 6;
        const SHADOW_PRESETS_OUTER_TOP_RIGHT = 7;
        const SHADOW_PRESETS_OUTER_TOP = 8;
        const SHADOW_PRESETS_OUTER_TOP_LEFT = 9;
        const SHADOW_PRESETS_INNER_BOTTTOM_RIGHT = 10;
        const SHADOW_PRESETS_INNER_BOTTOM = 11;
        const SHADOW_PRESETS_INNER_BOTTOM_LEFT = 12;
        const SHADOW_PRESETS_INNER_RIGHT = 13;
        const SHADOW_PRESETS_INNER_CENTER = 14;
        const SHADOW_PRESETS_INNER_LEFT = 15;
        const SHADOW_PRESETS_INNER_TOP_RIGHT = 16;
        const SHADOW_PRESETS_INNER_TOP = 17;
        const SHADOW_PRESETS_INNER_TOP_LEFT = 18;
        const SHADOW_PRESETS_PERSPECTIVE_BELOW = 19;
        const SHADOW_PRESETS_PERSPECTIVE_UPPER_RIGHT = 20;
        const SHADOW_PRESETS_PERSPECTIVE_UPPER_LEFT = 21;
        const SHADOW_PRESETS_PERSPECTIVE_LOWER_RIGHT = 22;
        const SHADOW_PRESETS_PERSPECTIVE_LOWER_LEFT = 23;
        /**
         * @param float $width
         *
         * @return float
         */
        protected function getExcelPointsWidth($width)
        {
        }
        /**
         * @param float $angle
         *
         * @return float
         */
        protected function getExcelPointsAngle($angle)
        {
        }
        protected function getTrueAlpha($alpha)
        {
        }
        protected function setColorProperties($color, $alpha, $type)
        {
        }
        protected function getLineStyleArrowSize($array_selector, $array_kay_selector)
        {
        }
        protected function getShadowPresetsMap($shadow_presets_option)
        {
        }
        protected function getArrayElementsValue($properties, $elements)
        {
        }
    }
    /**
     * Created by PhpStorm.
     * User: Wiktor Trzonkowski
     * Date: 7/2/14
     * Time: 2:36 PM.
     */
    class GridLines extends \PhpOffice\PhpSpreadsheet\Chart\Properties
    {
        /**
         * Properties of Class:
         * Object State (State for Minor Tick Mark) @var bool
         * Line Properties @var  array of mixed
         * Shadow Properties @var  array of mixed
         * Glow Properties @var  array of mixed
         * Soft Properties @var  array of mixed.
         */
        private $objectState = false;
        private $lineProperties = ['color' => ['type' => self::EXCEL_COLOR_TYPE_STANDARD, 'value' => null, 'alpha' => 0], 'style' => ['width' => '9525', 'compound' => self::LINE_STYLE_COMPOUND_SIMPLE, 'dash' => self::LINE_STYLE_DASH_SOLID, 'cap' => self::LINE_STYLE_CAP_FLAT, 'join' => self::LINE_STYLE_JOIN_BEVEL, 'arrow' => ['head' => ['type' => self::LINE_STYLE_ARROW_TYPE_NOARROW, 'size' => self::LINE_STYLE_ARROW_SIZE_5], 'end' => ['type' => self::LINE_STYLE_ARROW_TYPE_NOARROW, 'size' => self::LINE_STYLE_ARROW_SIZE_8]]]];
        private $shadowProperties = ['presets' => self::SHADOW_PRESETS_NOSHADOW, 'effect' => null, 'color' => ['type' => self::EXCEL_COLOR_TYPE_STANDARD, 'value' => 'black', 'alpha' => 85], 'size' => ['sx' => null, 'sy' => null, 'kx' => null], 'blur' => null, 'direction' => null, 'distance' => null, 'algn' => null, 'rotWithShape' => null];
        private $glowProperties = ['size' => null, 'color' => ['type' => self::EXCEL_COLOR_TYPE_STANDARD, 'value' => 'black', 'alpha' => 40]];
        private $softEdges = ['size' => null];
        /**
         * Get Object State.
         *
         * @return bool
         */
        public function getObjectState()
        {
        }
        /**
         * Change Object State to True.
         *
         * @return $this
         */
        private function activateObject()
        {
        }
        /**
         * Set Line Color Properties.
         *
         * @param string $value
         * @param int $alpha
         * @param string $type
         */
        public function setLineColorProperties($value, $alpha = 0, $type = self::EXCEL_COLOR_TYPE_STANDARD) : void
        {
        }
        /**
         * Set Line Color Properties.
         *
         * @param float $line_width
         * @param string $compound_type
         * @param string $dash_type
         * @param string $cap_type
         * @param string $join_type
         * @param string $head_arrow_type
         * @param string $head_arrow_size
         * @param string $end_arrow_type
         * @param string $end_arrow_size
         */
        public function setLineStyleProperties($line_width = null, $compound_type = null, $dash_type = null, $cap_type = null, $join_type = null, $head_arrow_type = null, $head_arrow_size = null, $end_arrow_type = null, $end_arrow_size = null) : void
        {
        }
        /**
         * Get Line Color Property.
         *
         * @param string $parameter
         *
         * @return string
         */
        public function getLineColorProperty($parameter)
        {
        }
        /**
         * Get Line Style Property.
         *
         * @param array|string $elements
         *
         * @return string
         */
        public function getLineStyleProperty($elements)
        {
        }
        /**
         * Set Glow Properties.
         *
         * @param float $size
         * @param string $color_value
         * @param int $color_alpha
         * @param string $color_type
         */
        public function setGlowProperties($size, $color_value = null, $color_alpha = null, $color_type = null) : void
        {
        }
        /**
         * Get Glow Color Property.
         *
         * @param string $property
         *
         * @return string
         */
        public function getGlowColor($property)
        {
        }
        /**
         * Get Glow Size.
         *
         * @return string
         */
        public function getGlowSize()
        {
        }
        /**
         * Set Glow Size.
         *
         * @param float $size
         *
         * @return $this
         */
        private function setGlowSize($size)
        {
        }
        /**
         * Set Glow Color.
         *
         * @param string $color
         * @param int $alpha
         * @param string $type
         *
         * @return $this
         */
        private function setGlowColor($color, $alpha, $type)
        {
        }
        /**
         * Get Line Style Arrow Parameters.
         *
         * @param string $arrow_selector
         * @param string $property_selector
         *
         * @return string
         */
        public function getLineStyleArrowParameters($arrow_selector, $property_selector)
        {
        }
        /**
         * Set Shadow Properties.
         *
         * @param int $sh_presets
         * @param string $sh_color_value
         * @param string $sh_color_type
         * @param int $sh_color_alpha
         * @param string $sh_blur
         * @param int $sh_angle
         * @param float $sh_distance
         */
        public function setShadowProperties($sh_presets, $sh_color_value = null, $sh_color_type = null, $sh_color_alpha = null, $sh_blur = null, $sh_angle = null, $sh_distance = null) : void
        {
        }
        /**
         * Set Shadow Presets Properties.
         *
         * @param int $shadow_presets
         *
         * @return $this
         */
        private function setShadowPresetsProperties($shadow_presets)
        {
        }
        /**
         * Set Shadow Properties Values.
         *
         * @param mixed &$reference
         *
         * @return $this
         */
        private function setShadowProperiesMapValues(array $properties_map, &$reference = null)
        {
        }
        /**
         * Set Shadow Color.
         *
         * @param string $color
         * @param int $alpha
         * @param string $type
         *
         * @return $this
         */
        private function setShadowColor($color, $alpha, $type)
        {
        }
        /**
         * Set Shadow Blur.
         *
         * @param float $blur
         *
         * @return $this
         */
        private function setShadowBlur($blur)
        {
        }
        /**
         * Set Shadow Angle.
         *
         * @param int $angle
         *
         * @return $this
         */
        private function setShadowAngle($angle)
        {
        }
        /**
         * Set Shadow Distance.
         *
         * @param float $distance
         *
         * @return $this
         */
        private function setShadowDistance($distance)
        {
        }
        /**
         * Get Shadow Property.
         *
         * @param string|string[] $elements
         *
         * @return string
         */
        public function getShadowProperty($elements)
        {
        }
        /**
         * Set Soft Edges Size.
         *
         * @param float $size
         */
        public function setSoftEdgesSize($size) : void
        {
        }
        /**
         * Get Soft Edges Size.
         *
         * @return string
         */
        public function getSoftEdgesSize()
        {
        }
    }
    class DataSeries
    {
        const TYPE_BARCHART = 'barChart';
        const TYPE_BARCHART_3D = 'bar3DChart';
        const TYPE_LINECHART = 'lineChart';
        const TYPE_LINECHART_3D = 'line3DChart';
        const TYPE_AREACHART = 'areaChart';
        const TYPE_AREACHART_3D = 'area3DChart';
        const TYPE_PIECHART = 'pieChart';
        const TYPE_PIECHART_3D = 'pie3DChart';
        const TYPE_DOUGHNUTCHART = 'doughnutChart';
        const TYPE_DONUTCHART = self::TYPE_DOUGHNUTCHART;
        // Synonym
        const TYPE_SCATTERCHART = 'scatterChart';
        const TYPE_SURFACECHART = 'surfaceChart';
        const TYPE_SURFACECHART_3D = 'surface3DChart';
        const TYPE_RADARCHART = 'radarChart';
        const TYPE_BUBBLECHART = 'bubbleChart';
        const TYPE_STOCKCHART = 'stockChart';
        const TYPE_CANDLECHART = self::TYPE_STOCKCHART;
        // Synonym
        const GROUPING_CLUSTERED = 'clustered';
        const GROUPING_STACKED = 'stacked';
        const GROUPING_PERCENT_STACKED = 'percentStacked';
        const GROUPING_STANDARD = 'standard';
        const DIRECTION_BAR = 'bar';
        const DIRECTION_HORIZONTAL = self::DIRECTION_BAR;
        const DIRECTION_COL = 'col';
        const DIRECTION_COLUMN = self::DIRECTION_COL;
        const DIRECTION_VERTICAL = self::DIRECTION_COL;
        const STYLE_LINEMARKER = 'lineMarker';
        const STYLE_SMOOTHMARKER = 'smoothMarker';
        const STYLE_MARKER = 'marker';
        const STYLE_FILLED = 'filled';
        const EMPTY_AS_GAP = 'gap';
        const EMPTY_AS_ZERO = 'zero';
        const EMPTY_AS_SPAN = 'span';
        /**
         * Series Plot Type.
         *
         * @var string
         */
        private $plotType;
        /**
         * Plot Grouping Type.
         *
         * @var string
         */
        private $plotGrouping;
        /**
         * Plot Direction.
         *
         * @var string
         */
        private $plotDirection;
        /**
         * Plot Style.
         *
         * @var null|string
         */
        private $plotStyle;
        /**
         * Order of plots in Series.
         *
         * @var array of integer
         */
        private $plotOrder = [];
        /**
         * Plot Label.
         *
         * @var array of DataSeriesValues
         */
        private $plotLabel = [];
        /**
         * Plot Category.
         *
         * @var array of DataSeriesValues
         */
        private $plotCategory = [];
        /**
         * Smooth Line.
         *
         * @var bool
         */
        private $smoothLine;
        /**
         * Plot Values.
         *
         * @var array of DataSeriesValues
         */
        private $plotValues = [];
        /**
         * Create a new DataSeries.
         *
         * @param null|mixed $plotType
         * @param null|mixed $plotGrouping
         * @param int[] $plotOrder
         * @param DataSeriesValues[] $plotLabel
         * @param DataSeriesValues[] $plotCategory
         * @param DataSeriesValues[] $plotValues
         * @param null|string $plotDirection
         * @param bool $smoothLine
         * @param null|string $plotStyle
         */
        public function __construct($plotType = null, $plotGrouping = null, array $plotOrder = [], array $plotLabel = [], array $plotCategory = [], array $plotValues = [], $plotDirection = null, $smoothLine = false, $plotStyle = null)
        {
        }
        /**
         * Get Plot Type.
         *
         * @return string
         */
        public function getPlotType()
        {
        }
        /**
         * Set Plot Type.
         *
         * @param string $plotType
         *
         * @return $this
         */
        public function setPlotType($plotType)
        {
        }
        /**
         * Get Plot Grouping Type.
         *
         * @return string
         */
        public function getPlotGrouping()
        {
        }
        /**
         * Set Plot Grouping Type.
         *
         * @param string $groupingType
         *
         * @return $this
         */
        public function setPlotGrouping($groupingType)
        {
        }
        /**
         * Get Plot Direction.
         *
         * @return string
         */
        public function getPlotDirection()
        {
        }
        /**
         * Set Plot Direction.
         *
         * @param string $plotDirection
         *
         * @return $this
         */
        public function setPlotDirection($plotDirection)
        {
        }
        /**
         * Get Plot Order.
         *
         * @return int[]
         */
        public function getPlotOrder()
        {
        }
        /**
         * Get Plot Labels.
         *
         * @return array of DataSeriesValues
         */
        public function getPlotLabels()
        {
        }
        /**
         * Get Plot Label by Index.
         *
         * @param mixed $index
         *
         * @return DataSeriesValues
         */
        public function getPlotLabelByIndex($index)
        {
        }
        /**
         * Get Plot Categories.
         *
         * @return array of DataSeriesValues
         */
        public function getPlotCategories()
        {
        }
        /**
         * Get Plot Category by Index.
         *
         * @param mixed $index
         *
         * @return DataSeriesValues
         */
        public function getPlotCategoryByIndex($index)
        {
        }
        /**
         * Get Plot Style.
         *
         * @return null|string
         */
        public function getPlotStyle()
        {
        }
        /**
         * Set Plot Style.
         *
         * @param null|string $plotStyle
         *
         * @return $this
         */
        public function setPlotStyle($plotStyle)
        {
        }
        /**
         * Get Plot Values.
         *
         * @return array of DataSeriesValues
         */
        public function getPlotValues()
        {
        }
        /**
         * Get Plot Values by Index.
         *
         * @param mixed $index
         *
         * @return DataSeriesValues
         */
        public function getPlotValuesByIndex($index)
        {
        }
        /**
         * Get Number of Plot Series.
         *
         * @return int
         */
        public function getPlotSeriesCount()
        {
        }
        /**
         * Get Smooth Line.
         *
         * @return bool
         */
        public function getSmoothLine()
        {
        }
        /**
         * Set Smooth Line.
         *
         * @param bool $smoothLine
         *
         * @return $this
         */
        public function setSmoothLine($smoothLine)
        {
        }
        public function refresh(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $worksheet) : void
        {
        }
    }
    class DataSeriesValues
    {
        const DATASERIES_TYPE_STRING = 'String';
        const DATASERIES_TYPE_NUMBER = 'Number';
        private static $dataTypeValues = [self::DATASERIES_TYPE_STRING, self::DATASERIES_TYPE_NUMBER];
        /**
         * Series Data Type.
         *
         * @var string
         */
        private $dataType;
        /**
         * Series Data Source.
         *
         * @var string
         */
        private $dataSource;
        /**
         * Format Code.
         *
         * @var string
         */
        private $formatCode;
        /**
         * Series Point Marker.
         *
         * @var string
         */
        private $pointMarker;
        /**
         * Point Count (The number of datapoints in the dataseries).
         *
         * @var int
         */
        private $pointCount = 0;
        /**
         * Data Values.
         *
         * @var array of mixed
         */
        private $dataValues = [];
        /**
         * Fill color (can be array with colors if dataseries have custom colors).
         *
         * @var string|string[]
         */
        private $fillColor;
        /**
         * Line Width.
         *
         * @var int
         */
        private $lineWidth = 12700;
        /**
         * Create a new DataSeriesValues object.
         *
         * @param string $dataType
         * @param string $dataSource
         * @param null|mixed $formatCode
         * @param int $pointCount
         * @param mixed $dataValues
         * @param null|mixed $marker
         * @param null|string|string[] $fillColor
         */
        public function __construct($dataType = self::DATASERIES_TYPE_NUMBER, $dataSource = null, $formatCode = null, $pointCount = 0, $dataValues = [], $marker = null, $fillColor = null)
        {
        }
        /**
         * Get Series Data Type.
         *
         * @return string
         */
        public function getDataType()
        {
        }
        /**
         * Set Series Data Type.
         *
         * @param string $dataType Datatype of this data series
         *                                Typical values are:
         *                                    DataSeriesValues::DATASERIES_TYPE_STRING
         *                                        Normally used for axis point values
         *                                    DataSeriesValues::DATASERIES_TYPE_NUMBER
         *                                        Normally used for chart data values
         *
         * @return $this
         */
        public function setDataType($dataType)
        {
        }
        /**
         * Get Series Data Source (formula).
         *
         * @return string
         */
        public function getDataSource()
        {
        }
        /**
         * Set Series Data Source (formula).
         *
         * @param string $dataSource
         *
         * @return $this
         */
        public function setDataSource($dataSource)
        {
        }
        /**
         * Get Point Marker.
         *
         * @return string
         */
        public function getPointMarker()
        {
        }
        /**
         * Set Point Marker.
         *
         * @param string $marker
         *
         * @return $this
         */
        public function setPointMarker($marker)
        {
        }
        /**
         * Get Series Format Code.
         *
         * @return string
         */
        public function getFormatCode()
        {
        }
        /**
         * Set Series Format Code.
         *
         * @param string $formatCode
         *
         * @return $this
         */
        public function setFormatCode($formatCode)
        {
        }
        /**
         * Get Series Point Count.
         *
         * @return int
         */
        public function getPointCount()
        {
        }
        /**
         * Get fill color.
         *
         * @return string|string[] HEX color or array with HEX colors
         */
        public function getFillColor()
        {
        }
        /**
         * Set fill color for series.
         *
         * @param string|string[] $color HEX color or array with HEX colors
         *
         * @return   DataSeriesValues
         */
        public function setFillColor($color)
        {
        }
        /**
         * Method for validating hex color.
         *
         * @param string $color value for color
         *
         * @return bool true if validation was successful
         */
        private function validateColor($color)
        {
        }
        /**
         * Get line width for series.
         *
         * @return int
         */
        public function getLineWidth()
        {
        }
        /**
         * Set line width for the series.
         *
         * @param int $width
         *
         * @return $this
         */
        public function setLineWidth($width)
        {
        }
        /**
         * Identify if the Data Series is a multi-level or a simple series.
         *
         * @return null|bool
         */
        public function isMultiLevelSeries()
        {
        }
        /**
         * Return the level count of a multi-level Data Series.
         *
         * @return int
         */
        public function multiLevelCount()
        {
        }
        /**
         * Get Series Data Values.
         *
         * @return array of mixed
         */
        public function getDataValues()
        {
        }
        /**
         * Get the first Series Data value.
         *
         * @return mixed
         */
        public function getDataValue()
        {
        }
        /**
         * Set Series Data Values.
         *
         * @param array $dataValues
         *
         * @return $this
         */
        public function setDataValues($dataValues)
        {
        }
        public function refresh(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $worksheet, $flatten = true) : void
        {
        }
    }
    class Title
    {
        /**
         * Title Caption.
         *
         * @var string
         */
        private $caption;
        /**
         * Title Layout.
         *
         * @var Layout
         */
        private $layout;
        /**
         * Create a new Title.
         *
         * @param null|mixed $caption
         */
        public function __construct($caption = null, ?\PhpOffice\PhpSpreadsheet\Chart\Layout $layout = null)
        {
        }
        /**
         * Get caption.
         *
         * @return string
         */
        public function getCaption()
        {
        }
        /**
         * Set caption.
         *
         * @param string $caption
         *
         * @return $this
         */
        public function setCaption($caption)
        {
        }
        /**
         * Get Layout.
         *
         * @return Layout
         */
        public function getLayout()
        {
        }
    }
    class PlotArea
    {
        /**
         * PlotArea Layout.
         *
         * @var Layout
         */
        private $layout;
        /**
         * Plot Series.
         *
         * @var DataSeries[]
         */
        private $plotSeries = [];
        /**
         * Create a new PlotArea.
         *
         * @param DataSeries[] $plotSeries
         */
        public function __construct(?\PhpOffice\PhpSpreadsheet\Chart\Layout $layout = null, array $plotSeries = [])
        {
        }
        /**
         * Get Layout.
         *
         * @return Layout
         */
        public function getLayout()
        {
        }
        /**
         * Get Number of Plot Groups.
         *
         * @return array of DataSeries
         */
        public function getPlotGroupCount()
        {
        }
        /**
         * Get Number of Plot Series.
         *
         * @return int
         */
        public function getPlotSeriesCount()
        {
        }
        /**
         * Get Plot Series.
         *
         * @return array of DataSeries
         */
        public function getPlotGroup()
        {
        }
        /**
         * Get Plot Series by Index.
         *
         * @param mixed $index
         *
         * @return DataSeries
         */
        public function getPlotGroupByIndex($index)
        {
        }
        /**
         * Set Plot Series.
         *
         * @param DataSeries[] $plotSeries
         *
         * @return $this
         */
        public function setPlotSeries(array $plotSeries)
        {
        }
        public function refresh(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $worksheet) : void
        {
        }
    }
    class Legend
    {
        /** Legend positions */
        const XL_LEGEND_POSITION_BOTTOM = -4107;
        //    Below the chart.
        const XL_LEGEND_POSITION_CORNER = 2;
        //    In the upper right-hand corner of the chart border.
        const XL_LEGEND_POSITION_CUSTOM = -4161;
        //    A custom position.
        const XL_LEGEND_POSITION_LEFT = -4131;
        //    Left of the chart.
        const XL_LEGEND_POSITION_RIGHT = -4152;
        //    Right of the chart.
        const XL_LEGEND_POSITION_TOP = -4160;
        //    Above the chart.
        const POSITION_RIGHT = 'r';
        const POSITION_LEFT = 'l';
        const POSITION_BOTTOM = 'b';
        const POSITION_TOP = 't';
        const POSITION_TOPRIGHT = 'tr';
        private static $positionXLref = [self::XL_LEGEND_POSITION_BOTTOM => self::POSITION_BOTTOM, self::XL_LEGEND_POSITION_CORNER => self::POSITION_TOPRIGHT, self::XL_LEGEND_POSITION_CUSTOM => '??', self::XL_LEGEND_POSITION_LEFT => self::POSITION_LEFT, self::XL_LEGEND_POSITION_RIGHT => self::POSITION_RIGHT, self::XL_LEGEND_POSITION_TOP => self::POSITION_TOP];
        /**
         * Legend position.
         *
         * @var string
         */
        private $position = self::POSITION_RIGHT;
        /**
         * Allow overlay of other elements?
         *
         * @var bool
         */
        private $overlay = true;
        /**
         * Legend Layout.
         *
         * @var Layout
         */
        private $layout;
        /**
         * Create a new Legend.
         *
         * @param string $position
         * @param bool $overlay
         */
        public function __construct($position = self::POSITION_RIGHT, ?\PhpOffice\PhpSpreadsheet\Chart\Layout $layout = null, $overlay = false)
        {
        }
        /**
         * Get legend position as an excel string value.
         *
         * @return string
         */
        public function getPosition()
        {
        }
        /**
         * Get legend position using an excel string value.
         *
         * @param string $position see self::POSITION_*
         *
         * @return bool
         */
        public function setPosition($position)
        {
        }
        /**
         * Get legend position as an Excel internal numeric value.
         *
         * @return int
         */
        public function getPositionXL()
        {
        }
        /**
         * Set legend position using an Excel internal numeric value.
         *
         * @param int $positionXL see self::XL_LEGEND_POSITION_*
         *
         * @return bool
         */
        public function setPositionXL($positionXL)
        {
        }
        /**
         * Get allow overlay of other elements?
         *
         * @return bool
         */
        public function getOverlay()
        {
        }
        /**
         * Set allow overlay of other elements?
         *
         * @param bool $overlay
         *
         * @return bool
         */
        public function setOverlay($overlay)
        {
        }
        /**
         * Get Layout.
         *
         * @return Layout
         */
        public function getLayout()
        {
        }
    }
    /**
     * Created by PhpStorm.
     * User: Wiktor Trzonkowski
     * Date: 6/17/14
     * Time: 12:11 PM.
     */
    class Axis extends \PhpOffice\PhpSpreadsheet\Chart\Properties
    {
        /**
         * Axis Number.
         *
         * @var array of mixed
         */
        private $axisNumber = ['format' => self::FORMAT_CODE_GENERAL, 'source_linked' => 1];
        /**
         * Axis Options.
         *
         * @var array of mixed
         */
        private $axisOptions = ['minimum' => null, 'maximum' => null, 'major_unit' => null, 'minor_unit' => null, 'orientation' => self::ORIENTATION_NORMAL, 'minor_tick_mark' => self::TICK_MARK_NONE, 'major_tick_mark' => self::TICK_MARK_NONE, 'axis_labels' => self::AXIS_LABELS_NEXT_TO, 'horizontal_crosses' => self::HORIZONTAL_CROSSES_AUTOZERO, 'horizontal_crosses_value' => null];
        /**
         * Fill Properties.
         *
         * @var array of mixed
         */
        private $fillProperties = ['type' => self::EXCEL_COLOR_TYPE_ARGB, 'value' => null, 'alpha' => 0];
        /**
         * Line Properties.
         *
         * @var array of mixed
         */
        private $lineProperties = ['type' => self::EXCEL_COLOR_TYPE_ARGB, 'value' => null, 'alpha' => 0];
        /**
         * Line Style Properties.
         *
         * @var array of mixed
         */
        private $lineStyleProperties = ['width' => '9525', 'compound' => self::LINE_STYLE_COMPOUND_SIMPLE, 'dash' => self::LINE_STYLE_DASH_SOLID, 'cap' => self::LINE_STYLE_CAP_FLAT, 'join' => self::LINE_STYLE_JOIN_BEVEL, 'arrow' => ['head' => ['type' => self::LINE_STYLE_ARROW_TYPE_NOARROW, 'size' => self::LINE_STYLE_ARROW_SIZE_5], 'end' => ['type' => self::LINE_STYLE_ARROW_TYPE_NOARROW, 'size' => self::LINE_STYLE_ARROW_SIZE_8]]];
        /**
         * Shadow Properties.
         *
         * @var array of mixed
         */
        private $shadowProperties = ['presets' => self::SHADOW_PRESETS_NOSHADOW, 'effect' => null, 'color' => ['type' => self::EXCEL_COLOR_TYPE_STANDARD, 'value' => 'black', 'alpha' => 40], 'size' => ['sx' => null, 'sy' => null, 'kx' => null], 'blur' => null, 'direction' => null, 'distance' => null, 'algn' => null, 'rotWithShape' => null];
        /**
         * Glow Properties.
         *
         * @var array of mixed
         */
        private $glowProperties = ['size' => null, 'color' => ['type' => self::EXCEL_COLOR_TYPE_STANDARD, 'value' => 'black', 'alpha' => 40]];
        /**
         * Soft Edge Properties.
         *
         * @var array of mixed
         */
        private $softEdges = ['size' => null];
        /**
         * Get Series Data Type.
         *
         * @param mixed $format_code
         *
         * @return string
         */
        public function setAxisNumberProperties($format_code)
        {
        }
        /**
         * Get Axis Number Format Data Type.
         *
         * @return string
         */
        public function getAxisNumberFormat()
        {
        }
        /**
         * Get Axis Number Source Linked.
         *
         * @return string
         */
        public function getAxisNumberSourceLinked()
        {
        }
        /**
         * Set Axis Options Properties.
         *
         * @param string $axis_labels
         * @param string $horizontal_crosses_value
         * @param string $horizontal_crosses
         * @param string $axis_orientation
         * @param string $major_tmt
         * @param string $minor_tmt
         * @param string $minimum
         * @param string $maximum
         * @param string $major_unit
         * @param string $minor_unit
         */
        public function setAxisOptionsProperties($axis_labels, $horizontal_crosses_value = null, $horizontal_crosses = null, $axis_orientation = null, $major_tmt = null, $minor_tmt = null, $minimum = null, $maximum = null, $major_unit = null, $minor_unit = null) : void
        {
        }
        /**
         * Get Axis Options Property.
         *
         * @param string $property
         *
         * @return string
         */
        public function getAxisOptionsProperty($property)
        {
        }
        /**
         * Set Axis Orientation Property.
         *
         * @param string $orientation
         */
        public function setAxisOrientation($orientation) : void
        {
        }
        /**
         * Set Fill Property.
         *
         * @param string $color
         * @param int $alpha
         * @param string $type
         */
        public function setFillParameters($color, $alpha = 0, $type = self::EXCEL_COLOR_TYPE_ARGB) : void
        {
        }
        /**
         * Set Line Property.
         *
         * @param string $color
         * @param int $alpha
         * @param string $type
         */
        public function setLineParameters($color, $alpha = 0, $type = self::EXCEL_COLOR_TYPE_ARGB) : void
        {
        }
        /**
         * Get Fill Property.
         *
         * @param string $property
         *
         * @return string
         */
        public function getFillProperty($property)
        {
        }
        /**
         * Get Line Property.
         *
         * @param string $property
         *
         * @return string
         */
        public function getLineProperty($property)
        {
        }
        /**
         * Set Line Style Properties.
         *
         * @param float $line_width
         * @param string $compound_type
         * @param string $dash_type
         * @param string $cap_type
         * @param string $join_type
         * @param string $head_arrow_type
         * @param string $head_arrow_size
         * @param string $end_arrow_type
         * @param string $end_arrow_size
         */
        public function setLineStyleProperties($line_width = null, $compound_type = null, $dash_type = null, $cap_type = null, $join_type = null, $head_arrow_type = null, $head_arrow_size = null, $end_arrow_type = null, $end_arrow_size = null) : void
        {
        }
        /**
         * Get Line Style Property.
         *
         * @param array|string $elements
         *
         * @return string
         */
        public function getLineStyleProperty($elements)
        {
        }
        /**
         * Get Line Style Arrow Excel Width.
         *
         * @param string $arrow
         *
         * @return string
         */
        public function getLineStyleArrowWidth($arrow)
        {
        }
        /**
         * Get Line Style Arrow Excel Length.
         *
         * @param string $arrow
         *
         * @return string
         */
        public function getLineStyleArrowLength($arrow)
        {
        }
        /**
         * Set Shadow Properties.
         *
         * @param int $sh_presets
         * @param string $sh_color_value
         * @param string $sh_color_type
         * @param string $sh_color_alpha
         * @param float $sh_blur
         * @param int $sh_angle
         * @param float $sh_distance
         */
        public function setShadowProperties($sh_presets, $sh_color_value = null, $sh_color_type = null, $sh_color_alpha = null, $sh_blur = null, $sh_angle = null, $sh_distance = null) : void
        {
        }
        /**
         * Set Shadow Color.
         *
         * @param int $shadow_presets
         *
         * @return $this
         */
        private function setShadowPresetsProperties($shadow_presets)
        {
        }
        /**
         * Set Shadow Properties from Mapped Values.
         *
         * @param mixed &$reference
         *
         * @return $this
         */
        private function setShadowProperiesMapValues(array $properties_map, &$reference = null)
        {
        }
        /**
         * Set Shadow Color.
         *
         * @param string $color
         * @param int $alpha
         * @param string $type
         *
         * @return $this
         */
        private function setShadowColor($color, $alpha, $type)
        {
        }
        /**
         * Set Shadow Blur.
         *
         * @param float $blur
         *
         * @return $this
         */
        private function setShadowBlur($blur)
        {
        }
        /**
         * Set Shadow Angle.
         *
         * @param int $angle
         *
         * @return $this
         */
        private function setShadowAngle($angle)
        {
        }
        /**
         * Set Shadow Distance.
         *
         * @param float $distance
         *
         * @return $this
         */
        private function setShadowDistance($distance)
        {
        }
        /**
         * Get Shadow Property.
         *
         * @param string|string[] $elements
         *
         * @return null|array|int|string
         */
        public function getShadowProperty($elements)
        {
        }
        /**
         * Set Glow Properties.
         *
         * @param float $size
         * @param string $color_value
         * @param int $color_alpha
         * @param string $color_type
         */
        public function setGlowProperties($size, $color_value = null, $color_alpha = null, $color_type = null) : void
        {
        }
        /**
         * Get Glow Property.
         *
         * @param array|string $property
         *
         * @return string
         */
        public function getGlowProperty($property)
        {
        }
        /**
         * Set Glow Color.
         *
         * @param float $size
         *
         * @return $this
         */
        private function setGlowSize($size)
        {
        }
        /**
         * Set Glow Color.
         *
         * @param string $color
         * @param int $alpha
         * @param string $type
         *
         * @return $this
         */
        private function setGlowColor($color, $alpha, $type)
        {
        }
        /**
         * Set Soft Edges Size.
         *
         * @param float $size
         */
        public function setSoftEdges($size) : void
        {
        }
        /**
         * Get Soft Edges Size.
         *
         * @return string
         */
        public function getSoftEdgesSize()
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Chart\Renderer {
    interface IRenderer
    {
        /**
         * IRenderer constructor.
         */
        public function __construct(\PhpOffice\PhpSpreadsheet\Chart\Chart $chart);
        /**
         * Render the chart to given file (or stream).
         *
         * @param string $filename Name of the file render to
         *
         * @return bool true on success
         */
        public function render($filename);
    }
    class JpGraph implements \PhpOffice\PhpSpreadsheet\Chart\Renderer\IRenderer
    {
        private static $width = 640;
        private static $height = 480;
        private static $colourSet = ['mediumpurple1', 'palegreen3', 'gold1', 'cadetblue1', 'darkmagenta', 'coral', 'dodgerblue3', 'eggplant', 'mediumblue', 'magenta', 'sandybrown', 'cyan', 'firebrick1', 'forestgreen', 'deeppink4', 'darkolivegreen', 'goldenrod2'];
        private static $markSet;
        private $chart;
        private $graph;
        private static $plotColour = 0;
        private static $plotMark = 0;
        /**
         * Create a new jpgraph.
         */
        public function __construct(\PhpOffice\PhpSpreadsheet\Chart\Chart $chart)
        {
        }
        private static function init() : void
        {
        }
        private function formatPointMarker($seriesPlot, $markerID)
        {
        }
        private function formatDataSetLabels($groupID, $datasetLabels, $labelCount, $rotation = '')
        {
        }
        private function percentageSumCalculation($groupID, $seriesCount)
        {
        }
        private function percentageAdjustValues($dataValues, $sumValues)
        {
        }
        private function getCaption($captionElement)
        {
        }
        private function renderTitle() : void
        {
        }
        private function renderLegend() : void
        {
        }
        private function renderCartesianPlotArea($type = 'textlin') : void
        {
        }
        private function renderPiePlotArea() : void
        {
        }
        private function renderRadarPlotArea() : void
        {
        }
        private function renderPlotLine($groupID, $filled = false, $combination = false, $dimensions = '2d') : void
        {
        }
        private function renderPlotBar($groupID, $dimensions = '2d') : void
        {
        }
        private function renderPlotScatter($groupID, $bubble) : void
        {
        }
        private function renderPlotRadar($groupID) : void
        {
        }
        private function renderPlotContour($groupID) : void
        {
        }
        private function renderPlotStock($groupID) : void
        {
        }
        private function renderAreaChart($groupCount, $dimensions = '2d') : void
        {
        }
        private function renderLineChart($groupCount, $dimensions = '2d') : void
        {
        }
        private function renderBarChart($groupCount, $dimensions = '2d') : void
        {
        }
        private function renderScatterChart($groupCount) : void
        {
        }
        private function renderBubbleChart($groupCount) : void
        {
        }
        private function renderPieChart($groupCount, $dimensions = '2d', $doughnut = false, $multiplePlots = false) : void
        {
        }
        private function renderRadarChart($groupCount) : void
        {
        }
        private function renderStockChart($groupCount) : void
        {
        }
        private function renderContourChart($groupCount, $dimensions) : void
        {
        }
        private function renderCombinationChart($groupCount, $dimensions, $outputDestination)
        {
        }
        public function render($outputDestination)
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet {
    class DocumentGenerator
    {
        /**
         * @param array[] $phpSpreadsheetFunctions
         */
        public static function generateFunctionListByCategory(array $phpSpreadsheetFunctions) : string
        {
        }
        private static function getCategories() : array
        {
        }
        private static function tableRow(array $lengths, ?array $values = null) : string
        {
        }
        private static function getPhpSpreadsheetFunctionText($functionCall) : string
        {
        }
        /**
         * @param array[] $phpSpreadsheetFunctions
         */
        public static function generateFunctionListByName(array $phpSpreadsheetFunctions) : string
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Worksheet {
    abstract class CellIterator implements \Iterator
    {
        /**
         * Worksheet to iterate.
         *
         * @var Worksheet
         */
        protected $worksheet;
        /**
         * Iterate only existing cells.
         *
         * @var bool
         */
        protected $onlyExistingCells = false;
        /**
         * Destructor.
         */
        public function __destruct()
        {
        }
        /**
         * Get loop only existing cells.
         *
         * @return bool
         */
        public function getIterateOnlyExistingCells()
        {
        }
        /**
         * Validate start/end values for "IterateOnlyExistingCells" mode, and adjust if necessary.
         */
        protected abstract function adjustForExistingOnlyRange();
        /**
         * Set the iterator to loop only existing cells.
         *
         * @param bool $value
         */
        public function setIterateOnlyExistingCells($value) : void
        {
        }
    }
    class RowCellIterator extends \PhpOffice\PhpSpreadsheet\Worksheet\CellIterator
    {
        /**
         * Current iterator position.
         *
         * @var int
         */
        private $currentColumnIndex;
        /**
         * Row index.
         *
         * @var int
         */
        private $rowIndex = 1;
        /**
         * Start position.
         *
         * @var int
         */
        private $startColumnIndex = 1;
        /**
         * End position.
         *
         * @var int
         */
        private $endColumnIndex = 1;
        /**
         * Create a new column iterator.
         *
         * @param Worksheet $worksheet The worksheet to iterate over
         * @param int $rowIndex The row that we want to iterate
         * @param string $startColumn The column address at which to start iterating
         * @param string $endColumn Optionally, the column address at which to stop iterating
         */
        public function __construct(?\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $worksheet = null, $rowIndex = 1, $startColumn = 'A', $endColumn = null)
        {
        }
        /**
         * (Re)Set the start column and the current column pointer.
         *
         * @param string $startColumn The column address at which to start iterating
         *
         * @return $this
         */
        public function resetStart($startColumn = 'A')
        {
        }
        /**
         * (Re)Set the end column.
         *
         * @param string $endColumn The column address at which to stop iterating
         *
         * @return $this
         */
        public function resetEnd($endColumn = null)
        {
        }
        /**
         * Set the column pointer to the selected column.
         *
         * @param string $column The column address to set the current pointer at
         *
         * @return $this
         */
        public function seek($column = 'A')
        {
        }
        /**
         * Rewind the iterator to the starting column.
         */
        public function rewind() : void
        {
        }
        /**
         * Return the current cell in this worksheet row.
         *
         * @return \PhpOffice\PhpSpreadsheet\Cell\Cell
         */
        public function current()
        {
        }
        /**
         * Return the current iterator key.
         *
         * @return string
         */
        public function key()
        {
        }
        /**
         * Set the iterator to its next value.
         */
        public function next() : void
        {
        }
        /**
         * Set the iterator to its previous value.
         */
        public function prev() : void
        {
        }
        /**
         * Indicate if more columns exist in the worksheet range of columns that we're iterating.
         *
         * @return bool
         */
        public function valid()
        {
        }
        /**
         * Return the current iterator position.
         *
         * @return int
         */
        public function getCurrentColumnIndex()
        {
        }
        /**
         * Validate start/end values for "IterateOnlyExistingCells" mode, and adjust if necessary.
         */
        protected function adjustForExistingOnlyRange() : void
        {
        }
    }
    class Protection
    {
        const ALGORITHM_MD2 = 'MD2';
        const ALGORITHM_MD4 = 'MD4';
        const ALGORITHM_MD5 = 'MD5';
        const ALGORITHM_SHA_1 = 'SHA-1';
        const ALGORITHM_SHA_256 = 'SHA-256';
        const ALGORITHM_SHA_384 = 'SHA-384';
        const ALGORITHM_SHA_512 = 'SHA-512';
        const ALGORITHM_RIPEMD_128 = 'RIPEMD-128';
        const ALGORITHM_RIPEMD_160 = 'RIPEMD-160';
        const ALGORITHM_WHIRLPOOL = 'WHIRLPOOL';
        /**
         * Sheet.
         *
         * @var bool
         */
        private $sheet = false;
        /**
         * Objects.
         *
         * @var bool
         */
        private $objects = false;
        /**
         * Scenarios.
         *
         * @var bool
         */
        private $scenarios = false;
        /**
         * Format cells.
         *
         * @var bool
         */
        private $formatCells = false;
        /**
         * Format columns.
         *
         * @var bool
         */
        private $formatColumns = false;
        /**
         * Format rows.
         *
         * @var bool
         */
        private $formatRows = false;
        /**
         * Insert columns.
         *
         * @var bool
         */
        private $insertColumns = false;
        /**
         * Insert rows.
         *
         * @var bool
         */
        private $insertRows = false;
        /**
         * Insert hyperlinks.
         *
         * @var bool
         */
        private $insertHyperlinks = false;
        /**
         * Delete columns.
         *
         * @var bool
         */
        private $deleteColumns = false;
        /**
         * Delete rows.
         *
         * @var bool
         */
        private $deleteRows = false;
        /**
         * Select locked cells.
         *
         * @var bool
         */
        private $selectLockedCells = false;
        /**
         * Sort.
         *
         * @var bool
         */
        private $sort = false;
        /**
         * AutoFilter.
         *
         * @var bool
         */
        private $autoFilter = false;
        /**
         * Pivot tables.
         *
         * @var bool
         */
        private $pivotTables = false;
        /**
         * Select unlocked cells.
         *
         * @var bool
         */
        private $selectUnlockedCells = false;
        /**
         * Hashed password.
         *
         * @var string
         */
        private $password = '';
        /**
         * Algorithm name.
         *
         * @var string
         */
        private $algorithm = '';
        /**
         * Hash value.
         *
         * @var string
         */
        private $hash = '';
        /**
         * Salt value.
         *
         * @var string
         */
        private $salt = '';
        /**
         * Spin count.
         *
         * @var int
         */
        private $spinCount = 10000;
        /**
         * Create a new Protection.
         */
        public function __construct()
        {
        }
        /**
         * Is some sort of protection enabled?
         *
         * @return bool
         */
        public function isProtectionEnabled()
        {
        }
        /**
         * Get Sheet.
         *
         * @return bool
         */
        public function getSheet()
        {
        }
        /**
         * Set Sheet.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setSheet($pValue)
        {
        }
        /**
         * Get Objects.
         *
         * @return bool
         */
        public function getObjects()
        {
        }
        /**
         * Set Objects.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setObjects($pValue)
        {
        }
        /**
         * Get Scenarios.
         *
         * @return bool
         */
        public function getScenarios()
        {
        }
        /**
         * Set Scenarios.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setScenarios($pValue)
        {
        }
        /**
         * Get FormatCells.
         *
         * @return bool
         */
        public function getFormatCells()
        {
        }
        /**
         * Set FormatCells.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setFormatCells($pValue)
        {
        }
        /**
         * Get FormatColumns.
         *
         * @return bool
         */
        public function getFormatColumns()
        {
        }
        /**
         * Set FormatColumns.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setFormatColumns($pValue)
        {
        }
        /**
         * Get FormatRows.
         *
         * @return bool
         */
        public function getFormatRows()
        {
        }
        /**
         * Set FormatRows.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setFormatRows($pValue)
        {
        }
        /**
         * Get InsertColumns.
         *
         * @return bool
         */
        public function getInsertColumns()
        {
        }
        /**
         * Set InsertColumns.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setInsertColumns($pValue)
        {
        }
        /**
         * Get InsertRows.
         *
         * @return bool
         */
        public function getInsertRows()
        {
        }
        /**
         * Set InsertRows.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setInsertRows($pValue)
        {
        }
        /**
         * Get InsertHyperlinks.
         *
         * @return bool
         */
        public function getInsertHyperlinks()
        {
        }
        /**
         * Set InsertHyperlinks.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setInsertHyperlinks($pValue)
        {
        }
        /**
         * Get DeleteColumns.
         *
         * @return bool
         */
        public function getDeleteColumns()
        {
        }
        /**
         * Set DeleteColumns.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setDeleteColumns($pValue)
        {
        }
        /**
         * Get DeleteRows.
         *
         * @return bool
         */
        public function getDeleteRows()
        {
        }
        /**
         * Set DeleteRows.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setDeleteRows($pValue)
        {
        }
        /**
         * Get SelectLockedCells.
         *
         * @return bool
         */
        public function getSelectLockedCells()
        {
        }
        /**
         * Set SelectLockedCells.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setSelectLockedCells($pValue)
        {
        }
        /**
         * Get Sort.
         *
         * @return bool
         */
        public function getSort()
        {
        }
        /**
         * Set Sort.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setSort($pValue)
        {
        }
        /**
         * Get AutoFilter.
         *
         * @return bool
         */
        public function getAutoFilter()
        {
        }
        /**
         * Set AutoFilter.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setAutoFilter($pValue)
        {
        }
        /**
         * Get PivotTables.
         *
         * @return bool
         */
        public function getPivotTables()
        {
        }
        /**
         * Set PivotTables.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setPivotTables($pValue)
        {
        }
        /**
         * Get SelectUnlockedCells.
         *
         * @return bool
         */
        public function getSelectUnlockedCells()
        {
        }
        /**
         * Set SelectUnlockedCells.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setSelectUnlockedCells($pValue)
        {
        }
        /**
         * Get hashed password.
         *
         * @return string
         */
        public function getPassword()
        {
        }
        /**
         * Set Password.
         *
         * @param string $pValue
         * @param bool $pAlreadyHashed If the password has already been hashed, set this to true
         *
         * @return $this
         */
        public function setPassword($pValue, $pAlreadyHashed = false)
        {
        }
        /**
         * Create a pseudorandom string.
         */
        private function generateSalt() : string
        {
        }
        /**
         * Get algorithm name.
         */
        public function getAlgorithm() : string
        {
        }
        /**
         * Set algorithm name.
         */
        public function setAlgorithm(string $algorithm) : void
        {
        }
        /**
         * Get salt value.
         */
        public function getSalt() : string
        {
        }
        /**
         * Set salt value.
         */
        public function setSalt(string $salt) : void
        {
        }
        /**
         * Get spin count.
         */
        public function getSpinCount() : int
        {
        }
        /**
         * Set spin count.
         */
        public function setSpinCount(int $spinCount) : void
        {
        }
        /**
         * Verify that the given non-hashed password can "unlock" the protection.
         */
        public function verify(string $password) : bool
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    class Row
    {
        /**
         * \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet.
         *
         * @var Worksheet
         */
        private $worksheet;
        /**
         * Row index.
         *
         * @var int
         */
        private $rowIndex = 0;
        /**
         * Create a new row.
         *
         * @param Worksheet $worksheet
         * @param int $rowIndex
         */
        public function __construct(?\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $worksheet = null, $rowIndex = 1)
        {
        }
        /**
         * Destructor.
         */
        public function __destruct()
        {
        }
        /**
         * Get row index.
         *
         * @return int
         */
        public function getRowIndex()
        {
        }
        /**
         * Get cell iterator.
         *
         * @param string $startColumn The column address at which to start iterating
         * @param string $endColumn Optionally, the column address at which to stop iterating
         *
         * @return RowCellIterator
         */
        public function getCellIterator($startColumn = 'A', $endColumn = null)
        {
        }
        /**
         * Returns bound worksheet.
         *
         * @return Worksheet
         */
        public function getWorksheet()
        {
        }
    }
    class Iterator implements \Iterator
    {
        /**
         * Spreadsheet to iterate.
         *
         * @var Spreadsheet
         */
        private $subject;
        /**
         * Current iterator position.
         *
         * @var int
         */
        private $position = 0;
        /**
         * Create a new worksheet iterator.
         */
        public function __construct(\PhpOffice\PhpSpreadsheet\Spreadsheet $subject)
        {
        }
        /**
         * Destructor.
         */
        public function __destruct()
        {
        }
        /**
         * Rewind iterator.
         */
        public function rewind() : void
        {
        }
        /**
         * Current Worksheet.
         *
         * @return Worksheet
         */
        public function current()
        {
        }
        /**
         * Current key.
         *
         * @return int
         */
        public function key()
        {
        }
        /**
         * Next value.
         */
        public function next() : void
        {
        }
        /**
         * Are there more Worksheet instances available?
         *
         * @return bool
         */
        public function valid()
        {
        }
    }
    class PageMargins
    {
        /**
         * Left.
         *
         * @var float
         */
        private $left = 0.7;
        /**
         * Right.
         *
         * @var float
         */
        private $right = 0.7;
        /**
         * Top.
         *
         * @var float
         */
        private $top = 0.75;
        /**
         * Bottom.
         *
         * @var float
         */
        private $bottom = 0.75;
        /**
         * Header.
         *
         * @var float
         */
        private $header = 0.3;
        /**
         * Footer.
         *
         * @var float
         */
        private $footer = 0.3;
        /**
         * Create a new PageMargins.
         */
        public function __construct()
        {
        }
        /**
         * Get Left.
         *
         * @return float
         */
        public function getLeft()
        {
        }
        /**
         * Set Left.
         *
         * @param float $pValue
         *
         * @return $this
         */
        public function setLeft($pValue)
        {
        }
        /**
         * Get Right.
         *
         * @return float
         */
        public function getRight()
        {
        }
        /**
         * Set Right.
         *
         * @param float $pValue
         *
         * @return $this
         */
        public function setRight($pValue)
        {
        }
        /**
         * Get Top.
         *
         * @return float
         */
        public function getTop()
        {
        }
        /**
         * Set Top.
         *
         * @param float $pValue
         *
         * @return $this
         */
        public function setTop($pValue)
        {
        }
        /**
         * Get Bottom.
         *
         * @return float
         */
        public function getBottom()
        {
        }
        /**
         * Set Bottom.
         *
         * @param float $pValue
         *
         * @return $this
         */
        public function setBottom($pValue)
        {
        }
        /**
         * Get Header.
         *
         * @return float
         */
        public function getHeader()
        {
        }
        /**
         * Set Header.
         *
         * @param float $pValue
         *
         * @return $this
         */
        public function setHeader($pValue)
        {
        }
        /**
         * Get Footer.
         *
         * @return float
         */
        public function getFooter()
        {
        }
        /**
         * Set Footer.
         *
         * @param float $pValue
         *
         * @return $this
         */
        public function setFooter($pValue)
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    class ColumnCellIterator extends \PhpOffice\PhpSpreadsheet\Worksheet\CellIterator
    {
        /**
         * Current iterator position.
         *
         * @var int
         */
        private $currentRow;
        /**
         * Column index.
         *
         * @var string
         */
        private $columnIndex;
        /**
         * Start position.
         *
         * @var int
         */
        private $startRow = 1;
        /**
         * End position.
         *
         * @var int
         */
        private $endRow = 1;
        /**
         * Create a new row iterator.
         *
         * @param Worksheet $subject The worksheet to iterate over
         * @param string $columnIndex The column that we want to iterate
         * @param int $startRow The row number at which to start iterating
         * @param int $endRow Optionally, the row number at which to stop iterating
         */
        public function __construct(?\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $subject = null, $columnIndex = 'A', $startRow = 1, $endRow = null)
        {
        }
        /**
         * (Re)Set the start row and the current row pointer.
         *
         * @param int $startRow The row number at which to start iterating
         *
         * @return $this
         */
        public function resetStart($startRow = 1)
        {
        }
        /**
         * (Re)Set the end row.
         *
         * @param int $endRow The row number at which to stop iterating
         *
         * @return $this
         */
        public function resetEnd($endRow = null)
        {
        }
        /**
         * Set the row pointer to the selected row.
         *
         * @param int $row The row number to set the current pointer at
         *
         * @return $this
         */
        public function seek($row = 1)
        {
        }
        /**
         * Rewind the iterator to the starting row.
         */
        public function rewind() : void
        {
        }
        /**
         * Return the current cell in this worksheet column.
         *
         * @return null|\PhpOffice\PhpSpreadsheet\Cell\Cell
         */
        public function current()
        {
        }
        /**
         * Return the current iterator key.
         *
         * @return int
         */
        public function key()
        {
        }
        /**
         * Set the iterator to its next value.
         */
        public function next() : void
        {
        }
        /**
         * Set the iterator to its previous value.
         */
        public function prev() : void
        {
        }
        /**
         * Indicate if more rows exist in the worksheet range of rows that we're iterating.
         *
         * @return bool
         */
        public function valid()
        {
        }
        /**
         * Validate start/end values for "IterateOnlyExistingCells" mode, and adjust if necessary.
         */
        protected function adjustForExistingOnlyRange() : void
        {
        }
    }
    class AutoFilter
    {
        /**
         * Autofilter Worksheet.
         *
         * @var Worksheet
         */
        private $workSheet;
        /**
         * Autofilter Range.
         *
         * @var string
         */
        private $range = '';
        /**
         * Autofilter Column Ruleset.
         *
         * @var AutoFilter\Column[]
         */
        private $columns = [];
        /**
         * Create a new AutoFilter.
         *
         * @param string $pRange Cell range (i.e. A1:E10)
         * @param Worksheet $pSheet
         */
        public function __construct($pRange = '', ?\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet = null)
        {
        }
        /**
         * Get AutoFilter Parent Worksheet.
         *
         * @return Worksheet
         */
        public function getParent()
        {
        }
        /**
         * Set AutoFilter Parent Worksheet.
         *
         * @param Worksheet $pSheet
         *
         * @return $this
         */
        public function setParent(?\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet = null)
        {
        }
        /**
         * Get AutoFilter Range.
         *
         * @return string
         */
        public function getRange()
        {
        }
        /**
         * Set AutoFilter Range.
         *
         * @param string $pRange Cell range (i.e. A1:E10)
         *
         * @return $this
         */
        public function setRange($pRange)
        {
        }
        /**
         * Get all AutoFilter Columns.
         *
         * @return AutoFilter\Column[]
         */
        public function getColumns()
        {
        }
        /**
         * Validate that the specified column is in the AutoFilter range.
         *
         * @param string $column Column name (e.g. A)
         *
         * @return int The column offset within the autofilter range
         */
        public function testColumnInRange($column)
        {
        }
        /**
         * Get a specified AutoFilter Column Offset within the defined AutoFilter range.
         *
         * @param string $pColumn Column name (e.g. A)
         *
         * @return int The offset of the specified column within the autofilter range
         */
        public function getColumnOffset($pColumn)
        {
        }
        /**
         * Get a specified AutoFilter Column.
         *
         * @param string $pColumn Column name (e.g. A)
         *
         * @return AutoFilter\Column
         */
        public function getColumn($pColumn)
        {
        }
        /**
         * Get a specified AutoFilter Column by it's offset.
         *
         * @param int $pColumnOffset Column offset within range (starting from 0)
         *
         * @return AutoFilter\Column
         */
        public function getColumnByOffset($pColumnOffset)
        {
        }
        /**
         * Set AutoFilter.
         *
         * @param AutoFilter\Column|string $pColumn
         *            A simple string containing a Column ID like 'A' is permitted
         *
         * @return $this
         */
        public function setColumn($pColumn)
        {
        }
        /**
         * Clear a specified AutoFilter Column.
         *
         * @param string $pColumn Column name (e.g. A)
         *
         * @return $this
         */
        public function clearColumn($pColumn)
        {
        }
        /**
         * Shift an AutoFilter Column Rule to a different column.
         *
         * Note: This method bypasses validation of the destination column to ensure it is within this AutoFilter range.
         *        Nor does it verify whether any column rule already exists at $toColumn, but will simply override any existing value.
         *        Use with caution.
         *
         * @param string $fromColumn Column name (e.g. A)
         * @param string $toColumn Column name (e.g. B)
         *
         * @return $this
         */
        public function shiftColumn($fromColumn, $toColumn)
        {
        }
        /**
         * Test if cell value is in the defined set of values.
         *
         * @param mixed $cellValue
         * @param mixed[] $dataSet
         *
         * @return bool
         */
        private static function filterTestInSimpleDataSet($cellValue, $dataSet)
        {
        }
        /**
         * Test if cell value is in the defined set of Excel date values.
         *
         * @param mixed $cellValue
         * @param mixed[] $dataSet
         *
         * @return bool
         */
        private static function filterTestInDateGroupSet($cellValue, $dataSet)
        {
        }
        /**
         * Test if cell value is within a set of values defined by a ruleset.
         *
         * @param mixed $cellValue
         * @param mixed[] $ruleSet
         *
         * @return bool
         */
        private static function filterTestInCustomDataSet($cellValue, $ruleSet)
        {
        }
        /**
         * Test if cell date value is matches a set of values defined by a set of months.
         *
         * @param mixed $cellValue
         * @param mixed[] $monthSet
         *
         * @return bool
         */
        private static function filterTestInPeriodDateSet($cellValue, $monthSet)
        {
        }
        /**
         * Search/Replace arrays to convert Excel wildcard syntax to a regexp syntax for preg_matching.
         *
         * @var array
         */
        private static $fromReplace = ['\\*', '\\?', '~~', '~.*', '~.?'];
        private static $toReplace = ['.*', '.', '~', '\\*', '\\?'];
        /**
         * Convert a dynamic rule daterange to a custom filter range expression for ease of calculation.
         *
         * @param string $dynamicRuleType
         * @param AutoFilter\Column $filterColumn
         *
         * @return mixed[]
         */
        private function dynamicFilterDateRange($dynamicRuleType, &$filterColumn)
        {
        }
        private function calculateTopTenValue($columnID, $startRow, $endRow, $ruleType, $ruleValue)
        {
        }
        /**
         * Apply the AutoFilter rules to the AutoFilter Range.
         *
         * @return $this
         */
        public function showHideRows()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
        /**
         * toString method replicates previous behavior by returning the range if object is
         * referenced as a property of its parent.
         */
        public function __toString()
        {
        }
    }
    abstract class Dimension
    {
        /**
         * Visible?
         *
         * @var bool
         */
        private $visible = true;
        /**
         * Outline level.
         *
         * @var int
         */
        private $outlineLevel = 0;
        /**
         * Collapsed.
         *
         * @var bool
         */
        private $collapsed = false;
        /**
         * Index to cellXf. Null value means row has no explicit cellXf format.
         *
         * @var null|int
         */
        private $xfIndex;
        /**
         * Create a new Dimension.
         *
         * @param int $initialValue Numeric row index
         */
        public function __construct($initialValue = null)
        {
        }
        /**
         * Get Visible.
         *
         * @return bool
         */
        public function getVisible()
        {
        }
        /**
         * Set Visible.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setVisible($pValue)
        {
        }
        /**
         * Get Outline Level.
         *
         * @return int
         */
        public function getOutlineLevel()
        {
        }
        /**
         * Set Outline Level.
         * Value must be between 0 and 7.
         *
         * @param int $pValue
         *
         * @return $this
         */
        public function setOutlineLevel($pValue)
        {
        }
        /**
         * Get Collapsed.
         *
         * @return bool
         */
        public function getCollapsed()
        {
        }
        /**
         * Set Collapsed.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setCollapsed($pValue)
        {
        }
        /**
         * Get index to cellXf.
         *
         * @return int
         */
        public function getXfIndex()
        {
        }
        /**
         * Set index to cellXf.
         *
         * @param int $pValue
         *
         * @return $this
         */
        public function setXfIndex($pValue)
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Worksheet\AutoFilter\Column {
    class Rule
    {
        const AUTOFILTER_RULETYPE_FILTER = 'filter';
        const AUTOFILTER_RULETYPE_DATEGROUP = 'dateGroupItem';
        const AUTOFILTER_RULETYPE_CUSTOMFILTER = 'customFilter';
        const AUTOFILTER_RULETYPE_DYNAMICFILTER = 'dynamicFilter';
        const AUTOFILTER_RULETYPE_TOPTENFILTER = 'top10Filter';
        private static $ruleTypes = [
            //    Currently we're not handling
            //        colorFilter
            //        extLst
            //        iconFilter
            self::AUTOFILTER_RULETYPE_FILTER,
            self::AUTOFILTER_RULETYPE_DATEGROUP,
            self::AUTOFILTER_RULETYPE_CUSTOMFILTER,
            self::AUTOFILTER_RULETYPE_DYNAMICFILTER,
            self::AUTOFILTER_RULETYPE_TOPTENFILTER,
        ];
        const AUTOFILTER_RULETYPE_DATEGROUP_YEAR = 'year';
        const AUTOFILTER_RULETYPE_DATEGROUP_MONTH = 'month';
        const AUTOFILTER_RULETYPE_DATEGROUP_DAY = 'day';
        const AUTOFILTER_RULETYPE_DATEGROUP_HOUR = 'hour';
        const AUTOFILTER_RULETYPE_DATEGROUP_MINUTE = 'minute';
        const AUTOFILTER_RULETYPE_DATEGROUP_SECOND = 'second';
        private static $dateTimeGroups = [self::AUTOFILTER_RULETYPE_DATEGROUP_YEAR, self::AUTOFILTER_RULETYPE_DATEGROUP_MONTH, self::AUTOFILTER_RULETYPE_DATEGROUP_DAY, self::AUTOFILTER_RULETYPE_DATEGROUP_HOUR, self::AUTOFILTER_RULETYPE_DATEGROUP_MINUTE, self::AUTOFILTER_RULETYPE_DATEGROUP_SECOND];
        const AUTOFILTER_RULETYPE_DYNAMIC_YESTERDAY = 'yesterday';
        const AUTOFILTER_RULETYPE_DYNAMIC_TODAY = 'today';
        const AUTOFILTER_RULETYPE_DYNAMIC_TOMORROW = 'tomorrow';
        const AUTOFILTER_RULETYPE_DYNAMIC_YEARTODATE = 'yearToDate';
        const AUTOFILTER_RULETYPE_DYNAMIC_THISYEAR = 'thisYear';
        const AUTOFILTER_RULETYPE_DYNAMIC_THISQUARTER = 'thisQuarter';
        const AUTOFILTER_RULETYPE_DYNAMIC_THISMONTH = 'thisMonth';
        const AUTOFILTER_RULETYPE_DYNAMIC_THISWEEK = 'thisWeek';
        const AUTOFILTER_RULETYPE_DYNAMIC_LASTYEAR = 'lastYear';
        const AUTOFILTER_RULETYPE_DYNAMIC_LASTQUARTER = 'lastQuarter';
        const AUTOFILTER_RULETYPE_DYNAMIC_LASTMONTH = 'lastMonth';
        const AUTOFILTER_RULETYPE_DYNAMIC_LASTWEEK = 'lastWeek';
        const AUTOFILTER_RULETYPE_DYNAMIC_NEXTYEAR = 'nextYear';
        const AUTOFILTER_RULETYPE_DYNAMIC_NEXTQUARTER = 'nextQuarter';
        const AUTOFILTER_RULETYPE_DYNAMIC_NEXTMONTH = 'nextMonth';
        const AUTOFILTER_RULETYPE_DYNAMIC_NEXTWEEK = 'nextWeek';
        const AUTOFILTER_RULETYPE_DYNAMIC_MONTH_1 = 'M1';
        const AUTOFILTER_RULETYPE_DYNAMIC_JANUARY = self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_1;
        const AUTOFILTER_RULETYPE_DYNAMIC_MONTH_2 = 'M2';
        const AUTOFILTER_RULETYPE_DYNAMIC_FEBRUARY = self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_2;
        const AUTOFILTER_RULETYPE_DYNAMIC_MONTH_3 = 'M3';
        const AUTOFILTER_RULETYPE_DYNAMIC_MARCH = self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_3;
        const AUTOFILTER_RULETYPE_DYNAMIC_MONTH_4 = 'M4';
        const AUTOFILTER_RULETYPE_DYNAMIC_APRIL = self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_4;
        const AUTOFILTER_RULETYPE_DYNAMIC_MONTH_5 = 'M5';
        const AUTOFILTER_RULETYPE_DYNAMIC_MAY = self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_5;
        const AUTOFILTER_RULETYPE_DYNAMIC_MONTH_6 = 'M6';
        const AUTOFILTER_RULETYPE_DYNAMIC_JUNE = self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_6;
        const AUTOFILTER_RULETYPE_DYNAMIC_MONTH_7 = 'M7';
        const AUTOFILTER_RULETYPE_DYNAMIC_JULY = self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_7;
        const AUTOFILTER_RULETYPE_DYNAMIC_MONTH_8 = 'M8';
        const AUTOFILTER_RULETYPE_DYNAMIC_AUGUST = self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_8;
        const AUTOFILTER_RULETYPE_DYNAMIC_MONTH_9 = 'M9';
        const AUTOFILTER_RULETYPE_DYNAMIC_SEPTEMBER = self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_9;
        const AUTOFILTER_RULETYPE_DYNAMIC_MONTH_10 = 'M10';
        const AUTOFILTER_RULETYPE_DYNAMIC_OCTOBER = self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_10;
        const AUTOFILTER_RULETYPE_DYNAMIC_MONTH_11 = 'M11';
        const AUTOFILTER_RULETYPE_DYNAMIC_NOVEMBER = self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_11;
        const AUTOFILTER_RULETYPE_DYNAMIC_MONTH_12 = 'M12';
        const AUTOFILTER_RULETYPE_DYNAMIC_DECEMBER = self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_12;
        const AUTOFILTER_RULETYPE_DYNAMIC_QUARTER_1 = 'Q1';
        const AUTOFILTER_RULETYPE_DYNAMIC_QUARTER_2 = 'Q2';
        const AUTOFILTER_RULETYPE_DYNAMIC_QUARTER_3 = 'Q3';
        const AUTOFILTER_RULETYPE_DYNAMIC_QUARTER_4 = 'Q4';
        const AUTOFILTER_RULETYPE_DYNAMIC_ABOVEAVERAGE = 'aboveAverage';
        const AUTOFILTER_RULETYPE_DYNAMIC_BELOWAVERAGE = 'belowAverage';
        private static $dynamicTypes = [self::AUTOFILTER_RULETYPE_DYNAMIC_YESTERDAY, self::AUTOFILTER_RULETYPE_DYNAMIC_TODAY, self::AUTOFILTER_RULETYPE_DYNAMIC_TOMORROW, self::AUTOFILTER_RULETYPE_DYNAMIC_YEARTODATE, self::AUTOFILTER_RULETYPE_DYNAMIC_THISYEAR, self::AUTOFILTER_RULETYPE_DYNAMIC_THISQUARTER, self::AUTOFILTER_RULETYPE_DYNAMIC_THISMONTH, self::AUTOFILTER_RULETYPE_DYNAMIC_THISWEEK, self::AUTOFILTER_RULETYPE_DYNAMIC_LASTYEAR, self::AUTOFILTER_RULETYPE_DYNAMIC_LASTQUARTER, self::AUTOFILTER_RULETYPE_DYNAMIC_LASTMONTH, self::AUTOFILTER_RULETYPE_DYNAMIC_LASTWEEK, self::AUTOFILTER_RULETYPE_DYNAMIC_NEXTYEAR, self::AUTOFILTER_RULETYPE_DYNAMIC_NEXTQUARTER, self::AUTOFILTER_RULETYPE_DYNAMIC_NEXTMONTH, self::AUTOFILTER_RULETYPE_DYNAMIC_NEXTWEEK, self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_1, self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_2, self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_3, self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_4, self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_5, self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_6, self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_7, self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_8, self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_9, self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_10, self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_11, self::AUTOFILTER_RULETYPE_DYNAMIC_MONTH_12, self::AUTOFILTER_RULETYPE_DYNAMIC_QUARTER_1, self::AUTOFILTER_RULETYPE_DYNAMIC_QUARTER_2, self::AUTOFILTER_RULETYPE_DYNAMIC_QUARTER_3, self::AUTOFILTER_RULETYPE_DYNAMIC_QUARTER_4, self::AUTOFILTER_RULETYPE_DYNAMIC_ABOVEAVERAGE, self::AUTOFILTER_RULETYPE_DYNAMIC_BELOWAVERAGE];
        /*
         *    The only valid filter rule operators for filter and customFilter types are:
         *        <xsd:enumeration value="equal"/>
         *        <xsd:enumeration value="lessThan"/>
         *        <xsd:enumeration value="lessThanOrEqual"/>
         *        <xsd:enumeration value="notEqual"/>
         *        <xsd:enumeration value="greaterThanOrEqual"/>
         *        <xsd:enumeration value="greaterThan"/>
         */
        const AUTOFILTER_COLUMN_RULE_EQUAL = 'equal';
        const AUTOFILTER_COLUMN_RULE_NOTEQUAL = 'notEqual';
        const AUTOFILTER_COLUMN_RULE_GREATERTHAN = 'greaterThan';
        const AUTOFILTER_COLUMN_RULE_GREATERTHANOREQUAL = 'greaterThanOrEqual';
        const AUTOFILTER_COLUMN_RULE_LESSTHAN = 'lessThan';
        const AUTOFILTER_COLUMN_RULE_LESSTHANOREQUAL = 'lessThanOrEqual';
        private static $operators = [self::AUTOFILTER_COLUMN_RULE_EQUAL, self::AUTOFILTER_COLUMN_RULE_NOTEQUAL, self::AUTOFILTER_COLUMN_RULE_GREATERTHAN, self::AUTOFILTER_COLUMN_RULE_GREATERTHANOREQUAL, self::AUTOFILTER_COLUMN_RULE_LESSTHAN, self::AUTOFILTER_COLUMN_RULE_LESSTHANOREQUAL];
        const AUTOFILTER_COLUMN_RULE_TOPTEN_BY_VALUE = 'byValue';
        const AUTOFILTER_COLUMN_RULE_TOPTEN_PERCENT = 'byPercent';
        private static $topTenValue = [self::AUTOFILTER_COLUMN_RULE_TOPTEN_BY_VALUE, self::AUTOFILTER_COLUMN_RULE_TOPTEN_PERCENT];
        const AUTOFILTER_COLUMN_RULE_TOPTEN_TOP = 'top';
        const AUTOFILTER_COLUMN_RULE_TOPTEN_BOTTOM = 'bottom';
        private static $topTenType = [self::AUTOFILTER_COLUMN_RULE_TOPTEN_TOP, self::AUTOFILTER_COLUMN_RULE_TOPTEN_BOTTOM];
        // Rule Operators (Numeric, Boolean etc)
        //    const AUTOFILTER_COLUMN_RULE_BETWEEN            = 'between';        //    greaterThanOrEqual 1 && lessThanOrEqual 2
        // Rule Operators (Numeric Special) which are translated to standard numeric operators with calculated values
        //    const AUTOFILTER_COLUMN_RULE_TOPTEN                = 'topTen';            //    greaterThan calculated value
        //    const AUTOFILTER_COLUMN_RULE_TOPTENPERCENT        = 'topTenPercent';    //    greaterThan calculated value
        //    const AUTOFILTER_COLUMN_RULE_ABOVEAVERAGE        = 'aboveAverage';    //    Value is calculated as the average
        //    const AUTOFILTER_COLUMN_RULE_BELOWAVERAGE        = 'belowAverage';    //    Value is calculated as the average
        // Rule Operators (String) which are set as wild-carded values
        //    const AUTOFILTER_COLUMN_RULE_BEGINSWITH            = 'beginsWith';            // A*
        //    const AUTOFILTER_COLUMN_RULE_ENDSWITH            = 'endsWith';            // *Z
        //    const AUTOFILTER_COLUMN_RULE_CONTAINS            = 'contains';            // *B*
        //    const AUTOFILTER_COLUMN_RULE_DOESNTCONTAIN        = 'notEqual';            //    notEqual *B*
        // Rule Operators (Date Special) which are translated to standard numeric operators with calculated values
        //    const AUTOFILTER_COLUMN_RULE_BEFORE                = 'lessThan';
        //    const AUTOFILTER_COLUMN_RULE_AFTER                = 'greaterThan';
        //    const AUTOFILTER_COLUMN_RULE_YESTERDAY            = 'yesterday';
        //    const AUTOFILTER_COLUMN_RULE_TODAY                = 'today';
        //    const AUTOFILTER_COLUMN_RULE_TOMORROW            = 'tomorrow';
        //    const AUTOFILTER_COLUMN_RULE_LASTWEEK            = 'lastWeek';
        //    const AUTOFILTER_COLUMN_RULE_THISWEEK            = 'thisWeek';
        //    const AUTOFILTER_COLUMN_RULE_NEXTWEEK            = 'nextWeek';
        //    const AUTOFILTER_COLUMN_RULE_LASTMONTH            = 'lastMonth';
        //    const AUTOFILTER_COLUMN_RULE_THISMONTH            = 'thisMonth';
        //    const AUTOFILTER_COLUMN_RULE_NEXTMONTH            = 'nextMonth';
        //    const AUTOFILTER_COLUMN_RULE_LASTQUARTER        = 'lastQuarter';
        //    const AUTOFILTER_COLUMN_RULE_THISQUARTER        = 'thisQuarter';
        //    const AUTOFILTER_COLUMN_RULE_NEXTQUARTER        = 'nextQuarter';
        //    const AUTOFILTER_COLUMN_RULE_LASTYEAR            = 'lastYear';
        //    const AUTOFILTER_COLUMN_RULE_THISYEAR            = 'thisYear';
        //    const AUTOFILTER_COLUMN_RULE_NEXTYEAR            = 'nextYear';
        //    const AUTOFILTER_COLUMN_RULE_YEARTODATE            = 'yearToDate';            //    <dynamicFilter val="40909" type="yearToDate" maxVal="41113"/>
        //    const AUTOFILTER_COLUMN_RULE_ALLDATESINMONTH    = 'allDatesInMonth';    //    <dynamicFilter type="M2"/> for Month/February
        //    const AUTOFILTER_COLUMN_RULE_ALLDATESINQUARTER    = 'allDatesInQuarter';    //    <dynamicFilter type="Q2"/> for Quarter 2
        /**
         * Autofilter Column.
         *
         * @var Column
         */
        private $parent;
        /**
         * Autofilter Rule Type.
         *
         * @var string
         */
        private $ruleType = self::AUTOFILTER_RULETYPE_FILTER;
        /**
         * Autofilter Rule Value.
         *
         * @var string
         */
        private $value = '';
        /**
         * Autofilter Rule Operator.
         *
         * @var string
         */
        private $operator = self::AUTOFILTER_COLUMN_RULE_EQUAL;
        /**
         * DateTimeGrouping Group Value.
         *
         * @var string
         */
        private $grouping = '';
        /**
         * Create a new Rule.
         *
         * @param Column $pParent
         */
        public function __construct(?\PhpOffice\PhpSpreadsheet\Worksheet\AutoFilter\Column $pParent = null)
        {
        }
        /**
         * Get AutoFilter Rule Type.
         *
         * @return string
         */
        public function getRuleType()
        {
        }
        /**
         * Set AutoFilter Rule Type.
         *
         * @param string $pRuleType see self::AUTOFILTER_RULETYPE_*
         *
         * @return $this
         */
        public function setRuleType($pRuleType)
        {
        }
        /**
         * Get AutoFilter Rule Value.
         *
         * @return string
         */
        public function getValue()
        {
        }
        /**
         * Set AutoFilter Rule Value.
         *
         * @param string|string[] $pValue
         *
         * @return $this
         */
        public function setValue($pValue)
        {
        }
        /**
         * Get AutoFilter Rule Operator.
         *
         * @return string
         */
        public function getOperator()
        {
        }
        /**
         * Set AutoFilter Rule Operator.
         *
         * @param string $pOperator see self::AUTOFILTER_COLUMN_RULE_*
         *
         * @return $this
         */
        public function setOperator($pOperator)
        {
        }
        /**
         * Get AutoFilter Rule Grouping.
         *
         * @return string
         */
        public function getGrouping()
        {
        }
        /**
         * Set AutoFilter Rule Grouping.
         *
         * @param string $pGrouping
         *
         * @return $this
         */
        public function setGrouping($pGrouping)
        {
        }
        /**
         * Set AutoFilter Rule.
         *
         * @param string $pOperator see self::AUTOFILTER_COLUMN_RULE_*
         * @param string|string[] $pValue
         * @param string $pGrouping
         *
         * @return $this
         */
        public function setRule($pOperator, $pValue, $pGrouping = null)
        {
        }
        /**
         * Get this Rule's AutoFilter Column Parent.
         *
         * @return Column
         */
        public function getParent()
        {
        }
        /**
         * Set this Rule's AutoFilter Column Parent.
         *
         * @param Column $pParent
         *
         * @return $this
         */
        public function setParent(?\PhpOffice\PhpSpreadsheet\Worksheet\AutoFilter\Column $pParent = null)
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Worksheet\AutoFilter {
    class Column
    {
        const AUTOFILTER_FILTERTYPE_FILTER = 'filters';
        const AUTOFILTER_FILTERTYPE_CUSTOMFILTER = 'customFilters';
        //    Supports no more than 2 rules, with an And/Or join criteria
        //        if more than 1 rule is defined
        const AUTOFILTER_FILTERTYPE_DYNAMICFILTER = 'dynamicFilter';
        //    Even though the filter rule is constant, the filtered data can vary
        //        e.g. filtered by date = TODAY
        const AUTOFILTER_FILTERTYPE_TOPTENFILTER = 'top10';
        /**
         * Types of autofilter rules.
         *
         * @var string[]
         */
        private static $filterTypes = [
            //    Currently we're not handling
            //        colorFilter
            //        extLst
            //        iconFilter
            self::AUTOFILTER_FILTERTYPE_FILTER,
            self::AUTOFILTER_FILTERTYPE_CUSTOMFILTER,
            self::AUTOFILTER_FILTERTYPE_DYNAMICFILTER,
            self::AUTOFILTER_FILTERTYPE_TOPTENFILTER,
        ];
        // Multiple Rule Connections
        const AUTOFILTER_COLUMN_JOIN_AND = 'and';
        const AUTOFILTER_COLUMN_JOIN_OR = 'or';
        /**
         * Join options for autofilter rules.
         *
         * @var string[]
         */
        private static $ruleJoins = [self::AUTOFILTER_COLUMN_JOIN_AND, self::AUTOFILTER_COLUMN_JOIN_OR];
        /**
         * Autofilter.
         *
         * @var AutoFilter
         */
        private $parent;
        /**
         * Autofilter Column Index.
         *
         * @var string
         */
        private $columnIndex = '';
        /**
         * Autofilter Column Filter Type.
         *
         * @var string
         */
        private $filterType = self::AUTOFILTER_FILTERTYPE_FILTER;
        /**
         * Autofilter Multiple Rules And/Or.
         *
         * @var string
         */
        private $join = self::AUTOFILTER_COLUMN_JOIN_OR;
        /**
         * Autofilter Column Rules.
         *
         * @var array of Column\Rule
         */
        private $ruleset = [];
        /**
         * Autofilter Column Dynamic Attributes.
         *
         * @var array of mixed
         */
        private $attributes = [];
        /**
         * Create a new Column.
         *
         * @param string $pColumn Column (e.g. A)
         * @param AutoFilter $pParent Autofilter for this column
         */
        public function __construct($pColumn, ?\PhpOffice\PhpSpreadsheet\Worksheet\AutoFilter $pParent = null)
        {
        }
        /**
         * Get AutoFilter column index as string eg: 'A'.
         *
         * @return string
         */
        public function getColumnIndex()
        {
        }
        /**
         * Set AutoFilter column index as string eg: 'A'.
         *
         * @param string $pColumn Column (e.g. A)
         *
         * @return $this
         */
        public function setColumnIndex($pColumn)
        {
        }
        /**
         * Get this Column's AutoFilter Parent.
         *
         * @return AutoFilter
         */
        public function getParent()
        {
        }
        /**
         * Set this Column's AutoFilter Parent.
         *
         * @param AutoFilter $pParent
         *
         * @return $this
         */
        public function setParent(?\PhpOffice\PhpSpreadsheet\Worksheet\AutoFilter $pParent = null)
        {
        }
        /**
         * Get AutoFilter Type.
         *
         * @return string
         */
        public function getFilterType()
        {
        }
        /**
         * Set AutoFilter Type.
         *
         * @param string $pFilterType
         *
         * @return $this
         */
        public function setFilterType($pFilterType)
        {
        }
        /**
         * Get AutoFilter Multiple Rules And/Or Join.
         *
         * @return string
         */
        public function getJoin()
        {
        }
        /**
         * Set AutoFilter Multiple Rules And/Or.
         *
         * @param string $pJoin And/Or
         *
         * @return $this
         */
        public function setJoin($pJoin)
        {
        }
        /**
         * Set AutoFilter Attributes.
         *
         * @param string[] $attributes
         *
         * @return $this
         */
        public function setAttributes(array $attributes)
        {
        }
        /**
         * Set An AutoFilter Attribute.
         *
         * @param string $pName Attribute Name
         * @param string $pValue Attribute Value
         *
         * @return $this
         */
        public function setAttribute($pName, $pValue)
        {
        }
        /**
         * Get AutoFilter Column Attributes.
         *
         * @return string[]
         */
        public function getAttributes()
        {
        }
        /**
         * Get specific AutoFilter Column Attribute.
         *
         * @param string $pName Attribute Name
         *
         * @return string
         */
        public function getAttribute($pName)
        {
        }
        /**
         * Get all AutoFilter Column Rules.
         *
         * @return Column\Rule[]
         */
        public function getRules()
        {
        }
        /**
         * Get a specified AutoFilter Column Rule.
         *
         * @param int $pIndex Rule index in the ruleset array
         *
         * @return Column\Rule
         */
        public function getRule($pIndex)
        {
        }
        /**
         * Create a new AutoFilter Column Rule in the ruleset.
         *
         * @return Column\Rule
         */
        public function createRule()
        {
        }
        /**
         * Add a new AutoFilter Column Rule to the ruleset.
         *
         * @return $this
         */
        public function addRule(\PhpOffice\PhpSpreadsheet\Worksheet\AutoFilter\Column\Rule $pRule)
        {
        }
        /**
         * Delete a specified AutoFilter Column Rule
         * If the number of rules is reduced to 1, then we reset And/Or logic to Or.
         *
         * @param int $pIndex Rule index in the ruleset array
         *
         * @return $this
         */
        public function deleteRule($pIndex)
        {
        }
        /**
         * Delete all AutoFilter Column Rules.
         *
         * @return $this
         */
        public function clearRules()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet {
    interface IComparable
    {
        /**
         * Get hash code.
         *
         * @return string Hash code
         */
        public function getHashCode();
    }
}
namespace PhpOffice\PhpSpreadsheet\Worksheet {
    class Worksheet implements \PhpOffice\PhpSpreadsheet\IComparable
    {
        // Break types
        const BREAK_NONE = 0;
        const BREAK_ROW = 1;
        const BREAK_COLUMN = 2;
        // Sheet state
        const SHEETSTATE_VISIBLE = 'visible';
        const SHEETSTATE_HIDDEN = 'hidden';
        const SHEETSTATE_VERYHIDDEN = 'veryHidden';
        /**
         * Maximum 31 characters allowed for sheet title.
         *
         * @var int
         */
        const SHEET_TITLE_MAXIMUM_LENGTH = 31;
        /**
         * Invalid characters in sheet title.
         *
         * @var array
         */
        private static $invalidCharacters = ['*', ':', '/', '\\', '?', '[', ']'];
        /**
         * Parent spreadsheet.
         *
         * @var Spreadsheet
         */
        private $parent;
        /**
         * Collection of cells.
         *
         * @var Cells
         */
        private $cellCollection;
        /**
         * Collection of row dimensions.
         *
         * @var RowDimension[]
         */
        private $rowDimensions = [];
        /**
         * Default row dimension.
         *
         * @var RowDimension
         */
        private $defaultRowDimension;
        /**
         * Collection of column dimensions.
         *
         * @var ColumnDimension[]
         */
        private $columnDimensions = [];
        /**
         * Default column dimension.
         *
         * @var ColumnDimension
         */
        private $defaultColumnDimension;
        /**
         * Collection of drawings.
         *
         * @var BaseDrawing[]
         */
        private $drawingCollection;
        /**
         * Collection of Chart objects.
         *
         * @var Chart[]
         */
        private $chartCollection = [];
        /**
         * Worksheet title.
         *
         * @var string
         */
        private $title;
        /**
         * Sheet state.
         *
         * @var string
         */
        private $sheetState;
        /**
         * Page setup.
         *
         * @var PageSetup
         */
        private $pageSetup;
        /**
         * Page margins.
         *
         * @var PageMargins
         */
        private $pageMargins;
        /**
         * Page header/footer.
         *
         * @var HeaderFooter
         */
        private $headerFooter;
        /**
         * Sheet view.
         *
         * @var SheetView
         */
        private $sheetView;
        /**
         * Protection.
         *
         * @var Protection
         */
        private $protection;
        /**
         * Collection of styles.
         *
         * @var Style[]
         */
        private $styles = [];
        /**
         * Conditional styles. Indexed by cell coordinate, e.g. 'A1'.
         *
         * @var array
         */
        private $conditionalStylesCollection = [];
        /**
         * Is the current cell collection sorted already?
         *
         * @var bool
         */
        private $cellCollectionIsSorted = false;
        /**
         * Collection of breaks.
         *
         * @var array
         */
        private $breaks = [];
        /**
         * Collection of merged cell ranges.
         *
         * @var string[]
         */
        private $mergeCells = [];
        /**
         * Collection of protected cell ranges.
         *
         * @var array
         */
        private $protectedCells = [];
        /**
         * Autofilter Range and selection.
         *
         * @var AutoFilter
         */
        private $autoFilter;
        /**
         * Freeze pane.
         *
         * @var null|string
         */
        private $freezePane;
        /**
         * Default position of the right bottom pane.
         *
         * @var null|string
         */
        private $topLeftCell;
        /**
         * Show gridlines?
         *
         * @var bool
         */
        private $showGridlines = true;
        /**
         * Print gridlines?
         *
         * @var bool
         */
        private $printGridlines = false;
        /**
         * Show row and column headers?
         *
         * @var bool
         */
        private $showRowColHeaders = true;
        /**
         * Show summary below? (Row/Column outline).
         *
         * @var bool
         */
        private $showSummaryBelow = true;
        /**
         * Show summary right? (Row/Column outline).
         *
         * @var bool
         */
        private $showSummaryRight = true;
        /**
         * Collection of comments.
         *
         * @var Comment[]
         */
        private $comments = [];
        /**
         * Active cell. (Only one!).
         *
         * @var string
         */
        private $activeCell = 'A1';
        /**
         * Selected cells.
         *
         * @var string
         */
        private $selectedCells = 'A1';
        /**
         * Cached highest column.
         *
         * @var string
         */
        private $cachedHighestColumn = 'A';
        /**
         * Cached highest row.
         *
         * @var int
         */
        private $cachedHighestRow = 1;
        /**
         * Right-to-left?
         *
         * @var bool
         */
        private $rightToLeft = false;
        /**
         * Hyperlinks. Indexed by cell coordinate, e.g. 'A1'.
         *
         * @var array
         */
        private $hyperlinkCollection = [];
        /**
         * Data validation objects. Indexed by cell coordinate, e.g. 'A1'.
         *
         * @var array
         */
        private $dataValidationCollection = [];
        /**
         * Tab color.
         *
         * @var Color
         */
        private $tabColor;
        /**
         * Dirty flag.
         *
         * @var bool
         */
        private $dirty = true;
        /**
         * Hash.
         *
         * @var string
         */
        private $hash;
        /**
         * CodeName.
         *
         * @var string
         */
        private $codeName;
        /**
         * Create a new worksheet.
         *
         * @param Spreadsheet $parent
         * @param string $pTitle
         */
        public function __construct(?\PhpOffice\PhpSpreadsheet\Spreadsheet $parent = null, $pTitle = 'Worksheet')
        {
        }
        /**
         * Disconnect all cells from this Worksheet object,
         * typically so that the worksheet object can be unset.
         */
        public function disconnectCells() : void
        {
        }
        /**
         * Code to execute when this worksheet is unset().
         */
        public function __destruct()
        {
        }
        /**
         * Return the cell collection.
         *
         * @return Cells
         */
        public function getCellCollection()
        {
        }
        /**
         * Get array of invalid characters for sheet title.
         *
         * @return array
         */
        public static function getInvalidCharacters()
        {
        }
        /**
         * Check sheet code name for valid Excel syntax.
         *
         * @param string $pValue The string to check
         *
         * @return string The valid string
         */
        private static function checkSheetCodeName($pValue)
        {
        }
        /**
         * Check sheet title for valid Excel syntax.
         *
         * @param string $pValue The string to check
         *
         * @return string The valid string
         */
        private static function checkSheetTitle($pValue)
        {
        }
        /**
         * Get a sorted list of all cell coordinates currently held in the collection by row and column.
         *
         * @param bool $sorted Also sort the cell collection?
         *
         * @return string[]
         */
        public function getCoordinates($sorted = true)
        {
        }
        /**
         * Get collection of row dimensions.
         *
         * @return RowDimension[]
         */
        public function getRowDimensions()
        {
        }
        /**
         * Get default row dimension.
         *
         * @return RowDimension
         */
        public function getDefaultRowDimension()
        {
        }
        /**
         * Get collection of column dimensions.
         *
         * @return ColumnDimension[]
         */
        public function getColumnDimensions()
        {
        }
        /**
         * Get default column dimension.
         *
         * @return ColumnDimension
         */
        public function getDefaultColumnDimension()
        {
        }
        /**
         * Get collection of drawings.
         *
         * @return BaseDrawing[]
         */
        public function getDrawingCollection()
        {
        }
        /**
         * Get collection of charts.
         *
         * @return Chart[]
         */
        public function getChartCollection()
        {
        }
        /**
         * Add chart.
         *
         * @param null|int $iChartIndex Index where chart should go (0,1,..., or null for last)
         *
         * @return Chart
         */
        public function addChart(\PhpOffice\PhpSpreadsheet\Chart\Chart $pChart, $iChartIndex = null)
        {
        }
        /**
         * Return the count of charts on this worksheet.
         *
         * @return int The number of charts
         */
        public function getChartCount()
        {
        }
        /**
         * Get a chart by its index position.
         *
         * @param string $index Chart index position
         *
         * @return Chart|false
         */
        public function getChartByIndex($index)
        {
        }
        /**
         * Return an array of the names of charts on this worksheet.
         *
         * @return string[] The names of charts
         */
        public function getChartNames()
        {
        }
        /**
         * Get a chart by name.
         *
         * @param string $chartName Chart name
         *
         * @return Chart|false
         */
        public function getChartByName($chartName)
        {
        }
        /**
         * Refresh column dimensions.
         *
         * @return $this
         */
        public function refreshColumnDimensions()
        {
        }
        /**
         * Refresh row dimensions.
         *
         * @return $this
         */
        public function refreshRowDimensions()
        {
        }
        /**
         * Calculate worksheet dimension.
         *
         * @return string String containing the dimension of this worksheet
         */
        public function calculateWorksheetDimension()
        {
        }
        /**
         * Calculate worksheet data dimension.
         *
         * @return string String containing the dimension of this worksheet that actually contain data
         */
        public function calculateWorksheetDataDimension()
        {
        }
        /**
         * Calculate widths for auto-size columns.
         *
         * @return $this
         */
        public function calculateColumnWidths()
        {
        }
        /**
         * Get parent.
         *
         * @return Spreadsheet
         */
        public function getParent()
        {
        }
        /**
         * Re-bind parent.
         *
         * @return $this
         */
        public function rebindParent(\PhpOffice\PhpSpreadsheet\Spreadsheet $parent)
        {
        }
        /**
         * Get title.
         *
         * @return string
         */
        public function getTitle()
        {
        }
        /**
         * Set title.
         *
         * @param string $pValue String containing the dimension of this worksheet
         * @param bool $updateFormulaCellReferences Flag indicating whether cell references in formulae should
         *            be updated to reflect the new sheet name.
         *          This should be left as the default true, unless you are
         *          certain that no formula cells on any worksheet contain
         *          references to this worksheet
         * @param bool $validate False to skip validation of new title. WARNING: This should only be set
         *                       at parse time (by Readers), where titles can be assumed to be valid.
         *
         * @return $this
         */
        public function setTitle($pValue, $updateFormulaCellReferences = true, $validate = true)
        {
        }
        /**
         * Get sheet state.
         *
         * @return string Sheet state (visible, hidden, veryHidden)
         */
        public function getSheetState()
        {
        }
        /**
         * Set sheet state.
         *
         * @param string $value Sheet state (visible, hidden, veryHidden)
         *
         * @return $this
         */
        public function setSheetState($value)
        {
        }
        /**
         * Get page setup.
         *
         * @return PageSetup
         */
        public function getPageSetup()
        {
        }
        /**
         * Set page setup.
         *
         * @return $this
         */
        public function setPageSetup(\PhpOffice\PhpSpreadsheet\Worksheet\PageSetup $pValue)
        {
        }
        /**
         * Get page margins.
         *
         * @return PageMargins
         */
        public function getPageMargins()
        {
        }
        /**
         * Set page margins.
         *
         * @return $this
         */
        public function setPageMargins(\PhpOffice\PhpSpreadsheet\Worksheet\PageMargins $pValue)
        {
        }
        /**
         * Get page header/footer.
         *
         * @return HeaderFooter
         */
        public function getHeaderFooter()
        {
        }
        /**
         * Set page header/footer.
         *
         * @return $this
         */
        public function setHeaderFooter(\PhpOffice\PhpSpreadsheet\Worksheet\HeaderFooter $pValue)
        {
        }
        /**
         * Get sheet view.
         *
         * @return SheetView
         */
        public function getSheetView()
        {
        }
        /**
         * Set sheet view.
         *
         * @return $this
         */
        public function setSheetView(\PhpOffice\PhpSpreadsheet\Worksheet\SheetView $pValue)
        {
        }
        /**
         * Get Protection.
         *
         * @return Protection
         */
        public function getProtection()
        {
        }
        /**
         * Set Protection.
         *
         * @return $this
         */
        public function setProtection(\PhpOffice\PhpSpreadsheet\Worksheet\Protection $pValue)
        {
        }
        /**
         * Get highest worksheet column.
         *
         * @param string $row Return the data highest column for the specified row,
         *                                     or the highest column of any row if no row number is passed
         *
         * @return string Highest column name
         */
        public function getHighestColumn($row = null)
        {
        }
        /**
         * Get highest worksheet column that contains data.
         *
         * @param string $row Return the highest data column for the specified row,
         *                                     or the highest data column of any row if no row number is passed
         *
         * @return string Highest column name that contains data
         */
        public function getHighestDataColumn($row = null)
        {
        }
        /**
         * Get highest worksheet row.
         *
         * @param string $column Return the highest data row for the specified column,
         *                                     or the highest row of any column if no column letter is passed
         *
         * @return int Highest row number
         */
        public function getHighestRow($column = null)
        {
        }
        /**
         * Get highest worksheet row that contains data.
         *
         * @param string $column Return the highest data row for the specified column,
         *                                     or the highest data row of any column if no column letter is passed
         *
         * @return int Highest row number that contains data
         */
        public function getHighestDataRow($column = null)
        {
        }
        /**
         * Get highest worksheet column and highest row that have cell records.
         *
         * @return array Highest column name and highest row number
         */
        public function getHighestRowAndColumn()
        {
        }
        /**
         * Set a cell value.
         *
         * @param string $pCoordinate Coordinate of the cell, eg: 'A1'
         * @param mixed $pValue Value of the cell
         *
         * @return $this
         */
        public function setCellValue($pCoordinate, $pValue)
        {
        }
        /**
         * Set a cell value by using numeric cell coordinates.
         *
         * @param int $columnIndex Numeric column coordinate of the cell
         * @param int $row Numeric row coordinate of the cell
         * @param mixed $value Value of the cell
         *
         * @return $this
         */
        public function setCellValueByColumnAndRow($columnIndex, $row, $value)
        {
        }
        /**
         * Set a cell value.
         *
         * @param string $pCoordinate Coordinate of the cell, eg: 'A1'
         * @param mixed $pValue Value of the cell
         * @param string $pDataType Explicit data type, see DataType::TYPE_*
         *
         * @return $this
         */
        public function setCellValueExplicit($pCoordinate, $pValue, $pDataType)
        {
        }
        /**
         * Set a cell value by using numeric cell coordinates.
         *
         * @param int $columnIndex Numeric column coordinate of the cell
         * @param int $row Numeric row coordinate of the cell
         * @param mixed $value Value of the cell
         * @param string $dataType Explicit data type, see DataType::TYPE_*
         *
         * @return $this
         */
        public function setCellValueExplicitByColumnAndRow($columnIndex, $row, $value, $dataType)
        {
        }
        /**
         * Get cell at a specific coordinate.
         *
         * @param string $pCoordinate Coordinate of the cell, eg: 'A1'
         * @param bool $createIfNotExists Flag indicating whether a new cell should be created if it doesn't
         *                                       already exist, or a null should be returned instead
         *
         * @return null|Cell Cell that was found/created or null
         */
        public function getCell($pCoordinate, $createIfNotExists = true)
        {
        }
        /**
         * Get cell at a specific coordinate by using numeric cell coordinates.
         *
         * @param int $columnIndex Numeric column coordinate of the cell
         * @param int $row Numeric row coordinate of the cell
         * @param bool $createIfNotExists Flag indicating whether a new cell should be created if it doesn't
         *                                       already exist, or a null should be returned instead
         *
         * @return null|Cell Cell that was found/created or null
         */
        public function getCellByColumnAndRow($columnIndex, $row, $createIfNotExists = true)
        {
        }
        /**
         * Create a new cell at the specified coordinate.
         *
         * @param string $pCoordinate Coordinate of the cell
         *
         * @return Cell Cell that was created
         */
        private function createNewCell($pCoordinate)
        {
        }
        /**
         * Does the cell at a specific coordinate exist?
         *
         * @param string $pCoordinate Coordinate of the cell eg: 'A1'
         *
         * @return bool
         */
        public function cellExists($pCoordinate)
        {
        }
        /**
         * Cell at a specific coordinate by using numeric cell coordinates exists?
         *
         * @param int $columnIndex Numeric column coordinate of the cell
         * @param int $row Numeric row coordinate of the cell
         *
         * @return bool
         */
        public function cellExistsByColumnAndRow($columnIndex, $row)
        {
        }
        /**
         * Get row dimension at a specific row.
         *
         * @param int $pRow Numeric index of the row
         * @param bool $create
         *
         * @return RowDimension
         */
        public function getRowDimension($pRow, $create = true)
        {
        }
        /**
         * Get column dimension at a specific column.
         *
         * @param string $pColumn String index of the column eg: 'A'
         * @param bool $create
         *
         * @return ColumnDimension
         */
        public function getColumnDimension($pColumn, $create = true)
        {
        }
        /**
         * Get column dimension at a specific column by using numeric cell coordinates.
         *
         * @param int $columnIndex Numeric column coordinate of the cell
         *
         * @return ColumnDimension
         */
        public function getColumnDimensionByColumn($columnIndex)
        {
        }
        /**
         * Get styles.
         *
         * @return Style[]
         */
        public function getStyles()
        {
        }
        /**
         * Get style for cell.
         *
         * @param string $pCellCoordinate Cell coordinate (or range) to get style for, eg: 'A1'
         *
         * @return Style
         */
        public function getStyle($pCellCoordinate)
        {
        }
        /**
         * Get conditional styles for a cell.
         *
         * @param string $pCoordinate eg: 'A1'
         *
         * @return Conditional[]
         */
        public function getConditionalStyles($pCoordinate)
        {
        }
        /**
         * Do conditional styles exist for this cell?
         *
         * @param string $pCoordinate eg: 'A1'
         *
         * @return bool
         */
        public function conditionalStylesExists($pCoordinate)
        {
        }
        /**
         * Removes conditional styles for a cell.
         *
         * @param string $pCoordinate eg: 'A1'
         *
         * @return $this
         */
        public function removeConditionalStyles($pCoordinate)
        {
        }
        /**
         * Get collection of conditional styles.
         *
         * @return array
         */
        public function getConditionalStylesCollection()
        {
        }
        /**
         * Set conditional styles.
         *
         * @param string $pCoordinate eg: 'A1'
         * @param $pValue Conditional[]
         *
         * @return $this
         */
        public function setConditionalStyles($pCoordinate, $pValue)
        {
        }
        /**
         * Get style for cell by using numeric cell coordinates.
         *
         * @param int $columnIndex1 Numeric column coordinate of the cell
         * @param int $row1 Numeric row coordinate of the cell
         * @param null|int $columnIndex2 Numeric column coordinate of the range cell
         * @param null|int $row2 Numeric row coordinate of the range cell
         *
         * @return Style
         */
        public function getStyleByColumnAndRow($columnIndex1, $row1, $columnIndex2 = null, $row2 = null)
        {
        }
        /**
         * Duplicate cell style to a range of cells.
         *
         * Please note that this will overwrite existing cell styles for cells in range!
         *
         * @param Style $pCellStyle Cell style to duplicate
         * @param string $pRange Range of cells (i.e. "A1:B10"), or just one cell (i.e. "A1")
         *
         * @return $this
         */
        public function duplicateStyle(\PhpOffice\PhpSpreadsheet\Style\Style $pCellStyle, $pRange)
        {
        }
        /**
         * Duplicate conditional style to a range of cells.
         *
         * Please note that this will overwrite existing cell styles for cells in range!
         *
         * @param Conditional[] $pCellStyle Cell style to duplicate
         * @param string $pRange Range of cells (i.e. "A1:B10"), or just one cell (i.e. "A1")
         *
         * @return $this
         */
        public function duplicateConditionalStyle(array $pCellStyle, $pRange = '')
        {
        }
        /**
         * Set break on a cell.
         *
         * @param string $pCoordinate Cell coordinate (e.g. A1)
         * @param int $pBreak Break type (type of Worksheet::BREAK_*)
         *
         * @return $this
         */
        public function setBreak($pCoordinate, $pBreak)
        {
        }
        /**
         * Set break on a cell by using numeric cell coordinates.
         *
         * @param int $columnIndex Numeric column coordinate of the cell
         * @param int $row Numeric row coordinate of the cell
         * @param int $break Break type (type of Worksheet::BREAK_*)
         *
         * @return $this
         */
        public function setBreakByColumnAndRow($columnIndex, $row, $break)
        {
        }
        /**
         * Get breaks.
         *
         * @return array[]
         */
        public function getBreaks()
        {
        }
        /**
         * Set merge on a cell range.
         *
         * @param string $pRange Cell range (e.g. A1:E1)
         *
         * @return $this
         */
        public function mergeCells($pRange)
        {
        }
        /**
         * Set merge on a cell range by using numeric cell coordinates.
         *
         * @param int $columnIndex1 Numeric column coordinate of the first cell
         * @param int $row1 Numeric row coordinate of the first cell
         * @param int $columnIndex2 Numeric column coordinate of the last cell
         * @param int $row2 Numeric row coordinate of the last cell
         *
         * @return $this
         */
        public function mergeCellsByColumnAndRow($columnIndex1, $row1, $columnIndex2, $row2)
        {
        }
        /**
         * Remove merge on a cell range.
         *
         * @param string $pRange Cell range (e.g. A1:E1)
         *
         * @return $this
         */
        public function unmergeCells($pRange)
        {
        }
        /**
         * Remove merge on a cell range by using numeric cell coordinates.
         *
         * @param int $columnIndex1 Numeric column coordinate of the first cell
         * @param int $row1 Numeric row coordinate of the first cell
         * @param int $columnIndex2 Numeric column coordinate of the last cell
         * @param int $row2 Numeric row coordinate of the last cell
         *
         * @return $this
         */
        public function unmergeCellsByColumnAndRow($columnIndex1, $row1, $columnIndex2, $row2)
        {
        }
        /**
         * Get merge cells array.
         *
         * @return string[]
         */
        public function getMergeCells()
        {
        }
        /**
         * Set merge cells array for the entire sheet. Use instead mergeCells() to merge
         * a single cell range.
         *
         * @param string[] $pValue
         *
         * @return $this
         */
        public function setMergeCells(array $pValue)
        {
        }
        /**
         * Set protection on a cell range.
         *
         * @param string $pRange Cell (e.g. A1) or cell range (e.g. A1:E1)
         * @param string $pPassword Password to unlock the protection
         * @param bool $pAlreadyHashed If the password has already been hashed, set this to true
         *
         * @return $this
         */
        public function protectCells($pRange, $pPassword, $pAlreadyHashed = false)
        {
        }
        /**
         * Set protection on a cell range by using numeric cell coordinates.
         *
         * @param int $columnIndex1 Numeric column coordinate of the first cell
         * @param int $row1 Numeric row coordinate of the first cell
         * @param int $columnIndex2 Numeric column coordinate of the last cell
         * @param int $row2 Numeric row coordinate of the last cell
         * @param string $password Password to unlock the protection
         * @param bool $alreadyHashed If the password has already been hashed, set this to true
         *
         * @return $this
         */
        public function protectCellsByColumnAndRow($columnIndex1, $row1, $columnIndex2, $row2, $password, $alreadyHashed = false)
        {
        }
        /**
         * Remove protection on a cell range.
         *
         * @param string $pRange Cell (e.g. A1) or cell range (e.g. A1:E1)
         *
         * @return $this
         */
        public function unprotectCells($pRange)
        {
        }
        /**
         * Remove protection on a cell range by using numeric cell coordinates.
         *
         * @param int $columnIndex1 Numeric column coordinate of the first cell
         * @param int $row1 Numeric row coordinate of the first cell
         * @param int $columnIndex2 Numeric column coordinate of the last cell
         * @param int $row2 Numeric row coordinate of the last cell
         *
         * @return $this
         */
        public function unprotectCellsByColumnAndRow($columnIndex1, $row1, $columnIndex2, $row2)
        {
        }
        /**
         * Get protected cells.
         *
         * @return array[]
         */
        public function getProtectedCells()
        {
        }
        /**
         * Get Autofilter.
         *
         * @return AutoFilter
         */
        public function getAutoFilter()
        {
        }
        /**
         * Set AutoFilter.
         *
         * @param AutoFilter|string $pValue
         *            A simple string containing a Cell range like 'A1:E10' is permitted for backward compatibility
         *
         * @return $this
         */
        public function setAutoFilter($pValue)
        {
        }
        /**
         * Set Autofilter Range by using numeric cell coordinates.
         *
         * @param int $columnIndex1 Numeric column coordinate of the first cell
         * @param int $row1 Numeric row coordinate of the first cell
         * @param int $columnIndex2 Numeric column coordinate of the second cell
         * @param int $row2 Numeric row coordinate of the second cell
         *
         * @return $this
         */
        public function setAutoFilterByColumnAndRow($columnIndex1, $row1, $columnIndex2, $row2)
        {
        }
        /**
         * Remove autofilter.
         *
         * @return $this
         */
        public function removeAutoFilter()
        {
        }
        /**
         * Get Freeze Pane.
         *
         * @return string
         */
        public function getFreezePane()
        {
        }
        /**
         * Freeze Pane.
         *
         * Examples:
         *
         *     - A2 will freeze the rows above cell A2 (i.e row 1)
         *     - B1 will freeze the columns to the left of cell B1 (i.e column A)
         *     - B2 will freeze the rows above and to the left of cell B2 (i.e row 1 and column A)
         *
         * @param null|string $cell Position of the split
         * @param null|string $topLeftCell default position of the right bottom pane
         *
         * @return $this
         */
        public function freezePane($cell, $topLeftCell = null)
        {
        }
        /**
         * Freeze Pane by using numeric cell coordinates.
         *
         * @param int $columnIndex Numeric column coordinate of the cell
         * @param int $row Numeric row coordinate of the cell
         *
         * @return $this
         */
        public function freezePaneByColumnAndRow($columnIndex, $row)
        {
        }
        /**
         * Unfreeze Pane.
         *
         * @return $this
         */
        public function unfreezePane()
        {
        }
        /**
         * Get the default position of the right bottom pane.
         *
         * @return int
         */
        public function getTopLeftCell()
        {
        }
        /**
         * Insert a new row, updating all possible related data.
         *
         * @param int $pBefore Insert before this one
         * @param int $pNumRows Number of rows to insert
         *
         * @return $this
         */
        public function insertNewRowBefore($pBefore, $pNumRows = 1)
        {
        }
        /**
         * Insert a new column, updating all possible related data.
         *
         * @param string $pBefore Insert before this one, eg: 'A'
         * @param int $pNumCols Number of columns to insert
         *
         * @return $this
         */
        public function insertNewColumnBefore($pBefore, $pNumCols = 1)
        {
        }
        /**
         * Insert a new column, updating all possible related data.
         *
         * @param int $beforeColumnIndex Insert before this one (numeric column coordinate of the cell)
         * @param int $pNumCols Number of columns to insert
         *
         * @return $this
         */
        public function insertNewColumnBeforeByIndex($beforeColumnIndex, $pNumCols = 1)
        {
        }
        /**
         * Delete a row, updating all possible related data.
         *
         * @param int $pRow Remove starting with this one
         * @param int $pNumRows Number of rows to remove
         *
         * @return $this
         */
        public function removeRow($pRow, $pNumRows = 1)
        {
        }
        /**
         * Remove a column, updating all possible related data.
         *
         * @param string $pColumn Remove starting with this one, eg: 'A'
         * @param int $pNumCols Number of columns to remove
         *
         * @return $this
         */
        public function removeColumn($pColumn, $pNumCols = 1)
        {
        }
        /**
         * Remove a column, updating all possible related data.
         *
         * @param int $columnIndex Remove starting with this one (numeric column coordinate of the cell)
         * @param int $numColumns Number of columns to remove
         *
         * @return $this
         */
        public function removeColumnByIndex($columnIndex, $numColumns = 1)
        {
        }
        /**
         * Show gridlines?
         *
         * @return bool
         */
        public function getShowGridlines()
        {
        }
        /**
         * Set show gridlines.
         *
         * @param bool $pValue Show gridlines (true/false)
         *
         * @return $this
         */
        public function setShowGridlines($pValue)
        {
        }
        /**
         * Print gridlines?
         *
         * @return bool
         */
        public function getPrintGridlines()
        {
        }
        /**
         * Set print gridlines.
         *
         * @param bool $pValue Print gridlines (true/false)
         *
         * @return $this
         */
        public function setPrintGridlines($pValue)
        {
        }
        /**
         * Show row and column headers?
         *
         * @return bool
         */
        public function getShowRowColHeaders()
        {
        }
        /**
         * Set show row and column headers.
         *
         * @param bool $pValue Show row and column headers (true/false)
         *
         * @return $this
         */
        public function setShowRowColHeaders($pValue)
        {
        }
        /**
         * Show summary below? (Row/Column outlining).
         *
         * @return bool
         */
        public function getShowSummaryBelow()
        {
        }
        /**
         * Set show summary below.
         *
         * @param bool $pValue Show summary below (true/false)
         *
         * @return $this
         */
        public function setShowSummaryBelow($pValue)
        {
        }
        /**
         * Show summary right? (Row/Column outlining).
         *
         * @return bool
         */
        public function getShowSummaryRight()
        {
        }
        /**
         * Set show summary right.
         *
         * @param bool $pValue Show summary right (true/false)
         *
         * @return $this
         */
        public function setShowSummaryRight($pValue)
        {
        }
        /**
         * Get comments.
         *
         * @return Comment[]
         */
        public function getComments()
        {
        }
        /**
         * Set comments array for the entire sheet.
         *
         * @param Comment[] $pValue
         *
         * @return $this
         */
        public function setComments(array $pValue)
        {
        }
        /**
         * Get comment for cell.
         *
         * @param string $pCellCoordinate Cell coordinate to get comment for, eg: 'A1'
         *
         * @return Comment
         */
        public function getComment($pCellCoordinate)
        {
        }
        /**
         * Get comment for cell by using numeric cell coordinates.
         *
         * @param int $columnIndex Numeric column coordinate of the cell
         * @param int $row Numeric row coordinate of the cell
         *
         * @return Comment
         */
        public function getCommentByColumnAndRow($columnIndex, $row)
        {
        }
        /**
         * Get active cell.
         *
         * @return string Example: 'A1'
         */
        public function getActiveCell()
        {
        }
        /**
         * Get selected cells.
         *
         * @return string
         */
        public function getSelectedCells()
        {
        }
        /**
         * Selected cell.
         *
         * @param string $pCoordinate Cell (i.e. A1)
         *
         * @return $this
         */
        public function setSelectedCell($pCoordinate)
        {
        }
        /**
         * Select a range of cells.
         *
         * @param string $pCoordinate Cell range, examples: 'A1', 'B2:G5', 'A:C', '3:6'
         *
         * @return $this
         */
        public function setSelectedCells($pCoordinate)
        {
        }
        /**
         * Selected cell by using numeric cell coordinates.
         *
         * @param int $columnIndex Numeric column coordinate of the cell
         * @param int $row Numeric row coordinate of the cell
         *
         * @return $this
         */
        public function setSelectedCellByColumnAndRow($columnIndex, $row)
        {
        }
        /**
         * Get right-to-left.
         *
         * @return bool
         */
        public function getRightToLeft()
        {
        }
        /**
         * Set right-to-left.
         *
         * @param bool $value Right-to-left true/false
         *
         * @return $this
         */
        public function setRightToLeft($value)
        {
        }
        /**
         * Fill worksheet from values in array.
         *
         * @param array $source Source array
         * @param mixed $nullValue Value in source array that stands for blank cell
         * @param string $startCell Insert array starting from this cell address as the top left coordinate
         * @param bool $strictNullComparison Apply strict comparison when testing for null values in the array
         *
         * @return $this
         */
        public function fromArray(array $source, $nullValue = null, $startCell = 'A1', $strictNullComparison = false)
        {
        }
        /**
         * Create array from a range of cells.
         *
         * @param string $pRange Range of cells (i.e. "A1:B10"), or just one cell (i.e. "A1")
         * @param mixed $nullValue Value returned in the array entry if a cell doesn't exist
         * @param bool $calculateFormulas Should formulas be calculated?
         * @param bool $formatData Should formatting be applied to cell values?
         * @param bool $returnCellRef False - Return a simple array of rows and columns indexed by number counting from zero
         *                               True - Return rows and columns indexed by their actual row and column IDs
         *
         * @return array
         */
        public function rangeToArray($pRange, $nullValue = null, $calculateFormulas = true, $formatData = true, $returnCellRef = false)
        {
        }
        /**
         * Create array from a range of cells.
         *
         * @param string $pNamedRange Name of the Named Range
         * @param mixed $nullValue Value returned in the array entry if a cell doesn't exist
         * @param bool $calculateFormulas Should formulas be calculated?
         * @param bool $formatData Should formatting be applied to cell values?
         * @param bool $returnCellRef False - Return a simple array of rows and columns indexed by number counting from zero
         *                                True - Return rows and columns indexed by their actual row and column IDs
         *
         * @return array
         */
        public function namedRangeToArray($pNamedRange, $nullValue = null, $calculateFormulas = true, $formatData = true, $returnCellRef = false)
        {
        }
        /**
         * Create array from worksheet.
         *
         * @param mixed $nullValue Value returned in the array entry if a cell doesn't exist
         * @param bool $calculateFormulas Should formulas be calculated?
         * @param bool $formatData Should formatting be applied to cell values?
         * @param bool $returnCellRef False - Return a simple array of rows and columns indexed by number counting from zero
         *                               True - Return rows and columns indexed by their actual row and column IDs
         *
         * @return array
         */
        public function toArray($nullValue = null, $calculateFormulas = true, $formatData = true, $returnCellRef = false)
        {
        }
        /**
         * Get row iterator.
         *
         * @param int $startRow The row number at which to start iterating
         * @param int $endRow The row number at which to stop iterating
         *
         * @return RowIterator
         */
        public function getRowIterator($startRow = 1, $endRow = null)
        {
        }
        /**
         * Get column iterator.
         *
         * @param string $startColumn The column address at which to start iterating
         * @param string $endColumn The column address at which to stop iterating
         *
         * @return ColumnIterator
         */
        public function getColumnIterator($startColumn = 'A', $endColumn = null)
        {
        }
        /**
         * Run PhpSpreadsheet garbage collector.
         *
         * @return $this
         */
        public function garbageCollect()
        {
        }
        /**
         * Get hash code.
         *
         * @return string Hash code
         */
        public function getHashCode()
        {
        }
        /**
         * Extract worksheet title from range.
         *
         * Example: extractSheetTitle("testSheet!A1") ==> 'A1'
         * Example: extractSheetTitle("'testSheet 1'!A1", true) ==> ['testSheet 1', 'A1'];
         *
         * @param string $pRange Range to extract title from
         * @param bool $returnRange Return range? (see example)
         *
         * @return mixed
         */
        public static function extractSheetTitle($pRange, $returnRange = false)
        {
        }
        /**
         * Get hyperlink.
         *
         * @param string $pCellCoordinate Cell coordinate to get hyperlink for, eg: 'A1'
         *
         * @return Hyperlink
         */
        public function getHyperlink($pCellCoordinate)
        {
        }
        /**
         * Set hyperlink.
         *
         * @param string $pCellCoordinate Cell coordinate to insert hyperlink, eg: 'A1'
         *
         * @return $this
         */
        public function setHyperlink($pCellCoordinate, ?\PhpOffice\PhpSpreadsheet\Cell\Hyperlink $pHyperlink = null)
        {
        }
        /**
         * Hyperlink at a specific coordinate exists?
         *
         * @param string $pCoordinate eg: 'A1'
         *
         * @return bool
         */
        public function hyperlinkExists($pCoordinate)
        {
        }
        /**
         * Get collection of hyperlinks.
         *
         * @return Hyperlink[]
         */
        public function getHyperlinkCollection()
        {
        }
        /**
         * Get data validation.
         *
         * @param string $pCellCoordinate Cell coordinate to get data validation for, eg: 'A1'
         *
         * @return DataValidation
         */
        public function getDataValidation($pCellCoordinate)
        {
        }
        /**
         * Set data validation.
         *
         * @param string $pCellCoordinate Cell coordinate to insert data validation, eg: 'A1'
         *
         * @return $this
         */
        public function setDataValidation($pCellCoordinate, ?\PhpOffice\PhpSpreadsheet\Cell\DataValidation $pDataValidation = null)
        {
        }
        /**
         * Data validation at a specific coordinate exists?
         *
         * @param string $pCoordinate eg: 'A1'
         *
         * @return bool
         */
        public function dataValidationExists($pCoordinate)
        {
        }
        /**
         * Get collection of data validations.
         *
         * @return DataValidation[]
         */
        public function getDataValidationCollection()
        {
        }
        /**
         * Accepts a range, returning it as a range that falls within the current highest row and column of the worksheet.
         *
         * @param string $range
         *
         * @return string Adjusted range value
         */
        public function shrinkRangeToFit($range)
        {
        }
        /**
         * Get tab color.
         *
         * @return Color
         */
        public function getTabColor()
        {
        }
        /**
         * Reset tab color.
         *
         * @return $this
         */
        public function resetTabColor()
        {
        }
        /**
         * Tab color set?
         *
         * @return bool
         */
        public function isTabColorSet()
        {
        }
        /**
         * Copy worksheet (!= clone!).
         *
         * @return static
         */
        public function copy()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
        /**
         * Define the code name of the sheet.
         *
         * @param string $pValue Same rule as Title minus space not allowed (but, like Excel, change
         *                       silently space to underscore)
         * @param bool $validate False to skip validation of new title. WARNING: This should only be set
         *                       at parse time (by Readers), where titles can be assumed to be valid.
         *
         * @return $this
         */
        public function setCodeName($pValue, $validate = true)
        {
        }
        /**
         * Return the code name of the sheet.
         *
         * @return null|string
         */
        public function getCodeName()
        {
        }
        /**
         * Sheet has a code name ?
         *
         * @return bool
         */
        public function hasCodeName()
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Worksheet\Drawing {
    class Shadow implements \PhpOffice\PhpSpreadsheet\IComparable
    {
        // Shadow alignment
        const SHADOW_BOTTOM = 'b';
        const SHADOW_BOTTOM_LEFT = 'bl';
        const SHADOW_BOTTOM_RIGHT = 'br';
        const SHADOW_CENTER = 'ctr';
        const SHADOW_LEFT = 'l';
        const SHADOW_TOP = 't';
        const SHADOW_TOP_LEFT = 'tl';
        const SHADOW_TOP_RIGHT = 'tr';
        /**
         * Visible.
         *
         * @var bool
         */
        private $visible;
        /**
         * Blur radius.
         *
         * Defaults to 6
         *
         * @var int
         */
        private $blurRadius;
        /**
         * Shadow distance.
         *
         * Defaults to 2
         *
         * @var int
         */
        private $distance;
        /**
         * Shadow direction (in degrees).
         *
         * @var int
         */
        private $direction;
        /**
         * Shadow alignment.
         *
         * @var int
         */
        private $alignment;
        /**
         * Color.
         *
         * @var Color
         */
        private $color;
        /**
         * Alpha.
         *
         * @var int
         */
        private $alpha;
        /**
         * Create a new Shadow.
         */
        public function __construct()
        {
        }
        /**
         * Get Visible.
         *
         * @return bool
         */
        public function getVisible()
        {
        }
        /**
         * Set Visible.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setVisible($pValue)
        {
        }
        /**
         * Get Blur radius.
         *
         * @return int
         */
        public function getBlurRadius()
        {
        }
        /**
         * Set Blur radius.
         *
         * @param int $pValue
         *
         * @return $this
         */
        public function setBlurRadius($pValue)
        {
        }
        /**
         * Get Shadow distance.
         *
         * @return int
         */
        public function getDistance()
        {
        }
        /**
         * Set Shadow distance.
         *
         * @param int $pValue
         *
         * @return $this
         */
        public function setDistance($pValue)
        {
        }
        /**
         * Get Shadow direction (in degrees).
         *
         * @return int
         */
        public function getDirection()
        {
        }
        /**
         * Set Shadow direction (in degrees).
         *
         * @param int $pValue
         *
         * @return $this
         */
        public function setDirection($pValue)
        {
        }
        /**
         * Get Shadow alignment.
         *
         * @return int
         */
        public function getAlignment()
        {
        }
        /**
         * Set Shadow alignment.
         *
         * @param int $pValue
         *
         * @return $this
         */
        public function setAlignment($pValue)
        {
        }
        /**
         * Get Color.
         *
         * @return Color
         */
        public function getColor()
        {
        }
        /**
         * Set Color.
         *
         * @param Color $pValue
         *
         * @return $this
         */
        public function setColor(?\PhpOffice\PhpSpreadsheet\Style\Color $pValue = null)
        {
        }
        /**
         * Get Alpha.
         *
         * @return int
         */
        public function getAlpha()
        {
        }
        /**
         * Set Alpha.
         *
         * @param int $pValue
         *
         * @return $this
         */
        public function setAlpha($pValue)
        {
        }
        /**
         * Get hash code.
         *
         * @return string Hash code
         */
        public function getHashCode()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Worksheet {
    class ColumnDimension extends \PhpOffice\PhpSpreadsheet\Worksheet\Dimension
    {
        /**
         * Column index.
         *
         * @var string
         */
        private $columnIndex;
        /**
         * Column width.
         *
         * When this is set to a negative value, the column width should be ignored by IWriter
         *
         * @var float
         */
        private $width = -1;
        /**
         * Auto size?
         *
         * @var bool
         */
        private $autoSize = false;
        /**
         * Create a new ColumnDimension.
         *
         * @param string $pIndex Character column index
         */
        public function __construct($pIndex = 'A')
        {
        }
        /**
         * Get column index as string eg: 'A'.
         *
         * @return string
         */
        public function getColumnIndex()
        {
        }
        /**
         * Set column index as string eg: 'A'.
         *
         * @param string $pValue
         *
         * @return $this
         */
        public function setColumnIndex($pValue)
        {
        }
        /**
         * Get Width.
         *
         * @return float
         */
        public function getWidth()
        {
        }
        /**
         * Set Width.
         *
         * @param float $pValue
         *
         * @return $this
         */
        public function setWidth($pValue)
        {
        }
        /**
         * Get Auto Size.
         *
         * @return bool
         */
        public function getAutoSize()
        {
        }
        /**
         * Set Auto Size.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setAutoSize($pValue)
        {
        }
    }
    class ColumnIterator implements \Iterator
    {
        /**
         * Worksheet to iterate.
         *
         * @var Worksheet
         */
        private $worksheet;
        /**
         * Current iterator position.
         *
         * @var int
         */
        private $currentColumnIndex = 1;
        /**
         * Start position.
         *
         * @var int
         */
        private $startColumnIndex = 1;
        /**
         * End position.
         *
         * @var int
         */
        private $endColumnIndex = 1;
        /**
         * Create a new column iterator.
         *
         * @param Worksheet $worksheet The worksheet to iterate over
         * @param string $startColumn The column address at which to start iterating
         * @param string $endColumn Optionally, the column address at which to stop iterating
         */
        public function __construct(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $worksheet, $startColumn = 'A', $endColumn = null)
        {
        }
        /**
         * Destructor.
         */
        public function __destruct()
        {
        }
        /**
         * (Re)Set the start column and the current column pointer.
         *
         * @param string $startColumn The column address at which to start iterating
         *
         * @return $this
         */
        public function resetStart($startColumn = 'A')
        {
        }
        /**
         * (Re)Set the end column.
         *
         * @param string $endColumn The column address at which to stop iterating
         *
         * @return $this
         */
        public function resetEnd($endColumn = null)
        {
        }
        /**
         * Set the column pointer to the selected column.
         *
         * @param string $column The column address to set the current pointer at
         *
         * @return $this
         */
        public function seek($column = 'A')
        {
        }
        /**
         * Rewind the iterator to the starting column.
         */
        public function rewind() : void
        {
        }
        /**
         * Return the current column in this worksheet.
         *
         * @return Column
         */
        public function current()
        {
        }
        /**
         * Return the current iterator key.
         *
         * @return string
         */
        public function key()
        {
        }
        /**
         * Set the iterator to its next value.
         */
        public function next() : void
        {
        }
        /**
         * Set the iterator to its previous value.
         */
        public function prev() : void
        {
        }
        /**
         * Indicate if more columns exist in the worksheet range of columns that we're iterating.
         *
         * @return bool
         */
        public function valid()
        {
        }
    }
    class Column
    {
        /**
         * \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet.
         *
         * @var Worksheet
         */
        private $parent;
        /**
         * Column index.
         *
         * @var string
         */
        private $columnIndex;
        /**
         * Create a new column.
         *
         * @param Worksheet $parent
         * @param string $columnIndex
         */
        public function __construct(?\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $parent = null, $columnIndex = 'A')
        {
        }
        /**
         * Destructor.
         */
        public function __destruct()
        {
        }
        /**
         * Get column index as string eg: 'A'.
         *
         * @return string
         */
        public function getColumnIndex()
        {
        }
        /**
         * Get cell iterator.
         *
         * @param int $startRow The row number at which to start iterating
         * @param int $endRow Optionally, the row number at which to stop iterating
         *
         * @return ColumnCellIterator
         */
        public function getCellIterator($startRow = 1, $endRow = null)
        {
        }
    }
    class BaseDrawing implements \PhpOffice\PhpSpreadsheet\IComparable
    {
        /**
         * Image counter.
         *
         * @var int
         */
        private static $imageCounter = 0;
        /**
         * Image index.
         *
         * @var int
         */
        private $imageIndex = 0;
        /**
         * Name.
         *
         * @var string
         */
        protected $name;
        /**
         * Description.
         *
         * @var string
         */
        protected $description;
        /**
         * Worksheet.
         *
         * @var Worksheet
         */
        protected $worksheet;
        /**
         * Coordinates.
         *
         * @var string
         */
        protected $coordinates;
        /**
         * Offset X.
         *
         * @var int
         */
        protected $offsetX;
        /**
         * Offset Y.
         *
         * @var int
         */
        protected $offsetY;
        /**
         * Width.
         *
         * @var int
         */
        protected $width;
        /**
         * Height.
         *
         * @var int
         */
        protected $height;
        /**
         * Proportional resize.
         *
         * @var bool
         */
        protected $resizeProportional;
        /**
         * Rotation.
         *
         * @var int
         */
        protected $rotation;
        /**
         * Shadow.
         *
         * @var Drawing\Shadow
         */
        protected $shadow;
        /**
         * Image hyperlink.
         *
         * @var null|Hyperlink
         */
        private $hyperlink;
        /**
         * Create a new BaseDrawing.
         */
        public function __construct()
        {
        }
        /**
         * Get image index.
         *
         * @return int
         */
        public function getImageIndex()
        {
        }
        /**
         * Get Name.
         *
         * @return string
         */
        public function getName()
        {
        }
        /**
         * Set Name.
         *
         * @param string $pValue
         *
         * @return $this
         */
        public function setName($pValue)
        {
        }
        /**
         * Get Description.
         *
         * @return string
         */
        public function getDescription()
        {
        }
        /**
         * Set Description.
         *
         * @param string $description
         *
         * @return $this
         */
        public function setDescription($description)
        {
        }
        /**
         * Get Worksheet.
         *
         * @return Worksheet
         */
        public function getWorksheet()
        {
        }
        /**
         * Set Worksheet.
         *
         * @param Worksheet $pValue
         * @param bool $pOverrideOld If a Worksheet has already been assigned, overwrite it and remove image from old Worksheet?
         *
         * @return $this
         */
        public function setWorksheet(?\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pValue = null, $pOverrideOld = false)
        {
        }
        /**
         * Get Coordinates.
         *
         * @return string
         */
        public function getCoordinates()
        {
        }
        /**
         * Set Coordinates.
         *
         * @param string $pValue eg: 'A1'
         *
         * @return $this
         */
        public function setCoordinates($pValue)
        {
        }
        /**
         * Get OffsetX.
         *
         * @return int
         */
        public function getOffsetX()
        {
        }
        /**
         * Set OffsetX.
         *
         * @param int $pValue
         *
         * @return $this
         */
        public function setOffsetX($pValue)
        {
        }
        /**
         * Get OffsetY.
         *
         * @return int
         */
        public function getOffsetY()
        {
        }
        /**
         * Set OffsetY.
         *
         * @param int $pValue
         *
         * @return $this
         */
        public function setOffsetY($pValue)
        {
        }
        /**
         * Get Width.
         *
         * @return int
         */
        public function getWidth()
        {
        }
        /**
         * Set Width.
         *
         * @param int $pValue
         *
         * @return $this
         */
        public function setWidth($pValue)
        {
        }
        /**
         * Get Height.
         *
         * @return int
         */
        public function getHeight()
        {
        }
        /**
         * Set Height.
         *
         * @param int $pValue
         *
         * @return $this
         */
        public function setHeight($pValue)
        {
        }
        /**
         * Set width and height with proportional resize.
         *
         * Example:
         * <code>
         * $objDrawing->setResizeProportional(true);
         * $objDrawing->setWidthAndHeight(160,120);
         * </code>
         *
         * @author Vincent@luo MSN:kele_100@hotmail.com
         *
         * @param int $width
         * @param int $height
         *
         * @return $this
         */
        public function setWidthAndHeight($width, $height)
        {
        }
        /**
         * Get ResizeProportional.
         *
         * @return bool
         */
        public function getResizeProportional()
        {
        }
        /**
         * Set ResizeProportional.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setResizeProportional($pValue)
        {
        }
        /**
         * Get Rotation.
         *
         * @return int
         */
        public function getRotation()
        {
        }
        /**
         * Set Rotation.
         *
         * @param int $pValue
         *
         * @return $this
         */
        public function setRotation($pValue)
        {
        }
        /**
         * Get Shadow.
         *
         * @return Drawing\Shadow
         */
        public function getShadow()
        {
        }
        /**
         * Set Shadow.
         *
         * @param Drawing\Shadow $pValue
         *
         * @return $this
         */
        public function setShadow(?\PhpOffice\PhpSpreadsheet\Worksheet\Drawing\Shadow $pValue = null)
        {
        }
        /**
         * Get hash code.
         *
         * @return string Hash code
         */
        public function getHashCode()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
        public function setHyperlink(?\PhpOffice\PhpSpreadsheet\Cell\Hyperlink $pHyperlink = null) : void
        {
        }
        /**
         * @return null|Hyperlink
         */
        public function getHyperlink()
        {
        }
    }
    class Drawing extends \PhpOffice\PhpSpreadsheet\Worksheet\BaseDrawing
    {
        /**
         * Path.
         *
         * @var string
         */
        private $path;
        /**
         * Create a new Drawing.
         */
        public function __construct()
        {
        }
        /**
         * Get Filename.
         *
         * @return string
         */
        public function getFilename()
        {
        }
        /**
         * Get indexed filename (using image index).
         *
         * @return string
         */
        public function getIndexedFilename()
        {
        }
        /**
         * Get Extension.
         *
         * @return string
         */
        public function getExtension()
        {
        }
        /**
         * Get Path.
         *
         * @return string
         */
        public function getPath()
        {
        }
        /**
         * Set Path.
         *
         * @param string $pValue File path
         * @param bool $pVerifyFile Verify file
         *
         * @return $this
         */
        public function setPath($pValue, $pVerifyFile = true)
        {
        }
        /**
         * Get hash code.
         *
         * @return string Hash code
         */
        public function getHashCode()
        {
        }
    }
    /**
     * <code>
     * Header/Footer Formatting Syntax taken from Office Open XML Part 4 - Markup Language Reference, page 1970:.
     *
     * There are a number of formatting codes that can be written inline with the actual header / footer text, which
     * affect the formatting in the header or footer.
     *
     * Example: This example shows the text "Center Bold Header" on the first line (center section), and the date on
     * the second line (center section).
     *         &CCenter &"-,Bold"Bold&"-,Regular"Header_x000A_&D
     *
     * General Rules:
     * There is no required order in which these codes must appear.
     *
     * The first occurrence of the following codes turns the formatting ON, the second occurrence turns it OFF again:
     * - strikethrough
     * - superscript
     * - subscript
     * Superscript and subscript cannot both be ON at same time. Whichever comes first wins and the other is ignored,
     * while the first is ON.
     * &L - code for "left section" (there are three header / footer locations, "left", "center", and "right"). When
     * two or more occurrences of this section marker exist, the contents from all markers are concatenated, in the
     * order of appearance, and placed into the left section.
     * &P - code for "current page #"
     * &N - code for "total pages"
     * &font size - code for "text font size", where font size is a font size in points.
     * &K - code for "text font color"
     * RGB Color is specified as RRGGBB
     * Theme Color is specifed as TTSNN where TT is the theme color Id, S is either "+" or "-" of the tint/shade
     * value, NN is the tint/shade value.
     * &S - code for "text strikethrough" on / off
     * &X - code for "text super script" on / off
     * &Y - code for "text subscript" on / off
     * &C - code for "center section". When two or more occurrences of this section marker exist, the contents
     * from all markers are concatenated, in the order of appearance, and placed into the center section.
     *
     * &D - code for "date"
     * &T - code for "time"
     * &G - code for "picture as background"
     * &U - code for "text single underline"
     * &E - code for "double underline"
     * &R - code for "right section". When two or more occurrences of this section marker exist, the contents
     * from all markers are concatenated, in the order of appearance, and placed into the right section.
     * &Z - code for "this workbook's file path"
     * &F - code for "this workbook's file name"
     * &A - code for "sheet tab name"
     * &+ - code for add to page #.
     * &- - code for subtract from page #.
     * &"font name,font type" - code for "text font name" and "text font type", where font name and font type
     * are strings specifying the name and type of the font, separated by a comma. When a hyphen appears in font
     * name, it means "none specified". Both of font name and font type can be localized values.
     * &"-,Bold" - code for "bold font style"
     * &B - also means "bold font style".
     * &"-,Regular" - code for "regular font style"
     * &"-,Italic" - code for "italic font style"
     * &I - also means "italic font style"
     * &"-,Bold Italic" code for "bold italic font style"
     * &O - code for "outline style"
     * &H - code for "shadow style"
     * </code>
     */
    class HeaderFooter
    {
        // Header/footer image location
        const IMAGE_HEADER_LEFT = 'LH';
        const IMAGE_HEADER_CENTER = 'CH';
        const IMAGE_HEADER_RIGHT = 'RH';
        const IMAGE_FOOTER_LEFT = 'LF';
        const IMAGE_FOOTER_CENTER = 'CF';
        const IMAGE_FOOTER_RIGHT = 'RF';
        /**
         * OddHeader.
         *
         * @var string
         */
        private $oddHeader = '';
        /**
         * OddFooter.
         *
         * @var string
         */
        private $oddFooter = '';
        /**
         * EvenHeader.
         *
         * @var string
         */
        private $evenHeader = '';
        /**
         * EvenFooter.
         *
         * @var string
         */
        private $evenFooter = '';
        /**
         * FirstHeader.
         *
         * @var string
         */
        private $firstHeader = '';
        /**
         * FirstFooter.
         *
         * @var string
         */
        private $firstFooter = '';
        /**
         * Different header for Odd/Even, defaults to false.
         *
         * @var bool
         */
        private $differentOddEven = false;
        /**
         * Different header for first page, defaults to false.
         *
         * @var bool
         */
        private $differentFirst = false;
        /**
         * Scale with document, defaults to true.
         *
         * @var bool
         */
        private $scaleWithDocument = true;
        /**
         * Align with margins, defaults to true.
         *
         * @var bool
         */
        private $alignWithMargins = true;
        /**
         * Header/footer images.
         *
         * @var HeaderFooterDrawing[]
         */
        private $headerFooterImages = [];
        /**
         * Create a new HeaderFooter.
         */
        public function __construct()
        {
        }
        /**
         * Get OddHeader.
         *
         * @return string
         */
        public function getOddHeader()
        {
        }
        /**
         * Set OddHeader.
         *
         * @param string $pValue
         *
         * @return $this
         */
        public function setOddHeader($pValue)
        {
        }
        /**
         * Get OddFooter.
         *
         * @return string
         */
        public function getOddFooter()
        {
        }
        /**
         * Set OddFooter.
         *
         * @param string $pValue
         *
         * @return $this
         */
        public function setOddFooter($pValue)
        {
        }
        /**
         * Get EvenHeader.
         *
         * @return string
         */
        public function getEvenHeader()
        {
        }
        /**
         * Set EvenHeader.
         *
         * @param string $pValue
         *
         * @return $this
         */
        public function setEvenHeader($pValue)
        {
        }
        /**
         * Get EvenFooter.
         *
         * @return string
         */
        public function getEvenFooter()
        {
        }
        /**
         * Set EvenFooter.
         *
         * @param string $pValue
         *
         * @return $this
         */
        public function setEvenFooter($pValue)
        {
        }
        /**
         * Get FirstHeader.
         *
         * @return string
         */
        public function getFirstHeader()
        {
        }
        /**
         * Set FirstHeader.
         *
         * @param string $pValue
         *
         * @return $this
         */
        public function setFirstHeader($pValue)
        {
        }
        /**
         * Get FirstFooter.
         *
         * @return string
         */
        public function getFirstFooter()
        {
        }
        /**
         * Set FirstFooter.
         *
         * @param string $pValue
         *
         * @return $this
         */
        public function setFirstFooter($pValue)
        {
        }
        /**
         * Get DifferentOddEven.
         *
         * @return bool
         */
        public function getDifferentOddEven()
        {
        }
        /**
         * Set DifferentOddEven.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setDifferentOddEven($pValue)
        {
        }
        /**
         * Get DifferentFirst.
         *
         * @return bool
         */
        public function getDifferentFirst()
        {
        }
        /**
         * Set DifferentFirst.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setDifferentFirst($pValue)
        {
        }
        /**
         * Get ScaleWithDocument.
         *
         * @return bool
         */
        public function getScaleWithDocument()
        {
        }
        /**
         * Set ScaleWithDocument.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setScaleWithDocument($pValue)
        {
        }
        /**
         * Get AlignWithMargins.
         *
         * @return bool
         */
        public function getAlignWithMargins()
        {
        }
        /**
         * Set AlignWithMargins.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setAlignWithMargins($pValue)
        {
        }
        /**
         * Add header/footer image.
         *
         * @param string $location
         *
         * @return $this
         */
        public function addImage(\PhpOffice\PhpSpreadsheet\Worksheet\HeaderFooterDrawing $image, $location = self::IMAGE_HEADER_LEFT)
        {
        }
        /**
         * Remove header/footer image.
         *
         * @param string $location
         *
         * @return $this
         */
        public function removeImage($location = self::IMAGE_HEADER_LEFT)
        {
        }
        /**
         * Set header/footer images.
         *
         * @param HeaderFooterDrawing[] $images
         *
         * @return $this
         */
        public function setImages(array $images)
        {
        }
        /**
         * Get header/footer images.
         *
         * @return HeaderFooterDrawing[]
         */
        public function getImages()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    class HeaderFooterDrawing extends \PhpOffice\PhpSpreadsheet\Worksheet\Drawing
    {
        /**
         * Get hash code.
         *
         * @return string Hash code
         */
        public function getHashCode()
        {
        }
    }
    class RowIterator implements \Iterator
    {
        /**
         * Worksheet to iterate.
         *
         * @var Worksheet
         */
        private $subject;
        /**
         * Current iterator position.
         *
         * @var int
         */
        private $position = 1;
        /**
         * Start position.
         *
         * @var int
         */
        private $startRow = 1;
        /**
         * End position.
         *
         * @var int
         */
        private $endRow = 1;
        /**
         * Create a new row iterator.
         *
         * @param Worksheet $subject The worksheet to iterate over
         * @param int $startRow The row number at which to start iterating
         * @param int $endRow Optionally, the row number at which to stop iterating
         */
        public function __construct(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $subject, $startRow = 1, $endRow = null)
        {
        }
        /**
         * Destructor.
         */
        public function __destruct()
        {
        }
        /**
         * (Re)Set the start row and the current row pointer.
         *
         * @param int $startRow The row number at which to start iterating
         *
         * @return $this
         */
        public function resetStart($startRow = 1)
        {
        }
        /**
         * (Re)Set the end row.
         *
         * @param int $endRow The row number at which to stop iterating
         *
         * @return $this
         */
        public function resetEnd($endRow = null)
        {
        }
        /**
         * Set the row pointer to the selected row.
         *
         * @param int $row The row number to set the current pointer at
         *
         * @return $this
         */
        public function seek($row = 1)
        {
        }
        /**
         * Rewind the iterator to the starting row.
         */
        public function rewind() : void
        {
        }
        /**
         * Return the current row in this worksheet.
         *
         * @return Row
         */
        public function current()
        {
        }
        /**
         * Return the current iterator key.
         *
         * @return int
         */
        public function key()
        {
        }
        /**
         * Set the iterator to its next value.
         */
        public function next() : void
        {
        }
        /**
         * Set the iterator to its previous value.
         */
        public function prev() : void
        {
        }
        /**
         * Indicate if more rows exist in the worksheet range of rows that we're iterating.
         *
         * @return bool
         */
        public function valid()
        {
        }
    }
    class RowDimension extends \PhpOffice\PhpSpreadsheet\Worksheet\Dimension
    {
        /**
         * Row index.
         *
         * @var int
         */
        private $rowIndex;
        /**
         * Row height (in pt).
         *
         * When this is set to a negative value, the row height should be ignored by IWriter
         *
         * @var float
         */
        private $height = -1;
        /**
         * ZeroHeight for Row?
         *
         * @var bool
         */
        private $zeroHeight = false;
        /**
         * Create a new RowDimension.
         *
         * @param int $pIndex Numeric row index
         */
        public function __construct($pIndex = 0)
        {
        }
        /**
         * Get Row Index.
         *
         * @return int
         */
        public function getRowIndex()
        {
        }
        /**
         * Set Row Index.
         *
         * @param int $pValue
         *
         * @return $this
         */
        public function setRowIndex($pValue)
        {
        }
        /**
         * Get Row Height.
         *
         * @return float
         */
        public function getRowHeight()
        {
        }
        /**
         * Set Row Height.
         *
         * @param float $pValue
         *
         * @return $this
         */
        public function setRowHeight($pValue)
        {
        }
        /**
         * Get ZeroHeight.
         *
         * @return bool
         */
        public function getZeroHeight()
        {
        }
        /**
         * Set ZeroHeight.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setZeroHeight($pValue)
        {
        }
    }
    class SheetView
    {
        // Sheet View types
        const SHEETVIEW_NORMAL = 'normal';
        const SHEETVIEW_PAGE_LAYOUT = 'pageLayout';
        const SHEETVIEW_PAGE_BREAK_PREVIEW = 'pageBreakPreview';
        private static $sheetViewTypes = [self::SHEETVIEW_NORMAL, self::SHEETVIEW_PAGE_LAYOUT, self::SHEETVIEW_PAGE_BREAK_PREVIEW];
        /**
         * ZoomScale.
         *
         * Valid values range from 10 to 400.
         *
         * @var int
         */
        private $zoomScale = 100;
        /**
         * ZoomScaleNormal.
         *
         * Valid values range from 10 to 400.
         *
         * @var int
         */
        private $zoomScaleNormal = 100;
        /**
         * ShowZeros.
         *
         * If true, "null" values from a calculation will be shown as "0". This is the default Excel behaviour and can be changed
         * with the advanced worksheet option "Show a zero in cells that have zero value"
         *
         * @var bool
         */
        private $showZeros = true;
        /**
         * View.
         *
         * Valid values range from 10 to 400.
         *
         * @var string
         */
        private $sheetviewType = self::SHEETVIEW_NORMAL;
        /**
         * Create a new SheetView.
         */
        public function __construct()
        {
        }
        /**
         * Get ZoomScale.
         *
         * @return int
         */
        public function getZoomScale()
        {
        }
        /**
         * Set ZoomScale.
         * Valid values range from 10 to 400.
         *
         * @param int $pValue
         *
         * @return $this
         */
        public function setZoomScale($pValue)
        {
        }
        /**
         * Get ZoomScaleNormal.
         *
         * @return int
         */
        public function getZoomScaleNormal()
        {
        }
        /**
         * Set ZoomScale.
         * Valid values range from 10 to 400.
         *
         * @param int $pValue
         *
         * @return $this
         */
        public function setZoomScaleNormal($pValue)
        {
        }
        /**
         * Set ShowZeroes setting.
         *
         * @param bool $pValue
         */
        public function setShowZeros($pValue) : void
        {
        }
        /**
         * @return bool
         */
        public function getShowZeros()
        {
        }
        /**
         * Get View.
         *
         * @return string
         */
        public function getView()
        {
        }
        /**
         * Set View.
         *
         * Valid values are
         *        'normal'            self::SHEETVIEW_NORMAL
         *        'pageLayout'        self::SHEETVIEW_PAGE_LAYOUT
         *        'pageBreakPreview'  self::SHEETVIEW_PAGE_BREAK_PREVIEW
         *
         * @param string $pValue
         *
         * @return $this
         */
        public function setView($pValue)
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    /**
     * <code>
     * Paper size taken from Office Open XML Part 4 - Markup Language Reference, page 1988:.
     *
     * 1 = Letter paper (8.5 in. by 11 in.)
     * 2 = Letter small paper (8.5 in. by 11 in.)
     * 3 = Tabloid paper (11 in. by 17 in.)
     * 4 = Ledger paper (17 in. by 11 in.)
     * 5 = Legal paper (8.5 in. by 14 in.)
     * 6 = Statement paper (5.5 in. by 8.5 in.)
     * 7 = Executive paper (7.25 in. by 10.5 in.)
     * 8 = A3 paper (297 mm by 420 mm)
     * 9 = A4 paper (210 mm by 297 mm)
     * 10 = A4 small paper (210 mm by 297 mm)
     * 11 = A5 paper (148 mm by 210 mm)
     * 12 = B4 paper (250 mm by 353 mm)
     * 13 = B5 paper (176 mm by 250 mm)
     * 14 = Folio paper (8.5 in. by 13 in.)
     * 15 = Quarto paper (215 mm by 275 mm)
     * 16 = Standard paper (10 in. by 14 in.)
     * 17 = Standard paper (11 in. by 17 in.)
     * 18 = Note paper (8.5 in. by 11 in.)
     * 19 = #9 envelope (3.875 in. by 8.875 in.)
     * 20 = #10 envelope (4.125 in. by 9.5 in.)
     * 21 = #11 envelope (4.5 in. by 10.375 in.)
     * 22 = #12 envelope (4.75 in. by 11 in.)
     * 23 = #14 envelope (5 in. by 11.5 in.)
     * 24 = C paper (17 in. by 22 in.)
     * 25 = D paper (22 in. by 34 in.)
     * 26 = E paper (34 in. by 44 in.)
     * 27 = DL envelope (110 mm by 220 mm)
     * 28 = C5 envelope (162 mm by 229 mm)
     * 29 = C3 envelope (324 mm by 458 mm)
     * 30 = C4 envelope (229 mm by 324 mm)
     * 31 = C6 envelope (114 mm by 162 mm)
     * 32 = C65 envelope (114 mm by 229 mm)
     * 33 = B4 envelope (250 mm by 353 mm)
     * 34 = B5 envelope (176 mm by 250 mm)
     * 35 = B6 envelope (176 mm by 125 mm)
     * 36 = Italy envelope (110 mm by 230 mm)
     * 37 = Monarch envelope (3.875 in. by 7.5 in.).
     * 38 = 6 3/4 envelope (3.625 in. by 6.5 in.)
     * 39 = US standard fanfold (14.875 in. by 11 in.)
     * 40 = German standard fanfold (8.5 in. by 12 in.)
     * 41 = German legal fanfold (8.5 in. by 13 in.)
     * 42 = ISO B4 (250 mm by 353 mm)
     * 43 = Japanese double postcard (200 mm by 148 mm)
     * 44 = Standard paper (9 in. by 11 in.)
     * 45 = Standard paper (10 in. by 11 in.)
     * 46 = Standard paper (15 in. by 11 in.)
     * 47 = Invite envelope (220 mm by 220 mm)
     * 50 = Letter extra paper (9.275 in. by 12 in.)
     * 51 = Legal extra paper (9.275 in. by 15 in.)
     * 52 = Tabloid extra paper (11.69 in. by 18 in.)
     * 53 = A4 extra paper (236 mm by 322 mm)
     * 54 = Letter transverse paper (8.275 in. by 11 in.)
     * 55 = A4 transverse paper (210 mm by 297 mm)
     * 56 = Letter extra transverse paper (9.275 in. by 12 in.)
     * 57 = SuperA/SuperA/A4 paper (227 mm by 356 mm)
     * 58 = SuperB/SuperB/A3 paper (305 mm by 487 mm)
     * 59 = Letter plus paper (8.5 in. by 12.69 in.)
     * 60 = A4 plus paper (210 mm by 330 mm)
     * 61 = A5 transverse paper (148 mm by 210 mm)
     * 62 = JIS B5 transverse paper (182 mm by 257 mm)
     * 63 = A3 extra paper (322 mm by 445 mm)
     * 64 = A5 extra paper (174 mm by 235 mm)
     * 65 = ISO B5 extra paper (201 mm by 276 mm)
     * 66 = A2 paper (420 mm by 594 mm)
     * 67 = A3 transverse paper (297 mm by 420 mm)
     * 68 = A3 extra transverse paper (322 mm by 445 mm)
     * </code>
     */
    class PageSetup
    {
        // Paper size
        const PAPERSIZE_LETTER = 1;
        const PAPERSIZE_LETTER_SMALL = 2;
        const PAPERSIZE_TABLOID = 3;
        const PAPERSIZE_LEDGER = 4;
        const PAPERSIZE_LEGAL = 5;
        const PAPERSIZE_STATEMENT = 6;
        const PAPERSIZE_EXECUTIVE = 7;
        const PAPERSIZE_A3 = 8;
        const PAPERSIZE_A4 = 9;
        const PAPERSIZE_A4_SMALL = 10;
        const PAPERSIZE_A5 = 11;
        const PAPERSIZE_B4 = 12;
        const PAPERSIZE_B5 = 13;
        const PAPERSIZE_FOLIO = 14;
        const PAPERSIZE_QUARTO = 15;
        const PAPERSIZE_STANDARD_1 = 16;
        const PAPERSIZE_STANDARD_2 = 17;
        const PAPERSIZE_NOTE = 18;
        const PAPERSIZE_NO9_ENVELOPE = 19;
        const PAPERSIZE_NO10_ENVELOPE = 20;
        const PAPERSIZE_NO11_ENVELOPE = 21;
        const PAPERSIZE_NO12_ENVELOPE = 22;
        const PAPERSIZE_NO14_ENVELOPE = 23;
        const PAPERSIZE_C = 24;
        const PAPERSIZE_D = 25;
        const PAPERSIZE_E = 26;
        const PAPERSIZE_DL_ENVELOPE = 27;
        const PAPERSIZE_C5_ENVELOPE = 28;
        const PAPERSIZE_C3_ENVELOPE = 29;
        const PAPERSIZE_C4_ENVELOPE = 30;
        const PAPERSIZE_C6_ENVELOPE = 31;
        const PAPERSIZE_C65_ENVELOPE = 32;
        const PAPERSIZE_B4_ENVELOPE = 33;
        const PAPERSIZE_B5_ENVELOPE = 34;
        const PAPERSIZE_B6_ENVELOPE = 35;
        const PAPERSIZE_ITALY_ENVELOPE = 36;
        const PAPERSIZE_MONARCH_ENVELOPE = 37;
        const PAPERSIZE_6_3_4_ENVELOPE = 38;
        const PAPERSIZE_US_STANDARD_FANFOLD = 39;
        const PAPERSIZE_GERMAN_STANDARD_FANFOLD = 40;
        const PAPERSIZE_GERMAN_LEGAL_FANFOLD = 41;
        const PAPERSIZE_ISO_B4 = 42;
        const PAPERSIZE_JAPANESE_DOUBLE_POSTCARD = 43;
        const PAPERSIZE_STANDARD_PAPER_1 = 44;
        const PAPERSIZE_STANDARD_PAPER_2 = 45;
        const PAPERSIZE_STANDARD_PAPER_3 = 46;
        const PAPERSIZE_INVITE_ENVELOPE = 47;
        const PAPERSIZE_LETTER_EXTRA_PAPER = 48;
        const PAPERSIZE_LEGAL_EXTRA_PAPER = 49;
        const PAPERSIZE_TABLOID_EXTRA_PAPER = 50;
        const PAPERSIZE_A4_EXTRA_PAPER = 51;
        const PAPERSIZE_LETTER_TRANSVERSE_PAPER = 52;
        const PAPERSIZE_A4_TRANSVERSE_PAPER = 53;
        const PAPERSIZE_LETTER_EXTRA_TRANSVERSE_PAPER = 54;
        const PAPERSIZE_SUPERA_SUPERA_A4_PAPER = 55;
        const PAPERSIZE_SUPERB_SUPERB_A3_PAPER = 56;
        const PAPERSIZE_LETTER_PLUS_PAPER = 57;
        const PAPERSIZE_A4_PLUS_PAPER = 58;
        const PAPERSIZE_A5_TRANSVERSE_PAPER = 59;
        const PAPERSIZE_JIS_B5_TRANSVERSE_PAPER = 60;
        const PAPERSIZE_A3_EXTRA_PAPER = 61;
        const PAPERSIZE_A5_EXTRA_PAPER = 62;
        const PAPERSIZE_ISO_B5_EXTRA_PAPER = 63;
        const PAPERSIZE_A2_PAPER = 64;
        const PAPERSIZE_A3_TRANSVERSE_PAPER = 65;
        const PAPERSIZE_A3_EXTRA_TRANSVERSE_PAPER = 66;
        // Page orientation
        const ORIENTATION_DEFAULT = 'default';
        const ORIENTATION_LANDSCAPE = 'landscape';
        const ORIENTATION_PORTRAIT = 'portrait';
        // Print Range Set Method
        const SETPRINTRANGE_OVERWRITE = 'O';
        const SETPRINTRANGE_INSERT = 'I';
        /**
         * Paper size.
         *
         * @var int
         */
        private $paperSize = self::PAPERSIZE_LETTER;
        /**
         * Orientation.
         *
         * @var string
         */
        private $orientation = self::ORIENTATION_DEFAULT;
        /**
         * Scale (Print Scale).
         *
         * Print scaling. Valid values range from 10 to 400
         * This setting is overridden when fitToWidth and/or fitToHeight are in use
         *
         * @var null|int
         */
        private $scale = 100;
        /**
         * Fit To Page
         * Whether scale or fitToWith / fitToHeight applies.
         *
         * @var bool
         */
        private $fitToPage = false;
        /**
         * Fit To Height
         * Number of vertical pages to fit on.
         *
         * @var null|int
         */
        private $fitToHeight = 1;
        /**
         * Fit To Width
         * Number of horizontal pages to fit on.
         *
         * @var null|int
         */
        private $fitToWidth = 1;
        /**
         * Columns to repeat at left.
         *
         * @var array Containing start column and end column, empty array if option unset
         */
        private $columnsToRepeatAtLeft = ['', ''];
        /**
         * Rows to repeat at top.
         *
         * @var array Containing start row number and end row number, empty array if option unset
         */
        private $rowsToRepeatAtTop = [0, 0];
        /**
         * Center page horizontally.
         *
         * @var bool
         */
        private $horizontalCentered = false;
        /**
         * Center page vertically.
         *
         * @var bool
         */
        private $verticalCentered = false;
        /**
         * Print area.
         *
         * @var string
         */
        private $printArea;
        /**
         * First page number.
         *
         * @var int
         */
        private $firstPageNumber;
        /**
         * Create a new PageSetup.
         */
        public function __construct()
        {
        }
        /**
         * Get Paper Size.
         *
         * @return int
         */
        public function getPaperSize()
        {
        }
        /**
         * Set Paper Size.
         *
         * @param int $pValue see self::PAPERSIZE_*
         *
         * @return $this
         */
        public function setPaperSize($pValue)
        {
        }
        /**
         * Get Orientation.
         *
         * @return string
         */
        public function getOrientation()
        {
        }
        /**
         * Set Orientation.
         *
         * @param string $pValue see self::ORIENTATION_*
         *
         * @return $this
         */
        public function setOrientation($pValue)
        {
        }
        /**
         * Get Scale.
         *
         * @return null|int
         */
        public function getScale()
        {
        }
        /**
         * Set Scale.
         * Print scaling. Valid values range from 10 to 400
         * This setting is overridden when fitToWidth and/or fitToHeight are in use.
         *
         * @param null|int $pValue
         * @param bool $pUpdate Update fitToPage so scaling applies rather than fitToHeight / fitToWidth
         *
         * @return $this
         */
        public function setScale($pValue, $pUpdate = true)
        {
        }
        /**
         * Get Fit To Page.
         *
         * @return bool
         */
        public function getFitToPage()
        {
        }
        /**
         * Set Fit To Page.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setFitToPage($pValue)
        {
        }
        /**
         * Get Fit To Height.
         *
         * @return null|int
         */
        public function getFitToHeight()
        {
        }
        /**
         * Set Fit To Height.
         *
         * @param null|int $pValue
         * @param bool $pUpdate Update fitToPage so it applies rather than scaling
         *
         * @return $this
         */
        public function setFitToHeight($pValue, $pUpdate = true)
        {
        }
        /**
         * Get Fit To Width.
         *
         * @return null|int
         */
        public function getFitToWidth()
        {
        }
        /**
         * Set Fit To Width.
         *
         * @param null|int $pValue
         * @param bool $pUpdate Update fitToPage so it applies rather than scaling
         *
         * @return $this
         */
        public function setFitToWidth($pValue, $pUpdate = true)
        {
        }
        /**
         * Is Columns to repeat at left set?
         *
         * @return bool
         */
        public function isColumnsToRepeatAtLeftSet()
        {
        }
        /**
         * Get Columns to repeat at left.
         *
         * @return array Containing start column and end column, empty array if option unset
         */
        public function getColumnsToRepeatAtLeft()
        {
        }
        /**
         * Set Columns to repeat at left.
         *
         * @param array $pValue Containing start column and end column, empty array if option unset
         *
         * @return $this
         */
        public function setColumnsToRepeatAtLeft(array $pValue)
        {
        }
        /**
         * Set Columns to repeat at left by start and end.
         *
         * @param string $pStart eg: 'A'
         * @param string $pEnd eg: 'B'
         *
         * @return $this
         */
        public function setColumnsToRepeatAtLeftByStartAndEnd($pStart, $pEnd)
        {
        }
        /**
         * Is Rows to repeat at top set?
         *
         * @return bool
         */
        public function isRowsToRepeatAtTopSet()
        {
        }
        /**
         * Get Rows to repeat at top.
         *
         * @return array Containing start column and end column, empty array if option unset
         */
        public function getRowsToRepeatAtTop()
        {
        }
        /**
         * Set Rows to repeat at top.
         *
         * @param array $pValue Containing start column and end column, empty array if option unset
         *
         * @return $this
         */
        public function setRowsToRepeatAtTop(array $pValue)
        {
        }
        /**
         * Set Rows to repeat at top by start and end.
         *
         * @param int $pStart eg: 1
         * @param int $pEnd eg: 1
         *
         * @return $this
         */
        public function setRowsToRepeatAtTopByStartAndEnd($pStart, $pEnd)
        {
        }
        /**
         * Get center page horizontally.
         *
         * @return bool
         */
        public function getHorizontalCentered()
        {
        }
        /**
         * Set center page horizontally.
         *
         * @param bool $value
         *
         * @return $this
         */
        public function setHorizontalCentered($value)
        {
        }
        /**
         * Get center page vertically.
         *
         * @return bool
         */
        public function getVerticalCentered()
        {
        }
        /**
         * Set center page vertically.
         *
         * @param bool $value
         *
         * @return $this
         */
        public function setVerticalCentered($value)
        {
        }
        /**
         * Get print area.
         *
         * @param int $index Identifier for a specific print area range if several ranges have been set
         *                            Default behaviour, or a index value of 0, will return all ranges as a comma-separated string
         *                            Otherwise, the specific range identified by the value of $index will be returned
         *                            Print areas are numbered from 1
         *
         * @return string
         */
        public function getPrintArea($index = 0)
        {
        }
        /**
         * Is print area set?
         *
         * @param int $index Identifier for a specific print area range if several ranges have been set
         *                            Default behaviour, or an index value of 0, will identify whether any print range is set
         *                            Otherwise, existence of the range identified by the value of $index will be returned
         *                            Print areas are numbered from 1
         *
         * @return bool
         */
        public function isPrintAreaSet($index = 0)
        {
        }
        /**
         * Clear a print area.
         *
         * @param int $index Identifier for a specific print area range if several ranges have been set
         *                            Default behaviour, or an index value of 0, will clear all print ranges that are set
         *                            Otherwise, the range identified by the value of $index will be removed from the series
         *                            Print areas are numbered from 1
         *
         * @return $this
         */
        public function clearPrintArea($index = 0)
        {
        }
        /**
         * Set print area. e.g. 'A1:D10' or 'A1:D10,G5:M20'.
         *
         * @param string $value
         * @param int $index Identifier for a specific print area range allowing several ranges to be set
         *                            When the method is "O"verwrite, then a positive integer index will overwrite that indexed
         *                                entry in the print areas list; a negative index value will identify which entry to
         *                                overwrite working bacward through the print area to the list, with the last entry as -1.
         *                                Specifying an index value of 0, will overwrite <b>all</b> existing print ranges.
         *                            When the method is "I"nsert, then a positive index will insert after that indexed entry in
         *                                the print areas list, while a negative index will insert before the indexed entry.
         *                                Specifying an index value of 0, will always append the new print range at the end of the
         *                                list.
         *                            Print areas are numbered from 1
         * @param string $method Determines the method used when setting multiple print areas
         *                            Default behaviour, or the "O" method, overwrites existing print area
         *                            The "I" method, inserts the new print area before any specified index, or at the end of the list
         *
         * @return $this
         */
        public function setPrintArea($value, $index = 0, $method = self::SETPRINTRANGE_OVERWRITE)
        {
        }
        /**
         * Add a new print area (e.g. 'A1:D10' or 'A1:D10,G5:M20') to the list of print areas.
         *
         * @param string $value
         * @param int $index Identifier for a specific print area range allowing several ranges to be set
         *                            A positive index will insert after that indexed entry in the print areas list, while a
         *                                negative index will insert before the indexed entry.
         *                                Specifying an index value of 0, will always append the new print range at the end of the
         *                                list.
         *                            Print areas are numbered from 1
         *
         * @return $this
         */
        public function addPrintArea($value, $index = -1)
        {
        }
        /**
         * Set print area.
         *
         * @param int $column1 Column 1
         * @param int $row1 Row 1
         * @param int $column2 Column 2
         * @param int $row2 Row 2
         * @param int $index Identifier for a specific print area range allowing several ranges to be set
         *                                When the method is "O"verwrite, then a positive integer index will overwrite that indexed
         *                                    entry in the print areas list; a negative index value will identify which entry to
         *                                    overwrite working backward through the print area to the list, with the last entry as -1.
         *                                    Specifying an index value of 0, will overwrite <b>all</b> existing print ranges.
         *                                When the method is "I"nsert, then a positive index will insert after that indexed entry in
         *                                    the print areas list, while a negative index will insert before the indexed entry.
         *                                    Specifying an index value of 0, will always append the new print range at the end of the
         *                                    list.
         *                                Print areas are numbered from 1
         * @param string $method Determines the method used when setting multiple print areas
         *                                Default behaviour, or the "O" method, overwrites existing print area
         *                                The "I" method, inserts the new print area before any specified index, or at the end of the list
         *
         * @return $this
         */
        public function setPrintAreaByColumnAndRow($column1, $row1, $column2, $row2, $index = 0, $method = self::SETPRINTRANGE_OVERWRITE)
        {
        }
        /**
         * Add a new print area to the list of print areas.
         *
         * @param int $column1 Start Column for the print area
         * @param int $row1 Start Row for the print area
         * @param int $column2 End Column for the print area
         * @param int $row2 End Row for the print area
         * @param int $index Identifier for a specific print area range allowing several ranges to be set
         *                                A positive index will insert after that indexed entry in the print areas list, while a
         *                                    negative index will insert before the indexed entry.
         *                                    Specifying an index value of 0, will always append the new print range at the end of the
         *                                    list.
         *                                Print areas are numbered from 1
         *
         * @return $this
         */
        public function addPrintAreaByColumnAndRow($column1, $row1, $column2, $row2, $index = -1)
        {
        }
        /**
         * Get first page number.
         *
         * @return int
         */
        public function getFirstPageNumber()
        {
        }
        /**
         * Set first page number.
         *
         * @param int $value
         *
         * @return $this
         */
        public function setFirstPageNumber($value)
        {
        }
        /**
         * Reset first page number.
         *
         * @return $this
         */
        public function resetFirstPageNumber()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    class MemoryDrawing extends \PhpOffice\PhpSpreadsheet\Worksheet\BaseDrawing
    {
        // Rendering functions
        const RENDERING_DEFAULT = 'imagepng';
        const RENDERING_PNG = 'imagepng';
        const RENDERING_GIF = 'imagegif';
        const RENDERING_JPEG = 'imagejpeg';
        // MIME types
        const MIMETYPE_DEFAULT = 'image/png';
        const MIMETYPE_PNG = 'image/png';
        const MIMETYPE_GIF = 'image/gif';
        const MIMETYPE_JPEG = 'image/jpeg';
        /**
         * Image resource.
         *
         * @var resource
         */
        private $imageResource;
        /**
         * Rendering function.
         *
         * @var string
         */
        private $renderingFunction;
        /**
         * Mime type.
         *
         * @var string
         */
        private $mimeType;
        /**
         * Unique name.
         *
         * @var string
         */
        private $uniqueName;
        /**
         * Create a new MemoryDrawing.
         */
        public function __construct()
        {
        }
        /**
         * Get image resource.
         *
         * @return resource
         */
        public function getImageResource()
        {
        }
        /**
         * Set image resource.
         *
         * @param resource $value
         *
         * @return $this
         */
        public function setImageResource($value)
        {
        }
        /**
         * Get rendering function.
         *
         * @return string
         */
        public function getRenderingFunction()
        {
        }
        /**
         * Set rendering function.
         *
         * @param string $value see self::RENDERING_*
         *
         * @return $this
         */
        public function setRenderingFunction($value)
        {
        }
        /**
         * Get mime type.
         *
         * @return string
         */
        public function getMimeType()
        {
        }
        /**
         * Set mime type.
         *
         * @param string $value see self::MIMETYPE_*
         *
         * @return $this
         */
        public function setMimeType($value)
        {
        }
        /**
         * Get indexed filename (using image index).
         *
         * @return string
         */
        public function getIndexedFilename()
        {
        }
        /**
         * Get hash code.
         *
         * @return string Hash code
         */
        public function getHashCode()
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet {
    class HashTable
    {
        /**
         * HashTable elements.
         *
         * @var IComparable[]
         */
        protected $items = [];
        /**
         * HashTable key map.
         *
         * @var string[]
         */
        protected $keyMap = [];
        /**
         * Create a new \PhpOffice\PhpSpreadsheet\HashTable.
         *
         * @param IComparable[] $pSource Optional source array to create HashTable from
         */
        public function __construct($pSource = null)
        {
        }
        /**
         * Add HashTable items from source.
         *
         * @param IComparable[] $pSource Source array to create HashTable from
         */
        public function addFromSource(?array $pSource = null) : void
        {
        }
        /**
         * Add HashTable item.
         *
         * @param IComparable $pSource Item to add
         */
        public function add(\PhpOffice\PhpSpreadsheet\IComparable $pSource) : void
        {
        }
        /**
         * Remove HashTable item.
         *
         * @param IComparable $pSource Item to remove
         */
        public function remove(\PhpOffice\PhpSpreadsheet\IComparable $pSource) : void
        {
        }
        /**
         * Clear HashTable.
         */
        public function clear() : void
        {
        }
        /**
         * Count.
         *
         * @return int
         */
        public function count()
        {
        }
        /**
         * Get index for hash code.
         *
         * @param string $pHashCode
         *
         * @return int Index
         */
        public function getIndexForHashCode($pHashCode)
        {
        }
        /**
         * Get by index.
         *
         * @param int $pIndex
         *
         * @return IComparable
         */
        public function getByIndex($pIndex)
        {
        }
        /**
         * Get by hashcode.
         *
         * @param string $pHashCode
         *
         * @return IComparable
         */
        public function getByHashCode($pHashCode)
        {
        }
        /**
         * HashTable to array.
         *
         * @return IComparable[]
         */
        public function toArray()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    class ReferenceHelper
    {
        /**    Constants                */
        /**    Regular Expressions      */
        const REFHELPER_REGEXP_CELLREF = '((\\w*|\'[^!]*\')!)?(?<![:a-z\\$])(\\$?[a-z]{1,3}\\$?\\d+)(?=[^:!\\d\'])';
        const REFHELPER_REGEXP_CELLRANGE = '((\\w*|\'[^!]*\')!)?(\\$?[a-z]{1,3}\\$?\\d+):(\\$?[a-z]{1,3}\\$?\\d+)';
        const REFHELPER_REGEXP_ROWRANGE = '((\\w*|\'[^!]*\')!)?(\\$?\\d+):(\\$?\\d+)';
        const REFHELPER_REGEXP_COLRANGE = '((\\w*|\'[^!]*\')!)?(\\$?[a-z]{1,3}):(\\$?[a-z]{1,3})';
        /**
         * Instance of this class.
         *
         * @var ReferenceHelper
         */
        private static $instance;
        /**
         * Get an instance of this class.
         *
         * @return ReferenceHelper
         */
        public static function getInstance()
        {
        }
        /**
         * Create a new ReferenceHelper.
         */
        protected function __construct()
        {
        }
        /**
         * Compare two column addresses
         * Intended for use as a Callback function for sorting column addresses by column.
         *
         * @param string $a First column to test (e.g. 'AA')
         * @param string $b Second column to test (e.g. 'Z')
         *
         * @return int
         */
        public static function columnSort($a, $b)
        {
        }
        /**
         * Compare two column addresses
         * Intended for use as a Callback function for reverse sorting column addresses by column.
         *
         * @param string $a First column to test (e.g. 'AA')
         * @param string $b Second column to test (e.g. 'Z')
         *
         * @return int
         */
        public static function columnReverseSort($a, $b)
        {
        }
        /**
         * Compare two cell addresses
         * Intended for use as a Callback function for sorting cell addresses by column and row.
         *
         * @param string $a First cell to test (e.g. 'AA1')
         * @param string $b Second cell to test (e.g. 'Z1')
         *
         * @return int
         */
        public static function cellSort($a, $b)
        {
        }
        /**
         * Compare two cell addresses
         * Intended for use as a Callback function for sorting cell addresses by column and row.
         *
         * @param string $a First cell to test (e.g. 'AA1')
         * @param string $b Second cell to test (e.g. 'Z1')
         *
         * @return int
         */
        public static function cellReverseSort($a, $b)
        {
        }
        /**
         * Test whether a cell address falls within a defined range of cells.
         *
         * @param string $cellAddress Address of the cell we're testing
         * @param int $beforeRow Number of the row we're inserting/deleting before
         * @param int $pNumRows Number of rows to insert/delete (negative values indicate deletion)
         * @param int $beforeColumnIndex Index number of the column we're inserting/deleting before
         * @param int $pNumCols Number of columns to insert/delete (negative values indicate deletion)
         *
         * @return bool
         */
        private static function cellAddressInDeleteRange($cellAddress, $beforeRow, $pNumRows, $beforeColumnIndex, $pNumCols)
        {
        }
        /**
         * Update page breaks when inserting/deleting rows/columns.
         *
         * @param Worksheet $pSheet The worksheet that we're editing
         * @param string $pBefore Insert/Delete before this cell address (e.g. 'A1')
         * @param int $beforeColumnIndex Index number of the column we're inserting/deleting before
         * @param int $pNumCols Number of columns to insert/delete (negative values indicate deletion)
         * @param int $beforeRow Number of the row we're inserting/deleting before
         * @param int $pNumRows Number of rows to insert/delete (negative values indicate deletion)
         */
        protected function adjustPageBreaks(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet, $pBefore, $beforeColumnIndex, $pNumCols, $beforeRow, $pNumRows) : void
        {
        }
        /**
         * Update cell comments when inserting/deleting rows/columns.
         *
         * @param Worksheet $pSheet The worksheet that we're editing
         * @param string $pBefore Insert/Delete before this cell address (e.g. 'A1')
         * @param int $beforeColumnIndex Index number of the column we're inserting/deleting before
         * @param int $pNumCols Number of columns to insert/delete (negative values indicate deletion)
         * @param int $beforeRow Number of the row we're inserting/deleting before
         * @param int $pNumRows Number of rows to insert/delete (negative values indicate deletion)
         */
        protected function adjustComments($pSheet, $pBefore, $beforeColumnIndex, $pNumCols, $beforeRow, $pNumRows) : void
        {
        }
        /**
         * Update hyperlinks when inserting/deleting rows/columns.
         *
         * @param Worksheet $pSheet The worksheet that we're editing
         * @param string $pBefore Insert/Delete before this cell address (e.g. 'A1')
         * @param int $beforeColumnIndex Index number of the column we're inserting/deleting before
         * @param int $pNumCols Number of columns to insert/delete (negative values indicate deletion)
         * @param int $beforeRow Number of the row we're inserting/deleting before
         * @param int $pNumRows Number of rows to insert/delete (negative values indicate deletion)
         */
        protected function adjustHyperlinks($pSheet, $pBefore, $beforeColumnIndex, $pNumCols, $beforeRow, $pNumRows) : void
        {
        }
        /**
         * Update data validations when inserting/deleting rows/columns.
         *
         * @param Worksheet $pSheet The worksheet that we're editing
         * @param string $pBefore Insert/Delete before this cell address (e.g. 'A1')
         * @param int $beforeColumnIndex Index number of the column we're inserting/deleting before
         * @param int $pNumCols Number of columns to insert/delete (negative values indicate deletion)
         * @param int $beforeRow Number of the row we're inserting/deleting before
         * @param int $pNumRows Number of rows to insert/delete (negative values indicate deletion)
         */
        protected function adjustDataValidations($pSheet, $pBefore, $beforeColumnIndex, $pNumCols, $beforeRow, $pNumRows) : void
        {
        }
        /**
         * Update merged cells when inserting/deleting rows/columns.
         *
         * @param Worksheet $pSheet The worksheet that we're editing
         * @param string $pBefore Insert/Delete before this cell address (e.g. 'A1')
         * @param int $beforeColumnIndex Index number of the column we're inserting/deleting before
         * @param int $pNumCols Number of columns to insert/delete (negative values indicate deletion)
         * @param int $beforeRow Number of the row we're inserting/deleting before
         * @param int $pNumRows Number of rows to insert/delete (negative values indicate deletion)
         */
        protected function adjustMergeCells($pSheet, $pBefore, $beforeColumnIndex, $pNumCols, $beforeRow, $pNumRows) : void
        {
        }
        /**
         * Update protected cells when inserting/deleting rows/columns.
         *
         * @param Worksheet $pSheet The worksheet that we're editing
         * @param string $pBefore Insert/Delete before this cell address (e.g. 'A1')
         * @param int $beforeColumnIndex Index number of the column we're inserting/deleting before
         * @param int $pNumCols Number of columns to insert/delete (negative values indicate deletion)
         * @param int $beforeRow Number of the row we're inserting/deleting before
         * @param int $pNumRows Number of rows to insert/delete (negative values indicate deletion)
         */
        protected function adjustProtectedCells($pSheet, $pBefore, $beforeColumnIndex, $pNumCols, $beforeRow, $pNumRows) : void
        {
        }
        /**
         * Update column dimensions when inserting/deleting rows/columns.
         *
         * @param Worksheet $pSheet The worksheet that we're editing
         * @param string $pBefore Insert/Delete before this cell address (e.g. 'A1')
         * @param int $beforeColumnIndex Index number of the column we're inserting/deleting before
         * @param int $pNumCols Number of columns to insert/delete (negative values indicate deletion)
         * @param int $beforeRow Number of the row we're inserting/deleting before
         * @param int $pNumRows Number of rows to insert/delete (negative values indicate deletion)
         */
        protected function adjustColumnDimensions($pSheet, $pBefore, $beforeColumnIndex, $pNumCols, $beforeRow, $pNumRows) : void
        {
        }
        /**
         * Update row dimensions when inserting/deleting rows/columns.
         *
         * @param Worksheet $pSheet The worksheet that we're editing
         * @param string $pBefore Insert/Delete before this cell address (e.g. 'A1')
         * @param int $beforeColumnIndex Index number of the column we're inserting/deleting before
         * @param int $pNumCols Number of columns to insert/delete (negative values indicate deletion)
         * @param int $beforeRow Number of the row we're inserting/deleting before
         * @param int $pNumRows Number of rows to insert/delete (negative values indicate deletion)
         */
        protected function adjustRowDimensions($pSheet, $pBefore, $beforeColumnIndex, $pNumCols, $beforeRow, $pNumRows) : void
        {
        }
        /**
         * Insert a new column or row, updating all possible related data.
         *
         * @param string $pBefore Insert before this cell address (e.g. 'A1')
         * @param int $pNumCols Number of columns to insert/delete (negative values indicate deletion)
         * @param int $pNumRows Number of rows to insert/delete (negative values indicate deletion)
         * @param Worksheet $pSheet The worksheet that we're editing
         */
        public function insertNewBefore($pBefore, $pNumCols, $pNumRows, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet) : void
        {
        }
        /**
         * Update references within formulas.
         *
         * @param string $pFormula Formula to update
         * @param string $pBefore Insert before this one
         * @param int $pNumCols Number of columns to insert
         * @param int $pNumRows Number of rows to insert
         * @param string $sheetName Worksheet name/title
         *
         * @return string Updated formula
         */
        public function updateFormulaReferences($pFormula = '', $pBefore = 'A1', $pNumCols = 0, $pNumRows = 0, $sheetName = '')
        {
        }
        /**
         * Update cell reference.
         *
         * @param string $pCellRange Cell range
         * @param string $pBefore Insert before this one
         * @param int $pNumCols Number of columns to increment
         * @param int $pNumRows Number of rows to increment
         *
         * @return string Updated cell range
         */
        public function updateCellReference($pCellRange = 'A1', $pBefore = 'A1', $pNumCols = 0, $pNumRows = 0)
        {
        }
        /**
         * Update named formulas (i.e. containing worksheet references / named ranges).
         *
         * @param Spreadsheet $spreadsheet Object to update
         * @param string $oldName Old name (name to replace)
         * @param string $newName New name
         */
        public function updateNamedFormulas(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet, $oldName = '', $newName = '') : void
        {
        }
        /**
         * Update cell range.
         *
         * @param string $pCellRange Cell range    (e.g. 'B2:D4', 'B:C' or '2:3')
         * @param string $pBefore Insert before this one
         * @param int $pNumCols Number of columns to increment
         * @param int $pNumRows Number of rows to increment
         *
         * @return string Updated cell range
         */
        private function updateCellRange($pCellRange = 'A1:A1', $pBefore = 'A1', $pNumCols = 0, $pNumRows = 0)
        {
        }
        /**
         * Update single cell reference.
         *
         * @param string $pCellReference Single cell reference
         * @param string $pBefore Insert before this one
         * @param int $pNumCols Number of columns to increment
         * @param int $pNumRows Number of rows to increment
         *
         * @return string Updated cell reference
         */
        private function updateSingleCellReference($pCellReference = 'A1', $pBefore = 'A1', $pNumCols = 0, $pNumRows = 0)
        {
        }
        /**
         * __clone implementation. Cloning should not be allowed in a Singleton!
         */
        public final function __clone()
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Writer {
    class Exception extends \PhpOffice\PhpSpreadsheet\Exception
    {
    }
    interface IWriter
    {
        /**
         * IWriter constructor.
         */
        public function __construct(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet);
        /**
         * Write charts in workbook?
         *        If this is true, then the Writer will write definitions for any charts that exist in the PhpSpreadsheet object.
         *        If false (the default) it will ignore any charts defined in the PhpSpreadsheet object.
         *
         * @return bool
         */
        public function getIncludeCharts();
        /**
         * Set write charts in workbook
         *        Set to true, to advise the Writer to include any charts that exist in the PhpSpreadsheet object.
         *        Set to false (the default) to ignore charts.
         *
         * @param bool $pValue
         *
         * @return IWriter
         */
        public function setIncludeCharts($pValue);
        /**
         * Get Pre-Calculate Formulas flag
         *     If this is true (the default), then the writer will recalculate all formulae in a workbook when saving,
         *        so that the pre-calculated values are immediately available to MS Excel or other office spreadsheet
         *        viewer when opening the file
         *     If false, then formulae are not calculated on save. This is faster for saving in PhpSpreadsheet, but slower
         *        when opening the resulting file in MS Excel, because Excel has to recalculate the formulae itself.
         *
         * @return bool
         */
        public function getPreCalculateFormulas();
        /**
         * Set Pre-Calculate Formulas
         *        Set to true (the default) to advise the Writer to calculate all formulae on save
         *        Set to false to prevent precalculation of formulae on save.
         *
         * @param bool $pValue Pre-Calculate Formulas?
         *
         * @return IWriter
         */
        public function setPreCalculateFormulas($pValue);
        /**
         * Save PhpSpreadsheet to file.
         *
         * @param resource|string $pFilename Name of the file to save
         */
        public function save($pFilename);
        /**
         * Get use disk caching where possible?
         *
         * @return bool
         */
        public function getUseDiskCaching();
        /**
         * Set use disk caching where possible?
         *
         * @param bool $pValue
         * @param string $pDirectory Disk caching directory
         *
         * @return IWriter
         */
        public function setUseDiskCaching($pValue, $pDirectory = null);
        /**
         * Get disk caching directory.
         *
         * @return string
         */
        public function getDiskCachingDirectory();
    }
    abstract class BaseWriter implements \PhpOffice\PhpSpreadsheet\Writer\IWriter
    {
        /**
         * Write charts that are defined in the workbook?
         * Identifies whether the Writer should write definitions for any charts that exist in the PhpSpreadsheet object;.
         *
         * @var bool
         */
        protected $includeCharts = false;
        /**
         * Pre-calculate formulas
         * Forces PhpSpreadsheet to recalculate all formulae in a workbook when saving, so that the pre-calculated values are
         * immediately available to MS Excel or other office spreadsheet viewer when opening the file.
         *
         * @var bool
         */
        protected $preCalculateFormulas = true;
        /**
         * Use disk caching where possible?
         *
         * @var bool
         */
        private $useDiskCaching = false;
        /**
         * Disk caching directory.
         *
         * @var string
         */
        private $diskCachingDirectory = './';
        /**
         * @var resource
         */
        protected $fileHandle;
        /**
         * @var bool
         */
        private $shouldCloseFile;
        public function getIncludeCharts()
        {
        }
        public function setIncludeCharts($pValue)
        {
        }
        public function getPreCalculateFormulas()
        {
        }
        public function setPreCalculateFormulas($pValue)
        {
        }
        public function getUseDiskCaching()
        {
        }
        public function setUseDiskCaching($pValue, $pDirectory = null)
        {
        }
        public function getDiskCachingDirectory()
        {
        }
        /**
         * Open file handle.
         *
         * @param resource|string $filename
         */
        public function openFileHandle($filename) : void
        {
        }
        /**
         * Close file handle only if we opened it ourselves.
         */
        protected function maybeCloseFileHandle() : void
        {
        }
    }
    class Html extends \PhpOffice\PhpSpreadsheet\Writer\BaseWriter
    {
        /**
         * Spreadsheet object.
         *
         * @var Spreadsheet
         */
        protected $spreadsheet;
        /**
         * Sheet index to write.
         *
         * @var int
         */
        private $sheetIndex = 0;
        /**
         * Images root.
         *
         * @var string
         */
        private $imagesRoot = '';
        /**
         * embed images, or link to images.
         *
         * @var bool
         */
        private $embedImages = false;
        /**
         * Use inline CSS?
         *
         * @var bool
         */
        private $useInlineCss = false;
        /**
         * Use embedded CSS?
         *
         * @var bool
         */
        private $useEmbeddedCSS = true;
        /**
         * Array of CSS styles.
         *
         * @var array
         */
        private $cssStyles;
        /**
         * Array of column widths in points.
         *
         * @var array
         */
        private $columnWidths;
        /**
         * Default font.
         *
         * @var Font
         */
        private $defaultFont;
        /**
         * Flag whether spans have been calculated.
         *
         * @var bool
         */
        private $spansAreCalculated = false;
        /**
         * Excel cells that should not be written as HTML cells.
         *
         * @var array
         */
        private $isSpannedCell = [];
        /**
         * Excel cells that are upper-left corner in a cell merge.
         *
         * @var array
         */
        private $isBaseCell = [];
        /**
         * Excel rows that should not be written as HTML rows.
         *
         * @var array
         */
        private $isSpannedRow = [];
        /**
         * Is the current writer creating PDF?
         *
         * @var bool
         */
        protected $isPdf = false;
        /**
         * Generate the Navigation block.
         *
         * @var bool
         */
        private $generateSheetNavigationBlock = true;
        /**
         * Create a new HTML.
         */
        public function __construct(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
        /**
         * Save Spreadsheet to file.
         *
         * @param resource|string $pFilename
         */
        public function save($pFilename) : void
        {
        }
        /**
         * Save Spreadsheet as html to variable.
         *
         * @return string
         */
        public function generateHtmlAll()
        {
        }
        const VALIGN_ARR = [\PhpOffice\PhpSpreadsheet\Style\Alignment::VERTICAL_BOTTOM => 'bottom', \PhpOffice\PhpSpreadsheet\Style\Alignment::VERTICAL_TOP => 'top', \PhpOffice\PhpSpreadsheet\Style\Alignment::VERTICAL_CENTER => 'middle', \PhpOffice\PhpSpreadsheet\Style\Alignment::VERTICAL_JUSTIFY => 'middle'];
        /**
         * Map VAlign.
         *
         * @param string $vAlign Vertical alignment
         *
         * @return string
         */
        private function mapVAlign($vAlign)
        {
        }
        const HALIGN_ARR = [\PhpOffice\PhpSpreadsheet\Style\Alignment::HORIZONTAL_LEFT => 'left', \PhpOffice\PhpSpreadsheet\Style\Alignment::HORIZONTAL_RIGHT => 'right', \PhpOffice\PhpSpreadsheet\Style\Alignment::HORIZONTAL_CENTER => 'center', \PhpOffice\PhpSpreadsheet\Style\Alignment::HORIZONTAL_CENTER_CONTINUOUS => 'center', \PhpOffice\PhpSpreadsheet\Style\Alignment::HORIZONTAL_JUSTIFY => 'justify'];
        /**
         * Map HAlign.
         *
         * @param string $hAlign Horizontal alignment
         *
         * @return string
         */
        private function mapHAlign($hAlign)
        {
        }
        const BORDER_ARR = [\PhpOffice\PhpSpreadsheet\Style\Border::BORDER_NONE => 'none', \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_DASHDOT => '1px dashed', \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_DASHDOTDOT => '1px dotted', \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_DASHED => '1px dashed', \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_DOTTED => '1px dotted', \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_DOUBLE => '3px double', \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_HAIR => '1px solid', \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_MEDIUM => '2px solid', \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_MEDIUMDASHDOT => '2px dashed', \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_MEDIUMDASHDOTDOT => '2px dotted', \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_SLANTDASHDOT => '2px dashed', \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_THICK => '3px solid'];
        /**
         * Map border style.
         *
         * @param int $borderStyle Sheet index
         *
         * @return string
         */
        private function mapBorderStyle($borderStyle)
        {
        }
        /**
         * Get sheet index.
         *
         * @return int
         */
        public function getSheetIndex()
        {
        }
        /**
         * Set sheet index.
         *
         * @param int $pValue Sheet index
         *
         * @return $this
         */
        public function setSheetIndex($pValue)
        {
        }
        /**
         * Get sheet index.
         *
         * @return bool
         */
        public function getGenerateSheetNavigationBlock()
        {
        }
        /**
         * Set sheet index.
         *
         * @param bool $pValue Flag indicating whether the sheet navigation block should be generated or not
         *
         * @return $this
         */
        public function setGenerateSheetNavigationBlock($pValue)
        {
        }
        /**
         * Write all sheets (resets sheetIndex to NULL).
         *
         * @return $this
         */
        public function writeAllSheets()
        {
        }
        private static function generateMeta($val, $desc)
        {
        }
        /**
         * Generate HTML header.
         *
         * @param bool $pIncludeStyles Include styles?
         *
         * @return string
         */
        public function generateHTMLHeader($pIncludeStyles = false)
        {
        }
        private function generateSheetPrep()
        {
        }
        private function generateSheetStarts($sheet, $rowMin)
        {
        }
        private function generateSheetTags($row, $theadStart, $theadEnd, $tbodyStart)
        {
        }
        /**
         * Generate sheet data.
         *
         * @return string
         */
        public function generateSheetData()
        {
        }
        /**
         * Generate sheet tabs.
         *
         * @return string
         */
        public function generateNavigation()
        {
        }
        /**
         * Extend Row if chart is placed after nominal end of row.
         * This code should be exercised by sample:
         * Chart/32_Chart_read_write_PDF.php.
         * However, that test is suppressed due to out-of-date
         * Jpgraph code issuing warnings. So, don't measure
         * code coverage for this function till that is fixed.
         *
         * @param Worksheet $pSheet \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet
         * @param int $row Row to check for charts
         *
         * @return array
         *
         * @codeCoverageIgnore
         */
        private function extendRowsForCharts(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet, $row)
        {
        }
        private function extendRowsForChartsAndImages(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet, $row)
        {
        }
        /**
         * Convert Windows file name to file protocol URL.
         *
         * @param string $filename file name on local system
         *
         * @return string
         */
        public static function winFileToUrl($filename)
        {
        }
        /**
         * Generate image tag in cell.
         *
         * @param Worksheet $pSheet \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet
         * @param string $coordinates Cell coordinates
         *
         * @return string
         */
        private function writeImageInCell(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet, $coordinates)
        {
        }
        /**
         * Generate chart tag in cell.
         * This code should be exercised by sample:
         * Chart/32_Chart_read_write_PDF.php.
         * However, that test is suppressed due to out-of-date
         * Jpgraph code issuing warnings. So, don't measure
         * code coverage for this function till that is fixed.
         *
         * @param Worksheet $pSheet \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet
         * @param string $coordinates Cell coordinates
         *
         * @return string
         *
         * @codeCoverageIgnore
         */
        private function writeChartInCell(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet, $coordinates)
        {
        }
        /**
         * Extend Row if chart is placed after nominal end of row.
         * This code should be exercised by sample:
         * Chart/32_Chart_read_write_PDF.php.
         * However, that test is suppressed due to out-of-date
         * Jpgraph code issuing warnings. So, don't measure
         * code coverage for this function till that is fixed.
         * Caption is described in documentation as fixed,
         * but in 32_Chart it is somehow an array of RichText.
         *
         * @param mixed $cap
         *
         * @return string
         *
         * @codeCoverageIgnore
         */
        private static function getChartCaption($cap)
        {
        }
        /**
         * Generate CSS styles.
         *
         * @param bool $generateSurroundingHTML Generate surrounding HTML tags? (&lt;style&gt; and &lt;/style&gt;)
         *
         * @return string
         */
        public function generateStyles($generateSurroundingHTML = true)
        {
        }
        private function buildCssRowHeights(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $sheet, array &$css, int $sheetIndex) : void
        {
        }
        private function buildCssPerSheet(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $sheet, array &$css) : void
        {
        }
        /**
         * Build CSS styles.
         *
         * @param bool $generateSurroundingHTML Generate surrounding HTML style? (html { })
         *
         * @return array
         */
        public function buildCSS($generateSurroundingHTML = true)
        {
        }
        /**
         * Create CSS style.
         *
         * @return array
         */
        private function createCSSStyle(\PhpOffice\PhpSpreadsheet\Style\Style $pStyle)
        {
        }
        /**
         * Create CSS style (\PhpOffice\PhpSpreadsheet\Style\Alignment).
         *
         * @param Alignment $pStyle \PhpOffice\PhpSpreadsheet\Style\Alignment
         *
         * @return array
         */
        private function createCSSStyleAlignment(\PhpOffice\PhpSpreadsheet\Style\Alignment $pStyle)
        {
        }
        /**
         * Create CSS style (\PhpOffice\PhpSpreadsheet\Style\Font).
         *
         * @return array
         */
        private function createCSSStyleFont(\PhpOffice\PhpSpreadsheet\Style\Font $pStyle)
        {
        }
        /**
         * Create CSS style (Borders).
         *
         * @param Borders $pStyle Borders
         *
         * @return array
         */
        private function createCSSStyleBorders(\PhpOffice\PhpSpreadsheet\Style\Borders $pStyle)
        {
        }
        /**
         * Create CSS style (Border).
         *
         * @param Border $pStyle Border
         *
         * @return string
         */
        private function createCSSStyleBorder(\PhpOffice\PhpSpreadsheet\Style\Border $pStyle)
        {
        }
        /**
         * Create CSS style (Fill).
         *
         * @param Fill $pStyle Fill
         *
         * @return array
         */
        private function createCSSStyleFill(\PhpOffice\PhpSpreadsheet\Style\Fill $pStyle)
        {
        }
        /**
         * Generate HTML footer.
         */
        public function generateHTMLFooter()
        {
        }
        private function generateTableTagInline($pSheet, $id)
        {
        }
        private function generateTableTag($pSheet, $id, &$html, $sheetIndex) : void
        {
        }
        /**
         * Generate table header.
         *
         * @param Worksheet $pSheet The worksheet for the table we are writing
         * @param bool   $showid whether or not to add id to table tag
         *
         * @return string
         */
        private function generateTableHeader($pSheet, $showid = true)
        {
        }
        /**
         * Generate table footer.
         */
        private function generateTableFooter()
        {
        }
        /**
         * Generate row start.
         *
         * @param Worksheet $pSheet \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet
         * @param int $sheetIndex Sheet index (0-based)
         * @param int $pRow row number
         *
         * @return string
         */
        private function generateRowStart(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet, $sheetIndex, $pRow)
        {
        }
        private function generateRowCellCss($pSheet, $cellAddress, $pRow, $colNum)
        {
        }
        private function generateRowCellDataValueRich($cell, &$cellData) : void
        {
        }
        private function generateRowCellDataValue($pSheet, $cell, &$cellData) : void
        {
        }
        private function generateRowCellData($pSheet, $cell, &$cssClass, $cellType)
        {
        }
        private function generateRowIncludeCharts($pSheet, $coordinate)
        {
        }
        private function generateRowSpans($html, $rowSpan, $colSpan)
        {
        }
        private function generateRowWriteCell(&$html, $pSheet, $coordinate, $cellType, $cellData, $colSpan, $rowSpan, $cssClass, $colNum, $sheetIndex, $pRow) : void
        {
        }
        /**
         * Generate row.
         *
         * @param Worksheet $pSheet \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet
         * @param array $pValues Array containing cells in a row
         * @param int $pRow Row number (0-based)
         * @param string $cellType eg: 'td'
         *
         * @return string
         */
        private function generateRow(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet, array $pValues, $pRow, $cellType)
        {
        }
        /**
         * Takes array where of CSS properties / values and converts to CSS string.
         *
         * @return string
         */
        private function assembleCSS(array $pValue = [])
        {
        }
        /**
         * Get images root.
         *
         * @return string
         */
        public function getImagesRoot()
        {
        }
        /**
         * Set images root.
         *
         * @param string $pValue
         *
         * @return $this
         */
        public function setImagesRoot($pValue)
        {
        }
        /**
         * Get embed images.
         *
         * @return bool
         */
        public function getEmbedImages()
        {
        }
        /**
         * Set embed images.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setEmbedImages($pValue)
        {
        }
        /**
         * Get use inline CSS?
         *
         * @return bool
         */
        public function getUseInlineCss()
        {
        }
        /**
         * Set use inline CSS?
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setUseInlineCss($pValue)
        {
        }
        /**
         * Get use embedded CSS?
         *
         * @deprecated no longer used
         *
         * @return bool
         *
         * @codeCoverageIgnore
         */
        public function getUseEmbeddedCSS()
        {
        }
        /**
         * Set use embedded CSS?
         *
         * @deprecated no longer used
         *
         * @param bool $pValue
         *
         * @return $this
         *
         * @codeCoverageIgnore
         */
        public function setUseEmbeddedCSS($pValue)
        {
        }
        /**
         * Add color to formatted string as inline style.
         *
         * @param string $pValue Plain formatted value without color
         * @param string $pFormat Format code
         *
         * @return string
         */
        public function formatColor($pValue, $pFormat)
        {
        }
        /**
         * Calculate information about HTML colspan and rowspan which is not always the same as Excel's.
         */
        private function calculateSpans() : void
        {
        }
        private function calculateSpansOmitRows($sheet, $sheetIndex, $candidateSpannedRow) : void
        {
        }
        /**
         * Write a comment in the same format as LibreOffice.
         *
         * @see https://github.com/LibreOffice/core/blob/9fc9bf3240f8c62ad7859947ab8a033ac1fe93fa/sc/source/filter/html/htmlexp.cxx#L1073-L1092
         *
         * @param string $coordinate
         *
         * @return string
         */
        private function writeComment(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet, $coordinate)
        {
        }
        /**
         * Generate @page declarations.
         *
         * @param bool $generateSurroundingHTML
         *
         * @return    string
         */
        private function generatePageDeclarations($generateSurroundingHTML)
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Writer\Xlsx {
    abstract class WriterPart
    {
        /**
         * Parent Xlsx object.
         *
         * @var Xlsx
         */
        private $parentWriter;
        /**
         * Get parent Xlsx object.
         *
         * @return Xlsx
         */
        public function getParentWriter()
        {
        }
        /**
         * Set parent Xlsx object.
         */
        public function __construct(\PhpOffice\PhpSpreadsheet\Writer\Xlsx $pWriter)
        {
        }
    }
    class Chart extends \PhpOffice\PhpSpreadsheet\Writer\Xlsx\WriterPart
    {
        protected $calculateCellValues;
        /**
         * @var int
         */
        private $seriesIndex;
        /**
         * Write charts to XML format.
         *
         * @param mixed $calculateCellValues
         *
         * @return string XML Output
         */
        public function writeChart(\PhpOffice\PhpSpreadsheet\Chart\Chart $pChart, $calculateCellValues = true)
        {
        }
        /**
         * Write Chart Title.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param Title $title
         */
        private function writeTitle(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, ?\PhpOffice\PhpSpreadsheet\Chart\Title $title = null) : void
        {
        }
        /**
         * Write Chart Legend.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param Legend $legend
         */
        private function writeLegend(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, ?\PhpOffice\PhpSpreadsheet\Chart\Legend $legend = null) : void
        {
        }
        /**
         * Write Chart Plot Area.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param Title $xAxisLabel
         * @param Title $yAxisLabel
         * @param Axis $xAxis
         * @param Axis $yAxis
         */
        private function writePlotArea(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet, \PhpOffice\PhpSpreadsheet\Chart\PlotArea $plotArea, ?\PhpOffice\PhpSpreadsheet\Chart\Title $xAxisLabel = null, ?\PhpOffice\PhpSpreadsheet\Chart\Title $yAxisLabel = null, ?\PhpOffice\PhpSpreadsheet\Chart\Axis $xAxis = null, ?\PhpOffice\PhpSpreadsheet\Chart\Axis $yAxis = null, ?\PhpOffice\PhpSpreadsheet\Chart\GridLines $majorGridlines = null, ?\PhpOffice\PhpSpreadsheet\Chart\GridLines $minorGridlines = null) : void
        {
        }
        /**
         * Write Data Labels.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param \PhpOffice\PhpSpreadsheet\Chart\Layout $chartLayout Chart layout
         */
        private function writeDataLabels(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, ?\PhpOffice\PhpSpreadsheet\Chart\Layout $chartLayout = null) : void
        {
        }
        /**
         * Write Category Axis.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param Title $xAxisLabel
         * @param string $id1
         * @param string $id2
         * @param bool $isMultiLevelSeries
         */
        private function writeCategoryAxis($objWriter, $xAxisLabel, $id1, $id2, $isMultiLevelSeries, \PhpOffice\PhpSpreadsheet\Chart\Axis $yAxis) : void
        {
        }
        /**
         * Write Value Axis.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param Title $yAxisLabel
         * @param string $groupType Chart type
         * @param string $id1
         * @param string $id2
         * @param bool $isMultiLevelSeries
         */
        private function writeValueAxis($objWriter, $yAxisLabel, $groupType, $id1, $id2, $isMultiLevelSeries, \PhpOffice\PhpSpreadsheet\Chart\Axis $xAxis, \PhpOffice\PhpSpreadsheet\Chart\GridLines $majorGridlines, \PhpOffice\PhpSpreadsheet\Chart\GridLines $minorGridlines) : void
        {
        }
        /**
         * Get the data series type(s) for a chart plot series.
         *
         * @param PlotArea $plotArea
         *
         * @return array|string
         */
        private static function getChartType($plotArea)
        {
        }
        /**
         * Method writing plot series values.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param int       $val       value for idx (default: 3)
         * @param string    $fillColor hex color (default: FF9900)
         *
         * @return XMLWriter XML Writer
         */
        private function writePlotSeriesValuesElement($objWriter, $val = 3, $fillColor = 'FF9900')
        {
        }
        /**
         * Write Plot Group (series of related plots).
         *
         * @param DataSeries $plotGroup
         * @param string $groupType Type of plot for dataseries
         * @param XMLWriter $objWriter XML Writer
         * @param bool &$catIsMultiLevelSeries Is category a multi-series category
         * @param bool &$valIsMultiLevelSeries Is value set a multi-series set
         * @param string &$plotGroupingType Type of grouping for multi-series values
         */
        private function writePlotGroup($plotGroup, $groupType, $objWriter, &$catIsMultiLevelSeries, &$valIsMultiLevelSeries, &$plotGroupingType) : void
        {
        }
        /**
         * Write Plot Series Label.
         *
         * @param DataSeriesValues $plotSeriesLabel
         * @param XMLWriter $objWriter XML Writer
         */
        private function writePlotSeriesLabel($plotSeriesLabel, $objWriter) : void
        {
        }
        /**
         * Write Plot Series Values.
         *
         * @param DataSeriesValues $plotSeriesValues
         * @param XMLWriter $objWriter XML Writer
         * @param string $groupType Type of plot for dataseries
         * @param string $dataType Datatype of series values
         */
        private function writePlotSeriesValues($plotSeriesValues, \PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, $groupType, $dataType = 'str') : void
        {
        }
        /**
         * Write Bubble Chart Details.
         *
         * @param DataSeriesValues $plotSeriesValues
         * @param XMLWriter $objWriter XML Writer
         */
        private function writeBubbles($plotSeriesValues, $objWriter) : void
        {
        }
        /**
         * Write Layout.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param Layout $layout
         */
        private function writeLayout(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, ?\PhpOffice\PhpSpreadsheet\Chart\Layout $layout = null) : void
        {
        }
        /**
         * Write Alternate Content block.
         *
         * @param XMLWriter $objWriter XML Writer
         */
        private function writeAlternateContent($objWriter) : void
        {
        }
        /**
         * Write Printer Settings.
         *
         * @param XMLWriter $objWriter XML Writer
         */
        private function writePrintSettings($objWriter) : void
        {
        }
    }
    class Style extends \PhpOffice\PhpSpreadsheet\Writer\Xlsx\WriterPart
    {
        /**
         * Write styles to XML format.
         *
         * @return string XML Output
         */
        public function writeStyles(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
        /**
         * Write Fill.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param Fill $pFill Fill style
         */
        private function writeFill(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Style\Fill $pFill) : void
        {
        }
        /**
         * Write Gradient Fill.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param Fill $pFill Fill style
         */
        private function writeGradientFill(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Style\Fill $pFill) : void
        {
        }
        /**
         * Write Pattern Fill.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param Fill $pFill Fill style
         */
        private function writePatternFill(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Style\Fill $pFill) : void
        {
        }
        /**
         * Write Font.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param Font $pFont Font style
         */
        private function writeFont(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Style\Font $pFont) : void
        {
        }
        /**
         * Write Border.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param Borders $pBorders Borders style
         */
        private function writeBorder(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Style\Borders $pBorders) : void
        {
        }
        /**
         * Write Cell Style Xf.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param \PhpOffice\PhpSpreadsheet\Style\Style $pStyle Style
         * @param Spreadsheet $spreadsheet Workbook
         */
        private function writeCellStyleXf(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Style\Style $pStyle, \PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet) : void
        {
        }
        /**
         * Write Cell Style Dxf.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param \PhpOffice\PhpSpreadsheet\Style\Style $pStyle Style
         */
        private function writeCellStyleDxf(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Style\Style $pStyle) : void
        {
        }
        /**
         * Write BorderPr.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param string $pName Element name
         * @param Border $pBorder Border style
         */
        private function writeBorderPr(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, $pName, \PhpOffice\PhpSpreadsheet\Style\Border $pBorder) : void
        {
        }
        /**
         * Write NumberFormat.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param NumberFormat $pNumberFormat Number Format
         * @param int $pId Number Format identifier
         */
        private function writeNumFmt(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Style\NumberFormat $pNumberFormat, $pId = 0) : void
        {
        }
        /**
         * Get an array of all styles.
         *
         * @return \PhpOffice\PhpSpreadsheet\Style\Style[] All styles in PhpSpreadsheet
         */
        public function allStyles(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
        /**
         * Get an array of all conditional styles.
         *
         * @return Conditional[] All conditional styles in PhpSpreadsheet
         */
        public function allConditionalStyles(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
        /**
         * Get an array of all fills.
         *
         * @return Fill[] All fills in PhpSpreadsheet
         */
        public function allFills(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
        /**
         * Get an array of all fonts.
         *
         * @return Font[] All fonts in PhpSpreadsheet
         */
        public function allFonts(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
        /**
         * Get an array of all borders.
         *
         * @return Borders[] All borders in PhpSpreadsheet
         */
        public function allBorders(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
        /**
         * Get an array of all number formats.
         *
         * @return NumberFormat[] All number formats in PhpSpreadsheet
         */
        public function allNumberFormats(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
    }
    class Workbook extends \PhpOffice\PhpSpreadsheet\Writer\Xlsx\WriterPart
    {
        /**
         * Write workbook to XML format.
         *
         * @param bool $recalcRequired Indicate whether formulas should be recalculated before writing
         *
         * @return string XML Output
         */
        public function writeWorkbook(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet, $recalcRequired = false)
        {
        }
        /**
         * Write file version.
         *
         * @param XMLWriter $objWriter XML Writer
         */
        private function writeFileVersion(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter) : void
        {
        }
        /**
         * Write WorkbookPr.
         *
         * @param XMLWriter $objWriter XML Writer
         */
        private function writeWorkbookPr(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter) : void
        {
        }
        /**
         * Write BookViews.
         *
         * @param XMLWriter $objWriter XML Writer
         */
        private function writeBookViews(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet) : void
        {
        }
        /**
         * Write WorkbookProtection.
         *
         * @param XMLWriter $objWriter XML Writer
         */
        private function writeWorkbookProtection(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet) : void
        {
        }
        /**
         * Write calcPr.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param bool $recalcRequired Indicate whether formulas should be recalculated before writing
         */
        private function writeCalcPr(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, $recalcRequired = true) : void
        {
        }
        /**
         * Write sheets.
         *
         * @param XMLWriter $objWriter XML Writer
         */
        private function writeSheets(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet) : void
        {
        }
        /**
         * Write sheet.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param string $pSheetname Sheet name
         * @param int $pSheetId Sheet id
         * @param int $pRelId Relationship ID
         * @param string $sheetState Sheet state (visible, hidden, veryHidden)
         */
        private function writeSheet(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, $pSheetname, $pSheetId = 1, $pRelId = 1, $sheetState = 'visible') : void
        {
        }
        /**
         * Write Defined Names.
         *
         * @param XMLWriter $objWriter XML Writer
         */
        private function writeDefinedNames(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet) : void
        {
        }
        /**
         * Write named ranges.
         *
         * @param XMLWriter $objWriter XML Writer
         */
        private function writeNamedRanges(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet) : void
        {
        }
        /**
         * Write Defined Name for named range.
         *
         * @param XMLWriter $objWriter XML Writer
         */
        private function writeDefinedNameForNamedRange(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\NamedRange $pNamedRange) : void
        {
        }
        /**
         * Write Defined Name for autoFilter.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param int $pSheetId
         */
        private function writeDefinedNameForAutofilter(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet, $pSheetId = 0) : void
        {
        }
        /**
         * Write Defined Name for PrintTitles.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param int $pSheetId
         */
        private function writeDefinedNameForPrintTitles(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet, $pSheetId = 0) : void
        {
        }
        /**
         * Write Defined Name for PrintTitles.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param int $pSheetId
         */
        private function writeDefinedNameForPrintArea(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet, $pSheetId = 0) : void
        {
        }
    }
    class RelsRibbon extends \PhpOffice\PhpSpreadsheet\Writer\Xlsx\WriterPart
    {
        /**
         * Write relationships for additional objects of custom UI (ribbon).
         *
         * @return string XML Output
         */
        public function writeRibbonRelationships(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
    }
    class StringTable extends \PhpOffice\PhpSpreadsheet\Writer\Xlsx\WriterPart
    {
        /**
         * Create worksheet stringtable.
         *
         * @param Worksheet $pSheet Worksheet
         * @param string[] $pExistingTable Existing table to eventually merge with
         *
         * @return string[] String table for worksheet
         */
        public function createStringTable(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet, $pExistingTable = null)
        {
        }
        /**
         * Write string table to XML format.
         *
         * @param string[] $pStringTable
         *
         * @return string XML Output
         */
        public function writeStringTable(array $pStringTable)
        {
        }
        /**
         * Write Rich Text.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param RichText $pRichText Rich text
         * @param string $prefix Optional Namespace prefix
         */
        public function writeRichText(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\RichText\RichText $pRichText, $prefix = null) : void
        {
        }
        /**
         * Write Rich Text.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param RichText|string $pRichText text string or Rich text
         * @param string $prefix Optional Namespace prefix
         */
        public function writeRichTextForCharts(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, $pRichText = null, $prefix = null) : void
        {
        }
        /**
         * Flip string table (for index searching).
         *
         * @param array $stringTable Stringtable
         *
         * @return array
         */
        public function flipStringTable(array $stringTable)
        {
        }
    }
    class Xlfn
    {
        const XLFNREGEXP = '/(?<!_xlfn[.])\\b(' . 'beta[.]dist' . '|beta[.]inv' . '|binom[.]dist' . '|binom[.]inv' . '|chisq[.]dist' . '|chisq[.]dist[.]rt' . '|chisq[.]inv' . '|chisq[.]inv[.]rt' . '|chisq[.]test' . '|confidence[.]norm' . '|confidence[.]t' . '|covariance[.]p' . '|covariance[.]s' . '|erf[.]precise' . '|erfc[.]precise' . '|expon[.]dist' . '|f[.]dist' . '|f[.]dist[.]rt' . '|f[.]inv' . '|f[.]inv[.]rt' . '|f[.]test' . '|gamma[.]dist' . '|gamma[.]inv' . '|gammaln[.]precise' . '|lognorm[.]dist' . '|lognorm[.]inv' . '|mode[.]mult' . '|mode[.]sngl' . '|negbinom[.]dist' . '|networkdays[.]intl' . '|norm[.]dist' . '|norm[.]inv' . '|norm[.]s[.]dist' . '|norm[.]s[.]inv' . '|percentile[.]exc' . '|percentile[.]inc' . '|percentrank[.]exc' . '|percentrank[.]inc' . '|poisson[.]dist' . '|quartile[.]exc' . '|quartile[.]inc' . '|rank[.]avg' . '|rank[.]eq' . '|stdev[.]p' . '|stdev[.]s' . '|t[.]dist' . '|t[.]dist[.]2t' . '|t[.]dist[.]rt' . '|t[.]inv' . '|t[.]inv[.]2t' . '|t[.]test' . '|var[.]p' . '|var[.]s' . '|weibull[.]dist' . '|z[.]test' . '|acot' . '|acoth' . '|arabic' . '|averageifs' . '|binom[.]dist[.]range' . '|bitand' . '|bitlshift' . '|bitor' . '|bitrshift' . '|bitxor' . '|ceiling[.]math' . '|combina' . '|cot' . '|coth' . '|csc' . '|csch' . '|days' . '|dbcs' . '|decimal' . '|encodeurl' . '|filterxml' . '|floor[.]math' . '|formulatext' . '|gamma' . '|gauss' . '|ifna' . '|imcosh' . '|imcot' . '|imcsc' . '|imcsch' . '|imsec' . '|imsech' . '|imsinh' . '|imtan' . '|isformula' . '|iso[.]ceiling' . '|isoweeknum' . '|munit' . '|numbervalue' . '|pduration' . '|permutationa' . '|phi' . '|rri' . '|sec' . '|sech' . '|sheet' . '|sheets' . '|skew[.]p' . '|unichar' . '|unicode' . '|webservice' . '|xor' . '|forecast[.]et2' . '|forecast[.]ets[.]confint' . '|forecast[.]ets[.]seasonality' . '|forecast[.]ets[.]stat' . '|forecast[.]linear' . '|switch' . '|concat' . '|countifs' . '|ifs' . '|maxifs' . '|minifs' . '|sumifs' . '|textjoin' . '|filter' . '|randarray' . '|sequence' . '|sort' . '|sortby' . '|unique' . '|xlookup' . '|xmatch' . ')(?=\\s*[(])/i';
        /**
         * Prefix function name in string with _xlfn. where required.
         */
        public static function addXlfn(string $funcstring) : string
        {
        }
        /**
         * Prefix function name in string with _xlfn. where required.
         * Leading character, expected to be equals sign, is stripped.
         */
        public static function addXlfnStripEquals(string $funcstring) : string
        {
        }
    }
    class RelsVBA extends \PhpOffice\PhpSpreadsheet\Writer\Xlsx\WriterPart
    {
        /**
         * Write relationships for a signed VBA Project.
         *
         * @return string XML Output
         */
        public function writeVBARelationships(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
    }
    class Worksheet extends \PhpOffice\PhpSpreadsheet\Writer\Xlsx\WriterPart
    {
        /**
         * Write worksheet to XML format.
         *
         * @param string[] $pStringTable
         * @param bool $includeCharts Flag indicating if we should write charts
         *
         * @return string XML Output
         */
        public function writeWorksheet(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet, $pStringTable = null, $includeCharts = false)
        {
        }
        /**
         * Write SheetPr.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param PhpspreadsheetWorksheet $pSheet Worksheet
         */
        private function writeSheetPr(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet) : void
        {
        }
        /**
         * Write Dimension.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param PhpspreadsheetWorksheet $pSheet Worksheet
         */
        private function writeDimension(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet) : void
        {
        }
        /**
         * Write SheetViews.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param PhpspreadsheetWorksheet $pSheet Worksheet
         */
        private function writeSheetViews(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet) : void
        {
        }
        /**
         * Write SheetFormatPr.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param PhpspreadsheetWorksheet $pSheet Worksheet
         */
        private function writeSheetFormatPr(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet) : void
        {
        }
        /**
         * Write Cols.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param PhpspreadsheetWorksheet $pSheet Worksheet
         */
        private function writeCols(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet) : void
        {
        }
        /**
         * Write SheetProtection.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param PhpspreadsheetWorksheet $pSheet Worksheet
         */
        private function writeSheetProtection(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet) : void
        {
        }
        private static function writeAttributeIf(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, $condition, string $attr, string $val) : void
        {
        }
        private static function writeElementIf(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, $condition, string $attr, string $val) : void
        {
        }
        private static function writeOtherCondElements(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Style\Conditional $conditional, string $cellCoordinate) : void
        {
        }
        private static function writeTextCondElements(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Style\Conditional $conditional, string $cellCoordinate) : void
        {
        }
        /**
         * Write ConditionalFormatting.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param PhpspreadsheetWorksheet $pSheet Worksheet
         */
        private function writeConditionalFormatting(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet) : void
        {
        }
        /**
         * Write DataValidations.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param PhpspreadsheetWorksheet $pSheet Worksheet
         */
        private function writeDataValidations(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet) : void
        {
        }
        /**
         * Write Hyperlinks.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param PhpspreadsheetWorksheet $pSheet Worksheet
         */
        private function writeHyperlinks(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet) : void
        {
        }
        /**
         * Write ProtectedRanges.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param PhpspreadsheetWorksheet $pSheet Worksheet
         */
        private function writeProtectedRanges(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet) : void
        {
        }
        /**
         * Write MergeCells.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param PhpspreadsheetWorksheet $pSheet Worksheet
         */
        private function writeMergeCells(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet) : void
        {
        }
        /**
         * Write PrintOptions.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param PhpspreadsheetWorksheet $pSheet Worksheet
         */
        private function writePrintOptions(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet) : void
        {
        }
        /**
         * Write PageMargins.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param PhpspreadsheetWorksheet $pSheet Worksheet
         */
        private function writePageMargins(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet) : void
        {
        }
        /**
         * Write AutoFilter.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param PhpspreadsheetWorksheet $pSheet Worksheet
         */
        private function writeAutoFilter(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet) : void
        {
        }
        /**
         * Write PageSetup.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param PhpspreadsheetWorksheet $pSheet Worksheet
         */
        private function writePageSetup(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet) : void
        {
        }
        /**
         * Write Header / Footer.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param PhpspreadsheetWorksheet $pSheet Worksheet
         */
        private function writeHeaderFooter(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet) : void
        {
        }
        /**
         * Write Breaks.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param PhpspreadsheetWorksheet $pSheet Worksheet
         */
        private function writeBreaks(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet) : void
        {
        }
        /**
         * Write SheetData.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param PhpspreadsheetWorksheet $pSheet Worksheet
         * @param string[] $pStringTable String table
         */
        private function writeSheetData(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet, array $pStringTable) : void
        {
        }
        /**
         * @param RichText|string $cellValue
         */
        private function writeCellInlineStr(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, string $mappedType, $cellValue) : void
        {
        }
        /**
         * @param RichText|string $cellValue
         * @param string[] $pFlippedStringTable
         */
        private function writeCellString(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, string $mappedType, $cellValue, array $pFlippedStringTable) : void
        {
        }
        /**
         * @param float|int $cellValue
         */
        private function writeCellNumeric(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, $cellValue) : void
        {
        }
        private function writeCellBoolean(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, string $mappedType, bool $cellValue) : void
        {
        }
        private function writeCellError(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, string $mappedType, string $cellValue, string $formulaerr = '#NULL!') : void
        {
        }
        private function writeCellFormula(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, string $cellValue, \PhpOffice\PhpSpreadsheet\Cell\Cell $pCell) : void
        {
        }
        /**
         * Write Cell.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param PhpspreadsheetWorksheet $pSheet Worksheet
         * @param string $pCellAddress Cell Address
         * @param string[] $pFlippedStringTable String table (flipped), for faster index searching
         */
        private function writeCell(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet, string $pCellAddress, array $pFlippedStringTable) : void
        {
        }
        /**
         * Write Drawings.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param PhpspreadsheetWorksheet $pSheet Worksheet
         * @param bool $includeCharts Flag indicating if we should include drawing details for charts
         */
        private function writeDrawings(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet, $includeCharts = false) : void
        {
        }
        /**
         * Write LegacyDrawing.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param PhpspreadsheetWorksheet $pSheet Worksheet
         */
        private function writeLegacyDrawing(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet) : void
        {
        }
        /**
         * Write LegacyDrawingHF.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param PhpspreadsheetWorksheet $pSheet Worksheet
         */
        private function writeLegacyDrawingHF(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet) : void
        {
        }
        private function writeAlternateContent(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet) : void
        {
        }
    }
    class ContentTypes extends \PhpOffice\PhpSpreadsheet\Writer\Xlsx\WriterPart
    {
        /**
         * Write content types to XML format.
         *
         * @param bool $includeCharts Flag indicating if we should include drawing details for charts
         *
         * @return string XML Output
         */
        public function writeContentTypes(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet, $includeCharts = false)
        {
        }
        /**
         * Get image mime type.
         *
         * @param string $pFile Filename
         *
         * @return string Mime Type
         */
        private function getImageMimeType($pFile)
        {
        }
        /**
         * Write Default content type.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param string $pPartname Part name
         * @param string $pContentType Content type
         */
        private function writeDefaultContentType(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, $pPartname, $pContentType) : void
        {
        }
        /**
         * Write Override content type.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param string $pPartname Part name
         * @param string $pContentType Content type
         */
        private function writeOverrideContentType(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, $pPartname, $pContentType) : void
        {
        }
    }
    class Comments extends \PhpOffice\PhpSpreadsheet\Writer\Xlsx\WriterPart
    {
        /**
         * Write comments to XML format.
         *
         * @return string XML Output
         */
        public function writeComments(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pWorksheet)
        {
        }
        /**
         * Write comment to XML format.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param string $pCellReference Cell reference
         * @param Comment $pComment Comment
         * @param array $pAuthors Array of authors
         */
        private function writeComment(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, $pCellReference, \PhpOffice\PhpSpreadsheet\Comment $pComment, array $pAuthors) : void
        {
        }
        /**
         * Write VML comments to XML format.
         *
         * @return string XML Output
         */
        public function writeVMLComments(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pWorksheet)
        {
        }
        /**
         * Write VML comment to XML format.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param string $pCellReference Cell reference, eg: 'A1'
         * @param Comment $pComment Comment
         */
        private function writeVMLComment(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, $pCellReference, \PhpOffice\PhpSpreadsheet\Comment $pComment) : void
        {
        }
    }
    class Rels extends \PhpOffice\PhpSpreadsheet\Writer\Xlsx\WriterPart
    {
        /**
         * Write relationships to XML format.
         *
         * @return string XML Output
         */
        public function writeRelationships(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
        /**
         * Write workbook relationships to XML format.
         *
         * @return string XML Output
         */
        public function writeWorkbookRelationships(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
        /**
         * Write worksheet relationships to XML format.
         *
         * Numbering is as follows:
         *     rId1                 - Drawings
         *  rId_hyperlink_x     - Hyperlinks
         *
         * @param int $pWorksheetId
         * @param bool $includeCharts Flag indicating if we should write charts
         *
         * @return string XML Output
         */
        public function writeWorksheetRelationships(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pWorksheet, $pWorksheetId = 1, $includeCharts = false)
        {
        }
        private function writeUnparsedRelationship(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pWorksheet, \PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, $relationship, $type) : void
        {
        }
        /**
         * Write drawing relationships to XML format.
         *
         * @param int &$chartRef Chart ID
         * @param bool $includeCharts Flag indicating if we should write charts
         *
         * @return string XML Output
         */
        public function writeDrawingRelationships(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pWorksheet, &$chartRef, $includeCharts = false)
        {
        }
        /**
         * Write header/footer drawing relationships to XML format.
         *
         * @return string XML Output
         */
        public function writeHeaderFooterDrawingRelationships(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pWorksheet)
        {
        }
        /**
         * Write Override content type.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param int $pId Relationship ID. rId will be prepended!
         * @param string $pType Relationship type
         * @param string $pTarget Relationship target
         * @param string $pTargetMode Relationship target mode
         */
        private function writeRelationship(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, $pId, $pType, $pTarget, $pTargetMode = '') : void
        {
        }
        /**
         * @param $objWriter
         * @param \PhpOffice\PhpSpreadsheet\Worksheet\Drawing $drawing
         * @param $i
         *
         * @return int
         */
        private function writeDrawingHyperLink($objWriter, $drawing, $i)
        {
        }
    }
    class Theme extends \PhpOffice\PhpSpreadsheet\Writer\Xlsx\WriterPart
    {
        /**
         * Map of Major fonts to write.
         *
         * @var array of string
         */
        private static $majorFonts = ['Jpan' => ' ', 'Hang' => ' ', 'Hans' => '', 'Hant' => '', 'Arab' => 'Times New Roman', 'Hebr' => 'Times New Roman', 'Thai' => 'Tahoma', 'Ethi' => 'Nyala', 'Beng' => 'Vrinda', 'Gujr' => 'Shruti', 'Khmr' => 'MoolBoran', 'Knda' => 'Tunga', 'Guru' => 'Raavi', 'Cans' => 'Euphemia', 'Cher' => 'Plantagenet Cherokee', 'Yiii' => 'Microsoft Yi Baiti', 'Tibt' => 'Microsoft Himalaya', 'Thaa' => 'MV Boli', 'Deva' => 'Mangal', 'Telu' => 'Gautami', 'Taml' => 'Latha', 'Syrc' => 'Estrangelo Edessa', 'Orya' => 'Kalinga', 'Mlym' => 'Kartika', 'Laoo' => 'DokChampa', 'Sinh' => 'Iskoola Pota', 'Mong' => 'Mongolian Baiti', 'Viet' => 'Times New Roman', 'Uigh' => 'Microsoft Uighur', 'Geor' => 'Sylfaen'];
        /**
         * Map of Minor fonts to write.
         *
         * @var array of string
         */
        private static $minorFonts = ['Jpan' => ' ', 'Hang' => ' ', 'Hans' => '', 'Hant' => '', 'Arab' => 'Arial', 'Hebr' => 'Arial', 'Thai' => 'Tahoma', 'Ethi' => 'Nyala', 'Beng' => 'Vrinda', 'Gujr' => 'Shruti', 'Khmr' => 'DaunPenh', 'Knda' => 'Tunga', 'Guru' => 'Raavi', 'Cans' => 'Euphemia', 'Cher' => 'Plantagenet Cherokee', 'Yiii' => 'Microsoft Yi Baiti', 'Tibt' => 'Microsoft Himalaya', 'Thaa' => 'MV Boli', 'Deva' => 'Mangal', 'Telu' => 'Gautami', 'Taml' => 'Latha', 'Syrc' => 'Estrangelo Edessa', 'Orya' => 'Kalinga', 'Mlym' => 'Kartika', 'Laoo' => 'DokChampa', 'Sinh' => 'Iskoola Pota', 'Mong' => 'Mongolian Baiti', 'Viet' => 'Arial', 'Uigh' => 'Microsoft Uighur', 'Geor' => 'Sylfaen'];
        /**
         * Map of core colours.
         *
         * @var array of string
         */
        private static $colourScheme = ['dk2' => '1F497D', 'lt2' => 'EEECE1', 'accent1' => '4F81BD', 'accent2' => 'C0504D', 'accent3' => '9BBB59', 'accent4' => '8064A2', 'accent5' => '4BACC6', 'accent6' => 'F79646', 'hlink' => '0000FF', 'folHlink' => '800080'];
        /**
         * Write theme to XML format.
         *
         * @return string XML Output
         */
        public function writeTheme(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
        /**
         * Write fonts to XML format.
         *
         * @param XMLWriter $objWriter
         * @param string $latinFont
         * @param array of string                $fontSet
         *
         * @return string XML Output
         */
        private function writeFonts($objWriter, $latinFont, $fontSet)
        {
        }
        /**
         * Write colour scheme to XML format.
         *
         * @param XMLWriter $objWriter
         *
         * @return string XML Output
         */
        private function writeColourScheme($objWriter)
        {
        }
    }
    class Drawing extends \PhpOffice\PhpSpreadsheet\Writer\Xlsx\WriterPart
    {
        /**
         * Write drawings to XML format.
         *
         * @param bool $includeCharts Flag indicating if we should include drawing details for charts
         *
         * @return string XML Output
         */
        public function writeDrawings(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pWorksheet, $includeCharts = false)
        {
        }
        /**
         * Write drawings to XML format.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param int $pRelationId
         */
        public function writeChart(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Chart\Chart $pChart, $pRelationId = -1) : void
        {
        }
        /**
         * Write drawings to XML format.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param int $pRelationId
         * @param null|int $hlinkClickId
         */
        public function writeDrawing(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Worksheet\BaseDrawing $pDrawing, $pRelationId = -1, $hlinkClickId = null) : void
        {
        }
        /**
         * Write VML header/footer images to XML format.
         *
         * @return string XML Output
         */
        public function writeVMLHeaderFooterImages(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pWorksheet)
        {
        }
        /**
         * Write VML comment to XML format.
         *
         * @param XMLWriter $objWriter XML Writer
         * @param string $pReference Reference
         * @param HeaderFooterDrawing $pImage Image
         */
        private function writeVMLHeaderFooterImage(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, $pReference, \PhpOffice\PhpSpreadsheet\Worksheet\HeaderFooterDrawing $pImage) : void
        {
        }
        /**
         * Get an array of all drawings.
         *
         * @return \PhpOffice\PhpSpreadsheet\Worksheet\Drawing[] All drawings in PhpSpreadsheet
         */
        public function allDrawings(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
        /**
         * @param null|int $hlinkClickId
         */
        private function writeHyperLinkDrawing(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, $hlinkClickId) : void
        {
        }
    }
    class DocProps extends \PhpOffice\PhpSpreadsheet\Writer\Xlsx\WriterPart
    {
        /**
         * Write docProps/app.xml to XML format.
         *
         * @return string XML Output
         */
        public function writeDocPropsApp(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
        /**
         * Write docProps/core.xml to XML format.
         *
         * @return string XML Output
         */
        public function writeDocPropsCore(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
        /**
         * Write docProps/custom.xml to XML format.
         *
         * @return string XML Output
         */
        public function writeDocPropsCustom(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Writer\Ods {
    abstract class WriterPart
    {
        /**
         * Parent Ods object.
         *
         * @var Ods
         */
        private $parentWriter;
        /**
         * Get Ods writer.
         *
         * @return Ods
         */
        public function getParentWriter()
        {
        }
        /**
         * Set parent Ods writer.
         */
        public function __construct(\PhpOffice\PhpSpreadsheet\Writer\Ods $writer)
        {
        }
    }
    /**
     * @author     Alexander Pervakov <frost-nzcr4@jagmort.com>
     */
    class Content extends \PhpOffice\PhpSpreadsheet\Writer\Ods\WriterPart
    {
        const NUMBER_COLS_REPEATED_MAX = 1024;
        const NUMBER_ROWS_REPEATED_MAX = 1048576;
        const CELL_STYLE_PREFIX = 'ce';
        /**
         * Write content.xml to XML format.
         *
         * @return string XML Output
         */
        public function write()
        {
        }
        /**
         * Write sheets.
         */
        private function writeSheets(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter) : void
        {
        }
        /**
         * Write rows of the specified sheet.
         */
        private function writeRows(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $sheet) : void
        {
        }
        /**
         * Write cells of the specified row.
         */
        private function writeCells(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Worksheet\Row $row) : void
        {
        }
        /**
         * Write span.
         *
         * @param int $curColumn
         * @param int $prevColumn
         */
        private function writeCellSpan(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, $curColumn, $prevColumn) : void
        {
        }
        /**
         * Write XF cell styles.
         */
        private function writeXfStyles(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $writer, \PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet) : void
        {
        }
        /**
         * Write attributes for merged cell.
         */
        private function writeCellMerge(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Cell\Cell $cell) : void
        {
        }
    }
    class Meta extends \PhpOffice\PhpSpreadsheet\Writer\Ods\WriterPart
    {
        /**
         * Write meta.xml to XML format.
         *
         * @param Spreadsheet $spreadsheet
         *
         * @return string XML Output
         */
        public function write(?\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet = null)
        {
        }
    }
    class Mimetype extends \PhpOffice\PhpSpreadsheet\Writer\Ods\WriterPart
    {
        /**
         * Write mimetype to plain text format.
         *
         * @param Spreadsheet $spreadsheet
         *
         * @return string XML Output
         */
        public function write(?\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet = null)
        {
        }
    }
    class Thumbnails extends \PhpOffice\PhpSpreadsheet\Writer\Ods\WriterPart
    {
        /**
         * Write Thumbnails/thumbnail.png to PNG format.
         *
         * @param Spreadsheet $spreadsheet
         *
         * @return string XML Output
         */
        public function writeThumbnail(?\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet = null)
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Writer\Ods\Cell {
    /**
     * @author     Alexander Pervakov <frost-nzcr4@jagmort.com>
     */
    class Comment
    {
        public static function write(\PhpOffice\PhpSpreadsheet\Shared\XMLWriter $objWriter, \PhpOffice\PhpSpreadsheet\Cell\Cell $cell) : void
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Writer\Ods {
    class MetaInf extends \PhpOffice\PhpSpreadsheet\Writer\Ods\WriterPart
    {
        /**
         * Write META-INF/manifest.xml to XML format.
         *
         * @return string XML Output
         */
        public function writeManifest()
        {
        }
    }
    class Settings extends \PhpOffice\PhpSpreadsheet\Writer\Ods\WriterPart
    {
        /**
         * Write settings.xml to XML format.
         *
         * @param Spreadsheet $spreadsheet
         *
         * @return string XML Output
         */
        public function write(?\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet = null)
        {
        }
    }
    class Styles extends \PhpOffice\PhpSpreadsheet\Writer\Ods\WriterPart
    {
        /**
         * Write styles.xml to XML format.
         *
         * @param Spreadsheet $spreadsheet
         *
         * @return string XML Output
         */
        public function write(?\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet = null)
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Writer {
    abstract class Pdf extends \PhpOffice\PhpSpreadsheet\Writer\Html
    {
        /**
         * Temporary storage directory.
         *
         * @var string
         */
        protected $tempDir = '';
        /**
         * Font.
         *
         * @var string
         */
        protected $font = 'freesans';
        /**
         * Orientation (Over-ride).
         *
         * @var string
         */
        protected $orientation;
        /**
         * Paper size (Over-ride).
         *
         * @var int
         */
        protected $paperSize;
        /**
         * Paper Sizes xRef List.
         *
         * @var array
         */
        protected static $paperSizes = [
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_LETTER => 'LETTER',
            //    (8.5 in. by 11 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_LETTER_SMALL => 'LETTER',
            //    (8.5 in. by 11 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_TABLOID => [792.0, 1224.0],
            //    (11 in. by 17 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_LEDGER => [1224.0, 792.0],
            //    (17 in. by 11 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_LEGAL => 'LEGAL',
            //    (8.5 in. by 14 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_STATEMENT => [396.0, 612.0],
            //    (5.5 in. by 8.5 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_EXECUTIVE => 'EXECUTIVE',
            //    (7.25 in. by 10.5 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_A3 => 'A3',
            //    (297 mm by 420 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_A4 => 'A4',
            //    (210 mm by 297 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_A4_SMALL => 'A4',
            //    (210 mm by 297 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_A5 => 'A5',
            //    (148 mm by 210 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_B4 => 'B4',
            //    (250 mm by 353 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_B5 => 'B5',
            //    (176 mm by 250 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_FOLIO => 'FOLIO',
            //    (8.5 in. by 13 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_QUARTO => [609.45, 779.53],
            //    (215 mm by 275 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_STANDARD_1 => [720.0, 1008.0],
            //    (10 in. by 14 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_STANDARD_2 => [792.0, 1224.0],
            //    (11 in. by 17 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_NOTE => 'LETTER',
            //    (8.5 in. by 11 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_NO9_ENVELOPE => [279.0, 639.0],
            //    (3.875 in. by 8.875 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_NO10_ENVELOPE => [297.0, 684.0],
            //    (4.125 in. by 9.5 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_NO11_ENVELOPE => [324.0, 747.0],
            //    (4.5 in. by 10.375 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_NO12_ENVELOPE => [342.0, 792.0],
            //    (4.75 in. by 11 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_NO14_ENVELOPE => [360.0, 828.0],
            //    (5 in. by 11.5 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_C => [1224.0, 1584.0],
            //    (17 in. by 22 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_D => [1584.0, 2448.0],
            //    (22 in. by 34 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_E => [2448.0, 3168.0],
            //    (34 in. by 44 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_DL_ENVELOPE => [311.81, 623.62],
            //    (110 mm by 220 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_C5_ENVELOPE => 'C5',
            //    (162 mm by 229 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_C3_ENVELOPE => 'C3',
            //    (324 mm by 458 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_C4_ENVELOPE => 'C4',
            //    (229 mm by 324 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_C6_ENVELOPE => 'C6',
            //    (114 mm by 162 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_C65_ENVELOPE => [323.15, 649.13],
            //    (114 mm by 229 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_B4_ENVELOPE => 'B4',
            //    (250 mm by 353 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_B5_ENVELOPE => 'B5',
            //    (176 mm by 250 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_B6_ENVELOPE => [498.9, 354.33],
            //    (176 mm by 125 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_ITALY_ENVELOPE => [311.81, 651.97],
            //    (110 mm by 230 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_MONARCH_ENVELOPE => [279.0, 540.0],
            //    (3.875 in. by 7.5 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_6_3_4_ENVELOPE => [261.0, 468.0],
            //    (3.625 in. by 6.5 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_US_STANDARD_FANFOLD => [1071.0, 792.0],
            //    (14.875 in. by 11 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_GERMAN_STANDARD_FANFOLD => [612.0, 864.0],
            //    (8.5 in. by 12 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_GERMAN_LEGAL_FANFOLD => 'FOLIO',
            //    (8.5 in. by 13 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_ISO_B4 => 'B4',
            //    (250 mm by 353 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_JAPANESE_DOUBLE_POSTCARD => [566.9299999999999, 419.53],
            //    (200 mm by 148 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_STANDARD_PAPER_1 => [648.0, 792.0],
            //    (9 in. by 11 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_STANDARD_PAPER_2 => [720.0, 792.0],
            //    (10 in. by 11 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_STANDARD_PAPER_3 => [1080.0, 792.0],
            //    (15 in. by 11 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_INVITE_ENVELOPE => [623.62, 623.62],
            //    (220 mm by 220 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_LETTER_EXTRA_PAPER => [667.8, 864.0],
            //    (9.275 in. by 12 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_LEGAL_EXTRA_PAPER => [667.8, 1080.0],
            //    (9.275 in. by 15 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_TABLOID_EXTRA_PAPER => [841.6799999999999, 1296.0],
            //    (11.69 in. by 18 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_A4_EXTRA_PAPER => [668.98, 912.76],
            //    (236 mm by 322 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_LETTER_TRANSVERSE_PAPER => [595.8, 792.0],
            //    (8.275 in. by 11 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_A4_TRANSVERSE_PAPER => 'A4',
            //    (210 mm by 297 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_LETTER_EXTRA_TRANSVERSE_PAPER => [667.8, 864.0],
            //    (9.275 in. by 12 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_SUPERA_SUPERA_A4_PAPER => [643.46, 1009.13],
            //    (227 mm by 356 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_SUPERB_SUPERB_A3_PAPER => [864.5700000000001, 1380.47],
            //    (305 mm by 487 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_LETTER_PLUS_PAPER => [612.0, 913.6799999999999],
            //    (8.5 in. by 12.69 in.)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_A4_PLUS_PAPER => [595.28, 935.4299999999999],
            //    (210 mm by 330 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_A5_TRANSVERSE_PAPER => 'A5',
            //    (148 mm by 210 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_JIS_B5_TRANSVERSE_PAPER => [515.91, 728.5],
            //    (182 mm by 257 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_A3_EXTRA_PAPER => [912.76, 1261.42],
            //    (322 mm by 445 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_A5_EXTRA_PAPER => [493.23, 666.14],
            //    (174 mm by 235 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_ISO_B5_EXTRA_PAPER => [569.76, 782.36],
            //    (201 mm by 276 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_A2_PAPER => 'A2',
            //    (420 mm by 594 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_A3_TRANSVERSE_PAPER => 'A3',
            //    (297 mm by 420 mm)
            \PhpOffice\PhpSpreadsheet\Worksheet\PageSetup::PAPERSIZE_A3_EXTRA_TRANSVERSE_PAPER => [912.76, 1261.42],
        ];
        /**
         * Create a new PDF Writer instance.
         *
         * @param Spreadsheet $spreadsheet Spreadsheet object
         */
        public function __construct(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
        /**
         * Get Font.
         *
         * @return string
         */
        public function getFont()
        {
        }
        /**
         * Set font. Examples:
         *      'arialunicid0-chinese-simplified'
         *      'arialunicid0-chinese-traditional'
         *      'arialunicid0-korean'
         *      'arialunicid0-japanese'.
         *
         * @param string $fontName
         *
         * @return $this
         */
        public function setFont($fontName)
        {
        }
        /**
         * Get Paper Size.
         *
         * @return int
         */
        public function getPaperSize()
        {
        }
        /**
         * Set Paper Size.
         *
         * @param string $pValue Paper size see PageSetup::PAPERSIZE_*
         *
         * @return self
         */
        public function setPaperSize($pValue)
        {
        }
        /**
         * Get Orientation.
         *
         * @return string
         */
        public function getOrientation()
        {
        }
        /**
         * Set Orientation.
         *
         * @param string $pValue Page orientation see PageSetup::ORIENTATION_*
         *
         * @return self
         */
        public function setOrientation($pValue)
        {
        }
        /**
         * Get temporary storage directory.
         *
         * @return string
         */
        public function getTempDir()
        {
        }
        /**
         * Set temporary storage directory.
         *
         * @param string $pValue Temporary storage directory
         *
         * @return self
         */
        public function setTempDir($pValue)
        {
        }
        /**
         * Save Spreadsheet to PDF file, pre-save.
         *
         * @param string $pFilename Name of the file to save as
         *
         * @return resource
         */
        protected function prepareForSave($pFilename)
        {
        }
        /**
         * Save PhpSpreadsheet to PDF file, post-save.
         */
        protected function restoreStateAfterSave() : void
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Writer\Pdf {
    class Tcpdf extends \PhpOffice\PhpSpreadsheet\Writer\Pdf
    {
        /**
         * Create a new PDF Writer instance.
         *
         * @param Spreadsheet $spreadsheet Spreadsheet object
         */
        public function __construct(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
        /**
         * Gets the implementation of external PDF library that should be used.
         *
         * @param string $orientation Page orientation
         * @param string $unit Unit measure
         * @param string $paperSize Paper size
         *
         * @return \TCPDF implementation
         */
        protected function createExternalWriterInstance($orientation, $unit, $paperSize)
        {
        }
        /**
         * Save Spreadsheet to file.
         *
         * @param string $pFilename Name of the file to save as
         */
        public function save($pFilename) : void
        {
        }
    }
    class Dompdf extends \PhpOffice\PhpSpreadsheet\Writer\Pdf
    {
        /**
         * Gets the implementation of external PDF library that should be used.
         *
         * @return \Dompdf\Dompdf implementation
         */
        protected function createExternalWriterInstance()
        {
        }
        /**
         * Save Spreadsheet to file.
         *
         * @param string $pFilename Name of the file to save as
         */
        public function save($pFilename) : void
        {
        }
    }
    class Mpdf extends \PhpOffice\PhpSpreadsheet\Writer\Pdf
    {
        /**
         * Gets the implementation of external PDF library that should be used.
         *
         * @param array $config Configuration array
         *
         * @return \Mpdf\Mpdf implementation
         */
        protected function createExternalWriterInstance($config)
        {
        }
        /**
         * Save Spreadsheet to file.
         *
         * @param string $pFilename Name of the file to save as
         */
        public function save($pFilename) : void
        {
        }
        /**
         * Convert inches to mm.
         *
         * @param float $inches
         *
         * @return float
         */
        private function inchesToMm($inches)
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Writer {
    class Csv extends \PhpOffice\PhpSpreadsheet\Writer\BaseWriter
    {
        /**
         * PhpSpreadsheet object.
         *
         * @var Spreadsheet
         */
        private $spreadsheet;
        /**
         * Delimiter.
         *
         * @var string
         */
        private $delimiter = ',';
        /**
         * Enclosure.
         *
         * @var string
         */
        private $enclosure = '"';
        /**
         * Line ending.
         *
         * @var string
         */
        private $lineEnding = PHP_EOL;
        /**
         * Sheet index to write.
         *
         * @var int
         */
        private $sheetIndex = 0;
        /**
         * Whether to write a BOM (for UTF8).
         *
         * @var bool
         */
        private $useBOM = false;
        /**
         * Whether to write a Separator line as the first line of the file
         *     sep=x.
         *
         * @var bool
         */
        private $includeSeparatorLine = false;
        /**
         * Whether to write a fully Excel compatible CSV file.
         *
         * @var bool
         */
        private $excelCompatibility = false;
        /**
         * Create a new CSV.
         *
         * @param Spreadsheet $spreadsheet Spreadsheet object
         */
        public function __construct(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
        /**
         * Save PhpSpreadsheet to file.
         *
         * @param resource|string $pFilename
         */
        public function save($pFilename) : void
        {
        }
        /**
         * Get delimiter.
         *
         * @return string
         */
        public function getDelimiter()
        {
        }
        /**
         * Set delimiter.
         *
         * @param string $pValue Delimiter, defaults to ','
         *
         * @return $this
         */
        public function setDelimiter($pValue)
        {
        }
        /**
         * Get enclosure.
         *
         * @return string
         */
        public function getEnclosure()
        {
        }
        /**
         * Set enclosure.
         *
         * @param string $pValue Enclosure, defaults to "
         *
         * @return $this
         */
        public function setEnclosure($pValue)
        {
        }
        /**
         * Get line ending.
         *
         * @return string
         */
        public function getLineEnding()
        {
        }
        /**
         * Set line ending.
         *
         * @param string $pValue Line ending, defaults to OS line ending (PHP_EOL)
         *
         * @return $this
         */
        public function setLineEnding($pValue)
        {
        }
        /**
         * Get whether BOM should be used.
         *
         * @return bool
         */
        public function getUseBOM()
        {
        }
        /**
         * Set whether BOM should be used.
         *
         * @param bool $pValue Use UTF-8 byte-order mark? Defaults to false
         *
         * @return $this
         */
        public function setUseBOM($pValue)
        {
        }
        /**
         * Get whether a separator line should be included.
         *
         * @return bool
         */
        public function getIncludeSeparatorLine()
        {
        }
        /**
         * Set whether a separator line should be included as the first line of the file.
         *
         * @param bool $pValue Use separator line? Defaults to false
         *
         * @return $this
         */
        public function setIncludeSeparatorLine($pValue)
        {
        }
        /**
         * Get whether the file should be saved with full Excel Compatibility.
         *
         * @return bool
         */
        public function getExcelCompatibility()
        {
        }
        /**
         * Set whether the file should be saved with full Excel Compatibility.
         *
         * @param bool $pValue Set the file to be written as a fully Excel compatible csv file
         *                                Note that this overrides other settings such as useBOM, enclosure and delimiter
         *
         * @return $this
         */
        public function setExcelCompatibility($pValue)
        {
        }
        /**
         * Get sheet index.
         *
         * @return int
         */
        public function getSheetIndex()
        {
        }
        /**
         * Set sheet index.
         *
         * @param int $pValue Sheet index
         *
         * @return $this
         */
        public function setSheetIndex($pValue)
        {
        }
        /**
         * Write line to CSV file.
         *
         * @param resource $pFileHandle PHP filehandle
         * @param array $pValues Array containing values in a row
         */
        private function writeLine($pFileHandle, array $pValues) : void
        {
        }
    }
    class Ods extends \PhpOffice\PhpSpreadsheet\Writer\BaseWriter
    {
        /**
         * Private writer parts.
         *
         * @var Ods\WriterPart[]
         */
        private $writerParts = [];
        /**
         * Private PhpSpreadsheet.
         *
         * @var Spreadsheet
         */
        private $spreadSheet;
        /**
         * Create a new Ods.
         */
        public function __construct(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
        /**
         * Get writer part.
         *
         * @param string $pPartName Writer part name
         *
         * @return null|Ods\WriterPart
         */
        public function getWriterPart($pPartName)
        {
        }
        /**
         * Save PhpSpreadsheet to file.
         *
         * @param resource|string $pFilename
         */
        public function save($pFilename) : void
        {
        }
        /**
         * Create zip object.
         *
         * @return ZipStream
         */
        private function createZip()
        {
        }
        /**
         * Get Spreadsheet object.
         *
         * @return Spreadsheet
         */
        public function getSpreadsheet()
        {
        }
        /**
         * Set Spreadsheet object.
         *
         * @param Spreadsheet $spreadsheet PhpSpreadsheet object
         *
         * @return $this
         */
        public function setSpreadsheet(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
    }
    class Xlsx extends \PhpOffice\PhpSpreadsheet\Writer\BaseWriter
    {
        /**
         * Office2003 compatibility.
         *
         * @var bool
         */
        private $office2003compatibility = false;
        /**
         * Private writer parts.
         *
         * @var Xlsx\WriterPart[]
         */
        private $writerParts = [];
        /**
         * Private Spreadsheet.
         *
         * @var Spreadsheet
         */
        private $spreadSheet;
        /**
         * Private string table.
         *
         * @var string[]
         */
        private $stringTable = [];
        /**
         * Private unique Conditional HashTable.
         *
         * @var HashTable
         */
        private $stylesConditionalHashTable;
        /**
         * Private unique Style HashTable.
         *
         * @var HashTable
         */
        private $styleHashTable;
        /**
         * Private unique Fill HashTable.
         *
         * @var HashTable
         */
        private $fillHashTable;
        /**
         * Private unique \PhpOffice\PhpSpreadsheet\Style\Font HashTable.
         *
         * @var HashTable
         */
        private $fontHashTable;
        /**
         * Private unique Borders HashTable.
         *
         * @var HashTable
         */
        private $bordersHashTable;
        /**
         * Private unique NumberFormat HashTable.
         *
         * @var HashTable
         */
        private $numFmtHashTable;
        /**
         * Private unique \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet\BaseDrawing HashTable.
         *
         * @var HashTable
         */
        private $drawingHashTable;
        /**
         * Create a new Xlsx Writer.
         */
        public function __construct(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
        /**
         * Get writer part.
         *
         * @param string $pPartName Writer part name
         *
         * @return \PhpOffice\PhpSpreadsheet\Writer\Xlsx\WriterPart
         */
        public function getWriterPart($pPartName)
        {
        }
        /**
         * Save PhpSpreadsheet to file.
         *
         * @param resource|string $pFilename
         */
        public function save($pFilename) : void
        {
        }
        /**
         * Get Spreadsheet object.
         *
         * @return Spreadsheet
         */
        public function getSpreadsheet()
        {
        }
        /**
         * Set Spreadsheet object.
         *
         * @param Spreadsheet $spreadsheet PhpSpreadsheet object
         *
         * @return $this
         */
        public function setSpreadsheet(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
        /**
         * Get string table.
         *
         * @return string[]
         */
        public function getStringTable()
        {
        }
        /**
         * Get Style HashTable.
         *
         * @return HashTable
         */
        public function getStyleHashTable()
        {
        }
        /**
         * Get Conditional HashTable.
         *
         * @return HashTable
         */
        public function getStylesConditionalHashTable()
        {
        }
        /**
         * Get Fill HashTable.
         *
         * @return HashTable
         */
        public function getFillHashTable()
        {
        }
        /**
         * Get \PhpOffice\PhpSpreadsheet\Style\Font HashTable.
         *
         * @return HashTable
         */
        public function getFontHashTable()
        {
        }
        /**
         * Get Borders HashTable.
         *
         * @return HashTable
         */
        public function getBordersHashTable()
        {
        }
        /**
         * Get NumberFormat HashTable.
         *
         * @return HashTable
         */
        public function getNumFmtHashTable()
        {
        }
        /**
         * Get \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet\BaseDrawing HashTable.
         *
         * @return HashTable
         */
        public function getDrawingHashTable()
        {
        }
        /**
         * Get Office2003 compatibility.
         *
         * @return bool
         */
        public function getOffice2003Compatibility()
        {
        }
        /**
         * Set Office2003 compatibility.
         *
         * @param bool $pValue Office2003 compatibility?
         *
         * @return $this
         */
        public function setOffice2003Compatibility($pValue)
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Writer\Xls {
    // Original file header of PEAR::Spreadsheet_Excel_Writer_BIFFwriter (used as the base for this class):
    // -----------------------------------------------------------------------------------------
    // *  Module written/ported by Xavier Noguer <xnoguer@rezebra.com>
    // *
    // *  The majority of this is _NOT_ my code.  I simply ported it from the
    // *  PERL Spreadsheet::WriteExcel module.
    // *
    // *  The author of the Spreadsheet::WriteExcel module is John McNamara
    // *  <jmcnamara@cpan.org>
    // *
    // *  I _DO_ maintain this code, and John McNamara has nothing to do with the
    // *  porting of this code to PHP.  Any questions directly related to this
    // *  class library should be directed to me.
    // *
    // *  License Information:
    // *
    // *    Spreadsheet_Excel_Writer:  A library for generating Excel Spreadsheets
    // *    Copyright (c) 2002-2003 Xavier Noguer xnoguer@rezebra.com
    // *
    // *    This library is free software; you can redistribute it and/or
    // *    modify it under the terms of the GNU Lesser General Public
    // *    License as published by the Free Software Foundation; either
    // *    version 2.1 of the License, or (at your option) any later version.
    // *
    // *    This library is distributed in the hope that it will be useful,
    // *    but WITHOUT ANY WARRANTY; without even the implied warranty of
    // *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
    // *    Lesser General Public License for more details.
    // *
    // *    You should have received a copy of the GNU Lesser General Public
    // *    License along with this library; if not, write to the Free Software
    // *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
    // */
    class BIFFwriter
    {
        /**
         * The byte order of this architecture. 0 => little endian, 1 => big endian.
         *
         * @var int
         */
        private static $byteOrder;
        /**
         * The string containing the data of the BIFF stream.
         *
         * @var string
         */
        public $_data;
        /**
         * The size of the data in bytes. Should be the same as strlen($this->_data).
         *
         * @var int
         */
        public $_datasize;
        /**
         * The maximum length for a BIFF record (excluding record header and length field). See addContinue().
         *
         * @var int
         *
         * @see addContinue()
         */
        private $limit = 8224;
        /**
         * Constructor.
         */
        public function __construct()
        {
        }
        /**
         * Determine the byte order and store it as class data to avoid
         * recalculating it for each call to new().
         *
         * @return int
         */
        public static function getByteOrder()
        {
        }
        /**
         * General storage function.
         *
         * @param string $data binary data to append
         */
        protected function append($data) : void
        {
        }
        /**
         * General storage function like append, but returns string instead of modifying $this->_data.
         *
         * @param string $data binary data to write
         *
         * @return string
         */
        public function writeData($data)
        {
        }
        /**
         * Writes Excel BOF record to indicate the beginning of a stream or
         * sub-stream in the BIFF file.
         *
         * @param int $type type of BIFF file to write: 0x0005 Workbook,
         *                       0x0010 Worksheet
         */
        protected function storeBof($type) : void
        {
        }
        /**
         * Writes Excel EOF record to indicate the end of a BIFF stream.
         */
        protected function storeEof() : void
        {
        }
        /**
         * Writes Excel EOF record to indicate the end of a BIFF stream.
         */
        public function writeEof()
        {
        }
        /**
         * Excel limits the size of BIFF records. In Excel 5 the limit is 2084 bytes. In
         * Excel 97 the limit is 8228 bytes. Records that are longer than these limits
         * must be split up into CONTINUE blocks.
         *
         * This function takes a long BIFF record and inserts CONTINUE records as
         * necessary.
         *
         * @param string $data The original binary data to be written
         *
         * @return string A very convenient string of continue blocks
         */
        private function addContinue($data)
        {
        }
    }
    // Original file header of PEAR::Spreadsheet_Excel_Writer_Workbook (used as the base for this class):
    // -----------------------------------------------------------------------------------------
    // /*
    // *  Module written/ported by Xavier Noguer <xnoguer@rezebra.com>
    // *
    // *  The majority of this is _NOT_ my code.  I simply ported it from the
    // *  PERL Spreadsheet::WriteExcel module.
    // *
    // *  The author of the Spreadsheet::WriteExcel module is John McNamara
    // *  <jmcnamara@cpan.org>
    // *
    // *  I _DO_ maintain this code, and John McNamara has nothing to do with the
    // *  porting of this code to PHP.  Any questions directly related to this
    // *  class library should be directed to me.
    // *
    // *  License Information:
    // *
    // *    Spreadsheet_Excel_Writer:  A library for generating Excel Spreadsheets
    // *    Copyright (c) 2002-2003 Xavier Noguer xnoguer@rezebra.com
    // *
    // *    This library is free software; you can redistribute it and/or
    // *    modify it under the terms of the GNU Lesser General Public
    // *    License as published by the Free Software Foundation; either
    // *    version 2.1 of the License, or (at your option) any later version.
    // *
    // *    This library is distributed in the hope that it will be useful,
    // *    but WITHOUT ANY WARRANTY; without even the implied warranty of
    // *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
    // *    Lesser General Public License for more details.
    // *
    // *    You should have received a copy of the GNU Lesser General Public
    // *    License along with this library; if not, write to the Free Software
    // *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
    // */
    class Workbook extends \PhpOffice\PhpSpreadsheet\Writer\Xls\BIFFwriter
    {
        /**
         * Formula parser.
         *
         * @var \PhpOffice\PhpSpreadsheet\Writer\Xls\Parser
         */
        private $parser;
        /**
         * The BIFF file size for the workbook.
         *
         * @var int
         *
         * @see calcSheetOffsets()
         */
        private $biffSize;
        /**
         * XF Writers.
         *
         * @var \PhpOffice\PhpSpreadsheet\Writer\Xls\Xf[]
         */
        private $xfWriters = [];
        /**
         * Array containing the colour palette.
         *
         * @var array
         */
        private $palette;
        /**
         * The codepage indicates the text encoding used for strings.
         *
         * @var int
         */
        private $codepage;
        /**
         * The country code used for localization.
         *
         * @var int
         */
        private $countryCode;
        /**
         * Workbook.
         *
         * @var Spreadsheet
         */
        private $spreadsheet;
        /**
         * Fonts writers.
         *
         * @var Font[]
         */
        private $fontWriters = [];
        /**
         * Added fonts. Maps from font's hash => index in workbook.
         *
         * @var array
         */
        private $addedFonts = [];
        /**
         * Shared number formats.
         *
         * @var array
         */
        private $numberFormats = [];
        /**
         * Added number formats. Maps from numberFormat's hash => index in workbook.
         *
         * @var array
         */
        private $addedNumberFormats = [];
        /**
         * Sizes of the binary worksheet streams.
         *
         * @var array
         */
        private $worksheetSizes = [];
        /**
         * Offsets of the binary worksheet streams relative to the start of the global workbook stream.
         *
         * @var array
         */
        private $worksheetOffsets = [];
        /**
         * Total number of shared strings in workbook.
         *
         * @var int
         */
        private $stringTotal;
        /**
         * Number of unique shared strings in workbook.
         *
         * @var int
         */
        private $stringUnique;
        /**
         * Array of unique shared strings in workbook.
         *
         * @var array
         */
        private $stringTable;
        /**
         * Color cache.
         */
        private $colors;
        /**
         * Escher object corresponding to MSODRAWINGGROUP.
         *
         * @var \PhpOffice\PhpSpreadsheet\Shared\Escher
         */
        private $escher;
        /**
         * Class constructor.
         *
         * @param Spreadsheet $spreadsheet The Workbook
         * @param int $str_total Total number of strings
         * @param int $str_unique Total number of unique strings
         * @param array $str_table String Table
         * @param array $colors Colour Table
         * @param Parser $parser The formula parser created for the Workbook
         */
        public function __construct(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet, &$str_total, &$str_unique, &$str_table, &$colors, \PhpOffice\PhpSpreadsheet\Writer\Xls\Parser $parser)
        {
        }
        /**
         * Add a new XF writer.
         *
         * @param bool $isStyleXf Is it a style XF?
         *
         * @return int Index to XF record
         */
        public function addXfWriter(\PhpOffice\PhpSpreadsheet\Style\Style $style, $isStyleXf = false)
        {
        }
        /**
         * Add a font to added fonts.
         *
         * @return int Index to FONT record
         */
        public function addFont(\PhpOffice\PhpSpreadsheet\Style\Font $font)
        {
        }
        /**
         * Alter color palette adding a custom color.
         *
         * @param string $rgb E.g. 'FF00AA'
         *
         * @return int Color index
         */
        private function addColor($rgb)
        {
        }
        /**
         * Sets the colour palette to the Excel 97+ default.
         */
        private function setPaletteXl97() : void
        {
        }
        /**
         * Assemble worksheets into a workbook and send the BIFF data to an OLE
         * storage.
         *
         * @param array $pWorksheetSizes The sizes in bytes of the binary worksheet streams
         *
         * @return string Binary data for workbook stream
         */
        public function writeWorkbook(array $pWorksheetSizes)
        {
        }
        /**
         * Calculate offsets for Worksheet BOF records.
         */
        private function calcSheetOffsets() : void
        {
        }
        /**
         * Store the Excel FONT records.
         */
        private function writeAllFonts() : void
        {
        }
        /**
         * Store user defined numerical formats i.e. FORMAT records.
         */
        private function writeAllNumberFormats() : void
        {
        }
        /**
         * Write all XF records.
         */
        private function writeAllXfs() : void
        {
        }
        /**
         * Write all STYLE records.
         */
        private function writeAllStyles() : void
        {
        }
        /**
         * Writes all the DEFINEDNAME records (BIFF8).
         * So far this is only used for repeating rows/columns (print titles) and print areas.
         */
        private function writeAllDefinedNamesBiff8()
        {
        }
        /**
         * Write a DEFINEDNAME record for BIFF8 using explicit binary formula data.
         *
         * @param string $name The name in UTF-8
         * @param string $formulaData The binary formula data
         * @param int $sheetIndex 1-based sheet index the defined name applies to. 0 = global
         * @param bool $isBuiltIn Built-in name?
         *
         * @return string Complete binary record data
         */
        private function writeDefinedNameBiff8($name, $formulaData, $sheetIndex = 0, $isBuiltIn = false)
        {
        }
        /**
         * Write a short NAME record.
         *
         * @param string $name
         * @param string $sheetIndex 1-based sheet index the defined name applies to. 0 = global
         * @param integer[][] $rangeBounds range boundaries
         * @param bool $isHidden
         *
         * @return string Complete binary record data
         * */
        private function writeShortNameBiff8($name, $sheetIndex, $rangeBounds, $isHidden = false)
        {
        }
        /**
         * Stores the CODEPAGE biff record.
         */
        private function writeCodepage() : void
        {
        }
        /**
         * Write Excel BIFF WINDOW1 record.
         */
        private function writeWindow1() : void
        {
        }
        /**
         * Writes Excel BIFF BOUNDSHEET record.
         *
         * @param Worksheet $sheet Worksheet name
         * @param int $offset Location of worksheet BOF
         */
        private function writeBoundSheet($sheet, $offset) : void
        {
        }
        /**
         * Write Internal SUPBOOK record.
         */
        private function writeSupbookInternal()
        {
        }
        /**
         * Writes the Excel BIFF EXTERNSHEET record. These references are used by
         * formulas.
         */
        private function writeExternalsheetBiff8()
        {
        }
        /**
         * Write Excel BIFF STYLE records.
         */
        private function writeStyle() : void
        {
        }
        /**
         * Writes Excel FORMAT record for non "built-in" numerical formats.
         *
         * @param string $format Custom format string
         * @param int $ifmt Format index code
         */
        private function writeNumberFormat($format, $ifmt) : void
        {
        }
        /**
         * Write DATEMODE record to indicate the date system in use (1904 or 1900).
         */
        private function writeDateMode() : void
        {
        }
        /**
         * Stores the COUNTRY record for localization.
         *
         * @return string
         */
        private function writeCountry()
        {
        }
        /**
         * Write the RECALCID record.
         *
         * @return string
         */
        private function writeRecalcId()
        {
        }
        /**
         * Stores the PALETTE biff record.
         */
        private function writePalette() : void
        {
        }
        /**
         * Handling of the SST continue blocks is complicated by the need to include an
         * additional continuation byte depending on whether the string is split between
         * blocks or whether it starts at the beginning of the block. (There are also
         * additional complications that will arise later when/if Rich Strings are
         * supported).
         *
         * The Excel documentation says that the SST record should be followed by an
         * EXTSST record. The EXTSST record is a hash table that is used to optimise
         * access to SST. However, despite the documentation it doesn't seem to be
         * required so we will ignore it.
         *
         * @return string Binary data
         */
        private function writeSharedStringsTable()
        {
        }
        /**
         * Writes the MSODRAWINGGROUP record if needed. Possibly split using CONTINUE records.
         */
        private function writeMsoDrawingGroup()
        {
        }
        /**
         * Get Escher object.
         *
         * @return \PhpOffice\PhpSpreadsheet\Shared\Escher
         */
        public function getEscher()
        {
        }
        /**
         * Set Escher object.
         *
         * @param \PhpOffice\PhpSpreadsheet\Shared\Escher $pValue
         */
        public function setEscher(?\PhpOffice\PhpSpreadsheet\Shared\Escher $pValue = null) : void
        {
        }
    }
    // Original file header of PEAR::Spreadsheet_Excel_Writer_Worksheet (used as the base for this class):
    // -----------------------------------------------------------------------------------------
    // /*
    // *  Module written/ported by Xavier Noguer <xnoguer@rezebra.com>
    // *
    // *  The majority of this is _NOT_ my code.  I simply ported it from the
    // *  PERL Spreadsheet::WriteExcel module.
    // *
    // *  The author of the Spreadsheet::WriteExcel module is John McNamara
    // *  <jmcnamara@cpan.org>
    // *
    // *  I _DO_ maintain this code, and John McNamara has nothing to do with the
    // *  porting of this code to PHP.  Any questions directly related to this
    // *  class library should be directed to me.
    // *
    // *  License Information:
    // *
    // *    Spreadsheet_Excel_Writer:  A library for generating Excel Spreadsheets
    // *    Copyright (c) 2002-2003 Xavier Noguer xnoguer@rezebra.com
    // *
    // *    This library is free software; you can redistribute it and/or
    // *    modify it under the terms of the GNU Lesser General Public
    // *    License as published by the Free Software Foundation; either
    // *    version 2.1 of the License, or (at your option) any later version.
    // *
    // *    This library is distributed in the hope that it will be useful,
    // *    but WITHOUT ANY WARRANTY; without even the implied warranty of
    // *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
    // *    Lesser General Public License for more details.
    // *
    // *    You should have received a copy of the GNU Lesser General Public
    // *    License along with this library; if not, write to the Free Software
    // *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
    // */
    class Worksheet extends \PhpOffice\PhpSpreadsheet\Writer\Xls\BIFFwriter
    {
        /**
         * Formula parser.
         *
         * @var \PhpOffice\PhpSpreadsheet\Writer\Xls\Parser
         */
        private $parser;
        /**
         * Maximum number of characters for a string (LABEL record in BIFF5).
         *
         * @var int
         */
        private $xlsStringMaxLength;
        /**
         * Array containing format information for columns.
         *
         * @var array
         */
        private $columnInfo;
        /**
         * Array containing the selected area for the worksheet.
         *
         * @var array
         */
        private $selection;
        /**
         * The active pane for the worksheet.
         *
         * @var int
         */
        private $activePane;
        /**
         * Whether to use outline.
         *
         * @var int
         */
        private $outlineOn;
        /**
         * Auto outline styles.
         *
         * @var bool
         */
        private $outlineStyle;
        /**
         * Whether to have outline summary below.
         *
         * @var bool
         */
        private $outlineBelow;
        /**
         * Whether to have outline summary at the right.
         *
         * @var bool
         */
        private $outlineRight;
        /**
         * Reference to the total number of strings in the workbook.
         *
         * @var int
         */
        private $stringTotal;
        /**
         * Reference to the number of unique strings in the workbook.
         *
         * @var int
         */
        private $stringUnique;
        /**
         * Reference to the array containing all the unique strings in the workbook.
         *
         * @var array
         */
        private $stringTable;
        /**
         * Color cache.
         */
        private $colors;
        /**
         * Index of first used row (at least 0).
         *
         * @var int
         */
        private $firstRowIndex;
        /**
         * Index of last used row. (no used rows means -1).
         *
         * @var int
         */
        private $lastRowIndex;
        /**
         * Index of first used column (at least 0).
         *
         * @var int
         */
        private $firstColumnIndex;
        /**
         * Index of last used column (no used columns means -1).
         *
         * @var int
         */
        private $lastColumnIndex;
        /**
         * Sheet object.
         *
         * @var \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet
         */
        public $phpSheet;
        /**
         * Count cell style Xfs.
         *
         * @var int
         */
        private $countCellStyleXfs;
        /**
         * Escher object corresponding to MSODRAWING.
         *
         * @var \PhpOffice\PhpSpreadsheet\Shared\Escher
         */
        private $escher;
        /**
         * Array of font hashes associated to FONT records index.
         *
         * @var array
         */
        public $fontHashIndex;
        /**
         * @var bool
         */
        private $preCalculateFormulas;
        /**
         * @var int
         */
        private $printHeaders;
        /**
         * Constructor.
         *
         * @param int $str_total Total number of strings
         * @param int $str_unique Total number of unique strings
         * @param array &$str_table String Table
         * @param array &$colors Colour Table
         * @param Parser $parser The formula parser created for the Workbook
         * @param bool $preCalculateFormulas Flag indicating whether formulas should be calculated or just written
         * @param \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $phpSheet The worksheet to write
         */
        public function __construct(&$str_total, &$str_unique, &$str_table, &$colors, \PhpOffice\PhpSpreadsheet\Writer\Xls\Parser $parser, $preCalculateFormulas, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $phpSheet)
        {
        }
        /**
         * Add data to the beginning of the workbook (note the reverse order)
         * and to the end of the workbook.
         *
         * @see \PhpOffice\PhpSpreadsheet\Writer\Xls\Workbook::storeWorkbook()
         */
        public function close() : void
        {
        }
        /**
         * Write a cell range address in BIFF8
         * always fixed range
         * See section 2.5.14 in OpenOffice.org's Documentation of the Microsoft Excel File Format.
         *
         * @param string $range E.g. 'A1' or 'A1:B6'
         *
         * @return string Binary data
         */
        private function writeBIFF8CellRangeAddressFixed($range)
        {
        }
        /**
         * Retrieves data from memory in one chunk, or from disk in $buffer
         * sized chunks.
         *
         * @return string The data
         */
        public function getData()
        {
        }
        /**
         * Set the option to print the row and column headers on the printed page.
         *
         * @param int $print Whether to print the headers or not. Defaults to 1 (print).
         */
        public function printRowColHeaders($print = 1) : void
        {
        }
        /**
         * This method sets the properties for outlining and grouping. The defaults
         * correspond to Excel's defaults.
         *
         * @param bool $visible
         * @param bool $symbols_below
         * @param bool $symbols_right
         * @param bool $auto_style
         */
        public function setOutline($visible = true, $symbols_below = true, $symbols_right = true, $auto_style = false) : void
        {
        }
        /**
         * Write a double to the specified row and column (zero indexed).
         * An integer can be written as a double. Excel will display an
         * integer. $format is optional.
         *
         * Returns  0 : normal termination
         *         -2 : row or column out of range
         *
         * @param int $row Zero indexed row
         * @param int $col Zero indexed column
         * @param float $num The number to write
         * @param mixed $xfIndex The optional XF format
         *
         * @return int
         */
        private function writeNumber($row, $col, $num, $xfIndex)
        {
        }
        /**
         * Write a LABELSST record or a LABEL record. Which one depends on BIFF version.
         *
         * @param int $row Row index (0-based)
         * @param int $col Column index (0-based)
         * @param string $str The string
         * @param int $xfIndex Index to XF record
         */
        private function writeString($row, $col, $str, $xfIndex) : void
        {
        }
        /**
         * Write a LABELSST record or a LABEL record. Which one depends on BIFF version
         * It differs from writeString by the writing of rich text strings.
         *
         * @param int $row Row index (0-based)
         * @param int $col Column index (0-based)
         * @param string $str The string
         * @param int $xfIndex The XF format index for the cell
         * @param array $arrcRun Index to Font record and characters beginning
         */
        private function writeRichTextString($row, $col, $str, $xfIndex, $arrcRun) : void
        {
        }
        /**
         * Write a string to the specified row and column (zero indexed).
         * This is the BIFF8 version (no 255 chars limit).
         * $format is optional.
         *
         * @param int $row Zero indexed row
         * @param int $col Zero indexed column
         * @param string $str The string to write
         * @param mixed $xfIndex The XF format index for the cell
         */
        private function writeLabelSst($row, $col, $str, $xfIndex) : void
        {
        }
        /**
         * Write a blank cell to the specified row and column (zero indexed).
         * A blank cell is used to specify formatting without adding a string
         * or a number.
         *
         * A blank cell without a format serves no purpose. Therefore, we don't write
         * a BLANK record unless a format is specified.
         *
         * Returns  0 : normal termination (including no format)
         *         -1 : insufficient number of arguments
         *         -2 : row or column out of range
         *
         * @param int $row Zero indexed row
         * @param int $col Zero indexed column
         * @param mixed $xfIndex The XF format index
         *
         * @return int
         */
        public function writeBlank($row, $col, $xfIndex)
        {
        }
        /**
         * Write a boolean or an error type to the specified row and column (zero indexed).
         *
         * @param int $row Row index (0-based)
         * @param int $col Column index (0-based)
         * @param int $value
         * @param bool $isError Error or Boolean?
         * @param int $xfIndex
         *
         * @return int
         */
        private function writeBoolErr($row, $col, $value, $isError, $xfIndex)
        {
        }
        const WRITE_FORMULA_NORMAL = 0;
        const WRITE_FORMULA_ERRORS = -1;
        const WRITE_FORMULA_RANGE = -2;
        const WRITE_FORMULA_EXCEPTION = -3;
        /**
         * Write a formula to the specified row and column (zero indexed).
         * The textual representation of the formula is passed to the parser in
         * Parser.php which returns a packed binary string.
         *
         * Returns  0 : WRITE_FORMULA_NORMAL  normal termination
         *         -1 : WRITE_FORMULA_ERRORS formula errors (bad formula)
         *         -2 : WRITE_FORMULA_RANGE  row or column out of range
         *         -3 : WRITE_FORMULA_EXCEPTION parse raised exception, probably due to definedname
         *
         * @param int $row Zero indexed row
         * @param int $col Zero indexed column
         * @param string $formula The formula text string
         * @param mixed $xfIndex The XF format index
         * @param mixed $calculatedValue Calculated value
         *
         * @return int
         */
        private function writeFormula($row, $col, $formula, $xfIndex, $calculatedValue)
        {
        }
        /**
         * Write a STRING record. This.
         *
         * @param string $stringValue
         */
        private function writeStringRecord($stringValue) : void
        {
        }
        /**
         * Write a hyperlink.
         * This is comprised of two elements: the visible label and
         * the invisible link. The visible label is the same as the link unless an
         * alternative string is specified. The label is written using the
         * writeString() method. Therefore the 255 characters string limit applies.
         * $string and $format are optional.
         *
         * The hyperlink can be to a http, ftp, mail, internal sheet (not yet), or external
         * directory url.
         *
         * Returns  0 : normal termination
         *         -2 : row or column out of range
         *         -3 : long string truncated to 255 chars
         *
         * @param int $row Row
         * @param int $col Column
         * @param string $url URL string
         *
         * @return int
         */
        private function writeUrl($row, $col, $url)
        {
        }
        /**
         * This is the more general form of writeUrl(). It allows a hyperlink to be
         * written to a range of cells. This function also decides the type of hyperlink
         * to be written. These are either, Web (http, ftp, mailto), Internal
         * (Sheet1!A1) or external ('c:\temp\foo.xls#Sheet1!A1').
         *
         * @param int $row1 Start row
         * @param int $col1 Start column
         * @param int $row2 End row
         * @param int $col2 End column
         * @param string $url URL string
         *
         * @return int
         *
         * @see writeUrl()
         */
        public function writeUrlRange($row1, $col1, $row2, $col2, $url)
        {
        }
        /**
         * Used to write http, ftp and mailto hyperlinks.
         * The link type ($options) is 0x03 is the same as absolute dir ref without
         * sheet. However it is differentiated by the $unknown2 data stream.
         *
         * @param int $row1 Start row
         * @param int $col1 Start column
         * @param int $row2 End row
         * @param int $col2 End column
         * @param string $url URL string
         *
         * @return int
         *
         * @see writeUrl()
         */
        public function writeUrlWeb($row1, $col1, $row2, $col2, $url)
        {
        }
        /**
         * Used to write internal reference hyperlinks such as "Sheet1!A1".
         *
         * @param int $row1 Start row
         * @param int $col1 Start column
         * @param int $row2 End row
         * @param int $col2 End column
         * @param string $url URL string
         *
         * @return int
         *
         * @see writeUrl()
         */
        public function writeUrlInternal($row1, $col1, $row2, $col2, $url)
        {
        }
        /**
         * Write links to external directory names such as 'c:\foo.xls',
         * c:\foo.xls#Sheet1!A1', '../../foo.xls'. and '../../foo.xls#Sheet1!A1'.
         *
         * Note: Excel writes some relative links with the $dir_long string. We ignore
         * these cases for the sake of simpler code.
         *
         * @param int $row1 Start row
         * @param int $col1 Start column
         * @param int $row2 End row
         * @param int $col2 End column
         * @param string $url URL string
         *
         * @return int
         *
         * @see writeUrl()
         */
        public function writeUrlExternal($row1, $col1, $row2, $col2, $url)
        {
        }
        /**
         * This method is used to set the height and format for a row.
         *
         * @param int $row The row to set
         * @param int $height Height we are giving to the row.
         *                        Use null to set XF without setting height
         * @param int $xfIndex The optional cell style Xf index to apply to the columns
         * @param bool $hidden The optional hidden attribute
         * @param int $level The optional outline level for row, in range [0,7]
         */
        private function writeRow($row, $height, $xfIndex, $hidden = false, $level = 0) : void
        {
        }
        /**
         * Writes Excel DIMENSIONS to define the area in which there is data.
         */
        private function writeDimensions() : void
        {
        }
        /**
         * Write BIFF record Window2.
         */
        private function writeWindow2() : void
        {
        }
        /**
         * Write BIFF record DEFAULTROWHEIGHT.
         */
        private function writeDefaultRowHeight() : void
        {
        }
        /**
         * Write BIFF record DEFCOLWIDTH if COLINFO records are in use.
         */
        private function writeDefcol() : void
        {
        }
        /**
         * Write BIFF record COLINFO to define column widths.
         *
         * Note: The SDK says the record length is 0x0B but Excel writes a 0x0C
         * length record.
         *
         * @param array $col_array This is the only parameter received and is composed of the following:
         *                0 => First formatted column,
         *                1 => Last formatted column,
         *                2 => Col width (8.43 is Excel default),
         *                3 => The optional XF format of the column,
         *                4 => Option flags.
         *                5 => Optional outline level
         */
        private function writeColinfo($col_array) : void
        {
        }
        /**
         * Write BIFF record SELECTION.
         */
        private function writeSelection() : void
        {
        }
        /**
         * Store the MERGEDCELLS records for all ranges of merged cells.
         */
        private function writeMergedCells() : void
        {
        }
        /**
         * Write SHEETLAYOUT record.
         */
        private function writeSheetLayout() : void
        {
        }
        /**
         * Write SHEETPROTECTION.
         */
        private function writeSheetProtection() : void
        {
        }
        /**
         * Write BIFF record RANGEPROTECTION.
         *
         * Openoffice.org's Documentaion of the Microsoft Excel File Format uses term RANGEPROTECTION for these records
         * Microsoft Office Excel 97-2007 Binary File Format Specification uses term FEAT for these records
         */
        private function writeRangeProtection() : void
        {
        }
        /**
         * Writes the Excel BIFF PANE record.
         * The panes can either be frozen or thawed (unfrozen).
         * Frozen panes are specified in terms of an integer number of rows and columns.
         * Thawed panes are specified in terms of Excel's units for rows and columns.
         */
        private function writePanes() : void
        {
        }
        /**
         * Store the page setup SETUP BIFF record.
         */
        private function writeSetup() : void
        {
        }
        /**
         * Store the header caption BIFF record.
         */
        private function writeHeader() : void
        {
        }
        /**
         * Store the footer caption BIFF record.
         */
        private function writeFooter() : void
        {
        }
        /**
         * Store the horizontal centering HCENTER BIFF record.
         */
        private function writeHcenter() : void
        {
        }
        /**
         * Store the vertical centering VCENTER BIFF record.
         */
        private function writeVcenter() : void
        {
        }
        /**
         * Store the LEFTMARGIN BIFF record.
         */
        private function writeMarginLeft() : void
        {
        }
        /**
         * Store the RIGHTMARGIN BIFF record.
         */
        private function writeMarginRight() : void
        {
        }
        /**
         * Store the TOPMARGIN BIFF record.
         */
        private function writeMarginTop() : void
        {
        }
        /**
         * Store the BOTTOMMARGIN BIFF record.
         */
        private function writeMarginBottom() : void
        {
        }
        /**
         * Write the PRINTHEADERS BIFF record.
         */
        private function writePrintHeaders() : void
        {
        }
        /**
         * Write the PRINTGRIDLINES BIFF record. Must be used in conjunction with the
         * GRIDSET record.
         */
        private function writePrintGridlines() : void
        {
        }
        /**
         * Write the GRIDSET BIFF record. Must be used in conjunction with the
         * PRINTGRIDLINES record.
         */
        private function writeGridset() : void
        {
        }
        /**
         * Write the AUTOFILTERINFO BIFF record. This is used to configure the number of autofilter select used in the sheet.
         */
        private function writeAutoFilterInfo() : void
        {
        }
        /**
         * Write the GUTS BIFF record. This is used to configure the gutter margins
         * where Excel outline symbols are displayed. The visibility of the gutters is
         * controlled by a flag in WSBOOL.
         *
         * @see writeWsbool()
         */
        private function writeGuts() : void
        {
        }
        /**
         * Write the WSBOOL BIFF record, mainly for fit-to-page. Used in conjunction
         * with the SETUP record.
         */
        private function writeWsbool() : void
        {
        }
        /**
         * Write the HORIZONTALPAGEBREAKS and VERTICALPAGEBREAKS BIFF records.
         */
        private function writeBreaks() : void
        {
        }
        /**
         * Set the Biff PROTECT record to indicate that the worksheet is protected.
         */
        private function writeProtect() : void
        {
        }
        /**
         * Write SCENPROTECT.
         */
        private function writeScenProtect() : void
        {
        }
        /**
         * Write OBJECTPROTECT.
         */
        private function writeObjectProtect() : void
        {
        }
        /**
         * Write the worksheet PASSWORD record.
         */
        private function writePassword() : void
        {
        }
        /**
         * Insert a 24bit bitmap image in a worksheet.
         *
         * @param int $row The row we are going to insert the bitmap into
         * @param int $col The column we are going to insert the bitmap into
         * @param mixed $bitmap The bitmap filename or GD-image resource
         * @param int $x the horizontal position (offset) of the image inside the cell
         * @param int $y the vertical position (offset) of the image inside the cell
         * @param float $scale_x The horizontal scale
         * @param float $scale_y The vertical scale
         */
        public function insertBitmap($row, $col, $bitmap, $x = 0, $y = 0, $scale_x = 1, $scale_y = 1) : void
        {
        }
        /**
         * Calculate the vertices that define the position of the image as required by
         * the OBJ record.
         *
         *         +------------+------------+
         *         |     A      |      B     |
         *   +-----+------------+------------+
         *   |     |(x1,y1)     |            |
         *   |  1  |(A1)._______|______      |
         *   |     |    |              |     |
         *   |     |    |              |     |
         *   +-----+----|    BITMAP    |-----+
         *   |     |    |              |     |
         *   |  2  |    |______________.     |
         *   |     |            |        (B2)|
         *   |     |            |     (x2,y2)|
         *   +---- +------------+------------+
         *
         * Example of a bitmap that covers some of the area from cell A1 to cell B2.
         *
         * Based on the width and height of the bitmap we need to calculate 8 vars:
         *     $col_start, $row_start, $col_end, $row_end, $x1, $y1, $x2, $y2.
         * The width and height of the cells are also variable and have to be taken into
         * account.
         * The values of $col_start and $row_start are passed in from the calling
         * function. The values of $col_end and $row_end are calculated by subtracting
         * the width and height of the bitmap from the width and height of the
         * underlying cells.
         * The vertices are expressed as a percentage of the underlying cell width as
         * follows (rhs values are in pixels):
         *
         *       x1 = X / W *1024
         *       y1 = Y / H *256
         *       x2 = (X-1) / W *1024
         *       y2 = (Y-1) / H *256
         *
         *       Where:  X is distance from the left side of the underlying cell
         *               Y is distance from the top of the underlying cell
         *               W is the width of the cell
         *               H is the height of the cell
         * The SDK incorrectly states that the height should be expressed as a
         *        percentage of 1024.
         *
         * @param int $col_start Col containing upper left corner of object
         * @param int $row_start Row containing top left corner of object
         * @param int $x1 Distance to left side of object
         * @param int $y1 Distance to top of object
         * @param int $width Width of image frame
         * @param int $height Height of image frame
         */
        public function positionImage($col_start, $row_start, $x1, $y1, $width, $height) : void
        {
        }
        /**
         * Store the OBJ record that precedes an IMDATA record. This could be generalise
         * to support other Excel objects.
         *
         * @param int $colL Column containing upper left corner of object
         * @param int $dxL Distance from left side of cell
         * @param int $rwT Row containing top left corner of object
         * @param int $dyT Distance from top of cell
         * @param int $colR Column containing lower right corner of object
         * @param int $dxR Distance from right of cell
         * @param int $rwB Row containing bottom right corner of object
         * @param int $dyB Distance from bottom of cell
         */
        private function writeObjPicture($colL, $dxL, $rwT, $dyT, $colR, $dxR, $rwB, $dyB) : void
        {
        }
        /**
         * Convert a GD-image into the internal format.
         *
         * @param resource $image The image to process
         *
         * @return array Array with data and properties of the bitmap
         */
        public function processBitmapGd($image)
        {
        }
        /**
         * Convert a 24 bit bitmap into the modified internal format used by Windows.
         * This is described in BITMAPCOREHEADER and BITMAPCOREINFO structures in the
         * MSDN library.
         *
         * @param string $bitmap The bitmap to process
         *
         * @return array Array with data and properties of the bitmap
         */
        public function processBitmap($bitmap)
        {
        }
        /**
         * Store the window zoom factor. This should be a reduced fraction but for
         * simplicity we will store all fractions with a numerator of 100.
         */
        private function writeZoom() : void
        {
        }
        /**
         * Get Escher object.
         *
         * @return \PhpOffice\PhpSpreadsheet\Shared\Escher
         */
        public function getEscher()
        {
        }
        /**
         * Set Escher object.
         *
         * @param \PhpOffice\PhpSpreadsheet\Shared\Escher $pValue
         */
        public function setEscher(?\PhpOffice\PhpSpreadsheet\Shared\Escher $pValue = null) : void
        {
        }
        /**
         * Write MSODRAWING record.
         */
        private function writeMsoDrawing() : void
        {
        }
        /**
         * Store the DATAVALIDATIONS and DATAVALIDATION records.
         */
        private function writeDataValidity() : void
        {
        }
        /**
         * Map Error code.
         *
         * @param string $errorCode
         *
         * @return int
         */
        private static function mapErrorCode($errorCode)
        {
        }
        /**
         * Write PLV Record.
         */
        private function writePageLayoutView() : void
        {
        }
        /**
         * Write CFRule Record.
         */
        private function writeCFRule(\PhpOffice\PhpSpreadsheet\Style\Conditional $conditional) : void
        {
        }
        /**
         * Write CFHeader record.
         */
        private function writeCFHeader() : void
        {
        }
    }
    class Font
    {
        /**
         * Color index.
         *
         * @var int
         */
        private $colorIndex;
        /**
         * Font.
         *
         * @var \PhpOffice\PhpSpreadsheet\Style\Font
         */
        private $font;
        /**
         * Constructor.
         */
        public function __construct(\PhpOffice\PhpSpreadsheet\Style\Font $font)
        {
        }
        /**
         * Set the color index.
         *
         * @param int $colorIndex
         */
        public function setColorIndex($colorIndex) : void
        {
        }
        /**
         * Get font record data.
         *
         * @return string
         */
        public function writeFont()
        {
        }
        /**
         * Map to BIFF5-BIFF8 codes for bold.
         *
         * @param bool $bold
         *
         * @return int
         */
        private static function mapBold($bold)
        {
        }
        /**
         * Map of BIFF2-BIFF8 codes for underline styles.
         *
         * @var array of int
         */
        private static $mapUnderline = [\PhpOffice\PhpSpreadsheet\Style\Font::UNDERLINE_NONE => 0x0, \PhpOffice\PhpSpreadsheet\Style\Font::UNDERLINE_SINGLE => 0x1, \PhpOffice\PhpSpreadsheet\Style\Font::UNDERLINE_DOUBLE => 0x2, \PhpOffice\PhpSpreadsheet\Style\Font::UNDERLINE_SINGLEACCOUNTING => 0x21, \PhpOffice\PhpSpreadsheet\Style\Font::UNDERLINE_DOUBLEACCOUNTING => 0x22];
        /**
         * Map underline.
         *
         * @param string $underline
         *
         * @return int
         */
        private static function mapUnderline($underline)
        {
        }
    }
    class Escher
    {
        /**
         * The object we are writing.
         */
        private $object;
        /**
         * The written binary data.
         */
        private $data;
        /**
         * Shape offsets. Positions in binary stream where a new shape record begins.
         *
         * @var array
         */
        private $spOffsets;
        /**
         * Shape types.
         *
         * @var array
         */
        private $spTypes;
        /**
         * Constructor.
         *
         * @param mixed $object
         */
        public function __construct($object)
        {
        }
        /**
         * Process the object to be written.
         *
         * @return string
         */
        public function close()
        {
        }
        /**
         * Gets the shape offsets.
         *
         * @return array
         */
        public function getSpOffsets()
        {
        }
        /**
         * Gets the shape types.
         *
         * @return array
         */
        public function getSpTypes()
        {
        }
    }
    // Original file header of PEAR::Spreadsheet_Excel_Writer_Format (used as the base for this class):
    // -----------------------------------------------------------------------------------------
    // /*
    // *  Module written/ported by Xavier Noguer <xnoguer@rezebra.com>
    // *
    // *  The majority of this is _NOT_ my code.  I simply ported it from the
    // *  PERL Spreadsheet::WriteExcel module.
    // *
    // *  The author of the Spreadsheet::WriteExcel module is John McNamara
    // *  <jmcnamara@cpan.org>
    // *
    // *  I _DO_ maintain this code, and John McNamara has nothing to do with the
    // *  porting of this code to PHP.  Any questions directly related to this
    // *  class library should be directed to me.
    // *
    // *  License Information:
    // *
    // *    Spreadsheet_Excel_Writer:  A library for generating Excel Spreadsheets
    // *    Copyright (c) 2002-2003 Xavier Noguer xnoguer@rezebra.com
    // *
    // *    This library is free software; you can redistribute it and/or
    // *    modify it under the terms of the GNU Lesser General Public
    // *    License as published by the Free Software Foundation; either
    // *    version 2.1 of the License, or (at your option) any later version.
    // *
    // *    This library is distributed in the hope that it will be useful,
    // *    but WITHOUT ANY WARRANTY; without even the implied warranty of
    // *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
    // *    Lesser General Public License for more details.
    // *
    // *    You should have received a copy of the GNU Lesser General Public
    // *    License along with this library; if not, write to the Free Software
    // *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
    // */
    class Xf
    {
        /**
         * Style XF or a cell XF ?
         *
         * @var bool
         */
        private $isStyleXf;
        /**
         * Index to the FONT record. Index 4 does not exist.
         *
         * @var int
         */
        private $fontIndex;
        /**
         * An index (2 bytes) to a FORMAT record (number format).
         *
         * @var int
         */
        private $numberFormatIndex;
        /**
         * 1 bit, apparently not used.
         *
         * @var int
         */
        private $textJustLast;
        /**
         * The cell's foreground color.
         *
         * @var int
         */
        private $foregroundColor;
        /**
         * The cell's background color.
         *
         * @var int
         */
        private $backgroundColor;
        /**
         * Color of the bottom border of the cell.
         *
         * @var int
         */
        private $bottomBorderColor;
        /**
         * Color of the top border of the cell.
         *
         * @var int
         */
        private $topBorderColor;
        /**
         * Color of the left border of the cell.
         *
         * @var int
         */
        private $leftBorderColor;
        /**
         * Color of the right border of the cell.
         *
         * @var int
         */
        private $rightBorderColor;
        /**
         * Constructor.
         *
         * @param Style $style The XF format
         */
        public function __construct(\PhpOffice\PhpSpreadsheet\Style\Style $style)
        {
        }
        /**
         * Generate an Excel BIFF XF record (style or cell).
         *
         * @return string The XF record
         */
        public function writeXf()
        {
        }
        /**
         * Is this a style XF ?
         *
         * @param bool $value
         */
        public function setIsStyleXf($value) : void
        {
        }
        /**
         * Sets the cell's bottom border color.
         *
         * @param int $colorIndex Color index
         */
        public function setBottomColor($colorIndex) : void
        {
        }
        /**
         * Sets the cell's top border color.
         *
         * @param int $colorIndex Color index
         */
        public function setTopColor($colorIndex) : void
        {
        }
        /**
         * Sets the cell's left border color.
         *
         * @param int $colorIndex Color index
         */
        public function setLeftColor($colorIndex) : void
        {
        }
        /**
         * Sets the cell's right border color.
         *
         * @param int $colorIndex Color index
         */
        public function setRightColor($colorIndex) : void
        {
        }
        /**
         * Sets the cell's diagonal border color.
         *
         * @param int $colorIndex Color index
         */
        public function setDiagColor($colorIndex) : void
        {
        }
        /**
         * Sets the cell's foreground color.
         *
         * @param int $colorIndex Color index
         */
        public function setFgColor($colorIndex) : void
        {
        }
        /**
         * Sets the cell's background color.
         *
         * @param int $colorIndex Color index
         */
        public function setBgColor($colorIndex) : void
        {
        }
        /**
         * Sets the index to the number format record
         * It can be date, time, currency, etc...
         *
         * @param int $numberFormatIndex Index to format record
         */
        public function setNumberFormatIndex($numberFormatIndex) : void
        {
        }
        /**
         * Set the font index.
         *
         * @param int $value Font index, note that value 4 does not exist
         */
        public function setFontIndex($value) : void
        {
        }
        /**
         * Map of BIFF2-BIFF8 codes for border styles.
         *
         * @var array of int
         */
        private static $mapBorderStyles = [\PhpOffice\PhpSpreadsheet\Style\Border::BORDER_NONE => 0x0, \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_THIN => 0x1, \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_MEDIUM => 0x2, \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_DASHED => 0x3, \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_DOTTED => 0x4, \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_THICK => 0x5, \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_DOUBLE => 0x6, \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_HAIR => 0x7, \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_MEDIUMDASHED => 0x8, \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_DASHDOT => 0x9, \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_MEDIUMDASHDOT => 0xa, \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_DASHDOTDOT => 0xb, \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_MEDIUMDASHDOTDOT => 0xc, \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_SLANTDASHDOT => 0xd];
        /**
         * Map border style.
         *
         * @param string $borderStyle
         *
         * @return int
         */
        private static function mapBorderStyle($borderStyle)
        {
        }
        /**
         * Map of BIFF2-BIFF8 codes for fill types.
         *
         * @var array of int
         */
        private static $mapFillTypes = [
            \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_NONE => 0x0,
            \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_SOLID => 0x1,
            \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_MEDIUMGRAY => 0x2,
            \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_DARKGRAY => 0x3,
            \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_LIGHTGRAY => 0x4,
            \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_DARKHORIZONTAL => 0x5,
            \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_DARKVERTICAL => 0x6,
            \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_DARKDOWN => 0x7,
            \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_DARKUP => 0x8,
            \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_DARKGRID => 0x9,
            \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_DARKTRELLIS => 0xa,
            \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_LIGHTHORIZONTAL => 0xb,
            \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_LIGHTVERTICAL => 0xc,
            \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_LIGHTDOWN => 0xd,
            \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_LIGHTUP => 0xe,
            \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_LIGHTGRID => 0xf,
            \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_LIGHTTRELLIS => 0x10,
            \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_GRAY125 => 0x11,
            \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_PATTERN_GRAY0625 => 0x12,
            \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_GRADIENT_LINEAR => 0x0,
            // does not exist in BIFF8
            \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_GRADIENT_PATH => 0x0,
        ];
        /**
         * Map fill type.
         *
         * @param string $fillType
         *
         * @return int
         */
        private static function mapFillType($fillType)
        {
        }
        /**
         * Map of BIFF2-BIFF8 codes for horizontal alignment.
         *
         * @var array of int
         */
        private static $mapHAlignments = [\PhpOffice\PhpSpreadsheet\Style\Alignment::HORIZONTAL_GENERAL => 0, \PhpOffice\PhpSpreadsheet\Style\Alignment::HORIZONTAL_LEFT => 1, \PhpOffice\PhpSpreadsheet\Style\Alignment::HORIZONTAL_CENTER => 2, \PhpOffice\PhpSpreadsheet\Style\Alignment::HORIZONTAL_RIGHT => 3, \PhpOffice\PhpSpreadsheet\Style\Alignment::HORIZONTAL_FILL => 4, \PhpOffice\PhpSpreadsheet\Style\Alignment::HORIZONTAL_JUSTIFY => 5, \PhpOffice\PhpSpreadsheet\Style\Alignment::HORIZONTAL_CENTER_CONTINUOUS => 6];
        /**
         * Map to BIFF2-BIFF8 codes for horizontal alignment.
         *
         * @param string $hAlign
         *
         * @return int
         */
        private function mapHAlign($hAlign)
        {
        }
        /**
         * Map of BIFF2-BIFF8 codes for vertical alignment.
         *
         * @var array of int
         */
        private static $mapVAlignments = [\PhpOffice\PhpSpreadsheet\Style\Alignment::VERTICAL_TOP => 0, \PhpOffice\PhpSpreadsheet\Style\Alignment::VERTICAL_CENTER => 1, \PhpOffice\PhpSpreadsheet\Style\Alignment::VERTICAL_BOTTOM => 2, \PhpOffice\PhpSpreadsheet\Style\Alignment::VERTICAL_JUSTIFY => 3];
        /**
         * Map to BIFF2-BIFF8 codes for vertical alignment.
         *
         * @param string $vAlign
         *
         * @return int
         */
        private static function mapVAlign($vAlign)
        {
        }
        /**
         * Map to BIFF8 codes for text rotation angle.
         *
         * @param int $textRotation
         *
         * @return int
         */
        private static function mapTextRotation($textRotation)
        {
        }
        /**
         * Map locked.
         *
         * @param string $locked
         *
         * @return int
         */
        private static function mapLocked($locked)
        {
        }
        /**
         * Map hidden.
         *
         * @param string $hidden
         *
         * @return int
         */
        private static function mapHidden($hidden)
        {
        }
    }
    // Original file header of PEAR::Spreadsheet_Excel_Writer_Parser (used as the base for this class):
    // -----------------------------------------------------------------------------------------
    // *  Class for parsing Excel formulas
    // *
    // *  License Information:
    // *
    // *    Spreadsheet_Excel_Writer:  A library for generating Excel Spreadsheets
    // *    Copyright (c) 2002-2003 Xavier Noguer xnoguer@rezebra.com
    // *
    // *    This library is free software; you can redistribute it and/or
    // *    modify it under the terms of the GNU Lesser General Public
    // *    License as published by the Free Software Foundation; either
    // *    version 2.1 of the License, or (at your option) any later version.
    // *
    // *    This library is distributed in the hope that it will be useful,
    // *    but WITHOUT ANY WARRANTY; without even the implied warranty of
    // *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
    // *    Lesser General Public License for more details.
    // *
    // *    You should have received a copy of the GNU Lesser General Public
    // *    License along with this library; if not, write to the Free Software
    // *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
    // */
    class Parser
    {
        /**    Constants                */
        // Sheet title in unquoted form
        // Invalid sheet title characters cannot occur in the sheet title:
        //         *:/\?[]
        // Moreover, there are valid sheet title characters that cannot occur in unquoted form (there may be more?)
        // +-% '^&<>=,;#()"{}
        const REGEX_SHEET_TITLE_UNQUOTED = '[^\\*\\:\\/\\\\\\?\\[\\]\\+\\-\\% \\\'\\^\\&\\<\\>\\=\\,\\;\\#\\(\\)\\"\\{\\}]+';
        // Sheet title in quoted form (without surrounding quotes)
        // Invalid sheet title characters cannot occur in the sheet title:
        // *:/\?[]                    (usual invalid sheet title characters)
        // Single quote is represented as a pair ''
        const REGEX_SHEET_TITLE_QUOTED = '(([^\\*\\:\\/\\\\\\?\\[\\]\\\'])+|(\\\'\\\')+)+';
        /**
         * The index of the character we are currently looking at.
         *
         * @var int
         */
        public $currentCharacter;
        /**
         * The token we are working on.
         *
         * @var string
         */
        public $currentToken;
        /**
         * The formula to parse.
         *
         * @var string
         */
        private $formula;
        /**
         * The character ahead of the current char.
         *
         * @var string
         */
        public $lookAhead;
        /**
         * The parse tree to be generated.
         *
         * @var string
         */
        private $parseTree;
        /**
         * Array of external sheets.
         *
         * @var array
         */
        private $externalSheets;
        /**
         * Array of sheet references in the form of REF structures.
         *
         * @var array
         */
        public $references;
        /**
         * The Excel ptg indices.
         *
         * @var array
         */
        private $ptg = ['ptgExp' => 0x1, 'ptgTbl' => 0x2, 'ptgAdd' => 0x3, 'ptgSub' => 0x4, 'ptgMul' => 0x5, 'ptgDiv' => 0x6, 'ptgPower' => 0x7, 'ptgConcat' => 0x8, 'ptgLT' => 0x9, 'ptgLE' => 0xa, 'ptgEQ' => 0xb, 'ptgGE' => 0xc, 'ptgGT' => 0xd, 'ptgNE' => 0xe, 'ptgIsect' => 0xf, 'ptgUnion' => 0x10, 'ptgRange' => 0x11, 'ptgUplus' => 0x12, 'ptgUminus' => 0x13, 'ptgPercent' => 0x14, 'ptgParen' => 0x15, 'ptgMissArg' => 0x16, 'ptgStr' => 0x17, 'ptgAttr' => 0x19, 'ptgSheet' => 0x1a, 'ptgEndSheet' => 0x1b, 'ptgErr' => 0x1c, 'ptgBool' => 0x1d, 'ptgInt' => 0x1e, 'ptgNum' => 0x1f, 'ptgArray' => 0x20, 'ptgFunc' => 0x21, 'ptgFuncVar' => 0x22, 'ptgName' => 0x23, 'ptgRef' => 0x24, 'ptgArea' => 0x25, 'ptgMemArea' => 0x26, 'ptgMemErr' => 0x27, 'ptgMemNoMem' => 0x28, 'ptgMemFunc' => 0x29, 'ptgRefErr' => 0x2a, 'ptgAreaErr' => 0x2b, 'ptgRefN' => 0x2c, 'ptgAreaN' => 0x2d, 'ptgMemAreaN' => 0x2e, 'ptgMemNoMemN' => 0x2f, 'ptgNameX' => 0x39, 'ptgRef3d' => 0x3a, 'ptgArea3d' => 0x3b, 'ptgRefErr3d' => 0x3c, 'ptgAreaErr3d' => 0x3d, 'ptgArrayV' => 0x40, 'ptgFuncV' => 0x41, 'ptgFuncVarV' => 0x42, 'ptgNameV' => 0x43, 'ptgRefV' => 0x44, 'ptgAreaV' => 0x45, 'ptgMemAreaV' => 0x46, 'ptgMemErrV' => 0x47, 'ptgMemNoMemV' => 0x48, 'ptgMemFuncV' => 0x49, 'ptgRefErrV' => 0x4a, 'ptgAreaErrV' => 0x4b, 'ptgRefNV' => 0x4c, 'ptgAreaNV' => 0x4d, 'ptgMemAreaNV' => 0x4e, 'ptgMemNoMemNV' => 0x4f, 'ptgFuncCEV' => 0x58, 'ptgNameXV' => 0x59, 'ptgRef3dV' => 0x5a, 'ptgArea3dV' => 0x5b, 'ptgRefErr3dV' => 0x5c, 'ptgAreaErr3dV' => 0x5d, 'ptgArrayA' => 0x60, 'ptgFuncA' => 0x61, 'ptgFuncVarA' => 0x62, 'ptgNameA' => 0x63, 'ptgRefA' => 0x64, 'ptgAreaA' => 0x65, 'ptgMemAreaA' => 0x66, 'ptgMemErrA' => 0x67, 'ptgMemNoMemA' => 0x68, 'ptgMemFuncA' => 0x69, 'ptgRefErrA' => 0x6a, 'ptgAreaErrA' => 0x6b, 'ptgRefNA' => 0x6c, 'ptgAreaNA' => 0x6d, 'ptgMemAreaNA' => 0x6e, 'ptgMemNoMemNA' => 0x6f, 'ptgFuncCEA' => 0x78, 'ptgNameXA' => 0x79, 'ptgRef3dA' => 0x7a, 'ptgArea3dA' => 0x7b, 'ptgRefErr3dA' => 0x7c, 'ptgAreaErr3dA' => 0x7d];
        /**
         * Thanks to Michael Meeks and Gnumeric for the initial arg values.
         *
         * The following hash was generated by "function_locale.pl" in the distro.
         * Refer to function_locale.pl for non-English function names.
         *
         * The array elements are as follow:
         * ptg:   The Excel function ptg code.
         * args:  The number of arguments that the function takes:
         *           >=0 is a fixed number of arguments.
         *           -1  is a variable  number of arguments.
         * class: The reference, value or array class of the function args.
         * vol:   The function is volatile.
         *
         * @var array
         */
        private $functions = [
            // function                  ptg  args  class  vol
            'COUNT' => [0, -1, 0, 0],
            'IF' => [1, -1, 1, 0],
            'ISNA' => [2, 1, 1, 0],
            'ISERROR' => [3, 1, 1, 0],
            'SUM' => [4, -1, 0, 0],
            'AVERAGE' => [5, -1, 0, 0],
            'MIN' => [6, -1, 0, 0],
            'MAX' => [7, -1, 0, 0],
            'ROW' => [8, -1, 0, 0],
            'COLUMN' => [9, -1, 0, 0],
            'NA' => [10, 0, 0, 0],
            'NPV' => [11, -1, 1, 0],
            'STDEV' => [12, -1, 0, 0],
            'DOLLAR' => [13, -1, 1, 0],
            'FIXED' => [14, -1, 1, 0],
            'SIN' => [15, 1, 1, 0],
            'COS' => [16, 1, 1, 0],
            'TAN' => [17, 1, 1, 0],
            'ATAN' => [18, 1, 1, 0],
            'PI' => [19, 0, 1, 0],
            'SQRT' => [20, 1, 1, 0],
            'EXP' => [21, 1, 1, 0],
            'LN' => [22, 1, 1, 0],
            'LOG10' => [23, 1, 1, 0],
            'ABS' => [24, 1, 1, 0],
            'INT' => [25, 1, 1, 0],
            'SIGN' => [26, 1, 1, 0],
            'ROUND' => [27, 2, 1, 0],
            'LOOKUP' => [28, -1, 0, 0],
            'INDEX' => [29, -1, 0, 1],
            'REPT' => [30, 2, 1, 0],
            'MID' => [31, 3, 1, 0],
            'LEN' => [32, 1, 1, 0],
            'VALUE' => [33, 1, 1, 0],
            'TRUE' => [34, 0, 1, 0],
            'FALSE' => [35, 0, 1, 0],
            'AND' => [36, -1, 0, 0],
            'OR' => [37, -1, 0, 0],
            'NOT' => [38, 1, 1, 0],
            'MOD' => [39, 2, 1, 0],
            'DCOUNT' => [40, 3, 0, 0],
            'DSUM' => [41, 3, 0, 0],
            'DAVERAGE' => [42, 3, 0, 0],
            'DMIN' => [43, 3, 0, 0],
            'DMAX' => [44, 3, 0, 0],
            'DSTDEV' => [45, 3, 0, 0],
            'VAR' => [46, -1, 0, 0],
            'DVAR' => [47, 3, 0, 0],
            'TEXT' => [48, 2, 1, 0],
            'LINEST' => [49, -1, 0, 0],
            'TREND' => [50, -1, 0, 0],
            'LOGEST' => [51, -1, 0, 0],
            'GROWTH' => [52, -1, 0, 0],
            'PV' => [56, -1, 1, 0],
            'FV' => [57, -1, 1, 0],
            'NPER' => [58, -1, 1, 0],
            'PMT' => [59, -1, 1, 0],
            'RATE' => [60, -1, 1, 0],
            'MIRR' => [61, 3, 0, 0],
            'IRR' => [62, -1, 0, 0],
            'RAND' => [63, 0, 1, 1],
            'MATCH' => [64, -1, 0, 0],
            'DATE' => [65, 3, 1, 0],
            'TIME' => [66, 3, 1, 0],
            'DAY' => [67, 1, 1, 0],
            'MONTH' => [68, 1, 1, 0],
            'YEAR' => [69, 1, 1, 0],
            'WEEKDAY' => [70, -1, 1, 0],
            'HOUR' => [71, 1, 1, 0],
            'MINUTE' => [72, 1, 1, 0],
            'SECOND' => [73, 1, 1, 0],
            'NOW' => [74, 0, 1, 1],
            'AREAS' => [75, 1, 0, 1],
            'ROWS' => [76, 1, 0, 1],
            'COLUMNS' => [77, 1, 0, 1],
            'OFFSET' => [78, -1, 0, 1],
            'SEARCH' => [82, -1, 1, 0],
            'TRANSPOSE' => [83, 1, 1, 0],
            'TYPE' => [86, 1, 1, 0],
            'ATAN2' => [97, 2, 1, 0],
            'ASIN' => [98, 1, 1, 0],
            'ACOS' => [99, 1, 1, 0],
            'CHOOSE' => [100, -1, 1, 0],
            'HLOOKUP' => [101, -1, 0, 0],
            'VLOOKUP' => [102, -1, 0, 0],
            'ISREF' => [105, 1, 0, 0],
            'LOG' => [109, -1, 1, 0],
            'CHAR' => [111, 1, 1, 0],
            'LOWER' => [112, 1, 1, 0],
            'UPPER' => [113, 1, 1, 0],
            'PROPER' => [114, 1, 1, 0],
            'LEFT' => [115, -1, 1, 0],
            'RIGHT' => [116, -1, 1, 0],
            'EXACT' => [117, 2, 1, 0],
            'TRIM' => [118, 1, 1, 0],
            'REPLACE' => [119, 4, 1, 0],
            'SUBSTITUTE' => [120, -1, 1, 0],
            'CODE' => [121, 1, 1, 0],
            'FIND' => [124, -1, 1, 0],
            'CELL' => [125, -1, 0, 1],
            'ISERR' => [126, 1, 1, 0],
            'ISTEXT' => [127, 1, 1, 0],
            'ISNUMBER' => [128, 1, 1, 0],
            'ISBLANK' => [129, 1, 1, 0],
            'T' => [130, 1, 0, 0],
            'N' => [131, 1, 0, 0],
            'DATEVALUE' => [140, 1, 1, 0],
            'TIMEVALUE' => [141, 1, 1, 0],
            'SLN' => [142, 3, 1, 0],
            'SYD' => [143, 4, 1, 0],
            'DDB' => [144, -1, 1, 0],
            'INDIRECT' => [148, -1, 1, 1],
            'CALL' => [150, -1, 1, 0],
            'CLEAN' => [162, 1, 1, 0],
            'MDETERM' => [163, 1, 2, 0],
            'MINVERSE' => [164, 1, 2, 0],
            'MMULT' => [165, 2, 2, 0],
            'IPMT' => [167, -1, 1, 0],
            'PPMT' => [168, -1, 1, 0],
            'COUNTA' => [169, -1, 0, 0],
            'PRODUCT' => [183, -1, 0, 0],
            'FACT' => [184, 1, 1, 0],
            'DPRODUCT' => [189, 3, 0, 0],
            'ISNONTEXT' => [190, 1, 1, 0],
            'STDEVP' => [193, -1, 0, 0],
            'VARP' => [194, -1, 0, 0],
            'DSTDEVP' => [195, 3, 0, 0],
            'DVARP' => [196, 3, 0, 0],
            'TRUNC' => [197, -1, 1, 0],
            'ISLOGICAL' => [198, 1, 1, 0],
            'DCOUNTA' => [199, 3, 0, 0],
            'USDOLLAR' => [204, -1, 1, 0],
            'FINDB' => [205, -1, 1, 0],
            'SEARCHB' => [206, -1, 1, 0],
            'REPLACEB' => [207, 4, 1, 0],
            'LEFTB' => [208, -1, 1, 0],
            'RIGHTB' => [209, -1, 1, 0],
            'MIDB' => [210, 3, 1, 0],
            'LENB' => [211, 1, 1, 0],
            'ROUNDUP' => [212, 2, 1, 0],
            'ROUNDDOWN' => [213, 2, 1, 0],
            'ASC' => [214, 1, 1, 0],
            'DBCS' => [215, 1, 1, 0],
            'RANK' => [216, -1, 0, 0],
            'ADDRESS' => [219, -1, 1, 0],
            'DAYS360' => [220, -1, 1, 0],
            'TODAY' => [221, 0, 1, 1],
            'VDB' => [222, -1, 1, 0],
            'MEDIAN' => [227, -1, 0, 0],
            'SUMPRODUCT' => [228, -1, 2, 0],
            'SINH' => [229, 1, 1, 0],
            'COSH' => [230, 1, 1, 0],
            'TANH' => [231, 1, 1, 0],
            'ASINH' => [232, 1, 1, 0],
            'ACOSH' => [233, 1, 1, 0],
            'ATANH' => [234, 1, 1, 0],
            'DGET' => [235, 3, 0, 0],
            'INFO' => [244, 1, 1, 1],
            'DB' => [247, -1, 1, 0],
            'FREQUENCY' => [252, 2, 0, 0],
            'ERROR.TYPE' => [261, 1, 1, 0],
            'REGISTER.ID' => [267, -1, 1, 0],
            'AVEDEV' => [269, -1, 0, 0],
            'BETADIST' => [270, -1, 1, 0],
            'GAMMALN' => [271, 1, 1, 0],
            'BETAINV' => [272, -1, 1, 0],
            'BINOMDIST' => [273, 4, 1, 0],
            'CHIDIST' => [274, 2, 1, 0],
            'CHIINV' => [275, 2, 1, 0],
            'COMBIN' => [276, 2, 1, 0],
            'CONFIDENCE' => [277, 3, 1, 0],
            'CRITBINOM' => [278, 3, 1, 0],
            'EVEN' => [279, 1, 1, 0],
            'EXPONDIST' => [280, 3, 1, 0],
            'FDIST' => [281, 3, 1, 0],
            'FINV' => [282, 3, 1, 0],
            'FISHER' => [283, 1, 1, 0],
            'FISHERINV' => [284, 1, 1, 0],
            'FLOOR' => [285, 2, 1, 0],
            'GAMMADIST' => [286, 4, 1, 0],
            'GAMMAINV' => [287, 3, 1, 0],
            'CEILING' => [288, 2, 1, 0],
            'HYPGEOMDIST' => [289, 4, 1, 0],
            'LOGNORMDIST' => [290, 3, 1, 0],
            'LOGINV' => [291, 3, 1, 0],
            'NEGBINOMDIST' => [292, 3, 1, 0],
            'NORMDIST' => [293, 4, 1, 0],
            'NORMSDIST' => [294, 1, 1, 0],
            'NORMINV' => [295, 3, 1, 0],
            'NORMSINV' => [296, 1, 1, 0],
            'STANDARDIZE' => [297, 3, 1, 0],
            'ODD' => [298, 1, 1, 0],
            'PERMUT' => [299, 2, 1, 0],
            'POISSON' => [300, 3, 1, 0],
            'TDIST' => [301, 3, 1, 0],
            'WEIBULL' => [302, 4, 1, 0],
            'SUMXMY2' => [303, 2, 2, 0],
            'SUMX2MY2' => [304, 2, 2, 0],
            'SUMX2PY2' => [305, 2, 2, 0],
            'CHITEST' => [306, 2, 2, 0],
            'CORREL' => [307, 2, 2, 0],
            'COVAR' => [308, 2, 2, 0],
            'FORECAST' => [309, 3, 2, 0],
            'FTEST' => [310, 2, 2, 0],
            'INTERCEPT' => [311, 2, 2, 0],
            'PEARSON' => [312, 2, 2, 0],
            'RSQ' => [313, 2, 2, 0],
            'STEYX' => [314, 2, 2, 0],
            'SLOPE' => [315, 2, 2, 0],
            'TTEST' => [316, 4, 2, 0],
            'PROB' => [317, -1, 2, 0],
            'DEVSQ' => [318, -1, 0, 0],
            'GEOMEAN' => [319, -1, 0, 0],
            'HARMEAN' => [320, -1, 0, 0],
            'SUMSQ' => [321, -1, 0, 0],
            'KURT' => [322, -1, 0, 0],
            'SKEW' => [323, -1, 0, 0],
            'ZTEST' => [324, -1, 0, 0],
            'LARGE' => [325, 2, 0, 0],
            'SMALL' => [326, 2, 0, 0],
            'QUARTILE' => [327, 2, 0, 0],
            'PERCENTILE' => [328, 2, 0, 0],
            'PERCENTRANK' => [329, -1, 0, 0],
            'MODE' => [330, -1, 2, 0],
            'TRIMMEAN' => [331, 2, 0, 0],
            'TINV' => [332, 2, 1, 0],
            'CONCATENATE' => [336, -1, 1, 0],
            'POWER' => [337, 2, 1, 0],
            'RADIANS' => [342, 1, 1, 0],
            'DEGREES' => [343, 1, 1, 0],
            'SUBTOTAL' => [344, -1, 0, 0],
            'SUMIF' => [345, -1, 0, 0],
            'COUNTIF' => [346, 2, 0, 0],
            'COUNTBLANK' => [347, 1, 0, 0],
            'ISPMT' => [350, 4, 1, 0],
            'DATEDIF' => [351, 3, 1, 0],
            'DATESTRING' => [352, 1, 1, 0],
            'NUMBERSTRING' => [353, 2, 1, 0],
            'ROMAN' => [354, -1, 1, 0],
            'GETPIVOTDATA' => [358, -1, 0, 0],
            'HYPERLINK' => [359, -1, 1, 0],
            'PHONETIC' => [360, 1, 0, 0],
            'AVERAGEA' => [361, -1, 0, 0],
            'MAXA' => [362, -1, 0, 0],
            'MINA' => [363, -1, 0, 0],
            'STDEVPA' => [364, -1, 0, 0],
            'VARPA' => [365, -1, 0, 0],
            'STDEVA' => [366, -1, 0, 0],
            'VARA' => [367, -1, 0, 0],
            'BAHTTEXT' => [368, 1, 0, 0],
        ];
        /**
         * The class constructor.
         */
        public function __construct()
        {
        }
        /**
         * Convert a token to the proper ptg value.
         *
         * @param mixed $token the token to convert
         *
         * @return mixed the converted token on success
         */
        private function convert($token)
        {
        }
        /**
         * Convert a number token to ptgInt or ptgNum.
         *
         * @param mixed $num an integer or double for conversion to its ptg value
         *
         * @return string
         */
        private function convertNumber($num)
        {
        }
        /**
         * Convert a string token to ptgStr.
         *
         * @param string $string a string for conversion to its ptg value
         *
         * @return mixed the converted token on success
         */
        private function convertString($string)
        {
        }
        /**
         * Convert a function to a ptgFunc or ptgFuncVarV depending on the number of
         * args that it takes.
         *
         * @param string $token the name of the function for convertion to ptg value
         * @param int $num_args the number of arguments the function receives
         *
         * @return string The packed ptg for the function
         */
        private function convertFunction($token, $num_args)
        {
        }
        /**
         * Convert an Excel range such as A1:D4 to a ptgRefV.
         *
         * @param string $range An Excel range in the A1:A2
         * @param int $class
         *
         * @return string
         */
        private function convertRange2d($range, $class = 0)
        {
        }
        /**
         * Convert an Excel 3d range such as "Sheet1!A1:D4" or "Sheet1:Sheet2!A1:D4" to
         * a ptgArea3d.
         *
         * @param string $token an Excel range in the Sheet1!A1:A2 format
         *
         * @return mixed the packed ptgArea3d token on success
         */
        private function convertRange3d($token)
        {
        }
        /**
         * Convert an Excel reference such as A1, $B2, C$3 or $D$4 to a ptgRefV.
         *
         * @param string $cell An Excel cell reference
         *
         * @return string The cell in packed() format with the corresponding ptg
         */
        private function convertRef2d($cell)
        {
        }
        /**
         * Convert an Excel 3d reference such as "Sheet1!A1" or "Sheet1:Sheet2!A1" to a
         * ptgRef3d.
         *
         * @param string $cell An Excel cell reference
         *
         * @return mixed the packed ptgRef3d token on success
         */
        private function convertRef3d($cell)
        {
        }
        /**
         * Convert an error code to a ptgErr.
         *
         * @param string $errorCode The error code for conversion to its ptg value
         *
         * @return string The error code ptgErr
         */
        private function convertError($errorCode)
        {
        }
        /**
         * Look up the REF index that corresponds to an external sheet name
         * (or range). If it doesn't exist yet add it to the workbook's references
         * array. It assumes all sheet names given must exist.
         *
         * @param string $ext_ref The name of the external reference
         *
         * @return mixed The reference index in packed() format on success
         */
        private function getRefIndex($ext_ref)
        {
        }
        /**
         * Look up the index that corresponds to an external sheet name. The hash of
         * sheet names is updated by the addworksheet() method of the
         * \PhpOffice\PhpSpreadsheet\Writer\Xls\Workbook class.
         *
         * @param string $sheet_name Sheet name
         *
         * @return int The sheet index, -1 if the sheet was not found
         */
        private function getSheetIndex($sheet_name)
        {
        }
        /**
         * This method is used to update the array of sheet names. It is
         * called by the addWorksheet() method of the
         * \PhpOffice\PhpSpreadsheet\Writer\Xls\Workbook class.
         *
         * @see \PhpOffice\PhpSpreadsheet\Writer\Xls\Workbook::addWorksheet()
         *
         * @param string $name The name of the worksheet being added
         * @param int $index The index of the worksheet being added
         */
        public function setExtSheet($name, $index) : void
        {
        }
        /**
         * pack() row and column into the required 3 or 4 byte format.
         *
         * @param string $cell The Excel cell reference to be packed
         *
         * @return array Array containing the row and column in packed() format
         */
        private function cellToPackedRowcol($cell)
        {
        }
        /**
         * pack() row range into the required 3 or 4 byte format.
         * Just using maximum col/rows, which is probably not the correct solution.
         *
         * @param string $range The Excel range to be packed
         *
         * @return array Array containing (row1,col1,row2,col2) in packed() format
         */
        private function rangeToPackedRange($range)
        {
        }
        /**
         * Convert an Excel cell reference such as A1 or $B2 or C$3 or $D$4 to a zero
         * indexed row and column number. Also returns two (0,1) values to indicate
         * whether the row or column are relative references.
         *
         * @param string $cell the Excel cell reference in A1 format
         *
         * @return array
         */
        private function cellToRowcol($cell)
        {
        }
        /**
         * Advance to the next valid token.
         */
        private function advance()
        {
        }
        /**
         * Checks if it's a valid token.
         *
         * @param mixed $token the token to check
         *
         * @return mixed The checked token or false on failure
         */
        private function match($token)
        {
        }
        /**
         * The parsing method. It parses a formula.
         *
         * @param string $formula the formula to parse, without the initial equal
         *                        sign (=)
         *
         * @return mixed true on success
         */
        public function parse($formula)
        {
        }
        /**
         * It parses a condition. It assumes the following rule:
         * Cond -> Expr [(">" | "<") Expr].
         *
         * @return mixed The parsed ptg'd tree on success
         */
        private function condition()
        {
        }
        /**
         * It parses a expression. It assumes the following rule:
         * Expr -> Term [("+" | "-") Term]
         *      -> "string"
         *      -> "-" Term : Negative value
         *      -> "+" Term : Positive value
         *      -> Error code.
         *
         * @return mixed The parsed ptg'd tree on success
         */
        private function expression()
        {
        }
        /**
         * This function just introduces a ptgParen element in the tree, so that Excel
         * doesn't get confused when working with a parenthesized formula afterwards.
         *
         * @see fact()
         *
         * @return array The parsed ptg'd tree
         */
        private function parenthesizedExpression()
        {
        }
        /**
         * It parses a term. It assumes the following rule:
         * Term -> Fact [("*" | "/") Fact].
         *
         * @return mixed The parsed ptg'd tree on success
         */
        private function term()
        {
        }
        /**
         * It parses a factor. It assumes the following rule:
         * Fact -> ( Expr )
         *       | CellRef
         *       | CellRange
         *       | Number
         *       | Function.
         *
         * @return mixed The parsed ptg'd tree on success
         */
        private function fact()
        {
        }
        /**
         * It parses a function call. It assumes the following rule:
         * Func -> ( Expr [,Expr]* ).
         *
         * @return mixed The parsed ptg'd tree on success
         */
        private function func()
        {
        }
        /**
         * Creates a tree. In fact an array which may have one or two arrays (sub-trees)
         * as elements.
         *
         * @param mixed $value the value of this node
         * @param mixed $left the left array (sub-tree) or a final node
         * @param mixed $right the right array (sub-tree) or a final node
         *
         * @return array A tree
         */
        private function createTree($value, $left, $right)
        {
        }
        /**
         * Builds a string containing the tree in reverse polish notation (What you
         * would use in a HP calculator stack).
         * The following tree:.
         *
         *    +
         *   / \
         *  2   3
         *
         * produces: "23+"
         *
         * The following tree:
         *
         *    +
         *   / \
         *  3   *
         *     / \
         *    6   A1
         *
         * produces: "36A1*+"
         *
         * In fact all operands, functions, references, etc... are written as ptg's
         *
         * @param array $tree the optional tree to convert
         *
         * @return string The tree in reverse polish notation
         */
        public function toReversePolish($tree = [])
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Writer {
    class Xls extends \PhpOffice\PhpSpreadsheet\Writer\BaseWriter
    {
        /**
         * PhpSpreadsheet object.
         *
         * @var Spreadsheet
         */
        private $spreadsheet;
        /**
         * Total number of shared strings in workbook.
         *
         * @var int
         */
        private $strTotal = 0;
        /**
         * Number of unique shared strings in workbook.
         *
         * @var int
         */
        private $strUnique = 0;
        /**
         * Array of unique shared strings in workbook.
         *
         * @var array
         */
        private $strTable = [];
        /**
         * Color cache. Mapping between RGB value and color index.
         *
         * @var array
         */
        private $colors;
        /**
         * Formula parser.
         *
         * @var \PhpOffice\PhpSpreadsheet\Writer\Xls\Parser
         */
        private $parser;
        /**
         * Identifier clusters for drawings. Used in MSODRAWINGGROUP record.
         *
         * @var array
         */
        private $IDCLs;
        /**
         * Basic OLE object summary information.
         *
         * @var array
         */
        private $summaryInformation;
        /**
         * Extended OLE object document summary information.
         *
         * @var array
         */
        private $documentSummaryInformation;
        /**
         * @var \PhpOffice\PhpSpreadsheet\Writer\Xls\Workbook
         */
        private $writerWorkbook;
        /**
         * @var \PhpOffice\PhpSpreadsheet\Writer\Xls\Worksheet[]
         */
        private $writerWorksheets;
        /**
         * Create a new Xls Writer.
         *
         * @param Spreadsheet $spreadsheet PhpSpreadsheet object
         */
        public function __construct(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet)
        {
        }
        /**
         * Save Spreadsheet to file.
         *
         * @param resource|string $pFilename
         */
        public function save($pFilename) : void
        {
        }
        /**
         * Build the Worksheet Escher objects.
         */
        private function buildWorksheetEschers() : void
        {
        }
        /**
         * Build the Escher object corresponding to the MSODRAWINGGROUP record.
         */
        private function buildWorkbookEscher() : void
        {
        }
        /**
         * Build the OLE Part for DocumentSummary Information.
         *
         * @return string
         */
        private function writeDocumentSummaryInformation()
        {
        }
        /**
         * Build the OLE Part for Summary Information.
         *
         * @return string
         */
        private function writeSummaryInformation()
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Document {
    class Security
    {
        /**
         * LockRevision.
         *
         * @var bool
         */
        private $lockRevision = false;
        /**
         * LockStructure.
         *
         * @var bool
         */
        private $lockStructure = false;
        /**
         * LockWindows.
         *
         * @var bool
         */
        private $lockWindows = false;
        /**
         * RevisionsPassword.
         *
         * @var string
         */
        private $revisionsPassword = '';
        /**
         * WorkbookPassword.
         *
         * @var string
         */
        private $workbookPassword = '';
        /**
         * Create a new Document Security instance.
         */
        public function __construct()
        {
        }
        /**
         * Is some sort of document security enabled?
         *
         * @return bool
         */
        public function isSecurityEnabled()
        {
        }
        /**
         * Get LockRevision.
         *
         * @return bool
         */
        public function getLockRevision()
        {
        }
        /**
         * Set LockRevision.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setLockRevision($pValue)
        {
        }
        /**
         * Get LockStructure.
         *
         * @return bool
         */
        public function getLockStructure()
        {
        }
        /**
         * Set LockStructure.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setLockStructure($pValue)
        {
        }
        /**
         * Get LockWindows.
         *
         * @return bool
         */
        public function getLockWindows()
        {
        }
        /**
         * Set LockWindows.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setLockWindows($pValue)
        {
        }
        /**
         * Get RevisionsPassword (hashed).
         *
         * @return string
         */
        public function getRevisionsPassword()
        {
        }
        /**
         * Set RevisionsPassword.
         *
         * @param string $pValue
         * @param bool $pAlreadyHashed If the password has already been hashed, set this to true
         *
         * @return $this
         */
        public function setRevisionsPassword($pValue, $pAlreadyHashed = false)
        {
        }
        /**
         * Get WorkbookPassword (hashed).
         *
         * @return string
         */
        public function getWorkbookPassword()
        {
        }
        /**
         * Set WorkbookPassword.
         *
         * @param string $pValue
         * @param bool $pAlreadyHashed If the password has already been hashed, set this to true
         *
         * @return $this
         */
        public function setWorkbookPassword($pValue, $pAlreadyHashed = false)
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    class Properties
    {
        /** constants */
        const PROPERTY_TYPE_BOOLEAN = 'b';
        const PROPERTY_TYPE_INTEGER = 'i';
        const PROPERTY_TYPE_FLOAT = 'f';
        const PROPERTY_TYPE_DATE = 'd';
        const PROPERTY_TYPE_STRING = 's';
        const PROPERTY_TYPE_UNKNOWN = 'u';
        /**
         * Creator.
         *
         * @var string
         */
        private $creator = 'Unknown Creator';
        /**
         * LastModifiedBy.
         *
         * @var string
         */
        private $lastModifiedBy;
        /**
         * Created.
         *
         * @var int
         */
        private $created;
        /**
         * Modified.
         *
         * @var int
         */
        private $modified;
        /**
         * Title.
         *
         * @var string
         */
        private $title = 'Untitled Spreadsheet';
        /**
         * Description.
         *
         * @var string
         */
        private $description = '';
        /**
         * Subject.
         *
         * @var string
         */
        private $subject = '';
        /**
         * Keywords.
         *
         * @var string
         */
        private $keywords = '';
        /**
         * Category.
         *
         * @var string
         */
        private $category = '';
        /**
         * Manager.
         *
         * @var string
         */
        private $manager = '';
        /**
         * Company.
         *
         * @var string
         */
        private $company = 'Microsoft Corporation';
        /**
         * Custom Properties.
         *
         * @var string
         */
        private $customProperties = [];
        /**
         * Create a new Document Properties instance.
         */
        public function __construct()
        {
        }
        /**
         * Get Creator.
         *
         * @return string
         */
        public function getCreator()
        {
        }
        /**
         * Set Creator.
         *
         * @param string $creator
         *
         * @return $this
         */
        public function setCreator($creator)
        {
        }
        /**
         * Get Last Modified By.
         *
         * @return string
         */
        public function getLastModifiedBy()
        {
        }
        /**
         * Set Last Modified By.
         *
         * @param string $pValue
         *
         * @return $this
         */
        public function setLastModifiedBy($pValue)
        {
        }
        /**
         * Get Created.
         *
         * @return int
         */
        public function getCreated()
        {
        }
        /**
         * Set Created.
         *
         * @param int|string $time
         *
         * @return $this
         */
        public function setCreated($time)
        {
        }
        /**
         * Get Modified.
         *
         * @return int
         */
        public function getModified()
        {
        }
        /**
         * Set Modified.
         *
         * @param int|string $time
         *
         * @return $this
         */
        public function setModified($time)
        {
        }
        /**
         * Get Title.
         *
         * @return string
         */
        public function getTitle()
        {
        }
        /**
         * Set Title.
         *
         * @param string $title
         *
         * @return $this
         */
        public function setTitle($title)
        {
        }
        /**
         * Get Description.
         *
         * @return string
         */
        public function getDescription()
        {
        }
        /**
         * Set Description.
         *
         * @param string $description
         *
         * @return $this
         */
        public function setDescription($description)
        {
        }
        /**
         * Get Subject.
         *
         * @return string
         */
        public function getSubject()
        {
        }
        /**
         * Set Subject.
         *
         * @param string $subject
         *
         * @return $this
         */
        public function setSubject($subject)
        {
        }
        /**
         * Get Keywords.
         *
         * @return string
         */
        public function getKeywords()
        {
        }
        /**
         * Set Keywords.
         *
         * @param string $keywords
         *
         * @return $this
         */
        public function setKeywords($keywords)
        {
        }
        /**
         * Get Category.
         *
         * @return string
         */
        public function getCategory()
        {
        }
        /**
         * Set Category.
         *
         * @param string $category
         *
         * @return $this
         */
        public function setCategory($category)
        {
        }
        /**
         * Get Company.
         *
         * @return string
         */
        public function getCompany()
        {
        }
        /**
         * Set Company.
         *
         * @param string $company
         *
         * @return $this
         */
        public function setCompany($company)
        {
        }
        /**
         * Get Manager.
         *
         * @return string
         */
        public function getManager()
        {
        }
        /**
         * Set Manager.
         *
         * @param string $manager
         *
         * @return $this
         */
        public function setManager($manager)
        {
        }
        /**
         * Get a List of Custom Property Names.
         *
         * @return array of string
         */
        public function getCustomProperties()
        {
        }
        /**
         * Check if a Custom Property is defined.
         *
         * @param string $propertyName
         *
         * @return bool
         */
        public function isCustomPropertySet($propertyName)
        {
        }
        /**
         * Get a Custom Property Value.
         *
         * @param string $propertyName
         *
         * @return mixed
         */
        public function getCustomPropertyValue($propertyName)
        {
        }
        /**
         * Get a Custom Property Type.
         *
         * @param string $propertyName
         *
         * @return string
         */
        public function getCustomPropertyType($propertyName)
        {
        }
        /**
         * Set a Custom Property.
         *
         * @param string $propertyName
         * @param mixed $propertyValue
         * @param string $propertyType
         *      'i'    : Integer
         *   'f' : Floating Point
         *   's' : String
         *   'd' : Date/Time
         *   'b' : Boolean
         *
         * @return $this
         */
        public function setCustomProperty($propertyName, $propertyValue = '', $propertyType = null)
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
        public static function convertProperty($propertyValue, $propertyType)
        {
        }
        public static function convertPropertyType($propertyType)
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Style {
    abstract class Supervisor implements \PhpOffice\PhpSpreadsheet\IComparable
    {
        /**
         * Supervisor?
         *
         * @var bool
         */
        protected $isSupervisor;
        /**
         * Parent. Only used for supervisor.
         *
         * @var Spreadsheet|Style
         */
        protected $parent;
        /**
         * Parent property name.
         *
         * @var null|string
         */
        protected $parentPropertyName;
        /**
         * Create a new Supervisor.
         *
         * @param bool $isSupervisor Flag indicating if this is a supervisor or not
         *                                    Leave this value at default unless you understand exactly what
         *                                        its ramifications are
         */
        public function __construct($isSupervisor = false)
        {
        }
        /**
         * Bind parent. Only used for supervisor.
         *
         * @param Spreadsheet|Style $parent
         * @param null|string $parentPropertyName
         *
         * @return $this
         */
        public function bindParent($parent, $parentPropertyName = null)
        {
        }
        /**
         * Is this a supervisor or a cell style component?
         *
         * @return bool
         */
        public function getIsSupervisor()
        {
        }
        /**
         * Get the currently active sheet. Only used for supervisor.
         *
         * @return Worksheet
         */
        public function getActiveSheet()
        {
        }
        /**
         * Get the currently active cell coordinate in currently active sheet.
         * Only used for supervisor.
         *
         * @return string E.g. 'A1'
         */
        public function getSelectedCells()
        {
        }
        /**
         * Get the currently active cell coordinate in currently active sheet.
         * Only used for supervisor.
         *
         * @return string E.g. 'A1'
         */
        public function getActiveCell()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    class Style extends \PhpOffice\PhpSpreadsheet\Style\Supervisor
    {
        /**
         * Font.
         *
         * @var Font
         */
        protected $font;
        /**
         * Fill.
         *
         * @var Fill
         */
        protected $fill;
        /**
         * Borders.
         *
         * @var Borders
         */
        protected $borders;
        /**
         * Alignment.
         *
         * @var Alignment
         */
        protected $alignment;
        /**
         * Number Format.
         *
         * @var NumberFormat
         */
        protected $numberFormat;
        /**
         * Conditional styles.
         *
         * @var Conditional[]
         */
        protected $conditionalStyles;
        /**
         * Protection.
         *
         * @var Protection
         */
        protected $protection;
        /**
         * Index of style in collection. Only used for real style.
         *
         * @var int
         */
        protected $index;
        /**
         * Use Quote Prefix when displaying in cell editor. Only used for real style.
         *
         * @var bool
         */
        protected $quotePrefix = false;
        /**
         * Create a new Style.
         *
         * @param bool $isSupervisor Flag indicating if this is a supervisor or not
         *         Leave this value at default unless you understand exactly what
         *    its ramifications are
         * @param bool $isConditional Flag indicating if this is a conditional style or not
         *       Leave this value at default unless you understand exactly what
         *    its ramifications are
         */
        public function __construct($isSupervisor = false, $isConditional = false)
        {
        }
        /**
         * Get the shared style component for the currently active cell in currently active sheet.
         * Only used for style supervisor.
         *
         * @return Style
         */
        public function getSharedComponent()
        {
        }
        /**
         * Get parent. Only used for style supervisor.
         *
         * @return Spreadsheet
         */
        public function getParent()
        {
        }
        /**
         * Build style array from subcomponents.
         *
         * @param array $array
         *
         * @return array
         */
        public function getStyleArray($array)
        {
        }
        /**
         * Apply styles from array.
         *
         * <code>
         * $spreadsheet->getActiveSheet()->getStyle('B2')->applyFromArray(
         *     [
         *         'font' => [
         *             'name' => 'Arial',
         *             'bold' => true,
         *             'italic' => false,
         *             'underline' => Font::UNDERLINE_DOUBLE,
         *             'strikethrough' => false,
         *             'color' => [
         *                 'rgb' => '808080'
         *             ]
         *         ],
         *         'borders' => [
         *             'bottom' => [
         *                 'borderStyle' => Border::BORDER_DASHDOT,
         *                 'color' => [
         *                     'rgb' => '808080'
         *                 ]
         *             ],
         *             'top' => [
         *                 'borderStyle' => Border::BORDER_DASHDOT,
         *                 'color' => [
         *                     'rgb' => '808080'
         *                 ]
         *             ]
         *         ],
         *         'alignment' => [
         *             'horizontal' => Alignment::HORIZONTAL_CENTER,
         *             'vertical' => Alignment::VERTICAL_CENTER,
         *             'wrapText' => true,
         *         ],
         *         'quotePrefix'    => true
         *     ]
         * );
         * </code>
         *
         * @param array $pStyles Array containing style information
         * @param bool $pAdvanced advanced mode for setting borders
         *
         * @return $this
         */
        public function applyFromArray(array $pStyles, $pAdvanced = true)
        {
        }
        /**
         * Get Fill.
         *
         * @return Fill
         */
        public function getFill()
        {
        }
        /**
         * Get Font.
         *
         * @return Font
         */
        public function getFont()
        {
        }
        /**
         * Set font.
         *
         * @return $this
         */
        public function setFont(\PhpOffice\PhpSpreadsheet\Style\Font $font)
        {
        }
        /**
         * Get Borders.
         *
         * @return Borders
         */
        public function getBorders()
        {
        }
        /**
         * Get Alignment.
         *
         * @return Alignment
         */
        public function getAlignment()
        {
        }
        /**
         * Get Number Format.
         *
         * @return NumberFormat
         */
        public function getNumberFormat()
        {
        }
        /**
         * Get Conditional Styles. Only used on supervisor.
         *
         * @return Conditional[]
         */
        public function getConditionalStyles()
        {
        }
        /**
         * Set Conditional Styles. Only used on supervisor.
         *
         * @param Conditional[] $pValue Array of conditional styles
         *
         * @return $this
         */
        public function setConditionalStyles(array $pValue)
        {
        }
        /**
         * Get Protection.
         *
         * @return Protection
         */
        public function getProtection()
        {
        }
        /**
         * Get quote prefix.
         *
         * @return bool
         */
        public function getQuotePrefix()
        {
        }
        /**
         * Set quote prefix.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setQuotePrefix($pValue)
        {
        }
        /**
         * Get hash code.
         *
         * @return string Hash code
         */
        public function getHashCode()
        {
        }
        /**
         * Get own index in style collection.
         *
         * @return int
         */
        public function getIndex()
        {
        }
        /**
         * Set own index in style collection.
         *
         * @param int $pValue
         */
        public function setIndex($pValue) : void
        {
        }
    }
    class Protection extends \PhpOffice\PhpSpreadsheet\Style\Supervisor
    {
        /** Protection styles */
        const PROTECTION_INHERIT = 'inherit';
        const PROTECTION_PROTECTED = 'protected';
        const PROTECTION_UNPROTECTED = 'unprotected';
        /**
         * Locked.
         *
         * @var string
         */
        protected $locked;
        /**
         * Hidden.
         *
         * @var string
         */
        protected $hidden;
        /**
         * Create a new Protection.
         *
         * @param bool $isSupervisor Flag indicating if this is a supervisor or not
         *                                    Leave this value at default unless you understand exactly what
         *                                        its ramifications are
         * @param bool $isConditional Flag indicating if this is a conditional style or not
         *                                    Leave this value at default unless you understand exactly what
         *                                        its ramifications are
         */
        public function __construct($isSupervisor = false, $isConditional = false)
        {
        }
        /**
         * Get the shared style component for the currently active cell in currently active sheet.
         * Only used for style supervisor.
         *
         * @return Protection
         */
        public function getSharedComponent()
        {
        }
        /**
         * Build style array from subcomponents.
         *
         * @param array $array
         *
         * @return array
         */
        public function getStyleArray($array)
        {
        }
        /**
         * Apply styles from array.
         *
         * <code>
         * $spreadsheet->getActiveSheet()->getStyle('B2')->getLocked()->applyFromArray(
         *     [
         *         'locked' => TRUE,
         *         'hidden' => FALSE
         *     ]
         * );
         * </code>
         *
         * @param array $pStyles Array containing style information
         *
         * @return $this
         */
        public function applyFromArray(array $pStyles)
        {
        }
        /**
         * Get locked.
         *
         * @return string
         */
        public function getLocked()
        {
        }
        /**
         * Set locked.
         *
         * @param string $pValue see self::PROTECTION_*
         *
         * @return $this
         */
        public function setLocked($pValue)
        {
        }
        /**
         * Get hidden.
         *
         * @return string
         */
        public function getHidden()
        {
        }
        /**
         * Set hidden.
         *
         * @param string $pValue see self::PROTECTION_*
         *
         * @return $this
         */
        public function setHidden($pValue)
        {
        }
        /**
         * Get hash code.
         *
         * @return string Hash code
         */
        public function getHashCode()
        {
        }
    }
    class Alignment extends \PhpOffice\PhpSpreadsheet\Style\Supervisor
    {
        // Horizontal alignment styles
        const HORIZONTAL_GENERAL = 'general';
        const HORIZONTAL_LEFT = 'left';
        const HORIZONTAL_RIGHT = 'right';
        const HORIZONTAL_CENTER = 'center';
        const HORIZONTAL_CENTER_CONTINUOUS = 'centerContinuous';
        const HORIZONTAL_JUSTIFY = 'justify';
        const HORIZONTAL_FILL = 'fill';
        const HORIZONTAL_DISTRIBUTED = 'distributed';
        // Excel2007 only
        // Vertical alignment styles
        const VERTICAL_BOTTOM = 'bottom';
        const VERTICAL_TOP = 'top';
        const VERTICAL_CENTER = 'center';
        const VERTICAL_JUSTIFY = 'justify';
        const VERTICAL_DISTRIBUTED = 'distributed';
        // Excel2007 only
        // Read order
        const READORDER_CONTEXT = 0;
        const READORDER_LTR = 1;
        const READORDER_RTL = 2;
        /**
         * Horizontal alignment.
         *
         * @var string
         */
        protected $horizontal = self::HORIZONTAL_GENERAL;
        /**
         * Vertical alignment.
         *
         * @var string
         */
        protected $vertical = self::VERTICAL_BOTTOM;
        /**
         * Text rotation.
         *
         * @var int
         */
        protected $textRotation = 0;
        /**
         * Wrap text.
         *
         * @var bool
         */
        protected $wrapText = false;
        /**
         * Shrink to fit.
         *
         * @var bool
         */
        protected $shrinkToFit = false;
        /**
         * Indent - only possible with horizontal alignment left and right.
         *
         * @var int
         */
        protected $indent = 0;
        /**
         * Read order.
         *
         * @var int
         */
        protected $readOrder = 0;
        /**
         * Create a new Alignment.
         *
         * @param bool $isSupervisor Flag indicating if this is a supervisor or not
         *                                       Leave this value at default unless you understand exactly what
         *                                          its ramifications are
         * @param bool $isConditional Flag indicating if this is a conditional style or not
         *                                       Leave this value at default unless you understand exactly what
         *                                          its ramifications are
         */
        public function __construct($isSupervisor = false, $isConditional = false)
        {
        }
        /**
         * Get the shared style component for the currently active cell in currently active sheet.
         * Only used for style supervisor.
         *
         * @return Alignment
         */
        public function getSharedComponent()
        {
        }
        /**
         * Build style array from subcomponents.
         *
         * @param array $array
         *
         * @return array
         */
        public function getStyleArray($array)
        {
        }
        /**
         * Apply styles from array.
         *
         * <code>
         * $spreadsheet->getActiveSheet()->getStyle('B2')->getAlignment()->applyFromArray(
         *        [
         *            'horizontal'   => \PhpOffice\PhpSpreadsheet\Style\Alignment::HORIZONTAL_CENTER,
         *            'vertical'     => \PhpOffice\PhpSpreadsheet\Style\Alignment::VERTICAL_CENTER,
         *            'textRotation' => 0,
         *            'wrapText'     => TRUE
         *        ]
         * );
         * </code>
         *
         * @param array $pStyles Array containing style information
         *
         * @return $this
         */
        public function applyFromArray(array $pStyles)
        {
        }
        /**
         * Get Horizontal.
         *
         * @return string
         */
        public function getHorizontal()
        {
        }
        /**
         * Set Horizontal.
         *
         * @param string $pValue see self::HORIZONTAL_*
         *
         * @return $this
         */
        public function setHorizontal($pValue)
        {
        }
        /**
         * Get Vertical.
         *
         * @return string
         */
        public function getVertical()
        {
        }
        /**
         * Set Vertical.
         *
         * @param string $pValue see self::VERTICAL_*
         *
         * @return $this
         */
        public function setVertical($pValue)
        {
        }
        /**
         * Get TextRotation.
         *
         * @return int
         */
        public function getTextRotation()
        {
        }
        /**
         * Set TextRotation.
         *
         * @param int $pValue
         *
         * @return $this
         */
        public function setTextRotation($pValue)
        {
        }
        /**
         * Get Wrap Text.
         *
         * @return bool
         */
        public function getWrapText()
        {
        }
        /**
         * Set Wrap Text.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setWrapText($pValue)
        {
        }
        /**
         * Get Shrink to fit.
         *
         * @return bool
         */
        public function getShrinkToFit()
        {
        }
        /**
         * Set Shrink to fit.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setShrinkToFit($pValue)
        {
        }
        /**
         * Get indent.
         *
         * @return int
         */
        public function getIndent()
        {
        }
        /**
         * Set indent.
         *
         * @param int $pValue
         *
         * @return $this
         */
        public function setIndent($pValue)
        {
        }
        /**
         * Get read order.
         *
         * @return int
         */
        public function getReadOrder()
        {
        }
        /**
         * Set read order.
         *
         * @param int $pValue
         *
         * @return $this
         */
        public function setReadOrder($pValue)
        {
        }
        /**
         * Get hash code.
         *
         * @return string Hash code
         */
        public function getHashCode()
        {
        }
    }
    class Fill extends \PhpOffice\PhpSpreadsheet\Style\Supervisor
    {
        // Fill types
        const FILL_NONE = 'none';
        const FILL_SOLID = 'solid';
        const FILL_GRADIENT_LINEAR = 'linear';
        const FILL_GRADIENT_PATH = 'path';
        const FILL_PATTERN_DARKDOWN = 'darkDown';
        const FILL_PATTERN_DARKGRAY = 'darkGray';
        const FILL_PATTERN_DARKGRID = 'darkGrid';
        const FILL_PATTERN_DARKHORIZONTAL = 'darkHorizontal';
        const FILL_PATTERN_DARKTRELLIS = 'darkTrellis';
        const FILL_PATTERN_DARKUP = 'darkUp';
        const FILL_PATTERN_DARKVERTICAL = 'darkVertical';
        const FILL_PATTERN_GRAY0625 = 'gray0625';
        const FILL_PATTERN_GRAY125 = 'gray125';
        const FILL_PATTERN_LIGHTDOWN = 'lightDown';
        const FILL_PATTERN_LIGHTGRAY = 'lightGray';
        const FILL_PATTERN_LIGHTGRID = 'lightGrid';
        const FILL_PATTERN_LIGHTHORIZONTAL = 'lightHorizontal';
        const FILL_PATTERN_LIGHTTRELLIS = 'lightTrellis';
        const FILL_PATTERN_LIGHTUP = 'lightUp';
        const FILL_PATTERN_LIGHTVERTICAL = 'lightVertical';
        const FILL_PATTERN_MEDIUMGRAY = 'mediumGray';
        /**
         * @var int
         */
        public $startcolorIndex;
        /**
         * @var int
         */
        public $endcolorIndex;
        /**
         * Fill type.
         *
         * @var string
         */
        protected $fillType = self::FILL_NONE;
        /**
         * Rotation.
         *
         * @var float
         */
        protected $rotation = 0;
        /**
         * Start color.
         *
         * @var Color
         */
        protected $startColor;
        /**
         * End color.
         *
         * @var Color
         */
        protected $endColor;
        /**
         * Create a new Fill.
         *
         * @param bool $isSupervisor Flag indicating if this is a supervisor or not
         *                                    Leave this value at default unless you understand exactly what
         *                                        its ramifications are
         * @param bool $isConditional Flag indicating if this is a conditional style or not
         *                                    Leave this value at default unless you understand exactly what
         *                                        its ramifications are
         */
        public function __construct($isSupervisor = false, $isConditional = false)
        {
        }
        /**
         * Get the shared style component for the currently active cell in currently active sheet.
         * Only used for style supervisor.
         *
         * @return Fill
         */
        public function getSharedComponent()
        {
        }
        /**
         * Build style array from subcomponents.
         *
         * @param array $array
         *
         * @return array
         */
        public function getStyleArray($array)
        {
        }
        /**
         * Apply styles from array.
         *
         * <code>
         * $spreadsheet->getActiveSheet()->getStyle('B2')->getFill()->applyFromArray(
         *     [
         *         'fillType' => Fill::FILL_GRADIENT_LINEAR,
         *         'rotation' => 0,
         *         'startColor' => [
         *             'rgb' => '000000'
         *         ],
         *         'endColor' => [
         *             'argb' => 'FFFFFFFF'
         *         ]
         *     ]
         * );
         * </code>
         *
         * @param array $pStyles Array containing style information
         *
         * @return $this
         */
        public function applyFromArray(array $pStyles)
        {
        }
        /**
         * Get Fill Type.
         *
         * @return string
         */
        public function getFillType()
        {
        }
        /**
         * Set Fill Type.
         *
         * @param string $pValue Fill type, see self::FILL_*
         *
         * @return $this
         */
        public function setFillType($pValue)
        {
        }
        /**
         * Get Rotation.
         *
         * @return float
         */
        public function getRotation()
        {
        }
        /**
         * Set Rotation.
         *
         * @param float $pValue
         *
         * @return $this
         */
        public function setRotation($pValue)
        {
        }
        /**
         * Get Start Color.
         *
         * @return Color
         */
        public function getStartColor()
        {
        }
        /**
         * Set Start Color.
         *
         * @return $this
         */
        public function setStartColor(\PhpOffice\PhpSpreadsheet\Style\Color $pValue)
        {
        }
        /**
         * Get End Color.
         *
         * @return Color
         */
        public function getEndColor()
        {
        }
        /**
         * Set End Color.
         *
         * @return $this
         */
        public function setEndColor(\PhpOffice\PhpSpreadsheet\Style\Color $pValue)
        {
        }
        /**
         * Get hash code.
         *
         * @return string Hash code
         */
        public function getHashCode()
        {
        }
    }
    class Color extends \PhpOffice\PhpSpreadsheet\Style\Supervisor
    {
        const NAMED_COLORS = ['Black', 'White', 'Red', 'Green', 'Blue', 'Yellow', 'Magenta', 'Cyan'];
        // Colors
        const COLOR_BLACK = 'FF000000';
        const COLOR_WHITE = 'FFFFFFFF';
        const COLOR_RED = 'FFFF0000';
        const COLOR_DARKRED = 'FF800000';
        const COLOR_BLUE = 'FF0000FF';
        const COLOR_DARKBLUE = 'FF000080';
        const COLOR_GREEN = 'FF00FF00';
        const COLOR_DARKGREEN = 'FF008000';
        const COLOR_YELLOW = 'FFFFFF00';
        const COLOR_DARKYELLOW = 'FF808000';
        /**
         * Indexed colors array.
         *
         * @var array
         */
        protected static $indexedColors;
        /**
         * ARGB - Alpha RGB.
         *
         * @var string
         */
        protected $argb;
        /**
         * Create a new Color.
         *
         * @param string $pARGB ARGB value for the colour
         * @param bool $isSupervisor Flag indicating if this is a supervisor or not
         *                                    Leave this value at default unless you understand exactly what
         *                                        its ramifications are
         * @param bool $isConditional Flag indicating if this is a conditional style or not
         *                                    Leave this value at default unless you understand exactly what
         *                                        its ramifications are
         */
        public function __construct($pARGB = self::COLOR_BLACK, $isSupervisor = false, $isConditional = false)
        {
        }
        /**
         * Get the shared style component for the currently active cell in currently active sheet.
         * Only used for style supervisor.
         *
         * @return Color
         */
        public function getSharedComponent()
        {
        }
        /**
         * Build style array from subcomponents.
         *
         * @param array $array
         *
         * @return array
         */
        public function getStyleArray($array)
        {
        }
        /**
         * Apply styles from array.
         *
         * <code>
         * $spreadsheet->getActiveSheet()->getStyle('B2')->getFont()->getColor()->applyFromArray(['rgb' => '808080']);
         * </code>
         *
         * @param array $pStyles Array containing style information
         *
         * @return $this
         */
        public function applyFromArray(array $pStyles)
        {
        }
        /**
         * Get ARGB.
         *
         * @return string
         */
        public function getARGB()
        {
        }
        /**
         * Set ARGB.
         *
         * @param string $pValue see self::COLOR_*
         *
         * @return $this
         */
        public function setARGB($pValue)
        {
        }
        /**
         * Get RGB.
         *
         * @return string
         */
        public function getRGB()
        {
        }
        /**
         * Set RGB.
         *
         * @param string $pValue RGB value
         *
         * @return $this
         */
        public function setRGB($pValue)
        {
        }
        /**
         * Get a specified colour component of an RGB value.
         *
         * @param string $RGB The colour as an RGB value (e.g. FF00CCCC or CCDDEE
         * @param int $offset Position within the RGB value to extract
         * @param bool $hex Flag indicating whether the component should be returned as a hex or a
         *                                    decimal value
         *
         * @return string The extracted colour component
         */
        private static function getColourComponent($RGB, $offset, $hex = true)
        {
        }
        /**
         * Get the red colour component of an RGB value.
         *
         * @param string $RGB The colour as an RGB value (e.g. FF00CCCC or CCDDEE
         * @param bool $hex Flag indicating whether the component should be returned as a hex or a
         *                                    decimal value
         *
         * @return string The red colour component
         */
        public static function getRed($RGB, $hex = true)
        {
        }
        /**
         * Get the green colour component of an RGB value.
         *
         * @param string $RGB The colour as an RGB value (e.g. FF00CCCC or CCDDEE
         * @param bool $hex Flag indicating whether the component should be returned as a hex or a
         *                                    decimal value
         *
         * @return string The green colour component
         */
        public static function getGreen($RGB, $hex = true)
        {
        }
        /**
         * Get the blue colour component of an RGB value.
         *
         * @param string $RGB The colour as an RGB value (e.g. FF00CCCC or CCDDEE
         * @param bool $hex Flag indicating whether the component should be returned as a hex or a
         *                                    decimal value
         *
         * @return string The blue colour component
         */
        public static function getBlue($RGB, $hex = true)
        {
        }
        /**
         * Adjust the brightness of a color.
         *
         * @param string $hex The colour as an RGBA or RGB value (e.g. FF00CCCC or CCDDEE)
         * @param float $adjustPercentage The percentage by which to adjust the colour as a float from -1 to 1
         *
         * @return string The adjusted colour as an RGBA or RGB value (e.g. FF00CCCC or CCDDEE)
         */
        public static function changeBrightness($hex, $adjustPercentage)
        {
        }
        /**
         * Get indexed color.
         *
         * @param int $pIndex Index entry point into the colour array
         * @param bool $background Flag to indicate whether default background or foreground colour
         *                                            should be returned if the indexed colour doesn't exist
         *
         * @return self
         */
        public static function indexedColor($pIndex, $background = false)
        {
        }
        /**
         * Get hash code.
         *
         * @return string Hash code
         */
        public function getHashCode()
        {
        }
    }
    class Conditional implements \PhpOffice\PhpSpreadsheet\IComparable
    {
        // Condition types
        const CONDITION_NONE = 'none';
        const CONDITION_CELLIS = 'cellIs';
        const CONDITION_CONTAINSTEXT = 'containsText';
        const CONDITION_EXPRESSION = 'expression';
        const CONDITION_CONTAINSBLANKS = 'containsBlanks';
        const CONDITION_NOTCONTAINSBLANKS = 'notContainsBlanks';
        // Operator types
        const OPERATOR_NONE = '';
        const OPERATOR_BEGINSWITH = 'beginsWith';
        const OPERATOR_ENDSWITH = 'endsWith';
        const OPERATOR_EQUAL = 'equal';
        const OPERATOR_GREATERTHAN = 'greaterThan';
        const OPERATOR_GREATERTHANOREQUAL = 'greaterThanOrEqual';
        const OPERATOR_LESSTHAN = 'lessThan';
        const OPERATOR_LESSTHANOREQUAL = 'lessThanOrEqual';
        const OPERATOR_NOTEQUAL = 'notEqual';
        const OPERATOR_CONTAINSTEXT = 'containsText';
        const OPERATOR_NOTCONTAINS = 'notContains';
        const OPERATOR_BETWEEN = 'between';
        const OPERATOR_NOTBETWEEN = 'notBetween';
        /**
         * Condition type.
         *
         * @var string
         */
        private $conditionType = self::CONDITION_NONE;
        /**
         * Operator type.
         *
         * @var string
         */
        private $operatorType = self::OPERATOR_NONE;
        /**
         * Text.
         *
         * @var string
         */
        private $text;
        /**
         * Stop on this condition, if it matches.
         *
         * @var bool
         */
        private $stopIfTrue = false;
        /**
         * Condition.
         *
         * @var string[]
         */
        private $condition = [];
        /**
         * Style.
         *
         * @var Style
         */
        private $style;
        /**
         * Create a new Conditional.
         */
        public function __construct()
        {
        }
        /**
         * Get Condition type.
         *
         * @return string
         */
        public function getConditionType()
        {
        }
        /**
         * Set Condition type.
         *
         * @param string $pValue Condition type, see self::CONDITION_*
         *
         * @return $this
         */
        public function setConditionType($pValue)
        {
        }
        /**
         * Get Operator type.
         *
         * @return string
         */
        public function getOperatorType()
        {
        }
        /**
         * Set Operator type.
         *
         * @param string $pValue Conditional operator type, see self::OPERATOR_*
         *
         * @return $this
         */
        public function setOperatorType($pValue)
        {
        }
        /**
         * Get text.
         *
         * @return string
         */
        public function getText()
        {
        }
        /**
         * Set text.
         *
         * @param string $value
         *
         * @return $this
         */
        public function setText($value)
        {
        }
        /**
         * Get StopIfTrue.
         *
         * @return bool
         */
        public function getStopIfTrue()
        {
        }
        /**
         * Set StopIfTrue.
         *
         * @param bool $value
         *
         * @return $this
         */
        public function setStopIfTrue($value)
        {
        }
        /**
         * Get Conditions.
         *
         * @return string[]
         */
        public function getConditions()
        {
        }
        /**
         * Set Conditions.
         *
         * @param string[] $pValue Condition
         *
         * @return $this
         */
        public function setConditions($pValue)
        {
        }
        /**
         * Add Condition.
         *
         * @param string $pValue Condition
         *
         * @return $this
         */
        public function addCondition($pValue)
        {
        }
        /**
         * Get Style.
         *
         * @return Style
         */
        public function getStyle()
        {
        }
        /**
         * Set Style.
         *
         * @param Style $pValue
         *
         * @return $this
         */
        public function setStyle(?\PhpOffice\PhpSpreadsheet\Style\Style $pValue = null)
        {
        }
        /**
         * Get hash code.
         *
         * @return string Hash code
         */
        public function getHashCode()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    class Borders extends \PhpOffice\PhpSpreadsheet\Style\Supervisor
    {
        // Diagonal directions
        const DIAGONAL_NONE = 0;
        const DIAGONAL_UP = 1;
        const DIAGONAL_DOWN = 2;
        const DIAGONAL_BOTH = 3;
        /**
         * Left.
         *
         * @var Border
         */
        protected $left;
        /**
         * Right.
         *
         * @var Border
         */
        protected $right;
        /**
         * Top.
         *
         * @var Border
         */
        protected $top;
        /**
         * Bottom.
         *
         * @var Border
         */
        protected $bottom;
        /**
         * Diagonal.
         *
         * @var Border
         */
        protected $diagonal;
        /**
         * DiagonalDirection.
         *
         * @var int
         */
        protected $diagonalDirection;
        /**
         * All borders pseudo-border. Only applies to supervisor.
         *
         * @var Border
         */
        protected $allBorders;
        /**
         * Outline pseudo-border. Only applies to supervisor.
         *
         * @var Border
         */
        protected $outline;
        /**
         * Inside pseudo-border. Only applies to supervisor.
         *
         * @var Border
         */
        protected $inside;
        /**
         * Vertical pseudo-border. Only applies to supervisor.
         *
         * @var Border
         */
        protected $vertical;
        /**
         * Horizontal pseudo-border. Only applies to supervisor.
         *
         * @var Border
         */
        protected $horizontal;
        /**
         * Create a new Borders.
         *
         * @param bool $isSupervisor Flag indicating if this is a supervisor or not
         *                                    Leave this value at default unless you understand exactly what
         *                                        its ramifications are
         * @param bool $isConditional Flag indicating if this is a conditional style or not
         *                                    Leave this value at default unless you understand exactly what
         *                                        its ramifications are
         */
        public function __construct($isSupervisor = false, $isConditional = false)
        {
        }
        /**
         * Get the shared style component for the currently active cell in currently active sheet.
         * Only used for style supervisor.
         *
         * @return Borders
         */
        public function getSharedComponent()
        {
        }
        /**
         * Build style array from subcomponents.
         *
         * @param array $array
         *
         * @return array
         */
        public function getStyleArray($array)
        {
        }
        /**
         * Apply styles from array.
         *
         * <code>
         * $spreadsheet->getActiveSheet()->getStyle('B2')->getBorders()->applyFromArray(
         *         [
         *             'bottom' => [
         *                 'borderStyle' => Border::BORDER_DASHDOT,
         *                 'color' => [
         *                     'rgb' => '808080'
         *                 ]
         *             ],
         *             'top' => [
         *                 'borderStyle' => Border::BORDER_DASHDOT,
         *                 'color' => [
         *                     'rgb' => '808080'
         *                 ]
         *             ]
         *         ]
         * );
         * </code>
         *
         * <code>
         * $spreadsheet->getActiveSheet()->getStyle('B2')->getBorders()->applyFromArray(
         *         [
         *             'allBorders' => [
         *                 'borderStyle' => Border::BORDER_DASHDOT,
         *                 'color' => [
         *                     'rgb' => '808080'
         *                 ]
         *             ]
         *         ]
         * );
         * </code>
         *
         * @param array $pStyles Array containing style information
         *
         * @return $this
         */
        public function applyFromArray(array $pStyles)
        {
        }
        /**
         * Get Left.
         *
         * @return Border
         */
        public function getLeft()
        {
        }
        /**
         * Get Right.
         *
         * @return Border
         */
        public function getRight()
        {
        }
        /**
         * Get Top.
         *
         * @return Border
         */
        public function getTop()
        {
        }
        /**
         * Get Bottom.
         *
         * @return Border
         */
        public function getBottom()
        {
        }
        /**
         * Get Diagonal.
         *
         * @return Border
         */
        public function getDiagonal()
        {
        }
        /**
         * Get AllBorders (pseudo-border). Only applies to supervisor.
         *
         * @return Border
         */
        public function getAllBorders()
        {
        }
        /**
         * Get Outline (pseudo-border). Only applies to supervisor.
         *
         * @return Border
         */
        public function getOutline()
        {
        }
        /**
         * Get Inside (pseudo-border). Only applies to supervisor.
         *
         * @return Border
         */
        public function getInside()
        {
        }
        /**
         * Get Vertical (pseudo-border). Only applies to supervisor.
         *
         * @return Border
         */
        public function getVertical()
        {
        }
        /**
         * Get Horizontal (pseudo-border). Only applies to supervisor.
         *
         * @return Border
         */
        public function getHorizontal()
        {
        }
        /**
         * Get DiagonalDirection.
         *
         * @return int
         */
        public function getDiagonalDirection()
        {
        }
        /**
         * Set DiagonalDirection.
         *
         * @param int $pValue see self::DIAGONAL_*
         *
         * @return $this
         */
        public function setDiagonalDirection($pValue)
        {
        }
        /**
         * Get hash code.
         *
         * @return string Hash code
         */
        public function getHashCode()
        {
        }
    }
    class Font extends \PhpOffice\PhpSpreadsheet\Style\Supervisor
    {
        // Underline types
        const UNDERLINE_NONE = 'none';
        const UNDERLINE_DOUBLE = 'double';
        const UNDERLINE_DOUBLEACCOUNTING = 'doubleAccounting';
        const UNDERLINE_SINGLE = 'single';
        const UNDERLINE_SINGLEACCOUNTING = 'singleAccounting';
        /**
         * Font Name.
         *
         * @var string
         */
        protected $name = 'Calibri';
        /**
         * Font Size.
         *
         * @var float
         */
        protected $size = 11;
        /**
         * Bold.
         *
         * @var bool
         */
        protected $bold = false;
        /**
         * Italic.
         *
         * @var bool
         */
        protected $italic = false;
        /**
         * Superscript.
         *
         * @var bool
         */
        protected $superscript = false;
        /**
         * Subscript.
         *
         * @var bool
         */
        protected $subscript = false;
        /**
         * Underline.
         *
         * @var string
         */
        protected $underline = self::UNDERLINE_NONE;
        /**
         * Strikethrough.
         *
         * @var bool
         */
        protected $strikethrough = false;
        /**
         * Foreground color.
         *
         * @var Color
         */
        protected $color;
        /**
         * @var int
         */
        public $colorIndex;
        /**
         * Create a new Font.
         *
         * @param bool $isSupervisor Flag indicating if this is a supervisor or not
         *                                    Leave this value at default unless you understand exactly what
         *                                        its ramifications are
         * @param bool $isConditional Flag indicating if this is a conditional style or not
         *                                    Leave this value at default unless you understand exactly what
         *                                        its ramifications are
         */
        public function __construct($isSupervisor = false, $isConditional = false)
        {
        }
        /**
         * Get the shared style component for the currently active cell in currently active sheet.
         * Only used for style supervisor.
         *
         * @return Font
         */
        public function getSharedComponent()
        {
        }
        /**
         * Build style array from subcomponents.
         *
         * @param array $array
         *
         * @return array
         */
        public function getStyleArray($array)
        {
        }
        /**
         * Apply styles from array.
         *
         * <code>
         * $spreadsheet->getActiveSheet()->getStyle('B2')->getFont()->applyFromArray(
         *     [
         *         'name' => 'Arial',
         *         'bold' => TRUE,
         *         'italic' => FALSE,
         *         'underline' => \PhpOffice\PhpSpreadsheet\Style\Font::UNDERLINE_DOUBLE,
         *         'strikethrough' => FALSE,
         *         'color' => [
         *             'rgb' => '808080'
         *         ]
         *     ]
         * );
         * </code>
         *
         * @param array $pStyles Array containing style information
         *
         * @return $this
         */
        public function applyFromArray(array $pStyles)
        {
        }
        /**
         * Get Name.
         *
         * @return string
         */
        public function getName()
        {
        }
        /**
         * Set Name.
         *
         * @param string $pValue
         *
         * @return $this
         */
        public function setName($pValue)
        {
        }
        /**
         * Get Size.
         *
         * @return float
         */
        public function getSize()
        {
        }
        /**
         * Set Size.
         *
         * @param float $pValue
         *
         * @return $this
         */
        public function setSize($pValue)
        {
        }
        /**
         * Get Bold.
         *
         * @return bool
         */
        public function getBold()
        {
        }
        /**
         * Set Bold.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setBold($pValue)
        {
        }
        /**
         * Get Italic.
         *
         * @return bool
         */
        public function getItalic()
        {
        }
        /**
         * Set Italic.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setItalic($pValue)
        {
        }
        /**
         * Get Superscript.
         *
         * @return bool
         */
        public function getSuperscript()
        {
        }
        /**
         * Set Superscript.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setSuperscript($pValue)
        {
        }
        /**
         * Get Subscript.
         *
         * @return bool
         */
        public function getSubscript()
        {
        }
        /**
         * Set Subscript.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setSubscript($pValue)
        {
        }
        /**
         * Get Underline.
         *
         * @return string
         */
        public function getUnderline()
        {
        }
        /**
         * Set Underline.
         *
         * @param bool|string $pValue \PhpOffice\PhpSpreadsheet\Style\Font underline type
         *                                    If a boolean is passed, then TRUE equates to UNDERLINE_SINGLE,
         *                                        false equates to UNDERLINE_NONE
         *
         * @return $this
         */
        public function setUnderline($pValue)
        {
        }
        /**
         * Get Strikethrough.
         *
         * @return bool
         */
        public function getStrikethrough()
        {
        }
        /**
         * Set Strikethrough.
         *
         * @param bool $pValue
         *
         * @return $this
         */
        public function setStrikethrough($pValue)
        {
        }
        /**
         * Get Color.
         *
         * @return Color
         */
        public function getColor()
        {
        }
        /**
         * Set Color.
         *
         * @return $this
         */
        public function setColor(\PhpOffice\PhpSpreadsheet\Style\Color $pValue)
        {
        }
        /**
         * Get hash code.
         *
         * @return string Hash code
         */
        public function getHashCode()
        {
        }
    }
    class Border extends \PhpOffice\PhpSpreadsheet\Style\Supervisor
    {
        // Border style
        const BORDER_NONE = 'none';
        const BORDER_DASHDOT = 'dashDot';
        const BORDER_DASHDOTDOT = 'dashDotDot';
        const BORDER_DASHED = 'dashed';
        const BORDER_DOTTED = 'dotted';
        const BORDER_DOUBLE = 'double';
        const BORDER_HAIR = 'hair';
        const BORDER_MEDIUM = 'medium';
        const BORDER_MEDIUMDASHDOT = 'mediumDashDot';
        const BORDER_MEDIUMDASHDOTDOT = 'mediumDashDotDot';
        const BORDER_MEDIUMDASHED = 'mediumDashed';
        const BORDER_SLANTDASHDOT = 'slantDashDot';
        const BORDER_THICK = 'thick';
        const BORDER_THIN = 'thin';
        /**
         * Border style.
         *
         * @var string
         */
        protected $borderStyle = self::BORDER_NONE;
        /**
         * Border color.
         *
         * @var Color
         */
        protected $color;
        /**
         * @var int
         */
        public $colorIndex;
        /**
         * Create a new Border.
         *
         * @param bool $isSupervisor Flag indicating if this is a supervisor or not
         *                                    Leave this value at default unless you understand exactly what
         *                                        its ramifications are
         * @param bool $isConditional Flag indicating if this is a conditional style or not
         *                                    Leave this value at default unless you understand exactly what
         *                                        its ramifications are
         */
        public function __construct($isSupervisor = false, $isConditional = false)
        {
        }
        /**
         * Get the shared style component for the currently active cell in currently active sheet.
         * Only used for style supervisor.
         *
         * @return Border
         */
        public function getSharedComponent()
        {
        }
        /**
         * Build style array from subcomponents.
         *
         * @param array $array
         *
         * @return array
         */
        public function getStyleArray($array)
        {
        }
        /**
         * Apply styles from array.
         *
         * <code>
         * $spreadsheet->getActiveSheet()->getStyle('B2')->getBorders()->getTop()->applyFromArray(
         *        [
         *            'borderStyle' => Border::BORDER_DASHDOT,
         *            'color' => [
         *                'rgb' => '808080'
         *            ]
         *        ]
         * );
         * </code>
         *
         * @param array $pStyles Array containing style information
         *
         * @return $this
         */
        public function applyFromArray(array $pStyles)
        {
        }
        /**
         * Get Border style.
         *
         * @return string
         */
        public function getBorderStyle()
        {
        }
        /**
         * Set Border style.
         *
         * @param bool|string $pValue
         *                            When passing a boolean, FALSE equates Border::BORDER_NONE
         *                                and TRUE to Border::BORDER_MEDIUM
         *
         * @return $this
         */
        public function setBorderStyle($pValue)
        {
        }
        /**
         * Get Border Color.
         *
         * @return Color
         */
        public function getColor()
        {
        }
        /**
         * Set Border Color.
         *
         * @return $this
         */
        public function setColor(\PhpOffice\PhpSpreadsheet\Style\Color $pValue)
        {
        }
        /**
         * Get hash code.
         *
         * @return string Hash code
         */
        public function getHashCode()
        {
        }
    }
    class NumberFormat extends \PhpOffice\PhpSpreadsheet\Style\Supervisor
    {
        // Pre-defined formats
        const FORMAT_GENERAL = 'General';
        const FORMAT_TEXT = '@';
        const FORMAT_NUMBER = '0';
        const FORMAT_NUMBER_00 = '0.00';
        const FORMAT_NUMBER_COMMA_SEPARATED1 = '#,##0.00';
        const FORMAT_NUMBER_COMMA_SEPARATED2 = '#,##0.00_-';
        const FORMAT_PERCENTAGE = '0%';
        const FORMAT_PERCENTAGE_00 = '0.00%';
        const FORMAT_DATE_YYYYMMDD2 = 'yyyy-mm-dd';
        const FORMAT_DATE_YYYYMMDD = 'yyyy-mm-dd';
        const FORMAT_DATE_DDMMYYYY = 'dd/mm/yyyy';
        const FORMAT_DATE_DMYSLASH = 'd/m/yy';
        const FORMAT_DATE_DMYMINUS = 'd-m-yy';
        const FORMAT_DATE_DMMINUS = 'd-m';
        const FORMAT_DATE_MYMINUS = 'm-yy';
        const FORMAT_DATE_XLSX14 = 'mm-dd-yy';
        const FORMAT_DATE_XLSX15 = 'd-mmm-yy';
        const FORMAT_DATE_XLSX16 = 'd-mmm';
        const FORMAT_DATE_XLSX17 = 'mmm-yy';
        const FORMAT_DATE_XLSX22 = 'm/d/yy h:mm';
        const FORMAT_DATE_DATETIME = 'd/m/yy h:mm';
        const FORMAT_DATE_TIME1 = 'h:mm AM/PM';
        const FORMAT_DATE_TIME2 = 'h:mm:ss AM/PM';
        const FORMAT_DATE_TIME3 = 'h:mm';
        const FORMAT_DATE_TIME4 = 'h:mm:ss';
        const FORMAT_DATE_TIME5 = 'mm:ss';
        const FORMAT_DATE_TIME6 = 'h:mm:ss';
        const FORMAT_DATE_TIME7 = 'i:s.S';
        const FORMAT_DATE_TIME8 = 'h:mm:ss;@';
        const FORMAT_DATE_YYYYMMDDSLASH = 'yyyy/mm/dd;@';
        const FORMAT_CURRENCY_USD_SIMPLE = '"$"#,##0.00_-';
        const FORMAT_CURRENCY_USD = '$#,##0_-';
        const FORMAT_CURRENCY_EUR_SIMPLE = '#,##0.00_-""';
        const FORMAT_CURRENCY_EUR = '#,##0_-""';
        const FORMAT_ACCOUNTING_USD = '_("$"* #,##0.00_);_("$"* \\(#,##0.00\\);_("$"* "-"??_);_(@_)';
        const FORMAT_ACCOUNTING_EUR = '_(""* #,##0.00_);_(""* \\(#,##0.00\\);_(""* "-"??_);_(@_)';
        /**
         * Excel built-in number formats.
         *
         * @var array
         */
        protected static $builtInFormats;
        /**
         * Excel built-in number formats (flipped, for faster lookups).
         *
         * @var array
         */
        protected static $flippedBuiltInFormats;
        /**
         * Format Code.
         *
         * @var string
         */
        protected $formatCode = self::FORMAT_GENERAL;
        /**
         * Built-in format Code.
         *
         * @var string
         */
        protected $builtInFormatCode = 0;
        /**
         * Create a new NumberFormat.
         *
         * @param bool $isSupervisor Flag indicating if this is a supervisor or not
         *                                    Leave this value at default unless you understand exactly what
         *                                        its ramifications are
         * @param bool $isConditional Flag indicating if this is a conditional style or not
         *                                    Leave this value at default unless you understand exactly what
         *                                        its ramifications are
         */
        public function __construct($isSupervisor = false, $isConditional = false)
        {
        }
        /**
         * Get the shared style component for the currently active cell in currently active sheet.
         * Only used for style supervisor.
         *
         * @return NumberFormat
         */
        public function getSharedComponent()
        {
        }
        /**
         * Build style array from subcomponents.
         *
         * @param array $array
         *
         * @return array
         */
        public function getStyleArray($array)
        {
        }
        /**
         * Apply styles from array.
         *
         * <code>
         * $spreadsheet->getActiveSheet()->getStyle('B2')->getNumberFormat()->applyFromArray(
         *     [
         *         'formatCode' => NumberFormat::FORMAT_CURRENCY_EUR_SIMPLE
         *     ]
         * );
         * </code>
         *
         * @param array $pStyles Array containing style information
         *
         * @return $this
         */
        public function applyFromArray(array $pStyles)
        {
        }
        /**
         * Get Format Code.
         *
         * @return string
         */
        public function getFormatCode()
        {
        }
        /**
         * Set Format Code.
         *
         * @param string $pValue see self::FORMAT_*
         *
         * @return $this
         */
        public function setFormatCode($pValue)
        {
        }
        /**
         * Get Built-In Format Code.
         *
         * @return int
         */
        public function getBuiltInFormatCode()
        {
        }
        /**
         * Set Built-In Format Code.
         *
         * @param int $pValue
         *
         * @return $this
         */
        public function setBuiltInFormatCode($pValue)
        {
        }
        /**
         * Fill built-in format codes.
         */
        private static function fillBuiltInFormatCodes() : void
        {
        }
        /**
         * Get built-in format code.
         *
         * @param int $pIndex
         *
         * @return string
         */
        public static function builtInFormatCode($pIndex)
        {
        }
        /**
         * Get built-in format code index.
         *
         * @param string $formatCode
         *
         * @return bool|int
         */
        public static function builtInFormatCodeIndex($formatCode)
        {
        }
        /**
         * Get hash code.
         *
         * @return string Hash code
         */
        public function getHashCode()
        {
        }
        /**
         * Search/replace values to convert Excel date/time format masks to PHP format masks.
         *
         * @var array
         */
        private static $dateFormatReplacements = [
            // first remove escapes related to non-format characters
            '\\' => '',
            //    12-hour suffix
            'am/pm' => 'A',
            //    4-digit year
            'e' => 'Y',
            'yyyy' => 'Y',
            //    2-digit year
            'yy' => 'y',
            //    first letter of month - no php equivalent
            'mmmmm' => 'M',
            //    full month name
            'mmmm' => 'F',
            //    short month name
            'mmm' => 'M',
            //    mm is minutes if time, but can also be month w/leading zero
            //    so we try to identify times be the inclusion of a : separator in the mask
            //    It isn't perfect, but the best way I know how
            ':mm' => ':i',
            'mm:' => 'i:',
            //    month leading zero
            'mm' => 'm',
            //    month no leading zero
            'm' => 'n',
            //    full day of week name
            'dddd' => 'l',
            //    short day of week name
            'ddd' => 'D',
            //    days leading zero
            'dd' => 'd',
            //    days no leading zero
            'd' => 'j',
            //    seconds
            'ss' => 's',
            //    fractional seconds - no php equivalent
            '.s' => '',
        ];
        /**
         * Search/replace values to convert Excel date/time format masks hours to PHP format masks (24 hr clock).
         *
         * @var array
         */
        private static $dateFormatReplacements24 = ['hh' => 'H', 'h' => 'G'];
        /**
         * Search/replace values to convert Excel date/time format masks hours to PHP format masks (12 hr clock).
         *
         * @var array
         */
        private static $dateFormatReplacements12 = ['hh' => 'h', 'h' => 'g'];
        private static function setLowercaseCallback($matches)
        {
        }
        private static function escapeQuotesCallback($matches)
        {
        }
        private static function formatAsDate(&$value, &$format) : void
        {
        }
        private static function formatAsPercentage(&$value, &$format) : void
        {
        }
        private static function formatAsFraction(&$value, &$format) : void
        {
        }
        private static function mergeComplexNumberFormatMasks($numbers, $masks)
        {
        }
        private static function processComplexNumberFormatMask($number, $mask)
        {
        }
        private static function complexNumberFormatMask($number, $mask, $splitOnPoint = true)
        {
        }
        private static function formatStraightNumericValue($value, $format, array $matches, $useThousands, $number_regex)
        {
        }
        private static function formatAsNumber($value, $format)
        {
        }
        private static function splitFormatCompare($value, $cond, $val, $dfcond, $dfval)
        {
        }
        private static function splitFormat($sections, $value)
        {
        }
        /**
         * Convert a value in a pre-defined format to a PHP string.
         *
         * @param mixed $value Value to format
         * @param string $format Format code, see = self::FORMAT_*
         * @param array $callBack Callback function for additional formatting of string
         *
         * @return string Formatted string
         */
        public static function toFormattedString($value, $format, $callBack = null)
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\RichText {
    interface ITextElement
    {
        /**
         * Get text.
         *
         * @return string Text
         */
        public function getText();
        /**
         * Set text.
         *
         * @param $text string Text
         *
         * @return ITextElement
         */
        public function setText($text);
        /**
         * Get font.
         *
         * @return null|\PhpOffice\PhpSpreadsheet\Style\Font
         */
        public function getFont();
        /**
         * Get hash code.
         *
         * @return string Hash code
         */
        public function getHashCode();
    }
    class TextElement implements \PhpOffice\PhpSpreadsheet\RichText\ITextElement
    {
        /**
         * Text.
         *
         * @var string
         */
        private $text;
        /**
         * Create a new TextElement instance.
         *
         * @param string $pText Text
         */
        public function __construct($pText = '')
        {
        }
        /**
         * Get text.
         *
         * @return string Text
         */
        public function getText()
        {
        }
        /**
         * Set text.
         *
         * @param $text string Text
         *
         * @return $this
         */
        public function setText($text)
        {
        }
        /**
         * Get font.
         *
         * @return null|\PhpOffice\PhpSpreadsheet\Style\Font
         */
        public function getFont()
        {
        }
        /**
         * Get hash code.
         *
         * @return string Hash code
         */
        public function getHashCode()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
    class Run extends \PhpOffice\PhpSpreadsheet\RichText\TextElement implements \PhpOffice\PhpSpreadsheet\RichText\ITextElement
    {
        /**
         * Font.
         *
         * @var Font
         */
        private $font;
        /**
         * Create a new Run instance.
         *
         * @param string $pText Text
         */
        public function __construct($pText = '')
        {
        }
        /**
         * Get font.
         *
         * @return null|\PhpOffice\PhpSpreadsheet\Style\Font
         */
        public function getFont()
        {
        }
        /**
         * Set font.
         *
         * @param Font $pFont Font
         *
         * @return $this
         */
        public function setFont(?\PhpOffice\PhpSpreadsheet\Style\Font $pFont = null)
        {
        }
        /**
         * Get hash code.
         *
         * @return string Hash code
         */
        public function getHashCode()
        {
        }
    }
    class RichText implements \PhpOffice\PhpSpreadsheet\IComparable
    {
        /**
         * Rich text elements.
         *
         * @var ITextElement[]
         */
        private $richTextElements;
        /**
         * Create a new RichText instance.
         *
         * @param Cell $pCell
         */
        public function __construct(?\PhpOffice\PhpSpreadsheet\Cell\Cell $pCell = null)
        {
        }
        /**
         * Add text.
         *
         * @param ITextElement $pText Rich text element
         *
         * @return $this
         */
        public function addText(\PhpOffice\PhpSpreadsheet\RichText\ITextElement $pText)
        {
        }
        /**
         * Create text.
         *
         * @param string $pText Text
         *
         * @return TextElement
         */
        public function createText($pText)
        {
        }
        /**
         * Create text run.
         *
         * @param string $pText Text
         *
         * @return Run
         */
        public function createTextRun($pText)
        {
        }
        /**
         * Get plain text.
         *
         * @return string
         */
        public function getPlainText()
        {
        }
        /**
         * Convert to string.
         *
         * @return string
         */
        public function __toString()
        {
        }
        /**
         * Get Rich Text elements.
         *
         * @return ITextElement[]
         */
        public function getRichTextElements()
        {
        }
        /**
         * Set Rich Text elements.
         *
         * @param ITextElement[] $textElements Array of elements
         *
         * @return $this
         */
        public function setRichTextElements(array $textElements)
        {
        }
        /**
         * Get hash code.
         *
         * @return string Hash code
         */
        public function getHashCode()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet {
    /**
     * Factory to create readers and writers easily.
     *
     * It is not required to use this class, but it should make it easier to read and write files.
     * Especially for reading files with an unknown format.
     */
    abstract class IOFactory
    {
        private static $readers = ['Xlsx' => \PhpOffice\PhpSpreadsheet\Reader\Xlsx::class, 'Xls' => \PhpOffice\PhpSpreadsheet\Reader\Xls::class, 'Xml' => \PhpOffice\PhpSpreadsheet\Reader\Xml::class, 'Ods' => \PhpOffice\PhpSpreadsheet\Reader\Ods::class, 'Slk' => \PhpOffice\PhpSpreadsheet\Reader\Slk::class, 'Gnumeric' => \PhpOffice\PhpSpreadsheet\Reader\Gnumeric::class, 'Html' => \PhpOffice\PhpSpreadsheet\Reader\Html::class, 'Csv' => \PhpOffice\PhpSpreadsheet\Reader\Csv::class];
        private static $writers = ['Xls' => \PhpOffice\PhpSpreadsheet\Writer\Xls::class, 'Xlsx' => \PhpOffice\PhpSpreadsheet\Writer\Xlsx::class, 'Ods' => \PhpOffice\PhpSpreadsheet\Writer\Ods::class, 'Csv' => \PhpOffice\PhpSpreadsheet\Writer\Csv::class, 'Html' => \PhpOffice\PhpSpreadsheet\Writer\Html::class, 'Tcpdf' => \PhpOffice\PhpSpreadsheet\Writer\Pdf\Tcpdf::class, 'Dompdf' => \PhpOffice\PhpSpreadsheet\Writer\Pdf\Dompdf::class, 'Mpdf' => \PhpOffice\PhpSpreadsheet\Writer\Pdf\Mpdf::class];
        /**
         * Create Writer\IWriter.
         *
         * @param string $writerType Example: Xlsx
         *
         * @return Writer\IWriter
         */
        public static function createWriter(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet, $writerType)
        {
        }
        /**
         * Create Reader\IReader.
         *
         * @param string $readerType Example: Xlsx
         *
         * @return Reader\IReader
         */
        public static function createReader($readerType)
        {
        }
        /**
         * Loads Spreadsheet from file using automatic Reader\IReader resolution.
         *
         * @param string $pFilename The name of the spreadsheet file
         *
         * @return Spreadsheet
         */
        public static function load($pFilename)
        {
        }
        /**
         * Identify file type using automatic Reader\IReader resolution.
         *
         * @param string $pFilename The name of the spreadsheet file to identify
         *
         * @return string
         */
        public static function identify($pFilename)
        {
        }
        /**
         * Create Reader\IReader for file using automatic Reader\IReader resolution.
         *
         * @param string $filename The name of the spreadsheet file
         *
         * @return Reader\IReader
         */
        public static function createReaderForFile($filename)
        {
        }
        /**
         * Guess a reader type from the file extension, if any.
         *
         * @param string $filename
         *
         * @return null|string
         */
        private static function getReaderTypeFromExtension($filename)
        {
        }
        /**
         * Register a writer with its type and class name.
         *
         * @param string $writerType
         * @param string $writerClass
         */
        public static function registerWriter($writerType, $writerClass) : void
        {
        }
        /**
         * Register a reader with its type and class name.
         *
         * @param string $readerType
         * @param string $readerClass
         */
        public static function registerReader($readerType, $readerClass) : void
        {
        }
    }
    class NamedRange
    {
        /**
         * Range name.
         *
         * @var string
         */
        private $name;
        /**
         * Worksheet on which the named range can be resolved.
         *
         * @var Worksheet
         */
        private $worksheet;
        /**
         * Range of the referenced cells.
         *
         * @var string
         */
        private $range;
        /**
         * Is the named range local? (i.e. can only be used on $this->worksheet).
         *
         * @var bool
         */
        private $localOnly;
        /**
         * Scope.
         *
         * @var Worksheet
         */
        private $scope;
        /**
         * Create a new NamedRange.
         *
         * @param string $pName
         * @param string $pRange
         * @param bool $pLocalOnly
         * @param null|Worksheet $pScope Scope. Only applies when $pLocalOnly = true. Null for global scope.
         */
        public function __construct($pName, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pWorksheet, $pRange = 'A1', $pLocalOnly = false, $pScope = null)
        {
        }
        /**
         * Get name.
         *
         * @return string
         */
        public function getName()
        {
        }
        /**
         * Set name.
         *
         * @param string $value
         *
         * @return $this
         */
        public function setName($value)
        {
        }
        /**
         * Get worksheet.
         *
         * @return Worksheet
         */
        public function getWorksheet()
        {
        }
        /**
         * Set worksheet.
         *
         * @param Worksheet $value
         *
         * @return $this
         */
        public function setWorksheet(?\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $value = null)
        {
        }
        /**
         * Get range.
         *
         * @return string
         */
        public function getRange()
        {
        }
        /**
         * Set range.
         *
         * @param string $value
         *
         * @return $this
         */
        public function setRange($value)
        {
        }
        /**
         * Get localOnly.
         *
         * @return bool
         */
        public function getLocalOnly()
        {
        }
        /**
         * Set localOnly.
         *
         * @param bool $value
         *
         * @return $this
         */
        public function setLocalOnly($value)
        {
        }
        /**
         * Get scope.
         *
         * @return null|Worksheet
         */
        public function getScope()
        {
        }
        /**
         * Set scope.
         *
         * @return $this
         */
        public function setScope(?\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $value = null)
        {
        }
        /**
         * Resolve a named range to a regular cell range.
         *
         * @param string $pNamedRange Named range
         * @param null|Worksheet $pSheet Scope. Use null for global scope
         *
         * @return NamedRange
         */
        public static function resolveRange($pNamedRange, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet)
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Helper {
    class Html
    {
        protected static $colourMap = ['aliceblue' => 'f0f8ff', 'antiquewhite' => 'faebd7', 'antiquewhite1' => 'ffefdb', 'antiquewhite2' => 'eedfcc', 'antiquewhite3' => 'cdc0b0', 'antiquewhite4' => '8b8378', 'aqua' => '00ffff', 'aquamarine1' => '7fffd4', 'aquamarine2' => '76eec6', 'aquamarine4' => '458b74', 'azure1' => 'f0ffff', 'azure2' => 'e0eeee', 'azure3' => 'c1cdcd', 'azure4' => '838b8b', 'beige' => 'f5f5dc', 'bisque1' => 'ffe4c4', 'bisque2' => 'eed5b7', 'bisque3' => 'cdb79e', 'bisque4' => '8b7d6b', 'black' => '000000', 'blanchedalmond' => 'ffebcd', 'blue' => '0000ff', 'blue1' => '0000ff', 'blue2' => '0000ee', 'blue4' => '00008b', 'blueviolet' => '8a2be2', 'brown' => 'a52a2a', 'brown1' => 'ff4040', 'brown2' => 'ee3b3b', 'brown3' => 'cd3333', 'brown4' => '8b2323', 'burlywood' => 'deb887', 'burlywood1' => 'ffd39b', 'burlywood2' => 'eec591', 'burlywood3' => 'cdaa7d', 'burlywood4' => '8b7355', 'cadetblue' => '5f9ea0', 'cadetblue1' => '98f5ff', 'cadetblue2' => '8ee5ee', 'cadetblue3' => '7ac5cd', 'cadetblue4' => '53868b', 'chartreuse1' => '7fff00', 'chartreuse2' => '76ee00', 'chartreuse3' => '66cd00', 'chartreuse4' => '458b00', 'chocolate' => 'd2691e', 'chocolate1' => 'ff7f24', 'chocolate2' => 'ee7621', 'chocolate3' => 'cd661d', 'coral' => 'ff7f50', 'coral1' => 'ff7256', 'coral2' => 'ee6a50', 'coral3' => 'cd5b45', 'coral4' => '8b3e2f', 'cornflowerblue' => '6495ed', 'cornsilk1' => 'fff8dc', 'cornsilk2' => 'eee8cd', 'cornsilk3' => 'cdc8b1', 'cornsilk4' => '8b8878', 'cyan1' => '00ffff', 'cyan2' => '00eeee', 'cyan3' => '00cdcd', 'cyan4' => '008b8b', 'darkgoldenrod' => 'b8860b', 'darkgoldenrod1' => 'ffb90f', 'darkgoldenrod2' => 'eead0e', 'darkgoldenrod3' => 'cd950c', 'darkgoldenrod4' => '8b6508', 'darkgreen' => '006400', 'darkkhaki' => 'bdb76b', 'darkolivegreen' => '556b2f', 'darkolivegreen1' => 'caff70', 'darkolivegreen2' => 'bcee68', 'darkolivegreen3' => 'a2cd5a', 'darkolivegreen4' => '6e8b3d', 'darkorange' => 'ff8c00', 'darkorange1' => 'ff7f00', 'darkorange2' => 'ee7600', 'darkorange3' => 'cd6600', 'darkorange4' => '8b4500', 'darkorchid' => '9932cc', 'darkorchid1' => 'bf3eff', 'darkorchid2' => 'b23aee', 'darkorchid3' => '9a32cd', 'darkorchid4' => '68228b', 'darksalmon' => 'e9967a', 'darkseagreen' => '8fbc8f', 'darkseagreen1' => 'c1ffc1', 'darkseagreen2' => 'b4eeb4', 'darkseagreen3' => '9bcd9b', 'darkseagreen4' => '698b69', 'darkslateblue' => '483d8b', 'darkslategray' => '2f4f4f', 'darkslategray1' => '97ffff', 'darkslategray2' => '8deeee', 'darkslategray3' => '79cdcd', 'darkslategray4' => '528b8b', 'darkturquoise' => '00ced1', 'darkviolet' => '9400d3', 'deeppink1' => 'ff1493', 'deeppink2' => 'ee1289', 'deeppink3' => 'cd1076', 'deeppink4' => '8b0a50', 'deepskyblue1' => '00bfff', 'deepskyblue2' => '00b2ee', 'deepskyblue3' => '009acd', 'deepskyblue4' => '00688b', 'dimgray' => '696969', 'dodgerblue1' => '1e90ff', 'dodgerblue2' => '1c86ee', 'dodgerblue3' => '1874cd', 'dodgerblue4' => '104e8b', 'firebrick' => 'b22222', 'firebrick1' => 'ff3030', 'firebrick2' => 'ee2c2c', 'firebrick3' => 'cd2626', 'firebrick4' => '8b1a1a', 'floralwhite' => 'fffaf0', 'forestgreen' => '228b22', 'fuchsia' => 'ff00ff', 'gainsboro' => 'dcdcdc', 'ghostwhite' => 'f8f8ff', 'gold1' => 'ffd700', 'gold2' => 'eec900', 'gold3' => 'cdad00', 'gold4' => '8b7500', 'goldenrod' => 'daa520', 'goldenrod1' => 'ffc125', 'goldenrod2' => 'eeb422', 'goldenrod3' => 'cd9b1d', 'goldenrod4' => '8b6914', 'gray' => 'bebebe', 'gray1' => '030303', 'gray10' => '1a1a1a', 'gray11' => '1c1c1c', 'gray12' => '1f1f1f', 'gray13' => '212121', 'gray14' => '242424', 'gray15' => '262626', 'gray16' => '292929', 'gray17' => '2b2b2b', 'gray18' => '2e2e2e', 'gray19' => '303030', 'gray2' => '050505', 'gray20' => '333333', 'gray21' => '363636', 'gray22' => '383838', 'gray23' => '3b3b3b', 'gray24' => '3d3d3d', 'gray25' => '404040', 'gray26' => '424242', 'gray27' => '454545', 'gray28' => '474747', 'gray29' => '4a4a4a', 'gray3' => '080808', 'gray30' => '4d4d4d', 'gray31' => '4f4f4f', 'gray32' => '525252', 'gray33' => '545454', 'gray34' => '575757', 'gray35' => '595959', 'gray36' => '5c5c5c', 'gray37' => '5e5e5e', 'gray38' => '616161', 'gray39' => '636363', 'gray4' => '0a0a0a', 'gray40' => '666666', 'gray41' => '696969', 'gray42' => '6b6b6b', 'gray43' => '6e6e6e', 'gray44' => '707070', 'gray45' => '737373', 'gray46' => '757575', 'gray47' => '787878', 'gray48' => '7a7a7a', 'gray49' => '7d7d7d', 'gray5' => '0d0d0d', 'gray50' => '7f7f7f', 'gray51' => '828282', 'gray52' => '858585', 'gray53' => '878787', 'gray54' => '8a8a8a', 'gray55' => '8c8c8c', 'gray56' => '8f8f8f', 'gray57' => '919191', 'gray58' => '949494', 'gray59' => '969696', 'gray6' => '0f0f0f', 'gray60' => '999999', 'gray61' => '9c9c9c', 'gray62' => '9e9e9e', 'gray63' => 'a1a1a1', 'gray64' => 'a3a3a3', 'gray65' => 'a6a6a6', 'gray66' => 'a8a8a8', 'gray67' => 'ababab', 'gray68' => 'adadad', 'gray69' => 'b0b0b0', 'gray7' => '121212', 'gray70' => 'b3b3b3', 'gray71' => 'b5b5b5', 'gray72' => 'b8b8b8', 'gray73' => 'bababa', 'gray74' => 'bdbdbd', 'gray75' => 'bfbfbf', 'gray76' => 'c2c2c2', 'gray77' => 'c4c4c4', 'gray78' => 'c7c7c7', 'gray79' => 'c9c9c9', 'gray8' => '141414', 'gray80' => 'cccccc', 'gray81' => 'cfcfcf', 'gray82' => 'd1d1d1', 'gray83' => 'd4d4d4', 'gray84' => 'd6d6d6', 'gray85' => 'd9d9d9', 'gray86' => 'dbdbdb', 'gray87' => 'dedede', 'gray88' => 'e0e0e0', 'gray89' => 'e3e3e3', 'gray9' => '171717', 'gray90' => 'e5e5e5', 'gray91' => 'e8e8e8', 'gray92' => 'ebebeb', 'gray93' => 'ededed', 'gray94' => 'f0f0f0', 'gray95' => 'f2f2f2', 'gray97' => 'f7f7f7', 'gray98' => 'fafafa', 'gray99' => 'fcfcfc', 'green' => '00ff00', 'green1' => '00ff00', 'green2' => '00ee00', 'green3' => '00cd00', 'green4' => '008b00', 'greenyellow' => 'adff2f', 'honeydew1' => 'f0fff0', 'honeydew2' => 'e0eee0', 'honeydew3' => 'c1cdc1', 'honeydew4' => '838b83', 'hotpink' => 'ff69b4', 'hotpink1' => 'ff6eb4', 'hotpink2' => 'ee6aa7', 'hotpink3' => 'cd6090', 'hotpink4' => '8b3a62', 'indianred' => 'cd5c5c', 'indianred1' => 'ff6a6a', 'indianred2' => 'ee6363', 'indianred3' => 'cd5555', 'indianred4' => '8b3a3a', 'ivory1' => 'fffff0', 'ivory2' => 'eeeee0', 'ivory3' => 'cdcdc1', 'ivory4' => '8b8b83', 'khaki' => 'f0e68c', 'khaki1' => 'fff68f', 'khaki2' => 'eee685', 'khaki3' => 'cdc673', 'khaki4' => '8b864e', 'lavender' => 'e6e6fa', 'lavenderblush1' => 'fff0f5', 'lavenderblush2' => 'eee0e5', 'lavenderblush3' => 'cdc1c5', 'lavenderblush4' => '8b8386', 'lawngreen' => '7cfc00', 'lemonchiffon1' => 'fffacd', 'lemonchiffon2' => 'eee9bf', 'lemonchiffon3' => 'cdc9a5', 'lemonchiffon4' => '8b8970', 'light' => 'eedd82', 'lightblue' => 'add8e6', 'lightblue1' => 'bfefff', 'lightblue2' => 'b2dfee', 'lightblue3' => '9ac0cd', 'lightblue4' => '68838b', 'lightcoral' => 'f08080', 'lightcyan1' => 'e0ffff', 'lightcyan2' => 'd1eeee', 'lightcyan3' => 'b4cdcd', 'lightcyan4' => '7a8b8b', 'lightgoldenrod1' => 'ffec8b', 'lightgoldenrod2' => 'eedc82', 'lightgoldenrod3' => 'cdbe70', 'lightgoldenrod4' => '8b814c', 'lightgoldenrodyellow' => 'fafad2', 'lightgray' => 'd3d3d3', 'lightpink' => 'ffb6c1', 'lightpink1' => 'ffaeb9', 'lightpink2' => 'eea2ad', 'lightpink3' => 'cd8c95', 'lightpink4' => '8b5f65', 'lightsalmon1' => 'ffa07a', 'lightsalmon2' => 'ee9572', 'lightsalmon3' => 'cd8162', 'lightsalmon4' => '8b5742', 'lightseagreen' => '20b2aa', 'lightskyblue' => '87cefa', 'lightskyblue1' => 'b0e2ff', 'lightskyblue2' => 'a4d3ee', 'lightskyblue3' => '8db6cd', 'lightskyblue4' => '607b8b', 'lightslateblue' => '8470ff', 'lightslategray' => '778899', 'lightsteelblue' => 'b0c4de', 'lightsteelblue1' => 'cae1ff', 'lightsteelblue2' => 'bcd2ee', 'lightsteelblue3' => 'a2b5cd', 'lightsteelblue4' => '6e7b8b', 'lightyellow1' => 'ffffe0', 'lightyellow2' => 'eeeed1', 'lightyellow3' => 'cdcdb4', 'lightyellow4' => '8b8b7a', 'lime' => '00ff00', 'limegreen' => '32cd32', 'linen' => 'faf0e6', 'magenta' => 'ff00ff', 'magenta2' => 'ee00ee', 'magenta3' => 'cd00cd', 'magenta4' => '8b008b', 'maroon' => 'b03060', 'maroon1' => 'ff34b3', 'maroon2' => 'ee30a7', 'maroon3' => 'cd2990', 'maroon4' => '8b1c62', 'medium' => '66cdaa', 'mediumaquamarine' => '66cdaa', 'mediumblue' => '0000cd', 'mediumorchid' => 'ba55d3', 'mediumorchid1' => 'e066ff', 'mediumorchid2' => 'd15fee', 'mediumorchid3' => 'b452cd', 'mediumorchid4' => '7a378b', 'mediumpurple' => '9370db', 'mediumpurple1' => 'ab82ff', 'mediumpurple2' => '9f79ee', 'mediumpurple3' => '8968cd', 'mediumpurple4' => '5d478b', 'mediumseagreen' => '3cb371', 'mediumslateblue' => '7b68ee', 'mediumspringgreen' => '00fa9a', 'mediumturquoise' => '48d1cc', 'mediumvioletred' => 'c71585', 'midnightblue' => '191970', 'mintcream' => 'f5fffa', 'mistyrose1' => 'ffe4e1', 'mistyrose2' => 'eed5d2', 'mistyrose3' => 'cdb7b5', 'mistyrose4' => '8b7d7b', 'moccasin' => 'ffe4b5', 'navajowhite1' => 'ffdead', 'navajowhite2' => 'eecfa1', 'navajowhite3' => 'cdb38b', 'navajowhite4' => '8b795e', 'navy' => '000080', 'navyblue' => '000080', 'oldlace' => 'fdf5e6', 'olive' => '808000', 'olivedrab' => '6b8e23', 'olivedrab1' => 'c0ff3e', 'olivedrab2' => 'b3ee3a', 'olivedrab4' => '698b22', 'orange' => 'ffa500', 'orange1' => 'ffa500', 'orange2' => 'ee9a00', 'orange3' => 'cd8500', 'orange4' => '8b5a00', 'orangered1' => 'ff4500', 'orangered2' => 'ee4000', 'orangered3' => 'cd3700', 'orangered4' => '8b2500', 'orchid' => 'da70d6', 'orchid1' => 'ff83fa', 'orchid2' => 'ee7ae9', 'orchid3' => 'cd69c9', 'orchid4' => '8b4789', 'pale' => 'db7093', 'palegoldenrod' => 'eee8aa', 'palegreen' => '98fb98', 'palegreen1' => '9aff9a', 'palegreen2' => '90ee90', 'palegreen3' => '7ccd7c', 'palegreen4' => '548b54', 'paleturquoise' => 'afeeee', 'paleturquoise1' => 'bbffff', 'paleturquoise2' => 'aeeeee', 'paleturquoise3' => '96cdcd', 'paleturquoise4' => '668b8b', 'palevioletred' => 'db7093', 'palevioletred1' => 'ff82ab', 'palevioletred2' => 'ee799f', 'palevioletred3' => 'cd6889', 'palevioletred4' => '8b475d', 'papayawhip' => 'ffefd5', 'peachpuff1' => 'ffdab9', 'peachpuff2' => 'eecbad', 'peachpuff3' => 'cdaf95', 'peachpuff4' => '8b7765', 'pink' => 'ffc0cb', 'pink1' => 'ffb5c5', 'pink2' => 'eea9b8', 'pink3' => 'cd919e', 'pink4' => '8b636c', 'plum' => 'dda0dd', 'plum1' => 'ffbbff', 'plum2' => 'eeaeee', 'plum3' => 'cd96cd', 'plum4' => '8b668b', 'powderblue' => 'b0e0e6', 'purple' => 'a020f0', 'rebeccapurple' => '663399', 'purple1' => '9b30ff', 'purple2' => '912cee', 'purple3' => '7d26cd', 'purple4' => '551a8b', 'red' => 'ff0000', 'red1' => 'ff0000', 'red2' => 'ee0000', 'red3' => 'cd0000', 'red4' => '8b0000', 'rosybrown' => 'bc8f8f', 'rosybrown1' => 'ffc1c1', 'rosybrown2' => 'eeb4b4', 'rosybrown3' => 'cd9b9b', 'rosybrown4' => '8b6969', 'royalblue' => '4169e1', 'royalblue1' => '4876ff', 'royalblue2' => '436eee', 'royalblue3' => '3a5fcd', 'royalblue4' => '27408b', 'saddlebrown' => '8b4513', 'salmon' => 'fa8072', 'salmon1' => 'ff8c69', 'salmon2' => 'ee8262', 'salmon3' => 'cd7054', 'salmon4' => '8b4c39', 'sandybrown' => 'f4a460', 'seagreen1' => '54ff9f', 'seagreen2' => '4eee94', 'seagreen3' => '43cd80', 'seagreen4' => '2e8b57', 'seashell1' => 'fff5ee', 'seashell2' => 'eee5de', 'seashell3' => 'cdc5bf', 'seashell4' => '8b8682', 'sienna' => 'a0522d', 'sienna1' => 'ff8247', 'sienna2' => 'ee7942', 'sienna3' => 'cd6839', 'sienna4' => '8b4726', 'silver' => 'c0c0c0', 'skyblue' => '87ceeb', 'skyblue1' => '87ceff', 'skyblue2' => '7ec0ee', 'skyblue3' => '6ca6cd', 'skyblue4' => '4a708b', 'slateblue' => '6a5acd', 'slateblue1' => '836fff', 'slateblue2' => '7a67ee', 'slateblue3' => '6959cd', 'slateblue4' => '473c8b', 'slategray' => '708090', 'slategray1' => 'c6e2ff', 'slategray2' => 'b9d3ee', 'slategray3' => '9fb6cd', 'slategray4' => '6c7b8b', 'snow1' => 'fffafa', 'snow2' => 'eee9e9', 'snow3' => 'cdc9c9', 'snow4' => '8b8989', 'springgreen1' => '00ff7f', 'springgreen2' => '00ee76', 'springgreen3' => '00cd66', 'springgreen4' => '008b45', 'steelblue' => '4682b4', 'steelblue1' => '63b8ff', 'steelblue2' => '5cacee', 'steelblue3' => '4f94cd', 'steelblue4' => '36648b', 'tan' => 'd2b48c', 'tan1' => 'ffa54f', 'tan2' => 'ee9a49', 'tan3' => 'cd853f', 'tan4' => '8b5a2b', 'teal' => '008080', 'thistle' => 'd8bfd8', 'thistle1' => 'ffe1ff', 'thistle2' => 'eed2ee', 'thistle3' => 'cdb5cd', 'thistle4' => '8b7b8b', 'tomato1' => 'ff6347', 'tomato2' => 'ee5c42', 'tomato3' => 'cd4f39', 'tomato4' => '8b3626', 'turquoise' => '40e0d0', 'turquoise1' => '00f5ff', 'turquoise2' => '00e5ee', 'turquoise3' => '00c5cd', 'turquoise4' => '00868b', 'violet' => 'ee82ee', 'violetred' => 'd02090', 'violetred1' => 'ff3e96', 'violetred2' => 'ee3a8c', 'violetred3' => 'cd3278', 'violetred4' => '8b2252', 'wheat' => 'f5deb3', 'wheat1' => 'ffe7ba', 'wheat2' => 'eed8ae', 'wheat3' => 'cdba96', 'wheat4' => '8b7e66', 'white' => 'ffffff', 'whitesmoke' => 'f5f5f5', 'yellow' => 'ffff00', 'yellow1' => 'ffff00', 'yellow2' => 'eeee00', 'yellow3' => 'cdcd00', 'yellow4' => '8b8b00', 'yellowgreen' => '9acd32'];
        protected $face;
        protected $size;
        protected $color;
        protected $bold = false;
        protected $italic = false;
        protected $underline = false;
        protected $superscript = false;
        protected $subscript = false;
        protected $strikethrough = false;
        protected $startTagCallbacks = ['font' => 'startFontTag', 'b' => 'startBoldTag', 'strong' => 'startBoldTag', 'i' => 'startItalicTag', 'em' => 'startItalicTag', 'u' => 'startUnderlineTag', 'ins' => 'startUnderlineTag', 'del' => 'startStrikethruTag', 'sup' => 'startSuperscriptTag', 'sub' => 'startSubscriptTag'];
        protected $endTagCallbacks = ['font' => 'endFontTag', 'b' => 'endBoldTag', 'strong' => 'endBoldTag', 'i' => 'endItalicTag', 'em' => 'endItalicTag', 'u' => 'endUnderlineTag', 'ins' => 'endUnderlineTag', 'del' => 'endStrikethruTag', 'sup' => 'endSuperscriptTag', 'sub' => 'endSubscriptTag', 'br' => 'breakTag', 'p' => 'breakTag', 'h1' => 'breakTag', 'h2' => 'breakTag', 'h3' => 'breakTag', 'h4' => 'breakTag', 'h5' => 'breakTag', 'h6' => 'breakTag'];
        protected $stack = [];
        protected $stringData = '';
        /**
         * @var RichText
         */
        protected $richTextObject;
        protected function initialise() : void
        {
        }
        /**
         * Parse HTML formatting and return the resulting RichText.
         *
         * @param string $html
         *
         * @return RichText
         */
        public function toRichTextObject($html)
        {
        }
        protected function cleanWhitespace() : void
        {
        }
        protected function buildTextRun() : void
        {
        }
        protected function rgbToColour($rgb)
        {
        }
        protected function colourNameLookup($rgb)
        {
        }
        protected function startFontTag($tag) : void
        {
        }
        protected function endFontTag() : void
        {
        }
        protected function startBoldTag() : void
        {
        }
        protected function endBoldTag() : void
        {
        }
        protected function startItalicTag() : void
        {
        }
        protected function endItalicTag() : void
        {
        }
        protected function startUnderlineTag() : void
        {
        }
        protected function endUnderlineTag() : void
        {
        }
        protected function startSubscriptTag() : void
        {
        }
        protected function endSubscriptTag() : void
        {
        }
        protected function startSuperscriptTag() : void
        {
        }
        protected function endSuperscriptTag() : void
        {
        }
        protected function startStrikethruTag() : void
        {
        }
        protected function endStrikethruTag() : void
        {
        }
        protected function breakTag() : void
        {
        }
        protected function parseTextNode(\DOMText $textNode) : void
        {
        }
        /**
         * @param string $callbackTag
         */
        protected function handleCallback(\DOMElement $element, $callbackTag, array $callbacks) : void
        {
        }
        protected function parseElementNode(\DOMElement $element) : void
        {
        }
        protected function parseElements(\DOMNode $element) : void
        {
        }
    }
    /**
     * Helper class to be used in sample code.
     */
    class Sample
    {
        /**
         * Returns whether we run on CLI or browser.
         *
         * @return bool
         */
        public function isCli()
        {
        }
        /**
         * Return the filename currently being executed.
         *
         * @return string
         */
        public function getScriptFilename()
        {
        }
        /**
         * Whether we are executing the index page.
         *
         * @return bool
         */
        public function isIndex()
        {
        }
        /**
         * Return the page title.
         *
         * @return string
         */
        public function getPageTitle()
        {
        }
        /**
         * Return the page heading.
         *
         * @return string
         */
        public function getPageHeading()
        {
        }
        /**
         * Returns an array of all known samples.
         *
         * @return string[] [$name => $path]
         */
        public function getSamples()
        {
        }
        /**
         * Write documents.
         *
         * @param string $filename
         * @param string[] $writers
         */
        public function write(\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet, $filename, array $writers = ['Xlsx', 'Xls']) : void
        {
        }
        /**
         * Returns the temporary directory and make sure it exists.
         *
         * @return string
         */
        private function getTemporaryFolder()
        {
        }
        /**
         * Returns the filename that should be used for sample output.
         *
         * @param string $filename
         * @param string $extension
         *
         * @return string
         */
        public function getFilename($filename, $extension = 'xlsx')
        {
        }
        /**
         * Return a random temporary file name.
         *
         * @param string $extension
         *
         * @return string
         */
        public function getTemporaryFilename($extension = 'xlsx')
        {
        }
        public function log($message) : void
        {
        }
        /**
         * Log ending notes.
         */
        public function logEndingNotes() : void
        {
        }
        /**
         * Log a line about the write operation.
         *
         * @param string $path
         * @param float $callStartTime
         */
        public function logWrite(\PhpOffice\PhpSpreadsheet\Writer\IWriter $writer, $path, $callStartTime) : void
        {
        }
        /**
         * Log a line about the read operation.
         *
         * @param string $format
         * @param string $path
         * @param float $callStartTime
         */
        public function logRead($format, $path, $callStartTime) : void
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Cell {
    interface IValueBinder
    {
        /**
         * Bind value to a cell.
         *
         * @param Cell $cell Cell to bind value to
         * @param mixed $value Value to bind in cell
         *
         * @return bool
         */
        public function bindValue(\PhpOffice\PhpSpreadsheet\Cell\Cell $cell, $value);
    }
    class DefaultValueBinder implements \PhpOffice\PhpSpreadsheet\Cell\IValueBinder
    {
        /**
         * Bind value to a cell.
         *
         * @param Cell $cell Cell to bind value to
         * @param mixed $value Value to bind in cell
         *
         * @return bool
         */
        public function bindValue(\PhpOffice\PhpSpreadsheet\Cell\Cell $cell, $value)
        {
        }
        /**
         * DataType for value.
         *
         * @param mixed $pValue
         *
         * @return string
         */
        public static function dataTypeForValue($pValue)
        {
        }
    }
    class AdvancedValueBinder extends \PhpOffice\PhpSpreadsheet\Cell\DefaultValueBinder implements \PhpOffice\PhpSpreadsheet\Cell\IValueBinder
    {
        /**
         * Bind value to a cell.
         *
         * @param Cell $cell Cell to bind value to
         * @param mixed $value Value to bind in cell
         *
         * @return bool
         */
        public function bindValue(\PhpOffice\PhpSpreadsheet\Cell\Cell $cell, $value = null)
        {
        }
    }
    /**
     * Validate a cell value according to its validation rules.
     */
    class DataValidator
    {
        /**
         * Does this cell contain valid value?
         *
         * @param Cell $cell Cell to check the value
         *
         * @return bool
         */
        public function isValid(\PhpOffice\PhpSpreadsheet\Cell\Cell $cell)
        {
        }
        /**
         * Does this cell contain valid value, based on list?
         *
         * @param Cell $cell Cell to check the value
         *
         * @return bool
         */
        private function isValueInList(\PhpOffice\PhpSpreadsheet\Cell\Cell $cell)
        {
        }
    }
    /**
     * Helper class to manipulate cell coordinates.
     *
     * Columns indexes and rows are always based on 1, **not** on 0. This match the behavior
     * that Excel users are used to, and also match the Excel functions `COLUMN()` and `ROW()`.
     */
    abstract class Coordinate
    {
        /**
         * Default range variable constant.
         *
         * @var string
         */
        const DEFAULT_RANGE = 'A1:A1';
        /**
         * Coordinate from string.
         *
         * @param string $pCoordinateString eg: 'A1'
         *
         * @return string[] Array containing column and row (indexes 0 and 1)
         */
        public static function coordinateFromString($pCoordinateString)
        {
        }
        /**
         * Checks if a coordinate represents a range of cells.
         *
         * @param string $coord eg: 'A1' or 'A1:A2' or 'A1:A2,C1:C2'
         *
         * @return bool Whether the coordinate represents a range of cells
         */
        public static function coordinateIsRange($coord)
        {
        }
        /**
         * Make string row, column or cell coordinate absolute.
         *
         * @param string $pCoordinateString e.g. 'A' or '1' or 'A1'
         *                    Note that this value can be a row or column reference as well as a cell reference
         *
         * @return string Absolute coordinate        e.g. '$A' or '$1' or '$A$1'
         */
        public static function absoluteReference($pCoordinateString)
        {
        }
        /**
         * Make string coordinate absolute.
         *
         * @param string $pCoordinateString e.g. 'A1'
         *
         * @return string Absolute coordinate        e.g. '$A$1'
         */
        public static function absoluteCoordinate($pCoordinateString)
        {
        }
        /**
         * Split range into coordinate strings.
         *
         * @param string $pRange e.g. 'B4:D9' or 'B4:D9,H2:O11' or 'B4'
         *
         * @return array Array containing one or more arrays containing one or two coordinate strings
         *                                e.g. ['B4','D9'] or [['B4','D9'], ['H2','O11']]
         *                                        or ['B4']
         */
        public static function splitRange($pRange)
        {
        }
        /**
         * Build range from coordinate strings.
         *
         * @param array $pRange Array containg one or more arrays containing one or two coordinate strings
         *
         * @return string String representation of $pRange
         */
        public static function buildRange(array $pRange)
        {
        }
        /**
         * Calculate range boundaries.
         *
         * @param string $pRange Cell range (e.g. A1:A1)
         *
         * @return array Range coordinates [Start Cell, End Cell]
         *                    where Start Cell and End Cell are arrays (Column Number, Row Number)
         */
        public static function rangeBoundaries($pRange)
        {
        }
        /**
         * Calculate range dimension.
         *
         * @param string $pRange Cell range (e.g. A1:A1)
         *
         * @return array Range dimension (width, height)
         */
        public static function rangeDimension($pRange)
        {
        }
        /**
         * Calculate range boundaries.
         *
         * @param string $pRange Cell range (e.g. A1:A1)
         *
         * @return array Range coordinates [Start Cell, End Cell]
         *                    where Start Cell and End Cell are arrays [Column ID, Row Number]
         */
        public static function getRangeBoundaries($pRange)
        {
        }
        /**
         * Column index from string.
         *
         * @param string $pString eg 'A'
         *
         * @return int Column index (A = 1)
         */
        public static function columnIndexFromString($pString)
        {
        }
        /**
         * String from column index.
         *
         * @param int $columnIndex Column index (A = 1)
         *
         * @return string
         */
        public static function stringFromColumnIndex($columnIndex)
        {
        }
        /**
         * Extract all cell references in range, which may be comprised of multiple cell ranges.
         *
         * @param string $pRange Range (e.g. A1 or A1:C10 or A1:E10 A20:E25)
         *
         * @return array Array containing single cell references
         */
        public static function extractAllCellReferencesInRange($pRange)
        {
        }
        /**
         * Get all cell references for an individual cell block.
         *
         * @param string $cellBlock A cell range e.g. A4:B5
         *
         * @return array All individual cells in that range
         */
        private static function getReferencesForCellBlock($cellBlock)
        {
        }
        /**
         * Convert an associative array of single cell coordinates to values to an associative array
         * of cell ranges to values.  Only adjacent cell coordinates with the same
         * value will be merged.  If the value is an object, it must implement the method getHashCode().
         *
         * For example, this function converts:
         *
         *    [ 'A1' => 'x', 'A2' => 'x', 'A3' => 'x', 'A4' => 'y' ]
         *
         * to:
         *
         *    [ 'A1:A3' => 'x', 'A4' => 'y' ]
         *
         * @param array $pCoordCollection associative array mapping coordinates to values
         *
         * @return array associative array mapping coordinate ranges to valuea
         */
        public static function mergeRangesInCollection(array $pCoordCollection)
        {
        }
        /**
         * Get the individual cell blocks from a range string, splitting by space and removing any $ characters.
         *
         * @param string $pRange
         *
         * @return string[]
         */
        private static function getCellBlocksFromRangeString($pRange)
        {
        }
        /**
         * Check that the given range is valid, i.e. that the start column and row are not greater than the end column and
         * row.
         *
         * @param string $cellBlock The original range, for displaying a meaningful error message
         * @param int $startColumnIndex
         * @param int $endColumnIndex
         * @param int $currentRow
         * @param int $endRow
         */
        private static function validateRange($cellBlock, $startColumnIndex, $endColumnIndex, $currentRow, $endRow) : void
        {
        }
    }
    class DataType
    {
        // Data types
        const TYPE_STRING2 = 'str';
        const TYPE_STRING = 's';
        const TYPE_FORMULA = 'f';
        const TYPE_NUMERIC = 'n';
        const TYPE_BOOL = 'b';
        const TYPE_NULL = 'null';
        const TYPE_INLINE = 'inlineStr';
        const TYPE_ERROR = 'e';
        /**
         * List of error codes.
         *
         * @var array
         */
        private static $errorCodes = ['#NULL!' => 0, '#DIV/0!' => 1, '#VALUE!' => 2, '#REF!' => 3, '#NAME?' => 4, '#NUM!' => 5, '#N/A' => 6];
        /**
         * Get list of error codes.
         *
         * @return array
         */
        public static function getErrorCodes()
        {
        }
        /**
         * Check a string that it satisfies Excel requirements.
         *
         * @param null|RichText|string $pValue Value to sanitize to an Excel string
         *
         * @return null|RichText|string Sanitized value
         */
        public static function checkString($pValue)
        {
        }
        /**
         * Check a value that it is a valid error code.
         *
         * @param mixed $pValue Value to sanitize to an Excel error code
         *
         * @return string Sanitized value
         */
        public static function checkErrorCode($pValue)
        {
        }
    }
    class Hyperlink
    {
        /**
         * URL to link the cell to.
         *
         * @var string
         */
        private $url;
        /**
         * Tooltip to display on the hyperlink.
         *
         * @var string
         */
        private $tooltip;
        /**
         * Create a new Hyperlink.
         *
         * @param string $pUrl Url to link the cell to
         * @param string $pTooltip Tooltip to display on the hyperlink
         */
        public function __construct($pUrl = '', $pTooltip = '')
        {
        }
        /**
         * Get URL.
         *
         * @return string
         */
        public function getUrl()
        {
        }
        /**
         * Set URL.
         *
         * @param string $value
         *
         * @return $this
         */
        public function setUrl($value)
        {
        }
        /**
         * Get tooltip.
         *
         * @return string
         */
        public function getTooltip()
        {
        }
        /**
         * Set tooltip.
         *
         * @param string $value
         *
         * @return $this
         */
        public function setTooltip($value)
        {
        }
        /**
         * Is this hyperlink internal? (to another worksheet).
         *
         * @return bool
         */
        public function isInternal()
        {
        }
        /**
         * @return string
         */
        public function getTypeHyperlink()
        {
        }
        /**
         * Get hash code.
         *
         * @return string Hash code
         */
        public function getHashCode()
        {
        }
    }
    class StringValueBinder implements \PhpOffice\PhpSpreadsheet\Cell\IValueBinder
    {
        /**
         * Bind value to a cell.
         *
         * @param Cell $cell Cell to bind value to
         * @param mixed $value Value to bind in cell
         *
         * @return bool
         */
        public function bindValue(\PhpOffice\PhpSpreadsheet\Cell\Cell $cell, $value)
        {
        }
    }
    class Cell
    {
        /**
         * Value binder to use.
         *
         * @var IValueBinder
         */
        private static $valueBinder;
        /**
         * Value of the cell.
         *
         * @var mixed
         */
        private $value;
        /**
         *    Calculated value of the cell (used for caching)
         *    This returns the value last calculated by MS Excel or whichever spreadsheet program was used to
         *        create the original spreadsheet file.
         *    Note that this value is not guaranteed to reflect the actual calculated value because it is
         *        possible that auto-calculation was disabled in the original spreadsheet, and underlying data
         *        values used by the formula have changed since it was last calculated.
         *
         * @var mixed
         */
        private $calculatedValue;
        /**
         * Type of the cell data.
         *
         * @var string
         */
        private $dataType;
        /**
         * Collection of cells.
         *
         * @var Cells
         */
        private $parent;
        /**
         * Index to cellXf.
         *
         * @var int
         */
        private $xfIndex = 0;
        /**
         * Attributes of the formula.
         */
        private $formulaAttributes;
        /**
         * Update the cell into the cell collection.
         *
         * @return $this
         */
        public function updateInCollection()
        {
        }
        public function detach() : void
        {
        }
        public function attach(\PhpOffice\PhpSpreadsheet\Collection\Cells $parent) : void
        {
        }
        /**
         * Create a new Cell.
         *
         * @param mixed $pValue
         * @param string $pDataType
         */
        public function __construct($pValue, $pDataType, \PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet)
        {
        }
        /**
         * Get cell coordinate column.
         *
         * @return string
         */
        public function getColumn()
        {
        }
        /**
         * Get cell coordinate row.
         *
         * @return int
         */
        public function getRow()
        {
        }
        /**
         * Get cell coordinate.
         *
         * @return string
         */
        public function getCoordinate()
        {
        }
        /**
         * Get cell value.
         *
         * @return mixed
         */
        public function getValue()
        {
        }
        /**
         * Get cell value with formatting.
         *
         * @return string
         */
        public function getFormattedValue()
        {
        }
        /**
         * Set cell value.
         *
         *    Sets the value for a cell, automatically determining the datatype using the value binder
         *
         * @param mixed $pValue Value
         *
         * @return $this
         */
        public function setValue($pValue)
        {
        }
        /**
         * Set the value for a cell, with the explicit data type passed to the method (bypassing any use of the value binder).
         *
         * @param mixed $pValue Value
         * @param string $pDataType Explicit data type, see DataType::TYPE_*
         *
         * @return Cell
         */
        public function setValueExplicit($pValue, $pDataType)
        {
        }
        /**
         * Get calculated cell value.
         *
         * @param bool $resetLog Whether the calculation engine logger should be reset or not
         *
         * @return mixed
         */
        public function getCalculatedValue($resetLog = true)
        {
        }
        /**
         * Set old calculated value (cached).
         *
         * @param mixed $pValue Value
         *
         * @return Cell
         */
        public function setCalculatedValue($pValue)
        {
        }
        /**
         *    Get old calculated value (cached)
         *    This returns the value last calculated by MS Excel or whichever spreadsheet program was used to
         *        create the original spreadsheet file.
         *    Note that this value is not guaranteed to reflect the actual calculated value because it is
         *        possible that auto-calculation was disabled in the original spreadsheet, and underlying data
         *        values used by the formula have changed since it was last calculated.
         *
         * @return mixed
         */
        public function getOldCalculatedValue()
        {
        }
        /**
         * Get cell data type.
         *
         * @return string
         */
        public function getDataType()
        {
        }
        /**
         * Set cell data type.
         *
         * @param string $pDataType see DataType::TYPE_*
         *
         * @return Cell
         */
        public function setDataType($pDataType)
        {
        }
        /**
         * Identify if the cell contains a formula.
         *
         * @return bool
         */
        public function isFormula()
        {
        }
        /**
         *    Does this cell contain Data validation rules?
         *
         * @return bool
         */
        public function hasDataValidation()
        {
        }
        /**
         * Get Data validation rules.
         *
         * @return DataValidation
         */
        public function getDataValidation()
        {
        }
        /**
         * Set Data validation rules.
         *
         * @param DataValidation $pDataValidation
         *
         * @return Cell
         */
        public function setDataValidation(?\PhpOffice\PhpSpreadsheet\Cell\DataValidation $pDataValidation = null)
        {
        }
        /**
         * Does this cell contain valid value?
         *
         * @return bool
         */
        public function hasValidValue()
        {
        }
        /**
         * Does this cell contain a Hyperlink?
         *
         * @return bool
         */
        public function hasHyperlink()
        {
        }
        /**
         * Get Hyperlink.
         *
         * @return Hyperlink
         */
        public function getHyperlink()
        {
        }
        /**
         * Set Hyperlink.
         *
         * @param Hyperlink $pHyperlink
         *
         * @return Cell
         */
        public function setHyperlink(?\PhpOffice\PhpSpreadsheet\Cell\Hyperlink $pHyperlink = null)
        {
        }
        /**
         * Get cell collection.
         *
         * @return Cells
         */
        public function getParent()
        {
        }
        /**
         * Get parent worksheet.
         *
         * @return Worksheet
         */
        public function getWorksheet()
        {
        }
        /**
         * Is this cell in a merge range.
         *
         * @return bool
         */
        public function isInMergeRange()
        {
        }
        /**
         * Is this cell the master (top left cell) in a merge range (that holds the actual data value).
         *
         * @return bool
         */
        public function isMergeRangeValueCell()
        {
        }
        /**
         * If this cell is in a merge range, then return the range.
         *
         * @return false|string
         */
        public function getMergeRange()
        {
        }
        /**
         * Get cell style.
         *
         * @return Style
         */
        public function getStyle()
        {
        }
        /**
         * Re-bind parent.
         *
         * @return Cell
         */
        public function rebindParent(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $parent)
        {
        }
        /**
         *    Is cell in a specific range?
         *
         * @param string $pRange Cell range (e.g. A1:A1)
         *
         * @return bool
         */
        public function isInRange($pRange)
        {
        }
        /**
         * Compare 2 cells.
         *
         * @param Cell $a Cell a
         * @param Cell $b Cell b
         *
         * @return int Result of comparison (always -1 or 1, never zero!)
         */
        public static function compareCells(self $a, self $b)
        {
        }
        /**
         * Get value binder to use.
         *
         * @return IValueBinder
         */
        public static function getValueBinder()
        {
        }
        /**
         * Set value binder to use.
         */
        public static function setValueBinder(\PhpOffice\PhpSpreadsheet\Cell\IValueBinder $binder) : void
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
        /**
         * Get index to cellXf.
         *
         * @return int
         */
        public function getXfIndex()
        {
        }
        /**
         * Set index to cellXf.
         *
         * @param int $pValue
         *
         * @return Cell
         */
        public function setXfIndex($pValue)
        {
        }
        /**
         * Set the formula attributes.
         *
         * @param mixed $pAttributes
         *
         * @return $this
         */
        public function setFormulaAttributes($pAttributes)
        {
        }
        /**
         * Get the formula attributes.
         */
        public function getFormulaAttributes()
        {
        }
        /**
         * Convert to string.
         *
         * @return string
         */
        public function __toString()
        {
        }
    }
    class DataValidation
    {
        // Data validation types
        const TYPE_NONE = 'none';
        const TYPE_CUSTOM = 'custom';
        const TYPE_DATE = 'date';
        const TYPE_DECIMAL = 'decimal';
        const TYPE_LIST = 'list';
        const TYPE_TEXTLENGTH = 'textLength';
        const TYPE_TIME = 'time';
        const TYPE_WHOLE = 'whole';
        // Data validation error styles
        const STYLE_STOP = 'stop';
        const STYLE_WARNING = 'warning';
        const STYLE_INFORMATION = 'information';
        // Data validation operators
        const OPERATOR_BETWEEN = 'between';
        const OPERATOR_EQUAL = 'equal';
        const OPERATOR_GREATERTHAN = 'greaterThan';
        const OPERATOR_GREATERTHANOREQUAL = 'greaterThanOrEqual';
        const OPERATOR_LESSTHAN = 'lessThan';
        const OPERATOR_LESSTHANOREQUAL = 'lessThanOrEqual';
        const OPERATOR_NOTBETWEEN = 'notBetween';
        const OPERATOR_NOTEQUAL = 'notEqual';
        /**
         * Formula 1.
         *
         * @var string
         */
        private $formula1 = '';
        /**
         * Formula 2.
         *
         * @var string
         */
        private $formula2 = '';
        /**
         * Type.
         *
         * @var string
         */
        private $type = self::TYPE_NONE;
        /**
         * Error style.
         *
         * @var string
         */
        private $errorStyle = self::STYLE_STOP;
        /**
         * Operator.
         *
         * @var string
         */
        private $operator = self::OPERATOR_BETWEEN;
        /**
         * Allow Blank.
         *
         * @var bool
         */
        private $allowBlank = false;
        /**
         * Show DropDown.
         *
         * @var bool
         */
        private $showDropDown = false;
        /**
         * Show InputMessage.
         *
         * @var bool
         */
        private $showInputMessage = false;
        /**
         * Show ErrorMessage.
         *
         * @var bool
         */
        private $showErrorMessage = false;
        /**
         * Error title.
         *
         * @var string
         */
        private $errorTitle = '';
        /**
         * Error.
         *
         * @var string
         */
        private $error = '';
        /**
         * Prompt title.
         *
         * @var string
         */
        private $promptTitle = '';
        /**
         * Prompt.
         *
         * @var string
         */
        private $prompt = '';
        /**
         * Create a new DataValidation.
         */
        public function __construct()
        {
        }
        /**
         * Get Formula 1.
         *
         * @return string
         */
        public function getFormula1()
        {
        }
        /**
         * Set Formula 1.
         *
         * @param string $value
         *
         * @return $this
         */
        public function setFormula1($value)
        {
        }
        /**
         * Get Formula 2.
         *
         * @return string
         */
        public function getFormula2()
        {
        }
        /**
         * Set Formula 2.
         *
         * @param string $value
         *
         * @return $this
         */
        public function setFormula2($value)
        {
        }
        /**
         * Get Type.
         *
         * @return string
         */
        public function getType()
        {
        }
        /**
         * Set Type.
         *
         * @param string $value
         *
         * @return $this
         */
        public function setType($value)
        {
        }
        /**
         * Get Error style.
         *
         * @return string
         */
        public function getErrorStyle()
        {
        }
        /**
         * Set Error style.
         *
         * @param string $value see self::STYLE_*
         *
         * @return $this
         */
        public function setErrorStyle($value)
        {
        }
        /**
         * Get Operator.
         *
         * @return string
         */
        public function getOperator()
        {
        }
        /**
         * Set Operator.
         *
         * @param string $value
         *
         * @return $this
         */
        public function setOperator($value)
        {
        }
        /**
         * Get Allow Blank.
         *
         * @return bool
         */
        public function getAllowBlank()
        {
        }
        /**
         * Set Allow Blank.
         *
         * @param bool $value
         *
         * @return $this
         */
        public function setAllowBlank($value)
        {
        }
        /**
         * Get Show DropDown.
         *
         * @return bool
         */
        public function getShowDropDown()
        {
        }
        /**
         * Set Show DropDown.
         *
         * @param bool $value
         *
         * @return $this
         */
        public function setShowDropDown($value)
        {
        }
        /**
         * Get Show InputMessage.
         *
         * @return bool
         */
        public function getShowInputMessage()
        {
        }
        /**
         * Set Show InputMessage.
         *
         * @param bool $value
         *
         * @return $this
         */
        public function setShowInputMessage($value)
        {
        }
        /**
         * Get Show ErrorMessage.
         *
         * @return bool
         */
        public function getShowErrorMessage()
        {
        }
        /**
         * Set Show ErrorMessage.
         *
         * @param bool $value
         *
         * @return $this
         */
        public function setShowErrorMessage($value)
        {
        }
        /**
         * Get Error title.
         *
         * @return string
         */
        public function getErrorTitle()
        {
        }
        /**
         * Set Error title.
         *
         * @param string $value
         *
         * @return $this
         */
        public function setErrorTitle($value)
        {
        }
        /**
         * Get Error.
         *
         * @return string
         */
        public function getError()
        {
        }
        /**
         * Set Error.
         *
         * @param string $value
         *
         * @return $this
         */
        public function setError($value)
        {
        }
        /**
         * Get Prompt title.
         *
         * @return string
         */
        public function getPromptTitle()
        {
        }
        /**
         * Set Prompt title.
         *
         * @param string $value
         *
         * @return $this
         */
        public function setPromptTitle($value)
        {
        }
        /**
         * Get Prompt.
         *
         * @return string
         */
        public function getPrompt()
        {
        }
        /**
         * Set Prompt.
         *
         * @param string $value
         *
         * @return $this
         */
        public function setPrompt($value)
        {
        }
        /**
         * Get hash code.
         *
         * @return string Hash code
         */
        public function getHashCode()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet {
    class Comment implements \PhpOffice\PhpSpreadsheet\IComparable
    {
        /**
         * Author.
         *
         * @var string
         */
        private $author;
        /**
         * Rich text comment.
         *
         * @var RichText
         */
        private $text;
        /**
         * Comment width (CSS style, i.e. XXpx or YYpt).
         *
         * @var string
         */
        private $width = '96pt';
        /**
         * Left margin (CSS style, i.e. XXpx or YYpt).
         *
         * @var string
         */
        private $marginLeft = '59.25pt';
        /**
         * Top margin (CSS style, i.e. XXpx or YYpt).
         *
         * @var string
         */
        private $marginTop = '1.5pt';
        /**
         * Visible.
         *
         * @var bool
         */
        private $visible = false;
        /**
         * Comment height (CSS style, i.e. XXpx or YYpt).
         *
         * @var string
         */
        private $height = '55.5pt';
        /**
         * Comment fill color.
         *
         * @var Style\Color
         */
        private $fillColor;
        /**
         * Alignment.
         *
         * @var string
         */
        private $alignment;
        /**
         * Create a new Comment.
         */
        public function __construct()
        {
        }
        /**
         * Get Author.
         *
         * @return string
         */
        public function getAuthor()
        {
        }
        /**
         * Set Author.
         *
         * @param string $author
         *
         * @return $this
         */
        public function setAuthor($author)
        {
        }
        /**
         * Get Rich text comment.
         *
         * @return RichText
         */
        public function getText()
        {
        }
        /**
         * Set Rich text comment.
         *
         * @return $this
         */
        public function setText(\PhpOffice\PhpSpreadsheet\RichText\RichText $pValue)
        {
        }
        /**
         * Get comment width (CSS style, i.e. XXpx or YYpt).
         *
         * @return string
         */
        public function getWidth()
        {
        }
        /**
         * Set comment width (CSS style, i.e. XXpx or YYpt).
         *
         * @param string $width
         *
         * @return $this
         */
        public function setWidth($width)
        {
        }
        /**
         * Get comment height (CSS style, i.e. XXpx or YYpt).
         *
         * @return string
         */
        public function getHeight()
        {
        }
        /**
         * Set comment height (CSS style, i.e. XXpx or YYpt).
         *
         * @param string $value
         *
         * @return $this
         */
        public function setHeight($value)
        {
        }
        /**
         * Get left margin (CSS style, i.e. XXpx or YYpt).
         *
         * @return string
         */
        public function getMarginLeft()
        {
        }
        /**
         * Set left margin (CSS style, i.e. XXpx or YYpt).
         *
         * @param string $value
         *
         * @return $this
         */
        public function setMarginLeft($value)
        {
        }
        /**
         * Get top margin (CSS style, i.e. XXpx or YYpt).
         *
         * @return string
         */
        public function getMarginTop()
        {
        }
        /**
         * Set top margin (CSS style, i.e. XXpx or YYpt).
         *
         * @param string $value
         *
         * @return $this
         */
        public function setMarginTop($value)
        {
        }
        /**
         * Is the comment visible by default?
         *
         * @return bool
         */
        public function getVisible()
        {
        }
        /**
         * Set comment default visibility.
         *
         * @param bool $value
         *
         * @return $this
         */
        public function setVisible($value)
        {
        }
        /**
         * Get fill color.
         *
         * @return Style\Color
         */
        public function getFillColor()
        {
        }
        /**
         * Set Alignment.
         *
         * @param string $alignment see Style\Alignment::HORIZONTAL_*
         *
         * @return $this
         */
        public function setAlignment($alignment)
        {
        }
        /**
         * Get Alignment.
         *
         * @return string
         */
        public function getAlignment()
        {
        }
        /**
         * Get hash code.
         *
         * @return string Hash code
         */
        public function getHashCode()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
        /**
         * Convert to string.
         *
         * @return string
         */
        public function __toString()
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Calculation {
    class MathTrig
    {
        //
        //    Private method to return an array of the factors of the input value
        //
        private static function factors($value)
        {
        }
        private static function romanCut($num, $n)
        {
        }
        /**
         * ARABIC.
         *
         * Converts a Roman numeral to an Arabic numeral.
         *
         * Excel Function:
         *        ARABIC(text)
         *
         * @param string $roman
         *
         * @return int|string the arabic numberal contrived from the roman numeral
         */
        public static function ARABIC($roman)
        {
        }
        /**
         * Recursively calculate the arabic value of a roman numeral.
         *
         * @param int $sum
         * @param int $subtract
         *
         * @return int
         */
        protected static function calculateArabic(array $roman, &$sum = 0, $subtract = 0)
        {
        }
        /**
         * ATAN2.
         *
         * This function calculates the arc tangent of the two variables x and y. It is similar to
         *        calculating the arc tangent of y  x, except that the signs of both arguments are used
         *        to determine the quadrant of the result.
         * The arctangent is the angle from the x-axis to a line containing the origin (0, 0) and a
         *        point with coordinates (xCoordinate, yCoordinate). The angle is given in radians between
         *        -pi and pi, excluding -pi.
         *
         * Note that the Excel ATAN2() function accepts its arguments in the reverse order to the standard
         *        PHP atan2() function, so we need to reverse them here before calling the PHP atan() function.
         *
         * Excel Function:
         *        ATAN2(xCoordinate,yCoordinate)
         *
         * @param float $xCoordinate the x-coordinate of the point
         * @param float $yCoordinate the y-coordinate of the point
         *
         * @return float|string the inverse tangent of the specified x- and y-coordinates, or a string containing an error
         */
        public static function ATAN2($xCoordinate = null, $yCoordinate = null)
        {
        }
        /**
         * BASE.
         *
         * Converts a number into a text representation with the given radix (base).
         *
         * Excel Function:
         *        BASE(Number, Radix [Min_length])
         *
         * @param float $number
         * @param float $radix
         * @param int $minLength
         *
         * @return string the text representation with the given radix (base)
         */
        public static function BASE($number, $radix, $minLength = null)
        {
        }
        /**
         * CEILING.
         *
         * Returns number rounded up, away from zero, to the nearest multiple of significance.
         *        For example, if you want to avoid using pennies in your prices and your product is
         *        priced at $4.42, use the formula =CEILING(4.42,0.05) to round prices up to the
         *        nearest nickel.
         *
         * Excel Function:
         *        CEILING(number[,significance])
         *
         * @param float $number the number you want to round
         * @param float $significance the multiple to which you want to round
         *
         * @return float|string Rounded Number, or a string containing an error
         */
        public static function CEILING($number, $significance = null)
        {
        }
        /**
         * COMBIN.
         *
         * Returns the number of combinations for a given number of items. Use COMBIN to
         *        determine the total possible number of groups for a given number of items.
         *
         * Excel Function:
         *        COMBIN(numObjs,numInSet)
         *
         * @param int $numObjs Number of different objects
         * @param int $numInSet Number of objects in each combination
         *
         * @return int|string Number of combinations, or a string containing an error
         */
        public static function COMBIN($numObjs, $numInSet)
        {
        }
        /**
         * EVEN.
         *
         * Returns number rounded up to the nearest even integer.
         * You can use this function for processing items that come in twos. For example,
         *        a packing crate accepts rows of one or two items. The crate is full when
         *        the number of items, rounded up to the nearest two, matches the crate's
         *        capacity.
         *
         * Excel Function:
         *        EVEN(number)
         *
         * @param float $number Number to round
         *
         * @return int|string Rounded Number, or a string containing an error
         */
        public static function EVEN($number)
        {
        }
        /**
         * FACT.
         *
         * Returns the factorial of a number.
         * The factorial of a number is equal to 1*2*3*...* number.
         *
         * Excel Function:
         *        FACT(factVal)
         *
         * @param float $factVal Factorial Value
         *
         * @return int|string Factorial, or a string containing an error
         */
        public static function FACT($factVal)
        {
        }
        /**
         * FACTDOUBLE.
         *
         * Returns the double factorial of a number.
         *
         * Excel Function:
         *        FACTDOUBLE(factVal)
         *
         * @param float $factVal Factorial Value
         *
         * @return int|string Double Factorial, or a string containing an error
         */
        public static function FACTDOUBLE($factVal)
        {
        }
        /**
         * FLOOR.
         *
         * Rounds number down, toward zero, to the nearest multiple of significance.
         *
         * Excel Function:
         *        FLOOR(number[,significance])
         *
         * @param float $number Number to round
         * @param float $significance Significance
         *
         * @return float|string Rounded Number, or a string containing an error
         */
        public static function FLOOR($number, $significance = null)
        {
        }
        /**
         * FLOOR.MATH.
         *
         * Round a number down to the nearest integer or to the nearest multiple of significance.
         *
         * Excel Function:
         *        FLOOR.MATH(number[,significance[,mode]])
         *
         * @param float $number Number to round
         * @param float $significance Significance
         * @param int $mode direction to round negative numbers
         *
         * @return float|string Rounded Number, or a string containing an error
         */
        public static function FLOORMATH($number, $significance = null, $mode = 0)
        {
        }
        /**
         * FLOOR.PRECISE.
         *
         * Rounds number down, toward zero, to the nearest multiple of significance.
         *
         * Excel Function:
         *        FLOOR.PRECISE(number[,significance])
         *
         * @param float $number Number to round
         * @param float $significance Significance
         *
         * @return float|string Rounded Number, or a string containing an error
         */
        public static function FLOORPRECISE($number, $significance = 1)
        {
        }
        private static function evaluateGCD($a, $b)
        {
        }
        /**
         * GCD.
         *
         * Returns the greatest common divisor of a series of numbers.
         * The greatest common divisor is the largest integer that divides both
         *        number1 and number2 without a remainder.
         *
         * Excel Function:
         *        GCD(number1[,number2[, ...]])
         *
         * @param mixed ...$args Data values
         *
         * @return int|mixed|string Greatest Common Divisor, or a string containing an error
         */
        public static function GCD(...$args)
        {
        }
        /**
         * INT.
         *
         * Casts a floating point value to an integer
         *
         * Excel Function:
         *        INT(number)
         *
         * @param float $number Number to cast to an integer
         *
         * @return int|string Integer value, or a string containing an error
         */
        public static function INT($number)
        {
        }
        /**
         * LCM.
         *
         * Returns the lowest common multiplier of a series of numbers
         * The least common multiple is the smallest positive integer that is a multiple
         * of all integer arguments number1, number2, and so on. Use LCM to add fractions
         * with different denominators.
         *
         * Excel Function:
         *        LCM(number1[,number2[, ...]])
         *
         * @param mixed ...$args Data values
         *
         * @return int|string Lowest Common Multiplier, or a string containing an error
         */
        public static function LCM(...$args)
        {
        }
        /**
         * LOG_BASE.
         *
         * Returns the logarithm of a number to a specified base. The default base is 10.
         *
         * Excel Function:
         *        LOG(number[,base])
         *
         * @param float $number The positive real number for which you want the logarithm
         * @param float $base The base of the logarithm. If base is omitted, it is assumed to be 10.
         *
         * @return float|string The result, or a string containing an error
         */
        public static function logBase($number = null, $base = 10)
        {
        }
        /**
         * MDETERM.
         *
         * Returns the matrix determinant of an array.
         *
         * Excel Function:
         *        MDETERM(array)
         *
         * @param array $matrixValues A matrix of values
         *
         * @return float|string The result, or a string containing an error
         */
        public static function MDETERM($matrixValues)
        {
        }
        /**
         * MINVERSE.
         *
         * Returns the inverse matrix for the matrix stored in an array.
         *
         * Excel Function:
         *        MINVERSE(array)
         *
         * @param array $matrixValues A matrix of values
         *
         * @return array|string The result, or a string containing an error
         */
        public static function MINVERSE($matrixValues)
        {
        }
        /**
         * MMULT.
         *
         * @param array $matrixData1 A matrix of values
         * @param array $matrixData2 A matrix of values
         *
         * @return array|string The result, or a string containing an error
         */
        public static function MMULT($matrixData1, $matrixData2)
        {
        }
        /**
         * MOD.
         *
         * @param int $a Dividend
         * @param int $b Divisor
         *
         * @return int|string Remainder, or a string containing an error
         */
        public static function MOD($a = 1, $b = 1)
        {
        }
        /**
         * MROUND.
         *
         * Rounds a number to the nearest multiple of a specified value
         *
         * @param float $number Number to round
         * @param int $multiple Multiple to which you want to round $number
         *
         * @return float|string Rounded Number, or a string containing an error
         */
        public static function MROUND($number, $multiple)
        {
        }
        /**
         * MULTINOMIAL.
         *
         * Returns the ratio of the factorial of a sum of values to the product of factorials.
         *
         * @param array of mixed Data Series
         *
         * @return float|string The result, or a string containing an error
         */
        public static function MULTINOMIAL(...$args)
        {
        }
        /**
         * ODD.
         *
         * Returns number rounded up to the nearest odd integer.
         *
         * @param float $number Number to round
         *
         * @return int|string Rounded Number, or a string containing an error
         */
        public static function ODD($number)
        {
        }
        /**
         * POWER.
         *
         * Computes x raised to the power y.
         *
         * @param float $x
         * @param float $y
         *
         * @return float|string The result, or a string containing an error
         */
        public static function POWER($x = 0, $y = 2)
        {
        }
        /**
         * PRODUCT.
         *
         * PRODUCT returns the product of all the values and cells referenced in the argument list.
         *
         * Excel Function:
         *        PRODUCT(value1[,value2[, ...]])
         *
         * @param mixed ...$args Data values
         *
         * @return float
         */
        public static function PRODUCT(...$args)
        {
        }
        /**
         * QUOTIENT.
         *
         * QUOTIENT function returns the integer portion of a division. Numerator is the divided number
         *        and denominator is the divisor.
         *
         * Excel Function:
         *        QUOTIENT(value1[,value2[, ...]])
         *
         * @param mixed ...$args Data values
         *
         * @return float
         */
        public static function QUOTIENT(...$args)
        {
        }
        /**
         * RAND.
         *
         * @param int $min Minimal value
         * @param int $max Maximal value
         *
         * @return int Random number
         */
        public static function RAND($min = 0, $max = 0)
        {
        }
        public static function ROMAN($aValue, $style = 0)
        {
        }
        /**
         * ROUNDUP.
         *
         * Rounds a number up to a specified number of decimal places
         *
         * @param float $number Number to round
         * @param int $digits Number of digits to which you want to round $number
         *
         * @return float|string Rounded Number, or a string containing an error
         */
        public static function ROUNDUP($number, $digits)
        {
        }
        /**
         * ROUNDDOWN.
         *
         * Rounds a number down to a specified number of decimal places
         *
         * @param float $number Number to round
         * @param int $digits Number of digits to which you want to round $number
         *
         * @return float|string Rounded Number, or a string containing an error
         */
        public static function ROUNDDOWN($number, $digits)
        {
        }
        /**
         * SERIESSUM.
         *
         * Returns the sum of a power series
         *
         * @param array of mixed Data Series
         *
         * @return float|string The result, or a string containing an error
         */
        public static function SERIESSUM(...$args)
        {
        }
        /**
         * SIGN.
         *
         * Determines the sign of a number. Returns 1 if the number is positive, zero (0)
         *        if the number is 0, and -1 if the number is negative.
         *
         * @param float $number Number to round
         *
         * @return int|string sign value, or a string containing an error
         */
        public static function SIGN($number)
        {
        }
        /**
         * SQRTPI.
         *
         * Returns the square root of (number * pi).
         *
         * @param float $number Number
         *
         * @return float|string Square Root of Number * Pi, or a string containing an error
         */
        public static function SQRTPI($number)
        {
        }
        protected static function filterHiddenArgs($cellReference, $args)
        {
        }
        protected static function filterFormulaArgs($cellReference, $args)
        {
        }
        /**
         * SUBTOTAL.
         *
         * Returns a subtotal in a list or database.
         *
         * @param int the number 1 to 11 that specifies which function to
         *                    use in calculating subtotals within a range
         *                    list
         *            Numbers 101 to 111 shadow the functions of 1 to 11
         *                    but ignore any values in the range that are
         *                    in hidden rows or columns
         * @param array of mixed Data Series
         *
         * @return float|string
         */
        public static function SUBTOTAL(...$args)
        {
        }
        /**
         * SUM.
         *
         * SUM computes the sum of all the values and cells referenced in the argument list.
         *
         * Excel Function:
         *        SUM(value1[,value2[, ...]])
         *
         * @param mixed ...$args Data values
         *
         * @return float
         */
        public static function SUM(...$args)
        {
        }
        /**
         * SUMIF.
         *
         * Counts the number of cells that contain numbers within the list of arguments
         *
         * Excel Function:
         *        SUMIF(value1[,value2[, ...]],condition)
         *
         * @param mixed $aArgs Data values
         * @param string $condition the criteria that defines which cells will be summed
         * @param mixed $sumArgs
         *
         * @return float
         */
        public static function SUMIF($aArgs, $condition, $sumArgs = [])
        {
        }
        /**
         * SUMIFS.
         *
         *    Counts the number of cells that contain numbers within the list of arguments
         *
         *    Excel Function:
         *        SUMIFS(value1[,value2[, ...]],condition)
         *
         * @param mixed $args Data values
         *
         * @return float
         */
        public static function SUMIFS(...$args)
        {
        }
        /**
         * SUMPRODUCT.
         *
         * Excel Function:
         *        SUMPRODUCT(value1[,value2[, ...]])
         *
         * @param mixed ...$args Data values
         *
         * @return float|string The result, or a string containing an error
         */
        public static function SUMPRODUCT(...$args)
        {
        }
        /**
         * SUMSQ.
         *
         * SUMSQ returns the sum of the squares of the arguments
         *
         * Excel Function:
         *        SUMSQ(value1[,value2[, ...]])
         *
         * @param mixed ...$args Data values
         *
         * @return float
         */
        public static function SUMSQ(...$args)
        {
        }
        /**
         * SUMX2MY2.
         *
         * @param mixed[] $matrixData1 Matrix #1
         * @param mixed[] $matrixData2 Matrix #2
         *
         * @return float
         */
        public static function SUMX2MY2($matrixData1, $matrixData2)
        {
        }
        /**
         * SUMX2PY2.
         *
         * @param mixed[] $matrixData1 Matrix #1
         * @param mixed[] $matrixData2 Matrix #2
         *
         * @return float
         */
        public static function SUMX2PY2($matrixData1, $matrixData2)
        {
        }
        /**
         * SUMXMY2.
         *
         * @param mixed[] $matrixData1 Matrix #1
         * @param mixed[] $matrixData2 Matrix #2
         *
         * @return float
         */
        public static function SUMXMY2($matrixData1, $matrixData2)
        {
        }
        /**
         * TRUNC.
         *
         * Truncates value to the number of fractional digits by number_digits.
         *
         * @param float $value
         * @param int $digits
         *
         * @return float|string Truncated value, or a string containing an error
         */
        public static function TRUNC($value = 0, $digits = 0)
        {
        }
        /**
         * SEC.
         *
         * Returns the secant of an angle.
         *
         * @param float $angle Number
         *
         * @return float|string The secant of the angle
         */
        public static function SEC($angle)
        {
        }
        /**
         * SECH.
         *
         * Returns the hyperbolic secant of an angle.
         *
         * @param float $angle Number
         *
         * @return float|string The hyperbolic secant of the angle
         */
        public static function SECH($angle)
        {
        }
        /**
         * CSC.
         *
         * Returns the cosecant of an angle.
         *
         * @param float $angle Number
         *
         * @return float|string The cosecant of the angle
         */
        public static function CSC($angle)
        {
        }
        /**
         * CSCH.
         *
         * Returns the hyperbolic cosecant of an angle.
         *
         * @param float $angle Number
         *
         * @return float|string The hyperbolic cosecant of the angle
         */
        public static function CSCH($angle)
        {
        }
        /**
         * COT.
         *
         * Returns the cotangent of an angle.
         *
         * @param float $angle Number
         *
         * @return float|string The cotangent of the angle
         */
        public static function COT($angle)
        {
        }
        /**
         * COTH.
         *
         * Returns the hyperbolic cotangent of an angle.
         *
         * @param float $angle Number
         *
         * @return float|string The hyperbolic cotangent of the angle
         */
        public static function COTH($angle)
        {
        }
        /**
         * ACOT.
         *
         * Returns the arccotangent of a number.
         *
         * @param float $number Number
         *
         * @return float|string The arccotangent of the number
         */
        public static function ACOT($number)
        {
        }
        /**
         * ACOTH.
         *
         * Returns the hyperbolic arccotangent of a number.
         *
         * @param float $number Number
         *
         * @return float|string The hyperbolic arccotangent of the number
         */
        public static function ACOTH($number)
        {
        }
    }
    class Calculation
    {
        /** Constants                */
        /** Regular Expressions        */
        //    Numeric operand
        const CALCULATION_REGEXP_NUMBER = '[-+]?\\d*\\.?\\d+(e[-+]?\\d+)?';
        //    String operand
        const CALCULATION_REGEXP_STRING = '"(?:[^"]|"")*"';
        //    Opening bracket
        const CALCULATION_REGEXP_OPENBRACE = '\\(';
        //    Function (allow for the old @ symbol that could be used to prefix a function, but we'll ignore it)
        const CALCULATION_REGEXP_FUNCTION = '@?(?:_xlfn\\.)?([A-Z][A-Z0-9\\.]*)[\\s]*\\(';
        //    Cell reference (cell or range of cells, with or without a sheet reference)
        const CALCULATION_REGEXP_CELLREF = '((([^\\s,!&%^\\/\\*\\+<>=-]*)|(\'[^\']*\')|(\\"[^\\"]*\\"))!)?\\$?\\b([a-z]{1,3})\\$?(\\d{1,7})(?![\\w.])';
        //    Named Range of cells
        const CALCULATION_REGEXP_NAMEDRANGE = '((([^\\s,!&%^\\/\\*\\+<>=-]*)|(\'[^\']*\')|(\\"[^\\"]*\\"))!)?([_A-Z][_A-Z0-9\\.]*)';
        //    Error
        const CALCULATION_REGEXP_ERROR = '\\#[A-Z][A-Z0_\\/]*[!\\?]?';
        /** constants */
        const RETURN_ARRAY_AS_ERROR = 'error';
        const RETURN_ARRAY_AS_VALUE = 'value';
        const RETURN_ARRAY_AS_ARRAY = 'array';
        const FORMULA_OPEN_FUNCTION_BRACE = '{';
        const FORMULA_CLOSE_FUNCTION_BRACE = '}';
        const FORMULA_STRING_QUOTE = '"';
        private static $returnArrayAsType = self::RETURN_ARRAY_AS_VALUE;
        /**
         * Instance of this class.
         *
         * @var Calculation
         */
        private static $instance;
        /**
         * Instance of the spreadsheet this Calculation Engine is using.
         *
         * @var Spreadsheet
         */
        private $spreadsheet;
        /**
         * Calculation cache.
         *
         * @var array
         */
        private $calculationCache = [];
        /**
         * Calculation cache enabled.
         *
         * @var bool
         */
        private $calculationCacheEnabled = true;
        /**
         * Used to generate unique store keys.
         *
         * @var int
         */
        private $branchStoreKeyCounter = 0;
        private $branchPruningEnabled = true;
        /**
         * List of operators that can be used within formulae
         * The true/false value indicates whether it is a binary operator or a unary operator.
         *
         * @var array
         */
        private static $operators = ['+' => true, '-' => true, '*' => true, '/' => true, '^' => true, '&' => true, '%' => false, '~' => false, '>' => true, '<' => true, '=' => true, '>=' => true, '<=' => true, '<>' => true, '|' => true, ':' => true];
        /**
         * List of binary operators (those that expect two operands).
         *
         * @var array
         */
        private static $binaryOperators = ['+' => true, '-' => true, '*' => true, '/' => true, '^' => true, '&' => true, '>' => true, '<' => true, '=' => true, '>=' => true, '<=' => true, '<>' => true, '|' => true, ':' => true];
        /**
         * The debug log generated by the calculation engine.
         *
         * @var Logger
         */
        private $debugLog;
        /**
         * Flag to determine how formula errors should be handled
         *        If true, then a user error will be triggered
         *        If false, then an exception will be thrown.
         *
         * @var bool
         */
        public $suppressFormulaErrors = false;
        /**
         * Error message for any error that was raised/thrown by the calculation engine.
         *
         * @var string
         */
        public $formulaError;
        /**
         * An array of the nested cell references accessed by the calculation engine, used for the debug log.
         *
         * @var CyclicReferenceStack
         */
        private $cyclicReferenceStack;
        private $cellStack = [];
        /**
         * Current iteration counter for cyclic formulae
         * If the value is 0 (or less) then cyclic formulae will throw an exception,
         * otherwise they will iterate to the limit defined here before returning a result.
         *
         * @var int
         */
        private $cyclicFormulaCounter = 1;
        private $cyclicFormulaCell = '';
        /**
         * Number of iterations for cyclic formulae.
         *
         * @var int
         */
        public $cyclicFormulaCount = 1;
        /**
         * Epsilon Precision used for comparisons in calculations.
         *
         * @var float
         */
        private $delta = 1.0E-13;
        /**
         * The current locale setting.
         *
         * @var string
         */
        private static $localeLanguage = 'en_us';
        //    US English    (default locale)
        /**
         * List of available locale settings
         * Note that this is read for the locale subdirectory only when requested.
         *
         * @var string[]
         */
        private static $validLocaleLanguages = ['en'];
        /**
         * Locale-specific argument separator for function arguments.
         *
         * @var string
         */
        private static $localeArgumentSeparator = ',';
        private static $localeFunctions = [];
        /**
         * Locale-specific translations for Excel constants (True, False and Null).
         *
         * @var string[]
         */
        public static $localeBoolean = ['TRUE' => 'TRUE', 'FALSE' => 'FALSE', 'NULL' => 'NULL'];
        /**
         * Excel constant string translations to their PHP equivalents
         * Constant conversion from text name/value to actual (datatyped) value.
         *
         * @var string[]
         */
        private static $excelConstants = ['TRUE' => true, 'FALSE' => false, 'NULL' => null];
        // PhpSpreadsheet functions
        private static $phpSpreadsheetFunctions = ['ABS' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'abs', 'argumentCount' => '1'], 'ACCRINT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'ACCRINT'], 'argumentCount' => '4-7'], 'ACCRINTM' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'ACCRINTM'], 'argumentCount' => '3-5'], 'ACOS' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'acos', 'argumentCount' => '1'], 'ACOSH' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'acosh', 'argumentCount' => '1'], 'ACOT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'ACOT'], 'argumentCount' => '1'], 'ACOTH' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'ACOTH'], 'argumentCount' => '1'], 'ADDRESS' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\LookupRef::class, 'cellAddress'], 'argumentCount' => '2-5'], 'AMORDEGRC' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'AMORDEGRC'], 'argumentCount' => '6,7'], 'AMORLINC' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'AMORLINC'], 'argumentCount' => '6,7'], 'AND' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_LOGICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Logical::class, 'logicalAnd'], 'argumentCount' => '1+'], 'ARABIC' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'ARABIC'], 'argumentCount' => '1'], 'AREAS' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '1'], 'ASC' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '1'], 'ASIN' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'asin', 'argumentCount' => '1'], 'ASINH' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'asinh', 'argumentCount' => '1'], 'ATAN' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'atan', 'argumentCount' => '1'], 'ATAN2' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'ATAN2'], 'argumentCount' => '2'], 'ATANH' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'atanh', 'argumentCount' => '1'], 'AVEDEV' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'AVEDEV'], 'argumentCount' => '1+'], 'AVERAGE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'AVERAGE'], 'argumentCount' => '1+'], 'AVERAGEA' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'AVERAGEA'], 'argumentCount' => '1+'], 'AVERAGEIF' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'AVERAGEIF'], 'argumentCount' => '2,3'], 'AVERAGEIFS' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '3+'], 'BAHTTEXT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '1'], 'BASE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'BASE'], 'argumentCount' => '2,3'], 'BESSELI' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'BESSELI'], 'argumentCount' => '2'], 'BESSELJ' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'BESSELJ'], 'argumentCount' => '2'], 'BESSELK' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'BESSELK'], 'argumentCount' => '2'], 'BESSELY' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'BESSELY'], 'argumentCount' => '2'], 'BETADIST' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'BETADIST'], 'argumentCount' => '3-5'], 'BETAINV' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'BETAINV'], 'argumentCount' => '3-5'], 'BIN2DEC' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'BINTODEC'], 'argumentCount' => '1'], 'BIN2HEX' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'BINTOHEX'], 'argumentCount' => '1,2'], 'BIN2OCT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'BINTOOCT'], 'argumentCount' => '1,2'], 'BINOMDIST' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'BINOMDIST'], 'argumentCount' => '4'], 'BITAND' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'BITAND'], 'argumentCount' => '2'], 'BITOR' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'BITOR'], 'argumentCount' => '2'], 'BITXOR' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'BITOR'], 'argumentCount' => '2'], 'BITLSHIFT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'BITLSHIFT'], 'argumentCount' => '2'], 'BITRSHIFT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'BITRSHIFT'], 'argumentCount' => '2'], 'CEILING' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'CEILING'], 'argumentCount' => '2'], 'CELL' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_INFORMATION, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '1,2'], 'CHAR' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'CHARACTER'], 'argumentCount' => '1'], 'CHIDIST' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'CHIDIST'], 'argumentCount' => '2'], 'CHIINV' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'CHIINV'], 'argumentCount' => '2'], 'CHITEST' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '2'], 'CHOOSE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\LookupRef::class, 'CHOOSE'], 'argumentCount' => '2+'], 'CLEAN' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'TRIMNONPRINTABLE'], 'argumentCount' => '1'], 'CODE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'ASCIICODE'], 'argumentCount' => '1'], 'COLUMN' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\LookupRef::class, 'COLUMN'], 'argumentCount' => '-1', 'passByReference' => [true]], 'COLUMNS' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\LookupRef::class, 'COLUMNS'], 'argumentCount' => '1'], 'COMBIN' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'COMBIN'], 'argumentCount' => '2'], 'COMPLEX' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'COMPLEX'], 'argumentCount' => '2,3'], 'CONCAT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'CONCATENATE'], 'argumentCount' => '1+'], 'CONCATENATE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'CONCATENATE'], 'argumentCount' => '1+'], 'CONFIDENCE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'CONFIDENCE'], 'argumentCount' => '3'], 'CONVERT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'CONVERTUOM'], 'argumentCount' => '3'], 'CORREL' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'CORREL'], 'argumentCount' => '2'], 'COS' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'cos', 'argumentCount' => '1'], 'COSH' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'cosh', 'argumentCount' => '1'], 'COT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'COT'], 'argumentCount' => '1'], 'COTH' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'COTH'], 'argumentCount' => '1'], 'COUNT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'COUNT'], 'argumentCount' => '1+'], 'COUNTA' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'COUNTA'], 'argumentCount' => '1+'], 'COUNTBLANK' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'COUNTBLANK'], 'argumentCount' => '1'], 'COUNTIF' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'COUNTIF'], 'argumentCount' => '2'], 'COUNTIFS' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'COUNTIFS'], 'argumentCount' => '2+'], 'COUPDAYBS' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'COUPDAYBS'], 'argumentCount' => '3,4'], 'COUPDAYS' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'COUPDAYS'], 'argumentCount' => '3,4'], 'COUPDAYSNC' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'COUPDAYSNC'], 'argumentCount' => '3,4'], 'COUPNCD' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'COUPNCD'], 'argumentCount' => '3,4'], 'COUPNUM' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'COUPNUM'], 'argumentCount' => '3,4'], 'COUPPCD' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'COUPPCD'], 'argumentCount' => '3,4'], 'COVAR' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'COVAR'], 'argumentCount' => '2'], 'CRITBINOM' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'CRITBINOM'], 'argumentCount' => '3'], 'CSC' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'CSC'], 'argumentCount' => '1'], 'CSCH' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'CSCH'], 'argumentCount' => '1'], 'CUBEKPIMEMBER' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_CUBE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '?'], 'CUBEMEMBER' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_CUBE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '?'], 'CUBEMEMBERPROPERTY' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_CUBE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '?'], 'CUBERANKEDMEMBER' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_CUBE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '?'], 'CUBESET' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_CUBE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '?'], 'CUBESETCOUNT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_CUBE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '?'], 'CUBEVALUE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_CUBE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '?'], 'CUMIPMT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'CUMIPMT'], 'argumentCount' => '6'], 'CUMPRINC' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'CUMPRINC'], 'argumentCount' => '6'], 'DATE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATE_AND_TIME, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\DateTime::class, 'DATE'], 'argumentCount' => '3'], 'DATEDIF' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATE_AND_TIME, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\DateTime::class, 'DATEDIF'], 'argumentCount' => '2,3'], 'DATEVALUE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATE_AND_TIME, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\DateTime::class, 'DATEVALUE'], 'argumentCount' => '1'], 'DAVERAGE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATABASE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Database::class, 'DAVERAGE'], 'argumentCount' => '3'], 'DAY' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATE_AND_TIME, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\DateTime::class, 'DAYOFMONTH'], 'argumentCount' => '1'], 'DAYS' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATE_AND_TIME, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\DateTime::class, 'DAYS'], 'argumentCount' => '2'], 'DAYS360' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATE_AND_TIME, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\DateTime::class, 'DAYS360'], 'argumentCount' => '2,3'], 'DB' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'DB'], 'argumentCount' => '4,5'], 'DCOUNT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATABASE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Database::class, 'DCOUNT'], 'argumentCount' => '3'], 'DCOUNTA' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATABASE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Database::class, 'DCOUNTA'], 'argumentCount' => '3'], 'DDB' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'DDB'], 'argumentCount' => '4,5'], 'DEC2BIN' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'DECTOBIN'], 'argumentCount' => '1,2'], 'DEC2HEX' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'DECTOHEX'], 'argumentCount' => '1,2'], 'DEC2OCT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'DECTOOCT'], 'argumentCount' => '1,2'], 'DEGREES' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'rad2deg', 'argumentCount' => '1'], 'DELTA' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'DELTA'], 'argumentCount' => '1,2'], 'DEVSQ' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'DEVSQ'], 'argumentCount' => '1+'], 'DGET' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATABASE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Database::class, 'DGET'], 'argumentCount' => '3'], 'DISC' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'DISC'], 'argumentCount' => '4,5'], 'DMAX' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATABASE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Database::class, 'DMAX'], 'argumentCount' => '3'], 'DMIN' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATABASE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Database::class, 'DMIN'], 'argumentCount' => '3'], 'DOLLAR' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'DOLLAR'], 'argumentCount' => '1,2'], 'DOLLARDE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'DOLLARDE'], 'argumentCount' => '2'], 'DOLLARFR' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'DOLLARFR'], 'argumentCount' => '2'], 'DPRODUCT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATABASE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Database::class, 'DPRODUCT'], 'argumentCount' => '3'], 'DSTDEV' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATABASE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Database::class, 'DSTDEV'], 'argumentCount' => '3'], 'DSTDEVP' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATABASE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Database::class, 'DSTDEVP'], 'argumentCount' => '3'], 'DSUM' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATABASE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Database::class, 'DSUM'], 'argumentCount' => '3'], 'DURATION' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '5,6'], 'DVAR' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATABASE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Database::class, 'DVAR'], 'argumentCount' => '3'], 'DVARP' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATABASE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Database::class, 'DVARP'], 'argumentCount' => '3'], 'EDATE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATE_AND_TIME, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\DateTime::class, 'EDATE'], 'argumentCount' => '2'], 'EFFECT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'EFFECT'], 'argumentCount' => '2'], 'EOMONTH' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATE_AND_TIME, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\DateTime::class, 'EOMONTH'], 'argumentCount' => '2'], 'ERF' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'ERF'], 'argumentCount' => '1,2'], 'ERF.PRECISE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'ERFPRECISE'], 'argumentCount' => '1'], 'ERFC' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'ERFC'], 'argumentCount' => '1'], 'ERFC.PRECISE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'ERFC'], 'argumentCount' => '1'], 'ERROR.TYPE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_INFORMATION, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'errorType'], 'argumentCount' => '1'], 'EVEN' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'EVEN'], 'argumentCount' => '1'], 'EXACT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'EXACT'], 'argumentCount' => '2'], 'EXP' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'exp', 'argumentCount' => '1'], 'EXPONDIST' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'EXPONDIST'], 'argumentCount' => '3'], 'FACT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'FACT'], 'argumentCount' => '1'], 'FACTDOUBLE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'FACTDOUBLE'], 'argumentCount' => '1'], 'FALSE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_LOGICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Logical::class, 'FALSE'], 'argumentCount' => '0'], 'FDIST' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '3'], 'FIND' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'SEARCHSENSITIVE'], 'argumentCount' => '2,3'], 'FINDB' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'SEARCHSENSITIVE'], 'argumentCount' => '2,3'], 'FINV' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '3'], 'FISHER' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'FISHER'], 'argumentCount' => '1'], 'FISHERINV' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'FISHERINV'], 'argumentCount' => '1'], 'FIXED' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'FIXEDFORMAT'], 'argumentCount' => '1-3'], 'FLOOR' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'FLOOR'], 'argumentCount' => '2'], 'FLOOR.MATH' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'FLOORMATH'], 'argumentCount' => '3'], 'FLOOR.PRECISE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'FLOORPRECISE'], 'argumentCount' => '2'], 'FORECAST' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'FORECAST'], 'argumentCount' => '3'], 'FORMULATEXT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\LookupRef::class, 'FORMULATEXT'], 'argumentCount' => '1', 'passCellReference' => true, 'passByReference' => [true]], 'FREQUENCY' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '2'], 'FTEST' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '2'], 'FV' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'FV'], 'argumentCount' => '3-5'], 'FVSCHEDULE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'FVSCHEDULE'], 'argumentCount' => '2'], 'GAMMADIST' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'GAMMADIST'], 'argumentCount' => '4'], 'GAMMAINV' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'GAMMAINV'], 'argumentCount' => '3'], 'GAMMALN' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'GAMMALN'], 'argumentCount' => '1'], 'GCD' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'GCD'], 'argumentCount' => '1+'], 'GEOMEAN' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'GEOMEAN'], 'argumentCount' => '1+'], 'GESTEP' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'GESTEP'], 'argumentCount' => '1,2'], 'GETPIVOTDATA' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '2+'], 'GROWTH' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'GROWTH'], 'argumentCount' => '1-4'], 'HARMEAN' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'HARMEAN'], 'argumentCount' => '1+'], 'HEX2BIN' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'HEXTOBIN'], 'argumentCount' => '1,2'], 'HEX2DEC' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'HEXTODEC'], 'argumentCount' => '1'], 'HEX2OCT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'HEXTOOCT'], 'argumentCount' => '1,2'], 'HLOOKUP' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\LookupRef::class, 'HLOOKUP'], 'argumentCount' => '3,4'], 'HOUR' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATE_AND_TIME, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\DateTime::class, 'HOUROFDAY'], 'argumentCount' => '1'], 'HYPERLINK' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\LookupRef::class, 'HYPERLINK'], 'argumentCount' => '1,2', 'passCellReference' => true], 'HYPGEOMDIST' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'HYPGEOMDIST'], 'argumentCount' => '4'], 'IF' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_LOGICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Logical::class, 'statementIf'], 'argumentCount' => '1-3'], 'IFERROR' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_LOGICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Logical::class, 'IFERROR'], 'argumentCount' => '2'], 'IFNA' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_LOGICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Logical::class, 'IFNA'], 'argumentCount' => '2'], 'IFS' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_LOGICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '2+'], 'IMABS' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'IMABS'], 'argumentCount' => '1'], 'IMAGINARY' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'IMAGINARY'], 'argumentCount' => '1'], 'IMARGUMENT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'IMARGUMENT'], 'argumentCount' => '1'], 'IMCONJUGATE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'IMCONJUGATE'], 'argumentCount' => '1'], 'IMCOS' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'IMCOS'], 'argumentCount' => '1'], 'IMCOSH' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'IMCOSH'], 'argumentCount' => '1'], 'IMCOT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'IMCOT'], 'argumentCount' => '1'], 'IMCSC' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'IMCSC'], 'argumentCount' => '1'], 'IMCSCH' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'IMCSCH'], 'argumentCount' => '1'], 'IMDIV' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'IMDIV'], 'argumentCount' => '2'], 'IMEXP' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'IMEXP'], 'argumentCount' => '1'], 'IMLN' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'IMLN'], 'argumentCount' => '1'], 'IMLOG10' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'IMLOG10'], 'argumentCount' => '1'], 'IMLOG2' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'IMLOG2'], 'argumentCount' => '1'], 'IMPOWER' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'IMPOWER'], 'argumentCount' => '2'], 'IMPRODUCT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'IMPRODUCT'], 'argumentCount' => '1+'], 'IMREAL' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'IMREAL'], 'argumentCount' => '1'], 'IMSEC' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'IMSEC'], 'argumentCount' => '1'], 'IMSECH' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'IMSECH'], 'argumentCount' => '1'], 'IMSIN' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'IMSIN'], 'argumentCount' => '1'], 'IMSINH' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'IMSINH'], 'argumentCount' => '1'], 'IMSQRT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'IMSQRT'], 'argumentCount' => '1'], 'IMSUB' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'IMSUB'], 'argumentCount' => '2'], 'IMSUM' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'IMSUM'], 'argumentCount' => '1+'], 'IMTAN' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'IMTAN'], 'argumentCount' => '1'], 'INDEX' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\LookupRef::class, 'INDEX'], 'argumentCount' => '1-4'], 'INDIRECT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\LookupRef::class, 'INDIRECT'], 'argumentCount' => '1,2', 'passCellReference' => true], 'INFO' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_INFORMATION, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '1'], 'INT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'INT'], 'argumentCount' => '1'], 'INTERCEPT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'INTERCEPT'], 'argumentCount' => '2'], 'INTRATE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'INTRATE'], 'argumentCount' => '4,5'], 'IPMT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'IPMT'], 'argumentCount' => '4-6'], 'IRR' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'IRR'], 'argumentCount' => '1,2'], 'ISBLANK' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_INFORMATION, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'isBlank'], 'argumentCount' => '1'], 'ISERR' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_INFORMATION, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'isErr'], 'argumentCount' => '1'], 'ISERROR' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_INFORMATION, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'isError'], 'argumentCount' => '1'], 'ISEVEN' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_INFORMATION, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'isEven'], 'argumentCount' => '1'], 'ISFORMULA' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_INFORMATION, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'isFormula'], 'argumentCount' => '1', 'passCellReference' => true, 'passByReference' => [true]], 'ISLOGICAL' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_INFORMATION, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'isLogical'], 'argumentCount' => '1'], 'ISNA' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_INFORMATION, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'isNa'], 'argumentCount' => '1'], 'ISNONTEXT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_INFORMATION, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'isNonText'], 'argumentCount' => '1'], 'ISNUMBER' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_INFORMATION, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'isNumber'], 'argumentCount' => '1'], 'ISODD' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_INFORMATION, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'isOdd'], 'argumentCount' => '1'], 'ISOWEEKNUM' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATE_AND_TIME, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\DateTime::class, 'ISOWEEKNUM'], 'argumentCount' => '1'], 'ISPMT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'ISPMT'], 'argumentCount' => '4'], 'ISREF' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_INFORMATION, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '1'], 'ISTEXT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_INFORMATION, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'isText'], 'argumentCount' => '1'], 'JIS' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '1'], 'KURT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'KURT'], 'argumentCount' => '1+'], 'LARGE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'LARGE'], 'argumentCount' => '2'], 'LCM' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'LCM'], 'argumentCount' => '1+'], 'LEFT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'LEFT'], 'argumentCount' => '1,2'], 'LEFTB' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'LEFT'], 'argumentCount' => '1,2'], 'LEN' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'STRINGLENGTH'], 'argumentCount' => '1'], 'LENB' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'STRINGLENGTH'], 'argumentCount' => '1'], 'LINEST' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'LINEST'], 'argumentCount' => '1-4'], 'LN' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'log', 'argumentCount' => '1'], 'LOG' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'logBase'], 'argumentCount' => '1,2'], 'LOG10' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'log10', 'argumentCount' => '1'], 'LOGEST' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'LOGEST'], 'argumentCount' => '1-4'], 'LOGINV' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'LOGINV'], 'argumentCount' => '3'], 'LOGNORMDIST' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'LOGNORMDIST'], 'argumentCount' => '3'], 'LOOKUP' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\LookupRef::class, 'LOOKUP'], 'argumentCount' => '2,3'], 'LOWER' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'LOWERCASE'], 'argumentCount' => '1'], 'MATCH' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\LookupRef::class, 'MATCH'], 'argumentCount' => '2,3'], 'MAX' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'MAX'], 'argumentCount' => '1+'], 'MAXA' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'MAXA'], 'argumentCount' => '1+'], 'MAXIFS' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'MAXIFS'], 'argumentCount' => '3+'], 'MDETERM' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'MDETERM'], 'argumentCount' => '1'], 'MDURATION' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '5,6'], 'MEDIAN' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'MEDIAN'], 'argumentCount' => '1+'], 'MEDIANIF' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '2+'], 'MID' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'MID'], 'argumentCount' => '3'], 'MIDB' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'MID'], 'argumentCount' => '3'], 'MIN' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'MIN'], 'argumentCount' => '1+'], 'MINA' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'MINA'], 'argumentCount' => '1+'], 'MINIFS' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'MINIFS'], 'argumentCount' => '3+'], 'MINUTE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATE_AND_TIME, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\DateTime::class, 'MINUTE'], 'argumentCount' => '1'], 'MINVERSE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'MINVERSE'], 'argumentCount' => '1'], 'MIRR' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'MIRR'], 'argumentCount' => '3'], 'MMULT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'MMULT'], 'argumentCount' => '2'], 'MOD' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'MOD'], 'argumentCount' => '2'], 'MODE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'MODE'], 'argumentCount' => '1+'], 'MODE.SNGL' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'MODE'], 'argumentCount' => '1+'], 'MONTH' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATE_AND_TIME, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\DateTime::class, 'MONTHOFYEAR'], 'argumentCount' => '1'], 'MROUND' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'MROUND'], 'argumentCount' => '2'], 'MULTINOMIAL' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'MULTINOMIAL'], 'argumentCount' => '1+'], 'N' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_INFORMATION, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'n'], 'argumentCount' => '1'], 'NA' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_INFORMATION, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'NA'], 'argumentCount' => '0'], 'NEGBINOMDIST' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'NEGBINOMDIST'], 'argumentCount' => '3'], 'NETWORKDAYS' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATE_AND_TIME, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\DateTime::class, 'NETWORKDAYS'], 'argumentCount' => '2-3'], 'NETWORKDAYS.INTL' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATE_AND_TIME, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '2-4'], 'NOMINAL' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'NOMINAL'], 'argumentCount' => '2'], 'NORMDIST' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'NORMDIST'], 'argumentCount' => '4'], 'NORMINV' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'NORMINV'], 'argumentCount' => '3'], 'NORMSDIST' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'NORMSDIST'], 'argumentCount' => '1'], 'NORMSINV' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'NORMSINV'], 'argumentCount' => '1'], 'NOT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_LOGICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Logical::class, 'NOT'], 'argumentCount' => '1'], 'NOW' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATE_AND_TIME, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\DateTime::class, 'DATETIMENOW'], 'argumentCount' => '0'], 'NPER' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'NPER'], 'argumentCount' => '3-5'], 'NPV' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'NPV'], 'argumentCount' => '2+'], 'NUMBERVALUE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'NUMBERVALUE'], 'argumentCount' => '1+'], 'OCT2BIN' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'OCTTOBIN'], 'argumentCount' => '1,2'], 'OCT2DEC' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'OCTTODEC'], 'argumentCount' => '1'], 'OCT2HEX' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_ENGINEERING, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Engineering::class, 'OCTTOHEX'], 'argumentCount' => '1,2'], 'ODD' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'ODD'], 'argumentCount' => '1'], 'ODDFPRICE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '8,9'], 'ODDFYIELD' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '8,9'], 'ODDLPRICE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '7,8'], 'ODDLYIELD' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '7,8'], 'OFFSET' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\LookupRef::class, 'OFFSET'], 'argumentCount' => '3-5', 'passCellReference' => true, 'passByReference' => [true]], 'OR' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_LOGICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Logical::class, 'logicalOr'], 'argumentCount' => '1+'], 'PDURATION' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'PDURATION'], 'argumentCount' => '3'], 'PEARSON' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'CORREL'], 'argumentCount' => '2'], 'PERCENTILE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'PERCENTILE'], 'argumentCount' => '2'], 'PERCENTRANK' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'PERCENTRANK'], 'argumentCount' => '2,3'], 'PERMUT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'PERMUT'], 'argumentCount' => '2'], 'PHONETIC' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '1'], 'PI' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'pi', 'argumentCount' => '0'], 'PMT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'PMT'], 'argumentCount' => '3-5'], 'POISSON' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'POISSON'], 'argumentCount' => '3'], 'POWER' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'POWER'], 'argumentCount' => '2'], 'PPMT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'PPMT'], 'argumentCount' => '4-6'], 'PRICE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'PRICE'], 'argumentCount' => '6,7'], 'PRICEDISC' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'PRICEDISC'], 'argumentCount' => '4,5'], 'PRICEMAT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'PRICEMAT'], 'argumentCount' => '5,6'], 'PROB' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '3,4'], 'PRODUCT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'PRODUCT'], 'argumentCount' => '1+'], 'PROPER' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'PROPERCASE'], 'argumentCount' => '1'], 'PV' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'PV'], 'argumentCount' => '3-5'], 'QUARTILE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'QUARTILE'], 'argumentCount' => '2'], 'QUOTIENT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'QUOTIENT'], 'argumentCount' => '2'], 'RADIANS' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'deg2rad', 'argumentCount' => '1'], 'RAND' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'RAND'], 'argumentCount' => '0'], 'RANDBETWEEN' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'RAND'], 'argumentCount' => '2'], 'RANK' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'RANK'], 'argumentCount' => '2,3'], 'RATE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'RATE'], 'argumentCount' => '3-6'], 'RECEIVED' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'RECEIVED'], 'argumentCount' => '4-5'], 'REPLACE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'REPLACE'], 'argumentCount' => '4'], 'REPLACEB' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'REPLACE'], 'argumentCount' => '4'], 'REPT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => 'str_repeat', 'argumentCount' => '2'], 'RIGHT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'RIGHT'], 'argumentCount' => '1,2'], 'RIGHTB' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'RIGHT'], 'argumentCount' => '1,2'], 'ROMAN' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'ROMAN'], 'argumentCount' => '1,2'], 'ROUND' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'round', 'argumentCount' => '2'], 'ROUNDDOWN' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'ROUNDDOWN'], 'argumentCount' => '2'], 'ROUNDUP' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'ROUNDUP'], 'argumentCount' => '2'], 'ROW' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\LookupRef::class, 'ROW'], 'argumentCount' => '-1', 'passByReference' => [true]], 'ROWS' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\LookupRef::class, 'ROWS'], 'argumentCount' => '1'], 'RRI' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'RRI'], 'argumentCount' => '3'], 'RSQ' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'RSQ'], 'argumentCount' => '2'], 'RTD' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '1+'], 'SEARCH' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'SEARCHINSENSITIVE'], 'argumentCount' => '2,3'], 'SEARCHB' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'SEARCHINSENSITIVE'], 'argumentCount' => '2,3'], 'SEC' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'SEC'], 'argumentCount' => '1'], 'SECH' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'SECH'], 'argumentCount' => '1'], 'SECOND' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATE_AND_TIME, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\DateTime::class, 'SECOND'], 'argumentCount' => '1'], 'SERIESSUM' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'SERIESSUM'], 'argumentCount' => '4'], 'SHEET' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_INFORMATION, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '0,1'], 'SHEETS' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_INFORMATION, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '0,1'], 'SIGN' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'SIGN'], 'argumentCount' => '1'], 'SIN' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'sin', 'argumentCount' => '1'], 'SINH' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'sinh', 'argumentCount' => '1'], 'SKEW' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'SKEW'], 'argumentCount' => '1+'], 'SLN' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'SLN'], 'argumentCount' => '3'], 'SLOPE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'SLOPE'], 'argumentCount' => '2'], 'SMALL' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'SMALL'], 'argumentCount' => '2'], 'SQRT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'sqrt', 'argumentCount' => '1'], 'SQRTPI' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'SQRTPI'], 'argumentCount' => '1'], 'STANDARDIZE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'STANDARDIZE'], 'argumentCount' => '3'], 'STDEV' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'STDEV'], 'argumentCount' => '1+'], 'STDEV.S' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'STDEV'], 'argumentCount' => '1+'], 'STDEV.P' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'STDEVP'], 'argumentCount' => '1+'], 'STDEVA' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'STDEVA'], 'argumentCount' => '1+'], 'STDEVP' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'STDEVP'], 'argumentCount' => '1+'], 'STDEVPA' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'STDEVPA'], 'argumentCount' => '1+'], 'STEYX' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'STEYX'], 'argumentCount' => '2'], 'SUBSTITUTE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'SUBSTITUTE'], 'argumentCount' => '3,4'], 'SUBTOTAL' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'SUBTOTAL'], 'argumentCount' => '2+', 'passCellReference' => true], 'SUM' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'SUM'], 'argumentCount' => '1+'], 'SUMIF' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'SUMIF'], 'argumentCount' => '2,3'], 'SUMIFS' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'SUMIFS'], 'argumentCount' => '3+'], 'SUMPRODUCT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'SUMPRODUCT'], 'argumentCount' => '1+'], 'SUMSQ' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'SUMSQ'], 'argumentCount' => '1+'], 'SUMX2MY2' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'SUMX2MY2'], 'argumentCount' => '2'], 'SUMX2PY2' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'SUMX2PY2'], 'argumentCount' => '2'], 'SUMXMY2' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'SUMXMY2'], 'argumentCount' => '2'], 'SWITCH' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_LOGICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Logical::class, 'statementSwitch'], 'argumentCount' => '3+'], 'SYD' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'SYD'], 'argumentCount' => '4'], 'T' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'RETURNSTRING'], 'argumentCount' => '1'], 'TAN' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'tan', 'argumentCount' => '1'], 'TANH' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => 'tanh', 'argumentCount' => '1'], 'TBILLEQ' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'TBILLEQ'], 'argumentCount' => '3'], 'TBILLPRICE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'TBILLPRICE'], 'argumentCount' => '3'], 'TBILLYIELD' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'TBILLYIELD'], 'argumentCount' => '3'], 'TDIST' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'TDIST'], 'argumentCount' => '3'], 'TEXT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'TEXTFORMAT'], 'argumentCount' => '2'], 'TEXTJOIN' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'TEXTJOIN'], 'argumentCount' => '3+'], 'TIME' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATE_AND_TIME, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\DateTime::class, 'TIME'], 'argumentCount' => '3'], 'TIMEVALUE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATE_AND_TIME, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\DateTime::class, 'TIMEVALUE'], 'argumentCount' => '1'], 'TINV' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'TINV'], 'argumentCount' => '2'], 'TODAY' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATE_AND_TIME, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\DateTime::class, 'DATENOW'], 'argumentCount' => '0'], 'TRANSPOSE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\LookupRef::class, 'TRANSPOSE'], 'argumentCount' => '1'], 'TREND' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'TREND'], 'argumentCount' => '1-4'], 'TRIM' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'TRIMSPACES'], 'argumentCount' => '1'], 'TRIMMEAN' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'TRIMMEAN'], 'argumentCount' => '2'], 'TRUE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_LOGICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Logical::class, 'TRUE'], 'argumentCount' => '0'], 'TRUNC' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_MATH_AND_TRIG, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\MathTrig::class, 'TRUNC'], 'argumentCount' => '1,2'], 'TTEST' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '4'], 'TYPE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_INFORMATION, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'TYPE'], 'argumentCount' => '1'], 'UNICHAR' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'CHARACTER'], 'argumentCount' => '1'], 'UNICODE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'ASCIICODE'], 'argumentCount' => '1'], 'UPPER' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'UPPERCASE'], 'argumentCount' => '1'], 'USDOLLAR' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '2'], 'VALUE' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_TEXT_AND_DATA, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\TextData::class, 'VALUE'], 'argumentCount' => '1'], 'VAR' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'VARFunc'], 'argumentCount' => '1+'], 'VAR.P' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'VARP'], 'argumentCount' => '1+'], 'VAR.S' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'VARFunc'], 'argumentCount' => '1+'], 'VARA' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'VARA'], 'argumentCount' => '1+'], 'VARP' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'VARP'], 'argumentCount' => '1+'], 'VARPA' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'VARPA'], 'argumentCount' => '1+'], 'VDB' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '5-7'], 'VLOOKUP' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_LOOKUP_AND_REFERENCE, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\LookupRef::class, 'VLOOKUP'], 'argumentCount' => '3,4'], 'WEEKDAY' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATE_AND_TIME, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\DateTime::class, 'WEEKDAY'], 'argumentCount' => '1,2'], 'WEEKNUM' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATE_AND_TIME, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\DateTime::class, 'WEEKNUM'], 'argumentCount' => '1,2'], 'WEIBULL' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'WEIBULL'], 'argumentCount' => '4'], 'WORKDAY' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATE_AND_TIME, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\DateTime::class, 'WORKDAY'], 'argumentCount' => '2-3'], 'WORKDAY.INTL' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATE_AND_TIME, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '2-4'], 'XIRR' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'XIRR'], 'argumentCount' => '2,3'], 'XNPV' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'XNPV'], 'argumentCount' => '3'], 'XOR' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_LOGICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Logical::class, 'logicalXor'], 'argumentCount' => '1+'], 'YEAR' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATE_AND_TIME, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\DateTime::class, 'YEAR'], 'argumentCount' => '1'], 'YEARFRAC' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_DATE_AND_TIME, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\DateTime::class, 'YEARFRAC'], 'argumentCount' => '2,3'], 'YIELD' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'DUMMY'], 'argumentCount' => '6,7'], 'YIELDDISC' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'YIELDDISC'], 'argumentCount' => '4,5'], 'YIELDMAT' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_FINANCIAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Financial::class, 'YIELDMAT'], 'argumentCount' => '5,6'], 'ZTEST' => ['category' => \PhpOffice\PhpSpreadsheet\Calculation\Category::CATEGORY_STATISTICAL, 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Statistical::class, 'ZTEST'], 'argumentCount' => '2-3']];
        //    Internal functions used for special control purposes
        private static $controlFunctions = ['MKMATRIX' => ['argumentCount' => '*', 'functionCall' => [__CLASS__, 'mkMatrix']], 'NAME.ERROR' => ['argumentCount' => '*', 'functionCall' => [\PhpOffice\PhpSpreadsheet\Calculation\Functions::class, 'NAME']]];
        public function __construct(?\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet = null)
        {
        }
        private static function loadLocales() : void
        {
        }
        /**
         * Get an instance of this class.
         *
         * @param Spreadsheet $spreadsheet Injected spreadsheet for working with a PhpSpreadsheet Spreadsheet object,
         *                                    or NULL to create a standalone claculation engine
         *
         * @return Calculation
         */
        public static function getInstance(?\PhpOffice\PhpSpreadsheet\Spreadsheet $spreadsheet = null)
        {
        }
        /**
         * Flush the calculation cache for any existing instance of this class
         *        but only if a Calculation instance exists.
         */
        public function flushInstance() : void
        {
        }
        /**
         * Get the Logger for this calculation engine instance.
         *
         * @return Logger
         */
        public function getDebugLog()
        {
        }
        /**
         * __clone implementation. Cloning should not be allowed in a Singleton!
         */
        public final function __clone()
        {
        }
        /**
         * Return the locale-specific translation of TRUE.
         *
         * @return string locale-specific translation of TRUE
         */
        public static function getTRUE()
        {
        }
        /**
         * Return the locale-specific translation of FALSE.
         *
         * @return string locale-specific translation of FALSE
         */
        public static function getFALSE()
        {
        }
        /**
         * Set the Array Return Type (Array or Value of first element in the array).
         *
         * @param string $returnType Array return type
         *
         * @return bool Success or failure
         */
        public static function setArrayReturnType($returnType)
        {
        }
        /**
         * Return the Array Return Type (Array or Value of first element in the array).
         *
         * @return string $returnType Array return type
         */
        public static function getArrayReturnType()
        {
        }
        /**
         * Is calculation caching enabled?
         *
         * @return bool
         */
        public function getCalculationCacheEnabled()
        {
        }
        /**
         * Enable/disable calculation cache.
         *
         * @param bool $pValue
         */
        public function setCalculationCacheEnabled($pValue) : void
        {
        }
        /**
         * Enable calculation cache.
         */
        public function enableCalculationCache() : void
        {
        }
        /**
         * Disable calculation cache.
         */
        public function disableCalculationCache() : void
        {
        }
        /**
         * Clear calculation cache.
         */
        public function clearCalculationCache() : void
        {
        }
        /**
         * Clear calculation cache for a specified worksheet.
         *
         * @param string $worksheetName
         */
        public function clearCalculationCacheForWorksheet($worksheetName) : void
        {
        }
        /**
         * Rename calculation cache for a specified worksheet.
         *
         * @param string $fromWorksheetName
         * @param string $toWorksheetName
         */
        public function renameCalculationCacheForWorksheet($fromWorksheetName, $toWorksheetName) : void
        {
        }
        /**
         * Enable/disable calculation cache.
         *
         * @param mixed $enabled
         */
        public function setBranchPruningEnabled($enabled) : void
        {
        }
        public function enableBranchPruning() : void
        {
        }
        public function disableBranchPruning() : void
        {
        }
        public function clearBranchStore() : void
        {
        }
        /**
         * Get the currently defined locale code.
         *
         * @return string
         */
        public function getLocale()
        {
        }
        /**
         * Set the locale code.
         *
         * @param string $locale The locale to use for formula translation, eg: 'en_us'
         *
         * @return bool
         */
        public function setLocale($locale)
        {
        }
        /**
         * @param string $fromSeparator
         * @param string $toSeparator
         * @param string $formula
         * @param bool $inBraces
         *
         * @return string
         */
        public static function translateSeparator($fromSeparator, $toSeparator, $formula, &$inBraces)
        {
        }
        /**
         * @param string[] $from
         * @param string[] $to
         * @param string $formula
         * @param string $fromSeparator
         * @param string $toSeparator
         *
         * @return string
         */
        private static function translateFormula(array $from, array $to, $formula, $fromSeparator, $toSeparator)
        {
        }
        private static $functionReplaceFromExcel = null;
        private static $functionReplaceToLocale = null;
        public function _translateFormulaToLocale($formula)
        {
        }
        private static $functionReplaceFromLocale = null;
        private static $functionReplaceToExcel = null;
        public function _translateFormulaToEnglish($formula)
        {
        }
        public static function localeFunc($function)
        {
        }
        /**
         * Wrap string values in quotes.
         *
         * @param mixed $value
         *
         * @return mixed
         */
        public static function wrapResult($value)
        {
        }
        /**
         * Remove quotes used as a wrapper to identify string values.
         *
         * @param mixed $value
         *
         * @return mixed
         */
        public static function unwrapResult($value)
        {
        }
        /**
         * Calculate cell value (using formula from a cell ID)
         * Retained for backward compatibility.
         *
         * @param Cell $pCell Cell to calculate
         *
         * @return mixed
         */
        public function calculate(?\PhpOffice\PhpSpreadsheet\Cell\Cell $pCell = null)
        {
        }
        /**
         * Calculate the value of a cell formula.
         *
         * @param Cell $pCell Cell to calculate
         * @param bool $resetLog Flag indicating whether the debug log should be reset or not
         *
         * @return mixed
         */
        public function calculateCellValue(?\PhpOffice\PhpSpreadsheet\Cell\Cell $pCell = null, $resetLog = true)
        {
        }
        /**
         * Validate and parse a formula string.
         *
         * @param string $formula Formula to parse
         *
         * @return array|bool
         */
        public function parseFormula($formula)
        {
        }
        /**
         * Calculate the value of a formula.
         *
         * @param string $formula Formula to parse
         * @param string $cellID Address of the cell to calculate
         * @param Cell $pCell Cell to calculate
         *
         * @return mixed
         */
        public function calculateFormula($formula, $cellID = null, ?\PhpOffice\PhpSpreadsheet\Cell\Cell $pCell = null)
        {
        }
        /**
         * @param string $cellReference
         * @param mixed $cellValue
         *
         * @return bool
         */
        public function getValueFromCache($cellReference, &$cellValue)
        {
        }
        /**
         * @param string $cellReference
         * @param mixed $cellValue
         */
        public function saveValueToCache($cellReference, $cellValue) : void
        {
        }
        /**
         * Parse a cell formula and calculate its value.
         *
         * @param string $formula The formula to parse and calculate
         * @param string $cellID The ID (e.g. A3) of the cell that we are calculating
         * @param Cell $pCell Cell to calculate
         *
         * @return mixed
         */
        public function _calculateFormulaValue($formula, $cellID = null, ?\PhpOffice\PhpSpreadsheet\Cell\Cell $pCell = null)
        {
        }
        /**
         * Ensure that paired matrix operands are both matrices and of the same size.
         *
         * @param mixed &$operand1 First matrix operand
         * @param mixed &$operand2 Second matrix operand
         * @param int $resize Flag indicating whether the matrices should be resized to match
         *                                        and (if so), whether the smaller dimension should grow or the
         *                                        larger should shrink.
         *                                            0 = no resize
         *                                            1 = shrink to fit
         *                                            2 = extend to fit
         *
         * @return array
         */
        private static function checkMatrixOperands(&$operand1, &$operand2, $resize = 1)
        {
        }
        /**
         * Read the dimensions of a matrix, and re-index it with straight numeric keys starting from row 0, column 0.
         *
         * @param array &$matrix matrix operand
         *
         * @return int[] An array comprising the number of rows, and number of columns
         */
        public static function getMatrixDimensions(array &$matrix)
        {
        }
        /**
         * Ensure that paired matrix operands are both matrices of the same size.
         *
         * @param mixed &$matrix1 First matrix operand
         * @param mixed &$matrix2 Second matrix operand
         * @param int $matrix1Rows Row size of first matrix operand
         * @param int $matrix1Columns Column size of first matrix operand
         * @param int $matrix2Rows Row size of second matrix operand
         * @param int $matrix2Columns Column size of second matrix operand
         */
        private static function resizeMatricesShrink(&$matrix1, &$matrix2, $matrix1Rows, $matrix1Columns, $matrix2Rows, $matrix2Columns) : void
        {
        }
        /**
         * Ensure that paired matrix operands are both matrices of the same size.
         *
         * @param mixed &$matrix1 First matrix operand
         * @param mixed &$matrix2 Second matrix operand
         * @param int $matrix1Rows Row size of first matrix operand
         * @param int $matrix1Columns Column size of first matrix operand
         * @param int $matrix2Rows Row size of second matrix operand
         * @param int $matrix2Columns Column size of second matrix operand
         */
        private static function resizeMatricesExtend(&$matrix1, &$matrix2, $matrix1Rows, $matrix1Columns, $matrix2Rows, $matrix2Columns) : void
        {
        }
        /**
         * Format details of an operand for display in the log (based on operand type).
         *
         * @param mixed $value First matrix operand
         *
         * @return mixed
         */
        private function showValue($value)
        {
        }
        /**
         * Format type and details of an operand for display in the log (based on operand type).
         *
         * @param mixed $value First matrix operand
         *
         * @return null|string
         */
        private function showTypeDetails($value)
        {
        }
        /**
         * @param string $formula
         *
         * @return false|string False indicates an error
         */
        private function convertMatrixReferences($formula)
        {
        }
        private static function mkMatrix(...$args)
        {
        }
        //    Binary Operators
        //    These operators always work on two values
        //    Array key is the operator, the value indicates whether this is a left or right associative operator
        private static $operatorAssociativity = [
            '^' => 0,
            //    Exponentiation
            '*' => 0,
            '/' => 0,
            //    Multiplication and Division
            '+' => 0,
            '-' => 0,
            //    Addition and Subtraction
            '&' => 0,
            //    Concatenation
            '|' => 0,
            ':' => 0,
            //    Intersect and Range
            '>' => 0,
            '<' => 0,
            '=' => 0,
            '>=' => 0,
            '<=' => 0,
            '<>' => 0,
        ];
        //    Comparison (Boolean) Operators
        //    These operators work on two values, but always return a boolean result
        private static $comparisonOperators = ['>' => true, '<' => true, '=' => true, '>=' => true, '<=' => true, '<>' => true];
        //    Operator Precedence
        //    This list includes all valid operators, whether binary (including boolean) or unary (such as %)
        //    Array key is the operator, the value is its precedence
        private static $operatorPrecedence = [
            ':' => 8,
            //    Range
            '|' => 7,
            //    Intersect
            '~' => 6,
            //    Negation
            '%' => 5,
            //    Percentage
            '^' => 4,
            //    Exponentiation
            '*' => 3,
            '/' => 3,
            //    Multiplication and Division
            '+' => 2,
            '-' => 2,
            //    Addition and Subtraction
            '&' => 1,
            //    Concatenation
            '>' => 0,
            '<' => 0,
            '=' => 0,
            '>=' => 0,
            '<=' => 0,
            '<>' => 0,
        ];
        // Convert infix to postfix notation
        /**
         * @param string $formula
         *
         * @return bool
         */
        private function _parseFormula($formula, ?\PhpOffice\PhpSpreadsheet\Cell\Cell $pCell = null)
        {
        }
        private static function dataTestReference(&$operandData)
        {
        }
        // evaluate postfix notation
        /**
         * @param mixed $tokens
         * @param null|string $cellID
         *
         * @return bool
         */
        private function processTokenStack($tokens, $cellID = null, ?\PhpOffice\PhpSpreadsheet\Cell\Cell $pCell = null)
        {
        }
        private function validateBinaryOperand(&$operand, &$stack)
        {
        }
        /**
         * @param null|string $cellID
         * @param mixed $operand1
         * @param mixed $operand2
         * @param string $operation
         * @param bool $recursingArrays
         *
         * @return mixed
         */
        private function executeBinaryComparisonOperation($cellID, $operand1, $operand2, $operation, \PhpOffice\PhpSpreadsheet\Calculation\Token\Stack &$stack, $recursingArrays = false)
        {
        }
        /**
         * Compare two strings in the same way as strcmp() except that lowercase come before uppercase letters.
         *
         * @param string $str1 First string value for the comparison
         * @param string $str2 Second string value for the comparison
         *
         * @return int
         */
        private function strcmpLowercaseFirst($str1, $str2)
        {
        }
        /**
         * @param mixed $operand1
         * @param mixed $operand2
         * @param mixed $operation
         * @param string $matrixFunction
         * @param mixed $stack
         *
         * @return bool|mixed
         */
        private function executeNumericBinaryOperation($operand1, $operand2, $operation, $matrixFunction, &$stack)
        {
        }
        // trigger an error, but nicely, if need be
        protected function raiseFormulaError($errorMessage)
        {
        }
        /**
         * Extract range values.
         *
         * @param string &$pRange String based range representation
         * @param Worksheet $pSheet Worksheet
         * @param bool $resetLog Flag indicating whether calculation log should be reset or not
         *
         * @return mixed Array of values in range if range contains more than one element. Otherwise, a single value is returned.
         */
        public function extractCellRange(&$pRange = 'A1', ?\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet = null, $resetLog = true)
        {
        }
        /**
         * Extract range values.
         *
         * @param string &$pRange String based range representation
         * @param Worksheet $pSheet Worksheet
         * @param bool $resetLog Flag indicating whether calculation log should be reset or not
         *
         * @return mixed Array of values in range if range contains more than one element. Otherwise, a single value is returned.
         */
        public function extractNamedRange(&$pRange = 'A1', ?\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet = null, $resetLog = true)
        {
        }
        /**
         * Is a specific function implemented?
         *
         * @param string $pFunction Function Name
         *
         * @return bool
         */
        public function isImplemented($pFunction)
        {
        }
        /**
         * Get a list of all implemented functions as an array of function objects.
         *
         * @return array of Category
         */
        public function getFunctions()
        {
        }
        /**
         * Get a list of implemented Excel function names.
         *
         * @return array
         */
        public function getImplementedFunctionNames()
        {
        }
        /**
         * Add cell reference if needed while making sure that it is the last argument.
         *
         * @param bool $passCellReference
         * @param array|string $functionCall
         *
         * @return array
         */
        private function addCellReference(array $args, $passCellReference, $functionCall, ?\PhpOffice\PhpSpreadsheet\Cell\Cell $pCell = null)
        {
        }
        private function getUnusedBranchStoreKey()
        {
        }
        private function getTokensAsString($tokens)
        {
        }
    }
    class Exception extends \PhpOffice\PhpSpreadsheet\Exception
    {
        /**
         * Error handler callback.
         *
         * @param mixed $code
         * @param mixed $string
         * @param mixed $file
         * @param mixed $line
         * @param mixed $context
         */
        public static function errorHandlerCallback($code, $string, $file, $line, $context) : void
        {
        }
    }
    /**
     * PARTLY BASED ON:
     * Copyright (c) 2007 E. W. Bachtal, Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software
     * and associated documentation files (the "Software"), to deal in the Software without restriction,
     * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
     * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
     * subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial
     * portions of the Software.
     *
     * The software is provided "as is", without warranty of any kind, express or implied, including but not
     * limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In
     * no event shall the authors or copyright holders be liable for any claim, damages or other liability,
     * whether in an action of contract, tort or otherwise, arising from, out of or in connection with the
     * software or the use or other dealings in the software.
     *
     * https://ewbi.blogs.com/develops/2007/03/excel_formula_p.html
     * https://ewbi.blogs.com/develops/2004/12/excel_formula_p.html
     */
    class FormulaToken
    {
        // Token types
        const TOKEN_TYPE_NOOP = 'Noop';
        const TOKEN_TYPE_OPERAND = 'Operand';
        const TOKEN_TYPE_FUNCTION = 'Function';
        const TOKEN_TYPE_SUBEXPRESSION = 'Subexpression';
        const TOKEN_TYPE_ARGUMENT = 'Argument';
        const TOKEN_TYPE_OPERATORPREFIX = 'OperatorPrefix';
        const TOKEN_TYPE_OPERATORINFIX = 'OperatorInfix';
        const TOKEN_TYPE_OPERATORPOSTFIX = 'OperatorPostfix';
        const TOKEN_TYPE_WHITESPACE = 'Whitespace';
        const TOKEN_TYPE_UNKNOWN = 'Unknown';
        // Token subtypes
        const TOKEN_SUBTYPE_NOTHING = 'Nothing';
        const TOKEN_SUBTYPE_START = 'Start';
        const TOKEN_SUBTYPE_STOP = 'Stop';
        const TOKEN_SUBTYPE_TEXT = 'Text';
        const TOKEN_SUBTYPE_NUMBER = 'Number';
        const TOKEN_SUBTYPE_LOGICAL = 'Logical';
        const TOKEN_SUBTYPE_ERROR = 'Error';
        const TOKEN_SUBTYPE_RANGE = 'Range';
        const TOKEN_SUBTYPE_MATH = 'Math';
        const TOKEN_SUBTYPE_CONCATENATION = 'Concatenation';
        const TOKEN_SUBTYPE_INTERSECTION = 'Intersection';
        const TOKEN_SUBTYPE_UNION = 'Union';
        /**
         * Value.
         *
         * @var string
         */
        private $value;
        /**
         * Token Type (represented by TOKEN_TYPE_*).
         *
         * @var string
         */
        private $tokenType;
        /**
         * Token SubType (represented by TOKEN_SUBTYPE_*).
         *
         * @var string
         */
        private $tokenSubType;
        /**
         * Create a new FormulaToken.
         *
         * @param string $pValue
         * @param string $pTokenType Token type (represented by TOKEN_TYPE_*)
         * @param string $pTokenSubType Token Subtype (represented by TOKEN_SUBTYPE_*)
         */
        public function __construct($pValue, $pTokenType = self::TOKEN_TYPE_UNKNOWN, $pTokenSubType = self::TOKEN_SUBTYPE_NOTHING)
        {
        }
        /**
         * Get Value.
         *
         * @return string
         */
        public function getValue()
        {
        }
        /**
         * Set Value.
         *
         * @param string $value
         */
        public function setValue($value) : void
        {
        }
        /**
         * Get Token Type (represented by TOKEN_TYPE_*).
         *
         * @return string
         */
        public function getTokenType()
        {
        }
        /**
         * Set Token Type (represented by TOKEN_TYPE_*).
         *
         * @param string $value
         */
        public function setTokenType($value) : void
        {
        }
        /**
         * Get Token SubType (represented by TOKEN_SUBTYPE_*).
         *
         * @return string
         */
        public function getTokenSubType()
        {
        }
        /**
         * Set Token SubType (represented by TOKEN_SUBTYPE_*).
         *
         * @param string $value
         */
        public function setTokenSubType($value) : void
        {
        }
    }
    abstract class Category
    {
        // Function categories
        const CATEGORY_CUBE = 'Cube';
        const CATEGORY_DATABASE = 'Database';
        const CATEGORY_DATE_AND_TIME = 'Date and Time';
        const CATEGORY_ENGINEERING = 'Engineering';
        const CATEGORY_FINANCIAL = 'Financial';
        const CATEGORY_INFORMATION = 'Information';
        const CATEGORY_LOGICAL = 'Logical';
        const CATEGORY_LOOKUP_AND_REFERENCE = 'Lookup and Reference';
        const CATEGORY_MATH_AND_TRIG = 'Math and Trig';
        const CATEGORY_STATISTICAL = 'Statistical';
        const CATEGORY_TEXT_AND_DATA = 'Text and Data';
    }
    class Financial
    {
        const FINANCIAL_MAX_ITERATIONS = 128;
        const FINANCIAL_PRECISION = 1.0E-8;
        /**
         * isLastDayOfMonth.
         *
         * Returns a boolean TRUE/FALSE indicating if this date is the last date of the month
         *
         * @param \DateTime $testDate The date for testing
         *
         * @return bool
         */
        private static function isLastDayOfMonth(\DateTime $testDate)
        {
        }
        private static function couponFirstPeriodDate($settlement, $maturity, $frequency, $next)
        {
        }
        private static function isValidFrequency($frequency)
        {
        }
        /**
         * daysPerYear.
         *
         * Returns the number of days in a specified year, as defined by the "basis" value
         *
         * @param int|string $year The year against which we're testing
         * @param int|string $basis The type of day count:
         *                                    0 or omitted US (NASD)    360
         *                                    1                        Actual (365 or 366 in a leap year)
         *                                    2                        360
         *                                    3                        365
         *                                    4                        European 360
         *
         * @return int|string Result, or a string containing an error
         */
        private static function daysPerYear($year, $basis = 0)
        {
        }
        private static function interestAndPrincipal($rate = 0, $per = 0, $nper = 0, $pv = 0, $fv = 0, $type = 0)
        {
        }
        /**
         * ACCRINT.
         *
         * Returns the accrued interest for a security that pays periodic interest.
         *
         * Excel Function:
         *        ACCRINT(issue,firstinterest,settlement,rate,par,frequency[,basis])
         *
         * @param mixed $issue the security's issue date
         * @param mixed $firstinterest the security's first interest date
         * @param mixed $settlement The security's settlement date.
         *                                    The security settlement date is the date after the issue date
         *                                    when the security is traded to the buyer.
         * @param float $rate the security's annual coupon rate
         * @param float $par The security's par value.
         *                                    If you omit par, ACCRINT uses $1,000.
         * @param int $frequency the number of coupon payments per year.
         *                                    Valid frequency values are:
         *                                        1    Annual
         *                                        2    Semi-Annual
         *                                        4    Quarterly
         * @param int $basis The type of day count to use.
         *                                        0 or omitted    US (NASD) 30/360
         *                                        1                Actual/actual
         *                                        2                Actual/360
         *                                        3                Actual/365
         *                                        4                European 30/360
         *
         * @return float|string Result, or a string containing an error
         */
        public static function ACCRINT($issue, $firstinterest, $settlement, $rate, $par = 1000, $frequency = 1, $basis = 0)
        {
        }
        /**
         * ACCRINTM.
         *
         * Returns the accrued interest for a security that pays interest at maturity.
         *
         * Excel Function:
         *        ACCRINTM(issue,settlement,rate[,par[,basis]])
         *
         * @param mixed $issue The security's issue date
         * @param mixed $settlement The security's settlement (or maturity) date
         * @param float $rate The security's annual coupon rate
         * @param float $par The security's par value.
         *                                    If you omit par, ACCRINT uses $1,000.
         * @param int $basis The type of day count to use.
         *                                        0 or omitted    US (NASD) 30/360
         *                                        1                Actual/actual
         *                                        2                Actual/360
         *                                        3                Actual/365
         *                                        4                European 30/360
         *
         * @return float|string Result, or a string containing an error
         */
        public static function ACCRINTM($issue, $settlement, $rate, $par = 1000, $basis = 0)
        {
        }
        /**
         * AMORDEGRC.
         *
         * Returns the depreciation for each accounting period.
         * This function is provided for the French accounting system. If an asset is purchased in
         * the middle of the accounting period, the prorated depreciation is taken into account.
         * The function is similar to AMORLINC, except that a depreciation coefficient is applied in
         * the calculation depending on the life of the assets.
         * This function will return the depreciation until the last period of the life of the assets
         * or until the cumulated value of depreciation is greater than the cost of the assets minus
         * the salvage value.
         *
         * Excel Function:
         *        AMORDEGRC(cost,purchased,firstPeriod,salvage,period,rate[,basis])
         *
         * @param float $cost The cost of the asset
         * @param mixed $purchased Date of the purchase of the asset
         * @param mixed $firstPeriod Date of the end of the first period
         * @param mixed $salvage The salvage value at the end of the life of the asset
         * @param float $period The period
         * @param float $rate Rate of depreciation
         * @param int $basis The type of day count to use.
         *                                        0 or omitted    US (NASD) 30/360
         *                                        1                Actual/actual
         *                                        2                Actual/360
         *                                        3                Actual/365
         *                                        4                European 30/360
         *
         * @return float
         */
        public static function AMORDEGRC($cost, $purchased, $firstPeriod, $salvage, $period, $rate, $basis = 0)
        {
        }
        /**
         * AMORLINC.
         *
         * Returns the depreciation for each accounting period.
         * This function is provided for the French accounting system. If an asset is purchased in
         * the middle of the accounting period, the prorated depreciation is taken into account.
         *
         * Excel Function:
         *        AMORLINC(cost,purchased,firstPeriod,salvage,period,rate[,basis])
         *
         * @param float $cost The cost of the asset
         * @param mixed $purchased Date of the purchase of the asset
         * @param mixed $firstPeriod Date of the end of the first period
         * @param mixed $salvage The salvage value at the end of the life of the asset
         * @param float $period The period
         * @param float $rate Rate of depreciation
         * @param int $basis The type of day count to use.
         *                                        0 or omitted    US (NASD) 30/360
         *                                        1                Actual/actual
         *                                        2                Actual/360
         *                                        3                Actual/365
         *                                        4                European 30/360
         *
         * @return float
         */
        public static function AMORLINC($cost, $purchased, $firstPeriod, $salvage, $period, $rate, $basis = 0)
        {
        }
        /**
         * COUPDAYBS.
         *
         * Returns the number of days from the beginning of the coupon period to the settlement date.
         *
         * Excel Function:
         *        COUPDAYBS(settlement,maturity,frequency[,basis])
         *
         * @param mixed $settlement The security's settlement date.
         *                                The security settlement date is the date after the issue
         *                                date when the security is traded to the buyer.
         * @param mixed $maturity The security's maturity date.
         *                                The maturity date is the date when the security expires.
         * @param int $frequency the number of coupon payments per year.
         *                                    Valid frequency values are:
         *                                        1    Annual
         *                                        2    Semi-Annual
         *                                        4    Quarterly
         * @param int $basis The type of day count to use.
         *                                        0 or omitted    US (NASD) 30/360
         *                                        1                Actual/actual
         *                                        2                Actual/360
         *                                        3                Actual/365
         *                                        4                European 30/360
         *
         * @return float|string
         */
        public static function COUPDAYBS($settlement, $maturity, $frequency, $basis = 0)
        {
        }
        /**
         * COUPDAYS.
         *
         * Returns the number of days in the coupon period that contains the settlement date.
         *
         * Excel Function:
         *        COUPDAYS(settlement,maturity,frequency[,basis])
         *
         * @param mixed $settlement The security's settlement date.
         *                                The security settlement date is the date after the issue
         *                                date when the security is traded to the buyer.
         * @param mixed $maturity The security's maturity date.
         *                                The maturity date is the date when the security expires.
         * @param mixed $frequency the number of coupon payments per year.
         *                                    Valid frequency values are:
         *                                        1    Annual
         *                                        2    Semi-Annual
         *                                        4    Quarterly
         * @param int $basis The type of day count to use.
         *                                        0 or omitted    US (NASD) 30/360
         *                                        1                Actual/actual
         *                                        2                Actual/360
         *                                        3                Actual/365
         *                                        4                European 30/360
         *
         * @return float|string
         */
        public static function COUPDAYS($settlement, $maturity, $frequency, $basis = 0)
        {
        }
        /**
         * COUPDAYSNC.
         *
         * Returns the number of days from the settlement date to the next coupon date.
         *
         * Excel Function:
         *        COUPDAYSNC(settlement,maturity,frequency[,basis])
         *
         * @param mixed $settlement The security's settlement date.
         *                                The security settlement date is the date after the issue
         *                                date when the security is traded to the buyer.
         * @param mixed $maturity The security's maturity date.
         *                                The maturity date is the date when the security expires.
         * @param mixed $frequency the number of coupon payments per year.
         *                                    Valid frequency values are:
         *                                        1    Annual
         *                                        2    Semi-Annual
         *                                        4    Quarterly
         * @param int $basis The type of day count to use.
         *                                        0 or omitted    US (NASD) 30/360
         *                                        1                Actual/actual
         *                                        2                Actual/360
         *                                        3                Actual/365
         *                                        4                European 30/360
         *
         * @return float|string
         */
        public static function COUPDAYSNC($settlement, $maturity, $frequency, $basis = 0)
        {
        }
        /**
         * COUPNCD.
         *
         * Returns the next coupon date after the settlement date.
         *
         * Excel Function:
         *        COUPNCD(settlement,maturity,frequency[,basis])
         *
         * @param mixed $settlement The security's settlement date.
         *                                The security settlement date is the date after the issue
         *                                date when the security is traded to the buyer.
         * @param mixed $maturity The security's maturity date.
         *                                The maturity date is the date when the security expires.
         * @param mixed $frequency the number of coupon payments per year.
         *                                    Valid frequency values are:
         *                                        1    Annual
         *                                        2    Semi-Annual
         *                                        4    Quarterly
         * @param int $basis The type of day count to use.
         *                                        0 or omitted    US (NASD) 30/360
         *                                        1                Actual/actual
         *                                        2                Actual/360
         *                                        3                Actual/365
         *                                        4                European 30/360
         *
         * @return mixed Excel date/time serial value, PHP date/time serial value or PHP date/time object,
         *                        depending on the value of the ReturnDateType flag
         */
        public static function COUPNCD($settlement, $maturity, $frequency, $basis = 0)
        {
        }
        /**
         * COUPNUM.
         *
         * Returns the number of coupons payable between the settlement date and maturity date,
         * rounded up to the nearest whole coupon.
         *
         * Excel Function:
         *        COUPNUM(settlement,maturity,frequency[,basis])
         *
         * @param mixed $settlement The security's settlement date.
         *                                The security settlement date is the date after the issue
         *                                date when the security is traded to the buyer.
         * @param mixed $maturity The security's maturity date.
         *                                The maturity date is the date when the security expires.
         * @param mixed $frequency the number of coupon payments per year.
         *                                    Valid frequency values are:
         *                                        1    Annual
         *                                        2    Semi-Annual
         *                                        4    Quarterly
         * @param int $basis The type of day count to use.
         *                                        0 or omitted    US (NASD) 30/360
         *                                        1                Actual/actual
         *                                        2                Actual/360
         *                                        3                Actual/365
         *                                        4                European 30/360
         *
         * @return int|string
         */
        public static function COUPNUM($settlement, $maturity, $frequency, $basis = 0)
        {
        }
        /**
         * COUPPCD.
         *
         * Returns the previous coupon date before the settlement date.
         *
         * Excel Function:
         *        COUPPCD(settlement,maturity,frequency[,basis])
         *
         * @param mixed $settlement The security's settlement date.
         *                                The security settlement date is the date after the issue
         *                                date when the security is traded to the buyer.
         * @param mixed $maturity The security's maturity date.
         *                                The maturity date is the date when the security expires.
         * @param mixed $frequency the number of coupon payments per year.
         *                                    Valid frequency values are:
         *                                        1    Annual
         *                                        2    Semi-Annual
         *                                        4    Quarterly
         * @param int $basis The type of day count to use.
         *                                        0 or omitted    US (NASD) 30/360
         *                                        1                Actual/actual
         *                                        2                Actual/360
         *                                        3                Actual/365
         *                                        4                European 30/360
         *
         * @return mixed Excel date/time serial value, PHP date/time serial value or PHP date/time object,
         *                        depending on the value of the ReturnDateType flag
         */
        public static function COUPPCD($settlement, $maturity, $frequency, $basis = 0)
        {
        }
        /**
         * CUMIPMT.
         *
         * Returns the cumulative interest paid on a loan between the start and end periods.
         *
         * Excel Function:
         *        CUMIPMT(rate,nper,pv,start,end[,type])
         *
         * @param float $rate The Interest rate
         * @param int $nper The total number of payment periods
         * @param float $pv Present Value
         * @param int $start The first period in the calculation.
         *                            Payment periods are numbered beginning with 1.
         * @param int $end the last period in the calculation
         * @param int $type A number 0 or 1 and indicates when payments are due:
         *                                0 or omitted    At the end of the period.
         *                                1                At the beginning of the period.
         *
         * @return float|string
         */
        public static function CUMIPMT($rate, $nper, $pv, $start, $end, $type = 0)
        {
        }
        /**
         * CUMPRINC.
         *
         * Returns the cumulative principal paid on a loan between the start and end periods.
         *
         * Excel Function:
         *        CUMPRINC(rate,nper,pv,start,end[,type])
         *
         * @param float $rate The Interest rate
         * @param int $nper The total number of payment periods
         * @param float $pv Present Value
         * @param int $start The first period in the calculation.
         *                            Payment periods are numbered beginning with 1.
         * @param int $end the last period in the calculation
         * @param int $type A number 0 or 1 and indicates when payments are due:
         *                                0 or omitted    At the end of the period.
         *                                1                At the beginning of the period.
         *
         * @return float|string
         */
        public static function CUMPRINC($rate, $nper, $pv, $start, $end, $type = 0)
        {
        }
        /**
         * DB.
         *
         * Returns the depreciation of an asset for a specified period using the
         * fixed-declining balance method.
         * This form of depreciation is used if you want to get a higher depreciation value
         * at the beginning of the depreciation (as opposed to linear depreciation). The
         * depreciation value is reduced with every depreciation period by the depreciation
         * already deducted from the initial cost.
         *
         * Excel Function:
         *        DB(cost,salvage,life,period[,month])
         *
         * @param float $cost Initial cost of the asset
         * @param float $salvage Value at the end of the depreciation.
         *                                (Sometimes called the salvage value of the asset)
         * @param int $life Number of periods over which the asset is depreciated.
         *                                (Sometimes called the useful life of the asset)
         * @param int $period The period for which you want to calculate the
         *                                depreciation. Period must use the same units as life.
         * @param int $month Number of months in the first year. If month is omitted,
         *                                it defaults to 12.
         *
         * @return float|string
         */
        public static function DB($cost, $salvage, $life, $period, $month = 12)
        {
        }
        /**
         * DDB.
         *
         * Returns the depreciation of an asset for a specified period using the
         * double-declining balance method or some other method you specify.
         *
         * Excel Function:
         *        DDB(cost,salvage,life,period[,factor])
         *
         * @param float $cost Initial cost of the asset
         * @param float $salvage Value at the end of the depreciation.
         *                                (Sometimes called the salvage value of the asset)
         * @param int $life Number of periods over which the asset is depreciated.
         *                                (Sometimes called the useful life of the asset)
         * @param int $period The period for which you want to calculate the
         *                                depreciation. Period must use the same units as life.
         * @param float $factor The rate at which the balance declines.
         *                                If factor is omitted, it is assumed to be 2 (the
         *                                double-declining balance method).
         *
         * @return float|string
         */
        public static function DDB($cost, $salvage, $life, $period, $factor = 2.0)
        {
        }
        /**
         * DISC.
         *
         * Returns the discount rate for a security.
         *
         * Excel Function:
         *        DISC(settlement,maturity,price,redemption[,basis])
         *
         * @param mixed $settlement The security's settlement date.
         *                                The security settlement date is the date after the issue
         *                                date when the security is traded to the buyer.
         * @param mixed $maturity The security's maturity date.
         *                                The maturity date is the date when the security expires.
         * @param int $price The security's price per $100 face value
         * @param int $redemption The security's redemption value per $100 face value
         * @param int $basis The type of day count to use.
         *                                        0 or omitted    US (NASD) 30/360
         *                                        1                Actual/actual
         *                                        2                Actual/360
         *                                        3                Actual/365
         *                                        4                European 30/360
         *
         * @return float|string
         */
        public static function DISC($settlement, $maturity, $price, $redemption, $basis = 0)
        {
        }
        /**
         * DOLLARDE.
         *
         * Converts a dollar price expressed as an integer part and a fraction
         *        part into a dollar price expressed as a decimal number.
         * Fractional dollar numbers are sometimes used for security prices.
         *
         * Excel Function:
         *        DOLLARDE(fractional_dollar,fraction)
         *
         * @param float $fractional_dollar Fractional Dollar
         * @param int $fraction Fraction
         *
         * @return float|string
         */
        public static function DOLLARDE($fractional_dollar = null, $fraction = 0)
        {
        }
        /**
         * DOLLARFR.
         *
         * Converts a dollar price expressed as a decimal number into a dollar price
         *        expressed as a fraction.
         * Fractional dollar numbers are sometimes used for security prices.
         *
         * Excel Function:
         *        DOLLARFR(decimal_dollar,fraction)
         *
         * @param float $decimal_dollar Decimal Dollar
         * @param int $fraction Fraction
         *
         * @return float|string
         */
        public static function DOLLARFR($decimal_dollar = null, $fraction = 0)
        {
        }
        /**
         * EFFECT.
         *
         * Returns the effective interest rate given the nominal rate and the number of
         *        compounding payments per year.
         *
         * Excel Function:
         *        EFFECT(nominal_rate,npery)
         *
         * @param float $nominal_rate Nominal interest rate
         * @param int $npery Number of compounding payments per year
         *
         * @return float|string
         */
        public static function EFFECT($nominal_rate = 0, $npery = 0)
        {
        }
        /**
         * FV.
         *
         * Returns the Future Value of a cash flow with constant payments and interest rate (annuities).
         *
         * Excel Function:
         *        FV(rate,nper,pmt[,pv[,type]])
         *
         * @param float $rate The interest rate per period
         * @param int $nper Total number of payment periods in an annuity
         * @param float $pmt The payment made each period: it cannot change over the
         *                            life of the annuity. Typically, pmt contains principal
         *                            and interest but no other fees or taxes.
         * @param float $pv present Value, or the lump-sum amount that a series of
         *                            future payments is worth right now
         * @param int $type A number 0 or 1 and indicates when payments are due:
         *                                0 or omitted    At the end of the period.
         *                                1                At the beginning of the period.
         *
         * @return float|string
         */
        public static function FV($rate = 0, $nper = 0, $pmt = 0, $pv = 0, $type = 0)
        {
        }
        /**
         * FVSCHEDULE.
         *
         * Returns the future value of an initial principal after applying a series of compound interest rates.
         * Use FVSCHEDULE to calculate the future value of an investment with a variable or adjustable rate.
         *
         * Excel Function:
         *        FVSCHEDULE(principal,schedule)
         *
         * @param float $principal the present value
         * @param float[] $schedule an array of interest rates to apply
         *
         * @return float
         */
        public static function FVSCHEDULE($principal, $schedule)
        {
        }
        /**
         * INTRATE.
         *
         * Returns the interest rate for a fully invested security.
         *
         * Excel Function:
         *        INTRATE(settlement,maturity,investment,redemption[,basis])
         *
         * @param mixed $settlement The security's settlement date.
         *                                The security settlement date is the date after the issue date when the security is traded to the buyer.
         * @param mixed $maturity The security's maturity date.
         *                                The maturity date is the date when the security expires.
         * @param int $investment the amount invested in the security
         * @param int $redemption the amount to be received at maturity
         * @param int $basis The type of day count to use.
         *                                        0 or omitted    US (NASD) 30/360
         *                                        1                Actual/actual
         *                                        2                Actual/360
         *                                        3                Actual/365
         *                                        4                European 30/360
         *
         * @return float|string
         */
        public static function INTRATE($settlement, $maturity, $investment, $redemption, $basis = 0)
        {
        }
        /**
         * IPMT.
         *
         * Returns the interest payment for a given period for an investment based on periodic, constant payments and a constant interest rate.
         *
         * Excel Function:
         *        IPMT(rate,per,nper,pv[,fv][,type])
         *
         * @param float $rate Interest rate per period
         * @param int $per Period for which we want to find the interest
         * @param int $nper Number of periods
         * @param float $pv Present Value
         * @param float $fv Future Value
         * @param int $type Payment type: 0 = at the end of each period, 1 = at the beginning of each period
         *
         * @return float|string
         */
        public static function IPMT($rate, $per, $nper, $pv, $fv = 0, $type = 0)
        {
        }
        /**
         * IRR.
         *
         * Returns the internal rate of return for a series of cash flows represented by the numbers in values.
         * These cash flows do not have to be even, as they would be for an annuity. However, the cash flows must occur
         * at regular intervals, such as monthly or annually. The internal rate of return is the interest rate received
         * for an investment consisting of payments (negative values) and income (positive values) that occur at regular
         * periods.
         *
         * Excel Function:
         *        IRR(values[,guess])
         *
         * @param float[] $values An array or a reference to cells that contain numbers for which you want
         *                                    to calculate the internal rate of return.
         *                                Values must contain at least one positive value and one negative value to
         *                                    calculate the internal rate of return.
         * @param float $guess A number that you guess is close to the result of IRR
         *
         * @return float|string
         */
        public static function IRR($values, $guess = 0.1)
        {
        }
        /**
         * ISPMT.
         *
         * Returns the interest payment for an investment based on an interest rate and a constant payment schedule.
         *
         * Excel Function:
         *     =ISPMT(interest_rate, period, number_payments, PV)
         *
         * interest_rate is the interest rate for the investment
         *
         * period is the period to calculate the interest rate.  It must be betweeen 1 and number_payments.
         *
         * number_payments is the number of payments for the annuity
         *
         * PV is the loan amount or present value of the payments
         */
        public static function ISPMT(...$args)
        {
        }
        /**
         * MIRR.
         *
         * Returns the modified internal rate of return for a series of periodic cash flows. MIRR considers both
         *        the cost of the investment and the interest received on reinvestment of cash.
         *
         * Excel Function:
         *        MIRR(values,finance_rate, reinvestment_rate)
         *
         * @param float[] $values An array or a reference to cells that contain a series of payments and
         *                                            income occurring at regular intervals.
         *                                        Payments are negative value, income is positive values.
         * @param float $finance_rate The interest rate you pay on the money used in the cash flows
         * @param float $reinvestment_rate The interest rate you receive on the cash flows as you reinvest them
         *
         * @return float|string Result, or a string containing an error
         */
        public static function MIRR($values, $finance_rate, $reinvestment_rate)
        {
        }
        /**
         * NOMINAL.
         *
         * Returns the nominal interest rate given the effective rate and the number of compounding payments per year.
         *
         * @param float $effect_rate Effective interest rate
         * @param int $npery Number of compounding payments per year
         *
         * @return float|string Result, or a string containing an error
         */
        public static function NOMINAL($effect_rate = 0, $npery = 0)
        {
        }
        /**
         * NPER.
         *
         * Returns the number of periods for a cash flow with constant periodic payments (annuities), and interest rate.
         *
         * @param float $rate Interest rate per period
         * @param int $pmt Periodic payment (annuity)
         * @param float $pv Present Value
         * @param float $fv Future Value
         * @param int $type Payment type: 0 = at the end of each period, 1 = at the beginning of each period
         *
         * @return float|string Result, or a string containing an error
         */
        public static function NPER($rate = 0, $pmt = 0, $pv = 0, $fv = 0, $type = 0)
        {
        }
        /**
         * NPV.
         *
         * Returns the Net Present Value of a cash flow series given a discount rate.
         *
         * @return float
         */
        public static function NPV(...$args)
        {
        }
        /**
         * PDURATION.
         *
         * Calculates the number of periods required for an investment to reach a specified value.
         *
         * @param float $rate Interest rate per period
         * @param float $pv Present Value
         * @param float $fv Future Value
         *
         * @return float|string Result, or a string containing an error
         */
        public static function PDURATION($rate = 0, $pv = 0, $fv = 0)
        {
        }
        /**
         * PMT.
         *
         * Returns the constant payment (annuity) for a cash flow with a constant interest rate.
         *
         * @param float $rate Interest rate per period
         * @param int $nper Number of periods
         * @param float $pv Present Value
         * @param float $fv Future Value
         * @param int $type Payment type: 0 = at the end of each period, 1 = at the beginning of each period
         *
         * @return float|string Result, or a string containing an error
         */
        public static function PMT($rate = 0, $nper = 0, $pv = 0, $fv = 0, $type = 0)
        {
        }
        /**
         * PPMT.
         *
         * Returns the interest payment for a given period for an investment based on periodic, constant payments and a constant interest rate.
         *
         * @param float $rate Interest rate per period
         * @param int $per Period for which we want to find the interest
         * @param int $nper Number of periods
         * @param float $pv Present Value
         * @param float $fv Future Value
         * @param int $type Payment type: 0 = at the end of each period, 1 = at the beginning of each period
         *
         * @return float|string Result, or a string containing an error
         */
        public static function PPMT($rate, $per, $nper, $pv, $fv = 0, $type = 0)
        {
        }
        private static function validatePrice($settlement, $maturity, $rate, $yield, $redemption, $frequency, $basis)
        {
        }
        public static function PRICE($settlement, $maturity, $rate, $yield, $redemption, $frequency, $basis = 0)
        {
        }
        /**
         * PRICEDISC.
         *
         * Returns the price per $100 face value of a discounted security.
         *
         * @param mixed $settlement The security's settlement date.
         *                                The security settlement date is the date after the issue date when the security is traded to the buyer.
         * @param mixed $maturity The security's maturity date.
         *                                The maturity date is the date when the security expires.
         * @param int $discount The security's discount rate
         * @param int $redemption The security's redemption value per $100 face value
         * @param int $basis The type of day count to use.
         *                                        0 or omitted    US (NASD) 30/360
         *                                        1                Actual/actual
         *                                        2                Actual/360
         *                                        3                Actual/365
         *                                        4                European 30/360
         *
         * @return float|string Result, or a string containing an error
         */
        public static function PRICEDISC($settlement, $maturity, $discount, $redemption, $basis = 0)
        {
        }
        /**
         * PRICEMAT.
         *
         * Returns the price per $100 face value of a security that pays interest at maturity.
         *
         * @param mixed $settlement The security's settlement date.
         *                                The security's settlement date is the date after the issue date when the security is traded to the buyer.
         * @param mixed $maturity The security's maturity date.
         *                                The maturity date is the date when the security expires.
         * @param mixed $issue The security's issue date
         * @param int $rate The security's interest rate at date of issue
         * @param int $yield The security's annual yield
         * @param int $basis The type of day count to use.
         *                                        0 or omitted    US (NASD) 30/360
         *                                        1                Actual/actual
         *                                        2                Actual/360
         *                                        3                Actual/365
         *                                        4                European 30/360
         *
         * @return float|string Result, or a string containing an error
         */
        public static function PRICEMAT($settlement, $maturity, $issue, $rate, $yield, $basis = 0)
        {
        }
        /**
         * PV.
         *
         * Returns the Present Value of a cash flow with constant payments and interest rate (annuities).
         *
         * @param float $rate Interest rate per period
         * @param int $nper Number of periods
         * @param float $pmt Periodic payment (annuity)
         * @param float $fv Future Value
         * @param int $type Payment type: 0 = at the end of each period, 1 = at the beginning of each period
         *
         * @return float|string Result, or a string containing an error
         */
        public static function PV($rate = 0, $nper = 0, $pmt = 0, $fv = 0, $type = 0)
        {
        }
        /**
         * RATE.
         *
         * Returns the interest rate per period of an annuity.
         * RATE is calculated by iteration and can have zero or more solutions.
         * If the successive results of RATE do not converge to within 0.0000001 after 20 iterations,
         * RATE returns the #NUM! error value.
         *
         * Excel Function:
         *        RATE(nper,pmt,pv[,fv[,type[,guess]]])
         *
         * @param float $nper The total number of payment periods in an annuity
         * @param float $pmt The payment made each period and cannot change over the life
         *                                    of the annuity.
         *                                Typically, pmt includes principal and interest but no other
         *                                    fees or taxes.
         * @param float $pv The present value - the total amount that a series of future
         *                                    payments is worth now
         * @param float $fv The future value, or a cash balance you want to attain after
         *                                    the last payment is made. If fv is omitted, it is assumed
         *                                    to be 0 (the future value of a loan, for example, is 0).
         * @param int $type A number 0 or 1 and indicates when payments are due:
         *                                        0 or omitted    At the end of the period.
         *                                        1                At the beginning of the period.
         * @param float $guess Your guess for what the rate will be.
         *                                    If you omit guess, it is assumed to be 10 percent.
         *
         * @return float|string
         */
        public static function RATE($nper, $pmt, $pv, $fv = 0.0, $type = 0, $guess = 0.1)
        {
        }
        private static function rateNextGuess($rate, $nper, $pmt, $pv, $fv, $type)
        {
        }
        /**
         * RECEIVED.
         *
         * Returns the price per $100 face value of a discounted security.
         *
         * @param mixed $settlement The security's settlement date.
         *                                The security settlement date is the date after the issue date when the security is traded to the buyer.
         * @param mixed $maturity The security's maturity date.
         *                                The maturity date is the date when the security expires.
         * @param int $investment The amount invested in the security
         * @param int $discount The security's discount rate
         * @param int $basis The type of day count to use.
         *                                        0 or omitted    US (NASD) 30/360
         *                                        1                Actual/actual
         *                                        2                Actual/360
         *                                        3                Actual/365
         *                                        4                European 30/360
         *
         * @return float|string Result, or a string containing an error
         */
        public static function RECEIVED($settlement, $maturity, $investment, $discount, $basis = 0)
        {
        }
        /**
         * RRI.
         *
         * Calculates the interest rate required for an investment to grow to a specified future value .
         *
         * @param float $nper The number of periods over which the investment is made
         * @param float $pv Present Value
         * @param float $fv Future Value
         *
         * @return float|string Result, or a string containing an error
         */
        public static function RRI($nper = 0, $pv = 0, $fv = 0)
        {
        }
        /**
         * SLN.
         *
         * Returns the straight-line depreciation of an asset for one period
         *
         * @param mixed $cost Initial cost of the asset
         * @param mixed $salvage Value at the end of the depreciation
         * @param mixed $life Number of periods over which the asset is depreciated
         *
         * @return float|string Result, or a string containing an error
         */
        public static function SLN($cost, $salvage, $life)
        {
        }
        /**
         * SYD.
         *
         * Returns the sum-of-years' digits depreciation of an asset for a specified period.
         *
         * @param mixed $cost Initial cost of the asset
         * @param mixed $salvage Value at the end of the depreciation
         * @param mixed $life Number of periods over which the asset is depreciated
         * @param mixed $period Period
         *
         * @return float|string Result, or a string containing an error
         */
        public static function SYD($cost, $salvage, $life, $period)
        {
        }
        /**
         * TBILLEQ.
         *
         * Returns the bond-equivalent yield for a Treasury bill.
         *
         * @param mixed $settlement The Treasury bill's settlement date.
         *                                The Treasury bill's settlement date is the date after the issue date when the Treasury bill is traded to the buyer.
         * @param mixed $maturity The Treasury bill's maturity date.
         *                                The maturity date is the date when the Treasury bill expires.
         * @param int $discount The Treasury bill's discount rate
         *
         * @return float|string Result, or a string containing an error
         */
        public static function TBILLEQ($settlement, $maturity, $discount)
        {
        }
        /**
         * TBILLPRICE.
         *
         * Returns the yield for a Treasury bill.
         *
         * @param mixed $settlement The Treasury bill's settlement date.
         *                                The Treasury bill's settlement date is the date after the issue date when the Treasury bill is traded to the buyer.
         * @param mixed $maturity The Treasury bill's maturity date.
         *                                The maturity date is the date when the Treasury bill expires.
         * @param int $discount The Treasury bill's discount rate
         *
         * @return float|string Result, or a string containing an error
         */
        public static function TBILLPRICE($settlement, $maturity, $discount)
        {
        }
        /**
         * TBILLYIELD.
         *
         * Returns the yield for a Treasury bill.
         *
         * @param mixed $settlement The Treasury bill's settlement date.
         *                                The Treasury bill's settlement date is the date after the issue date when the Treasury bill is traded to the buyer.
         * @param mixed $maturity The Treasury bill's maturity date.
         *                                The maturity date is the date when the Treasury bill expires.
         * @param int $price The Treasury bill's price per $100 face value
         *
         * @return float|mixed|string
         */
        public static function TBILLYIELD($settlement, $maturity, $price)
        {
        }
        private static function bothNegAndPos($neg, $pos)
        {
        }
        private static function xirrPart2(&$values)
        {
        }
        private static function xirrPart1(&$values, &$dates)
        {
        }
        private static function xirrPart3($values, $dates, $x1, $x2)
        {
        }
        /**
         * XIRR.
         *
         * Returns the internal rate of return for a schedule of cash flows that is not necessarily periodic.
         *
         * Excel Function:
         *        =XIRR(values,dates,guess)
         *
         * @param float[] $values     A series of cash flow payments
         *                                The series of values must contain at least one positive value & one negative value
         * @param mixed[] $dates      A series of payment dates
         *                                The first payment date indicates the beginning of the schedule of payments
         *                                All other dates must be later than this date, but they may occur in any order
         * @param float $guess        An optional guess at the expected answer
         *
         * @return float|mixed|string
         */
        public static function XIRR($values, $dates, $guess = 0.1)
        {
        }
        /**
         * XNPV.
         *
         * Returns the net present value for a schedule of cash flows that is not necessarily periodic.
         * To calculate the net present value for a series of cash flows that is periodic, use the NPV function.
         *
         * Excel Function:
         *        =XNPV(rate,values,dates)
         *
         * @param float $rate the discount rate to apply to the cash flows
         * @param float[] $values     A series of cash flows that corresponds to a schedule of payments in dates.
         *                                         The first payment is optional and corresponds to a cost or payment that occurs at the beginning of the investment.
         *                                         If the first value is a cost or payment, it must be a negative value. All succeeding payments are discounted based on a 365-day year.
         *                                         The series of values must contain at least one positive value and one negative value.
         * @param mixed[] $dates      A schedule of payment dates that corresponds to the cash flow payments.
         *                                         The first payment date indicates the beginning of the schedule of payments.
         *                                         All other dates must be later than this date, but they may occur in any order.
         *
         * @return float|mixed|string
         */
        public static function XNPV($rate, $values, $dates)
        {
        }
        private static function validateXnpv($rate, $values, $dates)
        {
        }
        private static function xnpvOrdered($rate, $values, $dates, $ordered = true)
        {
        }
        /**
         * YIELDDISC.
         *
         * Returns the annual yield of a security that pays interest at maturity.
         *
         * @param mixed $settlement The security's settlement date.
         *                                    The security's settlement date is the date after the issue date when the security is traded to the buyer.
         * @param mixed $maturity The security's maturity date.
         *                                    The maturity date is the date when the security expires.
         * @param int $price The security's price per $100 face value
         * @param int $redemption The security's redemption value per $100 face value
         * @param int $basis The type of day count to use.
         *                                        0 or omitted    US (NASD) 30/360
         *                                        1                Actual/actual
         *                                        2                Actual/360
         *                                        3                Actual/365
         *                                        4                European 30/360
         *
         * @return float|string Result, or a string containing an error
         */
        public static function YIELDDISC($settlement, $maturity, $price, $redemption, $basis = 0)
        {
        }
        /**
         * YIELDMAT.
         *
         * Returns the annual yield of a security that pays interest at maturity.
         *
         * @param mixed $settlement The security's settlement date.
         *                                   The security's settlement date is the date after the issue date when the security is traded to the buyer.
         * @param mixed $maturity The security's maturity date.
         *                                   The maturity date is the date when the security expires.
         * @param mixed $issue The security's issue date
         * @param int $rate The security's interest rate at date of issue
         * @param int $price The security's price per $100 face value
         * @param int $basis The type of day count to use.
         *                                        0 or omitted    US (NASD) 30/360
         *                                        1                Actual/actual
         *                                        2                Actual/360
         *                                        3                Actual/365
         *                                        4                European 30/360
         *
         * @return float|string Result, or a string containing an error
         */
        public static function YIELDMAT($settlement, $maturity, $issue, $rate, $price, $basis = 0)
        {
        }
    }
    class TextData
    {
        private static $invalidChars;
        private static function unicodeToOrd($character)
        {
        }
        /**
         * CHARACTER.
         *
         * @param string $character Value
         *
         * @return string
         */
        public static function CHARACTER($character)
        {
        }
        /**
         * TRIMNONPRINTABLE.
         *
         * @param mixed $stringValue Value to check
         *
         * @return string
         */
        public static function TRIMNONPRINTABLE($stringValue = '')
        {
        }
        /**
         * TRIMSPACES.
         *
         * @param mixed $stringValue Value to check
         *
         * @return string
         */
        public static function TRIMSPACES($stringValue = '')
        {
        }
        private static function convertBooleanValue($value)
        {
        }
        /**
         * ASCIICODE.
         *
         * @param string $characters Value
         *
         * @return int
         */
        public static function ASCIICODE($characters)
        {
        }
        /**
         * CONCATENATE.
         *
         * @return string
         */
        public static function CONCATENATE(...$args)
        {
        }
        /**
         * DOLLAR.
         *
         * This function converts a number to text using currency format, with the decimals rounded to the specified place.
         * The format used is $#,##0.00_);($#,##0.00)..
         *
         * @param float $value The value to format
         * @param int $decimals The number of digits to display to the right of the decimal point.
         *                                    If decimals is negative, number is rounded to the left of the decimal point.
         *                                    If you omit decimals, it is assumed to be 2
         *
         * @return string
         */
        public static function DOLLAR($value = 0, $decimals = 2)
        {
        }
        /**
         * SEARCHSENSITIVE.
         *
         * @param string $needle The string to look for
         * @param string $haystack The string in which to look
         * @param int $offset Offset within $haystack
         *
         * @return string
         */
        public static function SEARCHSENSITIVE($needle, $haystack, $offset = 1)
        {
        }
        /**
         * SEARCHINSENSITIVE.
         *
         * @param string $needle The string to look for
         * @param string $haystack The string in which to look
         * @param int $offset Offset within $haystack
         *
         * @return string
         */
        public static function SEARCHINSENSITIVE($needle, $haystack, $offset = 1)
        {
        }
        /**
         * FIXEDFORMAT.
         *
         * @param mixed $value Value to check
         * @param int $decimals
         * @param bool $no_commas
         *
         * @return string
         */
        public static function FIXEDFORMAT($value, $decimals = 2, $no_commas = false)
        {
        }
        /**
         * LEFT.
         *
         * @param string $value Value
         * @param int $chars Number of characters
         *
         * @return string
         */
        public static function LEFT($value = '', $chars = 1)
        {
        }
        /**
         * MID.
         *
         * @param string $value Value
         * @param int $start Start character
         * @param int $chars Number of characters
         *
         * @return string
         */
        public static function MID($value = '', $start = 1, $chars = null)
        {
        }
        /**
         * RIGHT.
         *
         * @param string $value Value
         * @param int $chars Number of characters
         *
         * @return string
         */
        public static function RIGHT($value = '', $chars = 1)
        {
        }
        /**
         * STRINGLENGTH.
         *
         * @param string $value Value
         *
         * @return int
         */
        public static function STRINGLENGTH($value = '')
        {
        }
        /**
         * LOWERCASE.
         *
         * Converts a string value to upper case.
         *
         * @param string $mixedCaseString
         *
         * @return string
         */
        public static function LOWERCASE($mixedCaseString)
        {
        }
        /**
         * UPPERCASE.
         *
         * Converts a string value to upper case.
         *
         * @param string $mixedCaseString
         *
         * @return string
         */
        public static function UPPERCASE($mixedCaseString)
        {
        }
        /**
         * PROPERCASE.
         *
         * Converts a string value to upper case.
         *
         * @param string $mixedCaseString
         *
         * @return string
         */
        public static function PROPERCASE($mixedCaseString)
        {
        }
        /**
         * REPLACE.
         *
         * @param string $oldText String to modify
         * @param int $start Start character
         * @param int $chars Number of characters
         * @param string $newText String to replace in defined position
         *
         * @return string
         */
        public static function REPLACE($oldText, $start, $chars, $newText)
        {
        }
        /**
         * SUBSTITUTE.
         *
         * @param string $text Value
         * @param string $fromText From Value
         * @param string $toText To Value
         * @param int $instance Instance Number
         *
         * @return string
         */
        public static function SUBSTITUTE($text = '', $fromText = '', $toText = '', $instance = 0)
        {
        }
        /**
         * RETURNSTRING.
         *
         * @param mixed $testValue Value to check
         *
         * @return null|string
         */
        public static function RETURNSTRING($testValue = '')
        {
        }
        /**
         * TEXTFORMAT.
         *
         * @param mixed $value Value to check
         * @param string $format Format mask to use
         *
         * @return string
         */
        public static function TEXTFORMAT($value, $format)
        {
        }
        /**
         * VALUE.
         *
         * @param mixed $value Value to check
         *
         * @return bool
         */
        public static function VALUE($value = '')
        {
        }
        /**
         * NUMBERVALUE.
         *
         * @param mixed $value Value to check
         * @param string $decimalSeparator decimal separator, defaults to locale defined value
         * @param string $groupSeparator group/thosands separator, defaults to locale defined value
         *
         * @return float|string
         */
        public static function NUMBERVALUE($value = '', $decimalSeparator = null, $groupSeparator = null)
        {
        }
        /**
         * Compares two text strings and returns TRUE if they are exactly the same, FALSE otherwise.
         * EXACT is case-sensitive but ignores formatting differences.
         * Use EXACT to test text being entered into a document.
         *
         * @param $value1
         * @param $value2
         *
         * @return bool
         */
        public static function EXACT($value1, $value2)
        {
        }
        /**
         * TEXTJOIN.
         *
         * @param mixed $delimiter
         * @param mixed $ignoreEmpty
         * @param mixed $args
         *
         * @return string
         */
        public static function TEXTJOIN($delimiter, $ignoreEmpty, ...$args)
        {
        }
    }
    /**
     * PARTLY BASED ON:
     * Copyright (c) 2007 E. W. Bachtal, Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software
     * and associated documentation files (the "Software"), to deal in the Software without restriction,
     * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
     * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
     * subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial
     * portions of the Software.
     *
     * The software is provided "as is", without warranty of any kind, express or implied, including but not
     * limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In
     * no event shall the authors or copyright holders be liable for any claim, damages or other liability,
     * whether in an action of contract, tort or otherwise, arising from, out of or in connection with the
     * software or the use or other dealings in the software.
     *
     * https://ewbi.blogs.com/develops/2007/03/excel_formula_p.html
     * https://ewbi.blogs.com/develops/2004/12/excel_formula_p.html
     */
    class FormulaParser
    {
        // Character constants
        const QUOTE_DOUBLE = '"';
        const QUOTE_SINGLE = '\'';
        const BRACKET_CLOSE = ']';
        const BRACKET_OPEN = '[';
        const BRACE_OPEN = '{';
        const BRACE_CLOSE = '}';
        const PAREN_OPEN = '(';
        const PAREN_CLOSE = ')';
        const SEMICOLON = ';';
        const WHITESPACE = ' ';
        const COMMA = ',';
        const ERROR_START = '#';
        const OPERATORS_SN = '+-';
        const OPERATORS_INFIX = '+-*/^&=><';
        const OPERATORS_POSTFIX = '%';
        /**
         * Formula.
         *
         * @var string
         */
        private $formula;
        /**
         * Tokens.
         *
         * @var FormulaToken[]
         */
        private $tokens = [];
        /**
         * Create a new FormulaParser.
         *
         * @param string $pFormula Formula to parse
         */
        public function __construct($pFormula = '')
        {
        }
        /**
         * Get Formula.
         *
         * @return string
         */
        public function getFormula()
        {
        }
        /**
         * Get Token.
         *
         * @param int $pId Token id
         *
         * @return string
         */
        public function getToken($pId = 0)
        {
        }
        /**
         * Get Token count.
         *
         * @return int
         */
        public function getTokenCount()
        {
        }
        /**
         * Get Tokens.
         *
         * @return FormulaToken[]
         */
        public function getTokens()
        {
        }
        /**
         * Parse to tokens.
         */
        private function parseToTokens() : void
        {
        }
    }
    class Statistical
    {
        const LOG_GAMMA_X_MAX_VALUE = 2.55E+305;
        const XMININ = 2.23E-308;
        const EPS = 2.22E-16;
        const MAX_VALUE = 1.2E+308;
        const MAX_ITERATIONS = 256;
        const SQRT2PI = 2.5066282746310007;
        private static function checkTrendArrays(&$array1, &$array2)
        {
        }
        /**
         * Incomplete beta function.
         *
         * @author Jaco van Kooten
         * @author Paul Meagher
         *
         * The computation is based on formulas from Numerical Recipes, Chapter 6.4 (W.H. Press et al, 1992).
         *
         * @param mixed $x require 0<=x<=1
         * @param mixed $p require p>0
         * @param mixed $q require q>0
         *
         * @return float 0 if x<0, p<=0, q<=0 or p+q>2.55E305 and 1 if x>1 to avoid errors and over/underflow
         */
        private static function incompleteBeta($x, $p, $q)
        {
        }
        // Function cache for logBeta function
        private static $logBetaCacheP = 0.0;
        private static $logBetaCacheQ = 0.0;
        private static $logBetaCacheResult = 0.0;
        /**
         * The natural logarithm of the beta function.
         *
         * @param mixed $p require p>0
         * @param mixed $q require q>0
         *
         * @return float 0 if p<=0, q<=0 or p+q>2.55E305 to avoid errors and over/underflow
         *
         * @author Jaco van Kooten
         */
        private static function logBeta($p, $q)
        {
        }
        /**
         * Evaluates of continued fraction part of incomplete beta function.
         * Based on an idea from Numerical Recipes (W.H. Press et al, 1992).
         *
         * @author Jaco van Kooten
         *
         * @param mixed $x
         * @param mixed $p
         * @param mixed $q
         *
         * @return float
         */
        private static function betaFraction($x, $p, $q)
        {
        }
        /**
         * logGamma function.
         *
         * @version 1.1
         *
         * @author Jaco van Kooten
         *
         * Original author was Jaco van Kooten. Ported to PHP by Paul Meagher.
         *
         * The natural logarithm of the gamma function. <br />
         * Based on public domain NETLIB (Fortran) code by W. J. Cody and L. Stoltz <br />
         * Applied Mathematics Division <br />
         * Argonne National Laboratory <br />
         * Argonne, IL 60439 <br />
         * <p>
         * References:
         * <ol>
         * <li>W. J. Cody and K. E. Hillstrom, 'Chebyshev Approximations for the Natural
         *     Logarithm of the Gamma Function,' Math. Comp. 21, 1967, pp. 198-203.</li>
         * <li>K. E. Hillstrom, ANL/AMD Program ANLC366S, DGAMMA/DLGAMA, May, 1969.</li>
         * <li>Hart, Et. Al., Computer Approximations, Wiley and sons, New York, 1968.</li>
         * </ol>
         * </p>
         * <p>
         * From the original documentation:
         * </p>
         * <p>
         * This routine calculates the LOG(GAMMA) function for a positive real argument X.
         * Computation is based on an algorithm outlined in references 1 and 2.
         * The program uses rational functions that theoretically approximate LOG(GAMMA)
         * to at least 18 significant decimal digits. The approximation for X > 12 is from
         * reference 3, while approximations for X < 12.0 are similar to those in reference
         * 1, but are unpublished. The accuracy achieved depends on the arithmetic system,
         * the compiler, the intrinsic functions, and proper selection of the
         * machine-dependent constants.
         * </p>
         * <p>
         * Error returns: <br />
         * The program returns the value XINF for X .LE. 0.0 or when overflow would occur.
         * The computation is believed to be free of underflow and overflow.
         * </p>
         *
         * @return float MAX_VALUE for x < 0.0 or when overflow would occur, i.e. x > 2.55E305
         */
        // Function cache for logGamma
        private static $logGammaCacheResult = 0.0;
        private static $logGammaCacheX = 0.0;
        private static function logGamma($x)
        {
        }
        //
        //    Private implementation of the incomplete Gamma function
        //
        private static function incompleteGamma($a, $x)
        {
        }
        //
        //    Private implementation of the Gamma function
        //
        private static function gamma($data)
        {
        }
        /*
         *                                inverse_ncdf.php
         *                            -------------------
         *    begin                : Friday, January 16, 2004
         *    copyright            : (C) 2004 Michael Nickerson
         *    email                : nickersonm@yahoo.com
         *
         */
        private static function inverseNcdf($p)
        {
        }
        /**
         * MS Excel does not count Booleans if passed as cell values, but they are counted if passed as literals.
         * OpenOffice Calc always counts Booleans.
         * Gnumeric never counts Booleans.
         *
         * @param mixed $arg
         * @param mixed $k
         *
         * @return int|mixed
         */
        private static function testAcceptedBoolean($arg, $k)
        {
        }
        /**
         * @param mixed $arg
         * @param mixed $k
         *
         * @return bool
         */
        private static function isAcceptedCountable($arg, $k)
        {
        }
        /**
         * AVEDEV.
         *
         * Returns the average of the absolute deviations of data points from their mean.
         * AVEDEV is a measure of the variability in a data set.
         *
         * Excel Function:
         *        AVEDEV(value1[,value2[, ...]])
         *
         * @param mixed ...$args Data values
         *
         * @return float|string
         */
        public static function AVEDEV(...$args)
        {
        }
        /**
         * AVERAGE.
         *
         * Returns the average (arithmetic mean) of the arguments
         *
         * Excel Function:
         *        AVERAGE(value1[,value2[, ...]])
         *
         * @param mixed ...$args Data values
         *
         * @return float|string
         */
        public static function AVERAGE(...$args)
        {
        }
        /**
         * AVERAGEA.
         *
         * Returns the average of its arguments, including numbers, text, and logical values
         *
         * Excel Function:
         *        AVERAGEA(value1[,value2[, ...]])
         *
         * @param mixed ...$args Data values
         *
         * @return float|string
         */
        public static function AVERAGEA(...$args)
        {
        }
        /**
         * AVERAGEIF.
         *
         * Returns the average value from a range of cells that contain numbers within the list of arguments
         *
         * Excel Function:
         *        AVERAGEIF(value1[,value2[, ...]],condition)
         *
         * @param mixed $aArgs Data values
         * @param string $condition the criteria that defines which cells will be checked
         * @param mixed[] $averageArgs Data values
         *
         * @return float|string
         */
        public static function AVERAGEIF($aArgs, $condition, $averageArgs = [])
        {
        }
        /**
         * BETADIST.
         *
         * Returns the beta distribution.
         *
         * @param float $value Value at which you want to evaluate the distribution
         * @param float $alpha Parameter to the distribution
         * @param float $beta Parameter to the distribution
         * @param mixed $rMin
         * @param mixed $rMax
         *
         * @return float|string
         */
        public static function BETADIST($value, $alpha, $beta, $rMin = 0, $rMax = 1)
        {
        }
        /**
         * BETAINV.
         *
         * Returns the inverse of the beta distribution.
         *
         * @param float $probability Probability at which you want to evaluate the distribution
         * @param float $alpha Parameter to the distribution
         * @param float $beta Parameter to the distribution
         * @param float $rMin Minimum value
         * @param float $rMax Maximum value
         *
         * @return float|string
         */
        public static function BETAINV($probability, $alpha, $beta, $rMin = 0, $rMax = 1)
        {
        }
        /**
         * BINOMDIST.
         *
         * Returns the individual term binomial distribution probability. Use BINOMDIST in problems with
         *        a fixed number of tests or trials, when the outcomes of any trial are only success or failure,
         *        when trials are independent, and when the probability of success is constant throughout the
         *        experiment. For example, BINOMDIST can calculate the probability that two of the next three
         *        babies born are male.
         *
         * @param float $value Number of successes in trials
         * @param float $trials Number of trials
         * @param float $probability Probability of success on each trial
         * @param bool $cumulative
         *
         * @return float|string
         */
        public static function BINOMDIST($value, $trials, $probability, $cumulative)
        {
        }
        /**
         * CHIDIST.
         *
         * Returns the one-tailed probability of the chi-squared distribution.
         *
         * @param float $value Value for the function
         * @param float $degrees degrees of freedom
         *
         * @return float|string
         */
        public static function CHIDIST($value, $degrees)
        {
        }
        /**
         * CHIINV.
         *
         * Returns the one-tailed probability of the chi-squared distribution.
         *
         * @param float $probability Probability for the function
         * @param float $degrees degrees of freedom
         *
         * @return float|string
         */
        public static function CHIINV($probability, $degrees)
        {
        }
        /**
         * CONFIDENCE.
         *
         * Returns the confidence interval for a population mean
         *
         * @param float $alpha
         * @param float $stdDev Standard Deviation
         * @param float $size
         *
         * @return float|string
         */
        public static function CONFIDENCE($alpha, $stdDev, $size)
        {
        }
        /**
         * CORREL.
         *
         * Returns covariance, the average of the products of deviations for each data point pair.
         *
         * @param mixed $yValues array of mixed Data Series Y
         * @param null|mixed $xValues array of mixed Data Series X
         *
         * @return float|string
         */
        public static function CORREL($yValues, $xValues = null)
        {
        }
        /**
         * COUNT.
         *
         * Counts the number of cells that contain numbers within the list of arguments
         *
         * Excel Function:
         *        COUNT(value1[,value2[, ...]])
         *
         * @param mixed ...$args Data values
         *
         * @return int
         */
        public static function COUNT(...$args)
        {
        }
        /**
         * COUNTA.
         *
         * Counts the number of cells that are not empty within the list of arguments
         *
         * Excel Function:
         *        COUNTA(value1[,value2[, ...]])
         *
         * @param mixed ...$args Data values
         *
         * @return int
         */
        public static function COUNTA(...$args)
        {
        }
        /**
         * COUNTBLANK.
         *
         * Counts the number of empty cells within the list of arguments
         *
         * Excel Function:
         *        COUNTBLANK(value1[,value2[, ...]])
         *
         * @param mixed ...$args Data values
         *
         * @return int
         */
        public static function COUNTBLANK(...$args)
        {
        }
        /**
         * COUNTIF.
         *
         * Counts the number of cells that contain numbers within the list of arguments
         *
         * Excel Function:
         *        COUNTIF(value1[,value2[, ...]],condition)
         *
         * @param mixed $aArgs Data values
         * @param string $condition the criteria that defines which cells will be counted
         *
         * @return int
         */
        public static function COUNTIF($aArgs, $condition)
        {
        }
        /**
         * COUNTIFS.
         *
         * Counts the number of cells that contain numbers within the list of arguments
         *
         * Excel Function:
         *        COUNTIFS(criteria_range1, criteria1, [criteria_range2, criteria2])
         *
         * @param mixed $args Criterias
         *
         * @return int
         */
        public static function COUNTIFS(...$args)
        {
        }
        /**
         * COVAR.
         *
         * Returns covariance, the average of the products of deviations for each data point pair.
         *
         * @param mixed $yValues array of mixed Data Series Y
         * @param mixed $xValues array of mixed Data Series X
         *
         * @return float|string
         */
        public static function COVAR($yValues, $xValues)
        {
        }
        /**
         * CRITBINOM.
         *
         * Returns the smallest value for which the cumulative binomial distribution is greater
         *        than or equal to a criterion value
         *
         * See https://support.microsoft.com/en-us/help/828117/ for details of the algorithm used
         *
         * @param float $trials number of Bernoulli trials
         * @param float $probability probability of a success on each trial
         * @param float $alpha criterion value
         *
         * @return int|string
         *
         * @TODO    Warning. This implementation differs from the algorithm detailed on the MS
         *            web site in that $CumPGuessMinus1 = $CumPGuess - 1 rather than $CumPGuess - $PGuess
         *            This eliminates a potential endless loop error, but may have an adverse affect on the
         *            accuracy of the function (although all my tests have so far returned correct results).
         */
        public static function CRITBINOM($trials, $probability, $alpha)
        {
        }
        /**
         * DEVSQ.
         *
         * Returns the sum of squares of deviations of data points from their sample mean.
         *
         * Excel Function:
         *        DEVSQ(value1[,value2[, ...]])
         *
         * @param mixed ...$args Data values
         *
         * @return float|string
         */
        public static function DEVSQ(...$args)
        {
        }
        /**
         * EXPONDIST.
         *
         *    Returns the exponential distribution. Use EXPONDIST to model the time between events,
         *        such as how long an automated bank teller takes to deliver cash. For example, you can
         *        use EXPONDIST to determine the probability that the process takes at most 1 minute.
         *
         * @param float $value Value of the function
         * @param float $lambda The parameter value
         * @param bool $cumulative
         *
         * @return float|string
         */
        public static function EXPONDIST($value, $lambda, $cumulative)
        {
        }
        /**
         * FISHER.
         *
         * Returns the Fisher transformation at x. This transformation produces a function that
         *        is normally distributed rather than skewed. Use this function to perform hypothesis
         *        testing on the correlation coefficient.
         *
         * @param float $value
         *
         * @return float|string
         */
        public static function FISHER($value)
        {
        }
        /**
         * FISHERINV.
         *
         * Returns the inverse of the Fisher transformation. Use this transformation when
         *        analyzing correlations between ranges or arrays of data. If y = FISHER(x), then
         *        FISHERINV(y) = x.
         *
         * @param float $value
         *
         * @return float|string
         */
        public static function FISHERINV($value)
        {
        }
        /**
         * FORECAST.
         *
         * Calculates, or predicts, a future value by using existing values. The predicted value is a y-value for a given x-value.
         *
         * @param float $xValue Value of X for which we want to find Y
         * @param mixed $yValues array of mixed Data Series Y
         * @param mixed $xValues of mixed Data Series X
         *
         * @return bool|float|string
         */
        public static function FORECAST($xValue, $yValues, $xValues)
        {
        }
        /**
         * GAMMADIST.
         *
         * Returns the gamma distribution.
         *
         * @param float $value Value at which you want to evaluate the distribution
         * @param float $a Parameter to the distribution
         * @param float $b Parameter to the distribution
         * @param bool $cumulative
         *
         * @return float|string
         */
        public static function GAMMADIST($value, $a, $b, $cumulative)
        {
        }
        /**
         * GAMMAINV.
         *
         * Returns the inverse of the beta distribution.
         *
         * @param float $probability Probability at which you want to evaluate the distribution
         * @param float $alpha Parameter to the distribution
         * @param float $beta Parameter to the distribution
         *
         * @return float|string
         */
        public static function GAMMAINV($probability, $alpha, $beta)
        {
        }
        /**
         * GAMMALN.
         *
         * Returns the natural logarithm of the gamma function.
         *
         * @param float $value
         *
         * @return float|string
         */
        public static function GAMMALN($value)
        {
        }
        /**
         * GEOMEAN.
         *
         * Returns the geometric mean of an array or range of positive data. For example, you
         *        can use GEOMEAN to calculate average growth rate given compound interest with
         *        variable rates.
         *
         * Excel Function:
         *        GEOMEAN(value1[,value2[, ...]])
         *
         * @param mixed ...$args Data values
         *
         * @return float|string
         */
        public static function GEOMEAN(...$args)
        {
        }
        /**
         * GROWTH.
         *
         * Returns values along a predicted exponential Trend
         *
         * @param mixed[] $yValues Data Series Y
         * @param mixed[] $xValues Data Series X
         * @param mixed[] $newValues Values of X for which we want to find Y
         * @param bool $const a logical value specifying whether to force the intersect to equal 0
         *
         * @return array of float
         */
        public static function GROWTH($yValues, $xValues = [], $newValues = [], $const = true)
        {
        }
        /**
         * HARMEAN.
         *
         * Returns the harmonic mean of a data set. The harmonic mean is the reciprocal of the
         *        arithmetic mean of reciprocals.
         *
         * Excel Function:
         *        HARMEAN(value1[,value2[, ...]])
         *
         * @param mixed ...$args Data values
         *
         * @return float|string
         */
        public static function HARMEAN(...$args)
        {
        }
        /**
         * HYPGEOMDIST.
         *
         * Returns the hypergeometric distribution. HYPGEOMDIST returns the probability of a given number of
         * sample successes, given the sample size, population successes, and population size.
         *
         * @param float $sampleSuccesses Number of successes in the sample
         * @param float $sampleNumber Size of the sample
         * @param float $populationSuccesses Number of successes in the population
         * @param float $populationNumber Population size
         *
         * @return float|string
         */
        public static function HYPGEOMDIST($sampleSuccesses, $sampleNumber, $populationSuccesses, $populationNumber)
        {
        }
        /**
         * INTERCEPT.
         *
         * Calculates the point at which a line will intersect the y-axis by using existing x-values and y-values.
         *
         * @param mixed[] $yValues Data Series Y
         * @param mixed[] $xValues Data Series X
         *
         * @return float|string
         */
        public static function INTERCEPT($yValues, $xValues)
        {
        }
        /**
         * KURT.
         *
         * Returns the kurtosis of a data set. Kurtosis characterizes the relative peakedness
         * or flatness of a distribution compared with the normal distribution. Positive
         * kurtosis indicates a relatively peaked distribution. Negative kurtosis indicates a
         * relatively flat distribution.
         *
         * @param array ...$args Data Series
         *
         * @return float|string
         */
        public static function KURT(...$args)
        {
        }
        /**
         * LARGE.
         *
         * Returns the nth largest value in a data set. You can use this function to
         *        select a value based on its relative standing.
         *
         * Excel Function:
         *        LARGE(value1[,value2[, ...]],entry)
         *
         * @param mixed $args Data values
         *
         * @return float|string The result, or a string containing an error
         */
        public static function LARGE(...$args)
        {
        }
        /**
         * LINEST.
         *
         * Calculates the statistics for a line by using the "least squares" method to calculate a straight line that best fits your data,
         *        and then returns an array that describes the line.
         *
         * @param mixed[] $yValues Data Series Y
         * @param null|mixed[] $xValues Data Series X
         * @param bool $const a logical value specifying whether to force the intersect to equal 0
         * @param bool $stats a logical value specifying whether to return additional regression statistics
         *
         * @return array|int|string The result, or a string containing an error
         */
        public static function LINEST($yValues, $xValues = null, $const = true, $stats = false)
        {
        }
        /**
         * LOGEST.
         *
         * Calculates an exponential curve that best fits the X and Y data series,
         *        and then returns an array that describes the line.
         *
         * @param mixed[] $yValues Data Series Y
         * @param null|mixed[] $xValues Data Series X
         * @param bool $const a logical value specifying whether to force the intersect to equal 0
         * @param bool $stats a logical value specifying whether to return additional regression statistics
         *
         * @return array|int|string The result, or a string containing an error
         */
        public static function LOGEST($yValues, $xValues = null, $const = true, $stats = false)
        {
        }
        /**
         * LOGINV.
         *
         * Returns the inverse of the normal cumulative distribution
         *
         * @param float $probability
         * @param float $mean
         * @param float $stdDev
         *
         * @return float|string The result, or a string containing an error
         *
         * @TODO    Try implementing P J Acklam's refinement algorithm for greater
         *            accuracy if I can get my head round the mathematics
         *            (as described at) http://home.online.no/~pjacklam/notes/invnorm/
         */
        public static function LOGINV($probability, $mean, $stdDev)
        {
        }
        /**
         * LOGNORMDIST.
         *
         * Returns the cumulative lognormal distribution of x, where ln(x) is normally distributed
         * with parameters mean and standard_dev.
         *
         * @param float $value
         * @param float $mean
         * @param float $stdDev
         *
         * @return float|string The result, or a string containing an error
         */
        public static function LOGNORMDIST($value, $mean, $stdDev)
        {
        }
        /**
         * MAX.
         *
         * MAX returns the value of the element of the values passed that has the highest value,
         *        with negative numbers considered smaller than positive numbers.
         *
         * Excel Function:
         *        MAX(value1[,value2[, ...]])
         *
         * @param mixed ...$args Data values
         *
         * @return float
         */
        public static function MAX(...$args)
        {
        }
        /**
         * MAXA.
         *
         * Returns the greatest value in a list of arguments, including numbers, text, and logical values
         *
         * Excel Function:
         *        MAXA(value1[,value2[, ...]])
         *
         * @param mixed ...$args Data values
         *
         * @return float
         */
        public static function MAXA(...$args)
        {
        }
        /**
         * MAXIFS.
         *
         * Counts the maximum value within a range of cells that contain numbers within the list of arguments
         *
         * Excel Function:
         *        MAXIFS(max_range, criteria_range1, criteria1, [criteria_range2, criteria2], ...)
         *
         * @param mixed $args Data range and criterias
         *
         * @return float
         */
        public static function MAXIFS(...$args)
        {
        }
        /**
         * MEDIAN.
         *
         * Returns the median of the given numbers. The median is the number in the middle of a set of numbers.
         *
         * Excel Function:
         *        MEDIAN(value1[,value2[, ...]])
         *
         * @param mixed ...$args Data values
         *
         * @return float|string The result, or a string containing an error
         */
        public static function MEDIAN(...$args)
        {
        }
        /**
         * MIN.
         *
         * MIN returns the value of the element of the values passed that has the smallest value,
         *        with negative numbers considered smaller than positive numbers.
         *
         * Excel Function:
         *        MIN(value1[,value2[, ...]])
         *
         * @param mixed ...$args Data values
         *
         * @return float
         */
        public static function MIN(...$args)
        {
        }
        /**
         * MINA.
         *
         * Returns the smallest value in a list of arguments, including numbers, text, and logical values
         *
         * Excel Function:
         *        MINA(value1[,value2[, ...]])
         *
         * @param mixed ...$args Data values
         *
         * @return float
         */
        public static function MINA(...$args)
        {
        }
        /**
         * MINIFS.
         *
         * Returns the minimum value within a range of cells that contain numbers within the list of arguments
         *
         * Excel Function:
         *        MINIFS(min_range, criteria_range1, criteria1, [criteria_range2, criteria2], ...)
         *
         * @param mixed $args Data range and criterias
         *
         * @return float
         */
        public static function MINIFS(...$args)
        {
        }
        //
        //    Special variant of array_count_values that isn't limited to strings and integers,
        //        but can work with floating point numbers as values
        //
        private static function modeCalc($data)
        {
        }
        /**
         * MODE.
         *
         * Returns the most frequently occurring, or repetitive, value in an array or range of data
         *
         * Excel Function:
         *        MODE(value1[,value2[, ...]])
         *
         * @param mixed ...$args Data values
         *
         * @return float|string The result, or a string containing an error
         */
        public static function MODE(...$args)
        {
        }
        /**
         * NEGBINOMDIST.
         *
         * Returns the negative binomial distribution. NEGBINOMDIST returns the probability that
         *        there will be number_f failures before the number_s-th success, when the constant
         *        probability of a success is probability_s. This function is similar to the binomial
         *        distribution, except that the number of successes is fixed, and the number of trials is
         *        variable. Like the binomial, trials are assumed to be independent.
         *
         * @param float $failures Number of Failures
         * @param float $successes Threshold number of Successes
         * @param float $probability Probability of success on each trial
         *
         * @return float|string The result, or a string containing an error
         */
        public static function NEGBINOMDIST($failures, $successes, $probability)
        {
        }
        /**
         * NORMDIST.
         *
         * Returns the normal distribution for the specified mean and standard deviation. This
         * function has a very wide range of applications in statistics, including hypothesis
         * testing.
         *
         * @param float $value
         * @param float $mean Mean Value
         * @param float $stdDev Standard Deviation
         * @param bool $cumulative
         *
         * @return float|string The result, or a string containing an error
         */
        public static function NORMDIST($value, $mean, $stdDev, $cumulative)
        {
        }
        /**
         * NORMINV.
         *
         * Returns the inverse of the normal cumulative distribution for the specified mean and standard deviation.
         *
         * @param float $probability
         * @param float $mean Mean Value
         * @param float $stdDev Standard Deviation
         *
         * @return float|string The result, or a string containing an error
         */
        public static function NORMINV($probability, $mean, $stdDev)
        {
        }
        /**
         * NORMSDIST.
         *
         * Returns the standard normal cumulative distribution function. The distribution has
         * a mean of 0 (zero) and a standard deviation of one. Use this function in place of a
         * table of standard normal curve areas.
         *
         * @param float $value
         *
         * @return float|string The result, or a string containing an error
         */
        public static function NORMSDIST($value)
        {
        }
        /**
         * NORMSINV.
         *
         * Returns the inverse of the standard normal cumulative distribution
         *
         * @param float $value
         *
         * @return float|string The result, or a string containing an error
         */
        public static function NORMSINV($value)
        {
        }
        /**
         * PERCENTILE.
         *
         * Returns the nth percentile of values in a range..
         *
         * Excel Function:
         *        PERCENTILE(value1[,value2[, ...]],entry)
         *
         * @param mixed $args Data values
         *
         * @return float|string The result, or a string containing an error
         */
        public static function PERCENTILE(...$args)
        {
        }
        /**
         * PERCENTRANK.
         *
         * Returns the rank of a value in a data set as a percentage of the data set.
         *
         * @param float[] $valueSet An array of, or a reference to, a list of numbers
         * @param int $value the number whose rank you want to find
         * @param int $significance the number of significant digits for the returned percentage value
         *
         * @return float
         */
        public static function PERCENTRANK($valueSet, $value, $significance = 3)
        {
        }
        /**
         * PERMUT.
         *
         * Returns the number of permutations for a given number of objects that can be
         *        selected from number objects. A permutation is any set or subset of objects or
         *        events where internal order is significant. Permutations are different from
         *        combinations, for which the internal order is not significant. Use this function
         *        for lottery-style probability calculations.
         *
         * @param int $numObjs Number of different objects
         * @param int $numInSet Number of objects in each permutation
         *
         * @return int|string Number of permutations, or a string containing an error
         */
        public static function PERMUT($numObjs, $numInSet)
        {
        }
        /**
         * POISSON.
         *
         * Returns the Poisson distribution. A common application of the Poisson distribution
         * is predicting the number of events over a specific time, such as the number of
         * cars arriving at a toll plaza in 1 minute.
         *
         * @param float $value
         * @param float $mean Mean Value
         * @param bool $cumulative
         *
         * @return float|string The result, or a string containing an error
         */
        public static function POISSON($value, $mean, $cumulative)
        {
        }
        /**
         * QUARTILE.
         *
         * Returns the quartile of a data set.
         *
         * Excel Function:
         *        QUARTILE(value1[,value2[, ...]],entry)
         *
         * @param mixed $args Data values
         *
         * @return float|string The result, or a string containing an error
         */
        public static function QUARTILE(...$args)
        {
        }
        /**
         * RANK.
         *
         * Returns the rank of a number in a list of numbers.
         *
         * @param int $value the number whose rank you want to find
         * @param float[] $valueSet An array of, or a reference to, a list of numbers
         * @param int $order Order to sort the values in the value set
         *
         * @return float|string The result, or a string containing an error
         */
        public static function RANK($value, $valueSet, $order = 0)
        {
        }
        /**
         * RSQ.
         *
         * Returns the square of the Pearson product moment correlation coefficient through data points in known_y's and known_x's.
         *
         * @param mixed[] $yValues Data Series Y
         * @param mixed[] $xValues Data Series X
         *
         * @return float|string The result, or a string containing an error
         */
        public static function RSQ($yValues, $xValues)
        {
        }
        /**
         * SKEW.
         *
         * Returns the skewness of a distribution. Skewness characterizes the degree of asymmetry
         * of a distribution around its mean. Positive skewness indicates a distribution with an
         * asymmetric tail extending toward more positive values. Negative skewness indicates a
         * distribution with an asymmetric tail extending toward more negative values.
         *
         * @param array ...$args Data Series
         *
         * @return float|string The result, or a string containing an error
         */
        public static function SKEW(...$args)
        {
        }
        /**
         * SLOPE.
         *
         * Returns the slope of the linear regression line through data points in known_y's and known_x's.
         *
         * @param mixed[] $yValues Data Series Y
         * @param mixed[] $xValues Data Series X
         *
         * @return float|string The result, or a string containing an error
         */
        public static function SLOPE($yValues, $xValues)
        {
        }
        /**
         * SMALL.
         *
         * Returns the nth smallest value in a data set. You can use this function to
         *        select a value based on its relative standing.
         *
         * Excel Function:
         *        SMALL(value1[,value2[, ...]],entry)
         *
         * @param mixed $args Data values
         *
         * @return float|string The result, or a string containing an error
         */
        public static function SMALL(...$args)
        {
        }
        /**
         * STANDARDIZE.
         *
         * Returns a normalized value from a distribution characterized by mean and standard_dev.
         *
         * @param float $value Value to normalize
         * @param float $mean Mean Value
         * @param float $stdDev Standard Deviation
         *
         * @return float|string Standardized value, or a string containing an error
         */
        public static function STANDARDIZE($value, $mean, $stdDev)
        {
        }
        /**
         * STDEV.
         *
         * Estimates standard deviation based on a sample. The standard deviation is a measure of how
         *        widely values are dispersed from the average value (the mean).
         *
         * Excel Function:
         *        STDEV(value1[,value2[, ...]])
         *
         * @param mixed ...$args Data values
         *
         * @return float|string The result, or a string containing an error
         */
        public static function STDEV(...$args)
        {
        }
        /**
         * STDEVA.
         *
         * Estimates standard deviation based on a sample, including numbers, text, and logical values
         *
         * Excel Function:
         *        STDEVA(value1[,value2[, ...]])
         *
         * @param mixed ...$args Data values
         *
         * @return float|string
         */
        public static function STDEVA(...$args)
        {
        }
        /**
         * STDEVP.
         *
         * Calculates standard deviation based on the entire population
         *
         * Excel Function:
         *        STDEVP(value1[,value2[, ...]])
         *
         * @param mixed ...$args Data values
         *
         * @return float|string
         */
        public static function STDEVP(...$args)
        {
        }
        /**
         * STDEVPA.
         *
         * Calculates standard deviation based on the entire population, including numbers, text, and logical values
         *
         * Excel Function:
         *        STDEVPA(value1[,value2[, ...]])
         *
         * @param mixed ...$args Data values
         *
         * @return float|string
         */
        public static function STDEVPA(...$args)
        {
        }
        /**
         * STEYX.
         *
         * Returns the standard error of the predicted y-value for each x in the regression.
         *
         * @param mixed[] $yValues Data Series Y
         * @param mixed[] $xValues Data Series X
         *
         * @return float|string
         */
        public static function STEYX($yValues, $xValues)
        {
        }
        /**
         * TDIST.
         *
         * Returns the probability of Student's T distribution.
         *
         * @param float $value Value for the function
         * @param float $degrees degrees of freedom
         * @param float $tails number of tails (1 or 2)
         *
         * @return float|string The result, or a string containing an error
         */
        public static function TDIST($value, $degrees, $tails)
        {
        }
        /**
         * TINV.
         *
         * Returns the one-tailed probability of the chi-squared distribution.
         *
         * @param float $probability Probability for the function
         * @param float $degrees degrees of freedom
         *
         * @return float|string The result, or a string containing an error
         */
        public static function TINV($probability, $degrees)
        {
        }
        /**
         * TREND.
         *
         * Returns values along a linear Trend
         *
         * @param mixed[] $yValues Data Series Y
         * @param mixed[] $xValues Data Series X
         * @param mixed[] $newValues Values of X for which we want to find Y
         * @param bool $const a logical value specifying whether to force the intersect to equal 0
         *
         * @return array of float
         */
        public static function TREND($yValues, $xValues = [], $newValues = [], $const = true)
        {
        }
        /**
         * TRIMMEAN.
         *
         * Returns the mean of the interior of a data set. TRIMMEAN calculates the mean
         *        taken by excluding a percentage of data points from the top and bottom tails
         *        of a data set.
         *
         * Excel Function:
         *        TRIMEAN(value1[,value2[, ...]], $discard)
         *
         * @param mixed $args Data values
         *
         * @return float|string
         */
        public static function TRIMMEAN(...$args)
        {
        }
        /**
         * VARFunc.
         *
         * Estimates variance based on a sample.
         *
         * Excel Function:
         *        VAR(value1[,value2[, ...]])
         *
         * @param mixed ...$args Data values
         *
         * @return float
         */
        public static function VARFunc(...$args)
        {
        }
        /**
         * VARA.
         *
         * Estimates variance based on a sample, including numbers, text, and logical values
         *
         * Excel Function:
         *        VARA(value1[,value2[, ...]])
         *
         * @param mixed ...$args Data values
         *
         * @return float
         */
        public static function VARA(...$args)
        {
        }
        /**
         * VARP.
         *
         * Calculates variance based on the entire population
         *
         * Excel Function:
         *        VARP(value1[,value2[, ...]])
         *
         * @param mixed ...$args Data values
         *
         * @return float
         */
        public static function VARP(...$args)
        {
        }
        /**
         * VARPA.
         *
         * Calculates variance based on the entire population, including numbers, text, and logical values
         *
         * Excel Function:
         *        VARPA(value1[,value2[, ...]])
         *
         * @param mixed ...$args Data values
         *
         * @return float
         */
        public static function VARPA(...$args)
        {
        }
        /**
         * WEIBULL.
         *
         * Returns the Weibull distribution. Use this distribution in reliability
         * analysis, such as calculating a device's mean time to failure.
         *
         * @param float $value
         * @param float $alpha Alpha Parameter
         * @param float $beta Beta Parameter
         * @param bool $cumulative
         *
         * @return float
         */
        public static function WEIBULL($value, $alpha, $beta, $cumulative)
        {
        }
        /**
         * ZTEST.
         *
         * Returns the Weibull distribution. Use this distribution in reliability
         * analysis, such as calculating a device's mean time to failure.
         *
         * @param float $dataSet
         * @param float $m0 Alpha Parameter
         * @param float $sigma Beta Parameter
         *
         * @return float|string
         */
        public static function ZTEST($dataSet, $m0, $sigma = null)
        {
        }
    }
    class LookupRef
    {
        /**
         * CELL_ADDRESS.
         *
         * Creates a cell address as text, given specified row and column numbers.
         *
         * Excel Function:
         *        =ADDRESS(row, column, [relativity], [referenceStyle], [sheetText])
         *
         * @param mixed $row Row number to use in the cell reference
         * @param mixed $column Column number to use in the cell reference
         * @param int $relativity Flag indicating the type of reference to return
         *                                1 or omitted    Absolute
         *                                2                Absolute row; relative column
         *                                3                Relative row; absolute column
         *                                4                Relative
         * @param bool $referenceStyle A logical value that specifies the A1 or R1C1 reference style.
         *                                TRUE or omitted        CELL_ADDRESS returns an A1-style reference
         *                                FALSE                CELL_ADDRESS returns an R1C1-style reference
         * @param string $sheetText Optional Name of worksheet to use
         *
         * @return string
         */
        public static function cellAddress($row, $column, $relativity = 1, $referenceStyle = true, $sheetText = '')
        {
        }
        /**
         * COLUMN.
         *
         * Returns the column number of the given cell reference
         * If the cell reference is a range of cells, COLUMN returns the column numbers of each column in the reference as a horizontal array.
         * If cell reference is omitted, and the function is being called through the calculation engine, then it is assumed to be the
         *        reference of the cell in which the COLUMN function appears; otherwise this function returns 0.
         *
         * Excel Function:
         *        =COLUMN([cellAddress])
         *
         * @param null|array|string $cellAddress A reference to a range of cells for which you want the column numbers
         *
         * @return int|int[]
         */
        public static function COLUMN($cellAddress = null)
        {
        }
        /**
         * COLUMNS.
         *
         * Returns the number of columns in an array or reference.
         *
         * Excel Function:
         *        =COLUMNS(cellAddress)
         *
         * @param null|array|string $cellAddress An array or array formula, or a reference to a range of cells for which you want the number of columns
         *
         * @return int The number of columns in cellAddress
         */
        public static function COLUMNS($cellAddress = null)
        {
        }
        /**
         * ROW.
         *
         * Returns the row number of the given cell reference
         * If the cell reference is a range of cells, ROW returns the row numbers of each row in the reference as a vertical array.
         * If cell reference is omitted, and the function is being called through the calculation engine, then it is assumed to be the
         *        reference of the cell in which the ROW function appears; otherwise this function returns 0.
         *
         * Excel Function:
         *        =ROW([cellAddress])
         *
         * @param null|array|string $cellAddress A reference to a range of cells for which you want the row numbers
         *
         * @return int or array of integer
         */
        public static function ROW($cellAddress = null)
        {
        }
        /**
         * ROWS.
         *
         * Returns the number of rows in an array or reference.
         *
         * Excel Function:
         *        =ROWS(cellAddress)
         *
         * @param null|array|string $cellAddress An array or array formula, or a reference to a range of cells for which you want the number of rows
         *
         * @return int The number of rows in cellAddress
         */
        public static function ROWS($cellAddress = null)
        {
        }
        /**
         * HYPERLINK.
         *
         * Excel Function:
         *        =HYPERLINK(linkURL,displayName)
         *
         * @param string $linkURL Value to check, is also the value returned when no error
         * @param string $displayName Value to return when testValue is an error condition
         * @param Cell $pCell The cell to set the hyperlink in
         *
         * @return mixed The value of $displayName (or $linkURL if $displayName was blank)
         */
        public static function HYPERLINK($linkURL = '', $displayName = null, ?\PhpOffice\PhpSpreadsheet\Cell\Cell $pCell = null)
        {
        }
        /**
         * INDIRECT.
         *
         * Returns the reference specified by a text string.
         * References are immediately evaluated to display their contents.
         *
         * Excel Function:
         *        =INDIRECT(cellAddress)
         *
         * NOTE - INDIRECT() does not yet support the optional a1 parameter introduced in Excel 2010
         *
         * @param null|array|string $cellAddress $cellAddress The cell address of the current cell (containing this formula)
         * @param Cell $pCell The current cell (containing this formula)
         *
         * @return mixed The cells referenced by cellAddress
         *
         * @TODO    Support for the optional a1 parameter introduced in Excel 2010
         */
        public static function INDIRECT($cellAddress = null, ?\PhpOffice\PhpSpreadsheet\Cell\Cell $pCell = null)
        {
        }
        /**
         * OFFSET.
         *
         * Returns a reference to a range that is a specified number of rows and columns from a cell or range of cells.
         * The reference that is returned can be a single cell or a range of cells. You can specify the number of rows and
         * the number of columns to be returned.
         *
         * Excel Function:
         *        =OFFSET(cellAddress, rows, cols, [height], [width])
         *
         * @param null|string $cellAddress The reference from which you want to base the offset. Reference must refer to a cell or
         *                                range of adjacent cells; otherwise, OFFSET returns the #VALUE! error value.
         * @param mixed $rows The number of rows, up or down, that you want the upper-left cell to refer to.
         *                                Using 5 as the rows argument specifies that the upper-left cell in the reference is
         *                                five rows below reference. Rows can be positive (which means below the starting reference)
         *                                or negative (which means above the starting reference).
         * @param mixed $columns The number of columns, to the left or right, that you want the upper-left cell of the result
         *                                to refer to. Using 5 as the cols argument specifies that the upper-left cell in the
         *                                reference is five columns to the right of reference. Cols can be positive (which means
         *                                to the right of the starting reference) or negative (which means to the left of the
         *                                starting reference).
         * @param mixed $height The height, in number of rows, that you want the returned reference to be. Height must be a positive number.
         * @param mixed $width The width, in number of columns, that you want the returned reference to be. Width must be a positive number.
         *
         * @return string A reference to a cell or range of cells
         */
        public static function OFFSET($cellAddress = null, $rows = 0, $columns = 0, $height = null, $width = null, ?\PhpOffice\PhpSpreadsheet\Cell\Cell $pCell = null)
        {
        }
        /**
         * CHOOSE.
         *
         * Uses lookup_value to return a value from the list of value arguments.
         * Use CHOOSE to select one of up to 254 values based on the lookup_value.
         *
         * Excel Function:
         *        =CHOOSE(index_num, value1, [value2], ...)
         *
         * @return mixed The selected value
         */
        public static function CHOOSE(...$chooseArgs)
        {
        }
        /**
         * MATCH.
         *
         * The MATCH function searches for a specified item in a range of cells
         *
         * Excel Function:
         *        =MATCH(lookup_value, lookup_array, [match_type])
         *
         * @param mixed $lookupValue The value that you want to match in lookup_array
         * @param mixed $lookupArray The range of cells being searched
         * @param mixed $matchType The number -1, 0, or 1. -1 means above, 0 means exact match, 1 means below.
         *                         If match_type is 1 or -1, the list has to be ordered.
         *
         * @return int|string The relative position of the found item
         */
        public static function MATCH($lookupValue, $lookupArray, $matchType = 1)
        {
        }
        /**
         * INDEX.
         *
         * Uses an index to choose a value from a reference or array
         *
         * Excel Function:
         *        =INDEX(range_array, row_num, [column_num])
         *
         * @param mixed $arrayValues A range of cells or an array constant
         * @param mixed $rowNum The row in array from which to return a value. If row_num is omitted, column_num is required.
         * @param mixed $columnNum The column in array from which to return a value. If column_num is omitted, row_num is required.
         *
         * @return mixed the value of a specified cell or array of cells
         */
        public static function INDEX($arrayValues, $rowNum = 0, $columnNum = 0)
        {
        }
        /**
         * TRANSPOSE.
         *
         * @param array $matrixData A matrix of values
         *
         * @return array
         *
         * Unlike the Excel TRANSPOSE function, which will only work on a single row or column, this function will transpose a full matrix
         */
        public static function TRANSPOSE($matrixData)
        {
        }
        private static function vlookupSort($a, $b)
        {
        }
        /**
         * VLOOKUP
         * The VLOOKUP function searches for value in the left-most column of lookup_array and returns the value in the same row based on the index_number.
         *
         * @param mixed $lookup_value The value that you want to match in lookup_array
         * @param mixed $lookup_array The range of cells being searched
         * @param mixed $index_number The column number in table_array from which the matching value must be returned. The first column is 1.
         * @param mixed $not_exact_match determines if you are looking for an exact match based on lookup_value
         *
         * @return mixed The value of the found cell
         */
        public static function VLOOKUP($lookup_value, $lookup_array, $index_number, $not_exact_match = true)
        {
        }
        /**
         * HLOOKUP
         * The HLOOKUP function searches for value in the top-most row of lookup_array and returns the value in the same column based on the index_number.
         *
         * @param mixed $lookup_value The value that you want to match in lookup_array
         * @param mixed $lookup_array The range of cells being searched
         * @param mixed $index_number The row number in table_array from which the matching value must be returned. The first row is 1.
         * @param mixed $not_exact_match determines if you are looking for an exact match based on lookup_value
         *
         * @return mixed The value of the found cell
         */
        public static function HLOOKUP($lookup_value, $lookup_array, $index_number, $not_exact_match = true)
        {
        }
        /**
         * LOOKUP
         * The LOOKUP function searches for value either from a one-row or one-column range or from an array.
         *
         * @param mixed $lookup_value The value that you want to match in lookup_array
         * @param mixed $lookup_vector The range of cells being searched
         * @param null|mixed $result_vector The column from which the matching value must be returned
         *
         * @return mixed The value of the found cell
         */
        public static function LOOKUP($lookup_value, $lookup_vector, $result_vector = null)
        {
        }
        /**
         * FORMULATEXT.
         *
         * @param mixed $cellReference The cell to check
         * @param Cell $pCell The current cell (containing this formula)
         *
         * @return string
         */
        public static function FORMULATEXT($cellReference = '', ?\PhpOffice\PhpSpreadsheet\Cell\Cell $pCell = null)
        {
        }
    }
    class Database
    {
        /**
         * fieldExtract.
         *
         * Extracts the column ID to use for the data field.
         *
         * @param mixed[] $database The range of cells that makes up the list or database.
         *                                        A database is a list of related data in which rows of related
         *                                        information are records, and columns of data are fields. The
         *                                        first row of the list contains labels for each column.
         * @param mixed $field Indicates which column is used in the function. Enter the
         *                                        column label enclosed between double quotation marks, such as
         *                                        "Age" or "Yield," or a number (without quotation marks) that
         *                                        represents the position of the column within the list: 1 for
         *                                        the first column, 2 for the second column, and so on.
         *
         * @return null|string
         */
        private static function fieldExtract($database, $field)
        {
        }
        /**
         * filter.
         *
         * Parses the selection criteria, extracts the database rows that match those criteria, and
         * returns that subset of rows.
         *
         * @param mixed[] $database The range of cells that makes up the list or database.
         *                                        A database is a list of related data in which rows of related
         *                                        information are records, and columns of data are fields. The
         *                                        first row of the list contains labels for each column.
         * @param mixed[] $criteria The range of cells that contains the conditions you specify.
         *                                        You can use any range for the criteria argument, as long as it
         *                                        includes at least one column label and at least one cell below
         *                                        the column label in which you specify a condition for the
         *                                        column.
         *
         * @return array of mixed
         */
        private static function filter($database, $criteria)
        {
        }
        private static function getFilteredColumn($database, $field, $criteria)
        {
        }
        /**
         * DAVERAGE.
         *
         * Averages the values in a column of a list or database that match conditions you specify.
         *
         * Excel Function:
         *        DAVERAGE(database,field,criteria)
         *
         * @param mixed[] $database The range of cells that makes up the list or database.
         *                                        A database is a list of related data in which rows of related
         *                                        information are records, and columns of data are fields. The
         *                                        first row of the list contains labels for each column.
         * @param int|string $field Indicates which column is used in the function. Enter the
         *                                        column label enclosed between double quotation marks, such as
         *                                        "Age" or "Yield," or a number (without quotation marks) that
         *                                        represents the position of the column within the list: 1 for
         *                                        the first column, 2 for the second column, and so on.
         * @param mixed[] $criteria The range of cells that contains the conditions you specify.
         *                                        You can use any range for the criteria argument, as long as it
         *                                        includes at least one column label and at least one cell below
         *                                        the column label in which you specify a condition for the
         *                                        column.
         *
         * @return float|string
         */
        public static function DAVERAGE($database, $field, $criteria)
        {
        }
        /**
         * DCOUNT.
         *
         * Counts the cells that contain numbers in a column of a list or database that match conditions
         * that you specify.
         *
         * Excel Function:
         *        DCOUNT(database,[field],criteria)
         *
         * Excel Function:
         *        DAVERAGE(database,field,criteria)
         *
         * @param mixed[] $database The range of cells that makes up the list or database.
         *                                        A database is a list of related data in which rows of related
         *                                        information are records, and columns of data are fields. The
         *                                        first row of the list contains labels for each column.
         * @param int|string $field Indicates which column is used in the function. Enter the
         *                                        column label enclosed between double quotation marks, such as
         *                                        "Age" or "Yield," or a number (without quotation marks) that
         *                                        represents the position of the column within the list: 1 for
         *                                        the first column, 2 for the second column, and so on.
         * @param mixed[] $criteria The range of cells that contains the conditions you specify.
         *                                        You can use any range for the criteria argument, as long as it
         *                                        includes at least one column label and at least one cell below
         *                                        the column label in which you specify a condition for the
         *                                        column.
         *
         * @return int
         *
         * @TODO    The field argument is optional. If field is omitted, DCOUNT counts all records in the
         *            database that match the criteria.
         */
        public static function DCOUNT($database, $field, $criteria)
        {
        }
        /**
         * DCOUNTA.
         *
         * Counts the nonblank cells in a column of a list or database that match conditions that you specify.
         *
         * Excel Function:
         *        DCOUNTA(database,[field],criteria)
         *
         * @param mixed[] $database The range of cells that makes up the list or database.
         *                                        A database is a list of related data in which rows of related
         *                                        information are records, and columns of data are fields. The
         *                                        first row of the list contains labels for each column.
         * @param int|string $field Indicates which column is used in the function. Enter the
         *                                        column label enclosed between double quotation marks, such as
         *                                        "Age" or "Yield," or a number (without quotation marks) that
         *                                        represents the position of the column within the list: 1 for
         *                                        the first column, 2 for the second column, and so on.
         * @param mixed[] $criteria The range of cells that contains the conditions you specify.
         *                                        You can use any range for the criteria argument, as long as it
         *                                        includes at least one column label and at least one cell below
         *                                        the column label in which you specify a condition for the
         *                                        column.
         *
         * @return int
         *
         * @TODO    The field argument is optional. If field is omitted, DCOUNTA counts all records in the
         *            database that match the criteria.
         */
        public static function DCOUNTA($database, $field, $criteria)
        {
        }
        /**
         * DGET.
         *
         * Extracts a single value from a column of a list or database that matches conditions that you
         * specify.
         *
         * Excel Function:
         *        DGET(database,field,criteria)
         *
         * @param mixed[] $database The range of cells that makes up the list or database.
         *                                        A database is a list of related data in which rows of related
         *                                        information are records, and columns of data are fields. The
         *                                        first row of the list contains labels for each column.
         * @param int|string $field Indicates which column is used in the function. Enter the
         *                                        column label enclosed between double quotation marks, such as
         *                                        "Age" or "Yield," or a number (without quotation marks) that
         *                                        represents the position of the column within the list: 1 for
         *                                        the first column, 2 for the second column, and so on.
         * @param mixed[] $criteria The range of cells that contains the conditions you specify.
         *                                        You can use any range for the criteria argument, as long as it
         *                                        includes at least one column label and at least one cell below
         *                                        the column label in which you specify a condition for the
         *                                        column.
         *
         * @return mixed
         */
        public static function DGET($database, $field, $criteria)
        {
        }
        /**
         * DMAX.
         *
         * Returns the largest number in a column of a list or database that matches conditions you that
         * specify.
         *
         * Excel Function:
         *        DMAX(database,field,criteria)
         *
         * @param mixed[] $database The range of cells that makes up the list or database.
         *                                        A database is a list of related data in which rows of related
         *                                        information are records, and columns of data are fields. The
         *                                        first row of the list contains labels for each column.
         * @param int|string $field Indicates which column is used in the function. Enter the
         *                                        column label enclosed between double quotation marks, such as
         *                                        "Age" or "Yield," or a number (without quotation marks) that
         *                                        represents the position of the column within the list: 1 for
         *                                        the first column, 2 for the second column, and so on.
         * @param mixed[] $criteria The range of cells that contains the conditions you specify.
         *                                        You can use any range for the criteria argument, as long as it
         *                                        includes at least one column label and at least one cell below
         *                                        the column label in which you specify a condition for the
         *                                        column.
         *
         * @return float
         */
        public static function DMAX($database, $field, $criteria)
        {
        }
        /**
         * DMIN.
         *
         * Returns the smallest number in a column of a list or database that matches conditions you that
         * specify.
         *
         * Excel Function:
         *        DMIN(database,field,criteria)
         *
         * @param mixed[] $database The range of cells that makes up the list or database.
         *                                        A database is a list of related data in which rows of related
         *                                        information are records, and columns of data are fields. The
         *                                        first row of the list contains labels for each column.
         * @param int|string $field Indicates which column is used in the function. Enter the
         *                                        column label enclosed between double quotation marks, such as
         *                                        "Age" or "Yield," or a number (without quotation marks) that
         *                                        represents the position of the column within the list: 1 for
         *                                        the first column, 2 for the second column, and so on.
         * @param mixed[] $criteria The range of cells that contains the conditions you specify.
         *                                        You can use any range for the criteria argument, as long as it
         *                                        includes at least one column label and at least one cell below
         *                                        the column label in which you specify a condition for the
         *                                        column.
         *
         * @return float
         */
        public static function DMIN($database, $field, $criteria)
        {
        }
        /**
         * DPRODUCT.
         *
         * Multiplies the values in a column of a list or database that match conditions that you specify.
         *
         * Excel Function:
         *        DPRODUCT(database,field,criteria)
         *
         * @param mixed[] $database The range of cells that makes up the list or database.
         *                                        A database is a list of related data in which rows of related
         *                                        information are records, and columns of data are fields. The
         *                                        first row of the list contains labels for each column.
         * @param int|string $field Indicates which column is used in the function. Enter the
         *                                        column label enclosed between double quotation marks, such as
         *                                        "Age" or "Yield," or a number (without quotation marks) that
         *                                        represents the position of the column within the list: 1 for
         *                                        the first column, 2 for the second column, and so on.
         * @param mixed[] $criteria The range of cells that contains the conditions you specify.
         *                                        You can use any range for the criteria argument, as long as it
         *                                        includes at least one column label and at least one cell below
         *                                        the column label in which you specify a condition for the
         *                                        column.
         *
         * @return float
         */
        public static function DPRODUCT($database, $field, $criteria)
        {
        }
        /**
         * DSTDEV.
         *
         * Estimates the standard deviation of a population based on a sample by using the numbers in a
         * column of a list or database that match conditions that you specify.
         *
         * Excel Function:
         *        DSTDEV(database,field,criteria)
         *
         * @param mixed[] $database The range of cells that makes up the list or database.
         *                                        A database is a list of related data in which rows of related
         *                                        information are records, and columns of data are fields. The
         *                                        first row of the list contains labels for each column.
         * @param int|string $field Indicates which column is used in the function. Enter the
         *                                        column label enclosed between double quotation marks, such as
         *                                        "Age" or "Yield," or a number (without quotation marks) that
         *                                        represents the position of the column within the list: 1 for
         *                                        the first column, 2 for the second column, and so on.
         * @param mixed[] $criteria The range of cells that contains the conditions you specify.
         *                                        You can use any range for the criteria argument, as long as it
         *                                        includes at least one column label and at least one cell below
         *                                        the column label in which you specify a condition for the
         *                                        column.
         *
         * @return float|string
         */
        public static function DSTDEV($database, $field, $criteria)
        {
        }
        /**
         * DSTDEVP.
         *
         * Calculates the standard deviation of a population based on the entire population by using the
         * numbers in a column of a list or database that match conditions that you specify.
         *
         * Excel Function:
         *        DSTDEVP(database,field,criteria)
         *
         * @param mixed[] $database The range of cells that makes up the list or database.
         *                                        A database is a list of related data in which rows of related
         *                                        information are records, and columns of data are fields. The
         *                                        first row of the list contains labels for each column.
         * @param int|string $field Indicates which column is used in the function. Enter the
         *                                        column label enclosed between double quotation marks, such as
         *                                        "Age" or "Yield," or a number (without quotation marks) that
         *                                        represents the position of the column within the list: 1 for
         *                                        the first column, 2 for the second column, and so on.
         * @param mixed[] $criteria The range of cells that contains the conditions you specify.
         *                                        You can use any range for the criteria argument, as long as it
         *                                        includes at least one column label and at least one cell below
         *                                        the column label in which you specify a condition for the
         *                                        column.
         *
         * @return float|string
         */
        public static function DSTDEVP($database, $field, $criteria)
        {
        }
        /**
         * DSUM.
         *
         * Adds the numbers in a column of a list or database that match conditions that you specify.
         *
         * Excel Function:
         *        DSUM(database,field,criteria)
         *
         * @param mixed[] $database The range of cells that makes up the list or database.
         *                                        A database is a list of related data in which rows of related
         *                                        information are records, and columns of data are fields. The
         *                                        first row of the list contains labels for each column.
         * @param int|string $field Indicates which column is used in the function. Enter the
         *                                        column label enclosed between double quotation marks, such as
         *                                        "Age" or "Yield," or a number (without quotation marks) that
         *                                        represents the position of the column within the list: 1 for
         *                                        the first column, 2 for the second column, and so on.
         * @param mixed[] $criteria The range of cells that contains the conditions you specify.
         *                                        You can use any range for the criteria argument, as long as it
         *                                        includes at least one column label and at least one cell below
         *                                        the column label in which you specify a condition for the
         *                                        column.
         *
         * @return float
         */
        public static function DSUM($database, $field, $criteria)
        {
        }
        /**
         * DVAR.
         *
         * Estimates the variance of a population based on a sample by using the numbers in a column
         * of a list or database that match conditions that you specify.
         *
         * Excel Function:
         *        DVAR(database,field,criteria)
         *
         * @param mixed[] $database The range of cells that makes up the list or database.
         *                                        A database is a list of related data in which rows of related
         *                                        information are records, and columns of data are fields. The
         *                                        first row of the list contains labels for each column.
         * @param int|string $field Indicates which column is used in the function. Enter the
         *                                        column label enclosed between double quotation marks, such as
         *                                        "Age" or "Yield," or a number (without quotation marks) that
         *                                        represents the position of the column within the list: 1 for
         *                                        the first column, 2 for the second column, and so on.
         * @param mixed[] $criteria The range of cells that contains the conditions you specify.
         *                                        You can use any range for the criteria argument, as long as it
         *                                        includes at least one column label and at least one cell below
         *                                        the column label in which you specify a condition for the
         *                                        column.
         *
         * @return float
         */
        public static function DVAR($database, $field, $criteria)
        {
        }
        /**
         * DVARP.
         *
         * Calculates the variance of a population based on the entire population by using the numbers
         * in a column of a list or database that match conditions that you specify.
         *
         * Excel Function:
         *        DVARP(database,field,criteria)
         *
         * @param mixed[] $database The range of cells that makes up the list or database.
         *                                        A database is a list of related data in which rows of related
         *                                        information are records, and columns of data are fields. The
         *                                        first row of the list contains labels for each column.
         * @param int|string $field Indicates which column is used in the function. Enter the
         *                                        column label enclosed between double quotation marks, such as
         *                                        "Age" or "Yield," or a number (without quotation marks) that
         *                                        represents the position of the column within the list: 1 for
         *                                        the first column, 2 for the second column, and so on.
         * @param mixed[] $criteria The range of cells that contains the conditions you specify.
         *                                        You can use any range for the criteria argument, as long as it
         *                                        includes at least one column label and at least one cell below
         *                                        the column label in which you specify a condition for the
         *                                        column.
         *
         * @return float
         */
        public static function DVARP($database, $field, $criteria)
        {
        }
    }
    class DateTime
    {
        /**
         * Identify if a year is a leap year or not.
         *
         * @param int|string $year The year to test
         *
         * @return bool TRUE if the year is a leap year, otherwise FALSE
         */
        public static function isLeapYear($year)
        {
        }
        /**
         * Return the number of days between two dates based on a 360 day calendar.
         *
         * @param int $startDay Day of month of the start date
         * @param int $startMonth Month of the start date
         * @param int $startYear Year of the start date
         * @param int $endDay Day of month of the start date
         * @param int $endMonth Month of the start date
         * @param int $endYear Year of the start date
         * @param bool $methodUS Whether to use the US method or the European method of calculation
         *
         * @return int Number of days between the start date and the end date
         */
        private static function dateDiff360($startDay, $startMonth, $startYear, $endDay, $endMonth, $endYear, $methodUS)
        {
        }
        /**
         * getDateValue.
         *
         * @param mixed $dateValue
         *
         * @return mixed Excel date/time serial value, or string if error
         */
        public static function getDateValue($dateValue)
        {
        }
        /**
         * getTimeValue.
         *
         * @param string $timeValue
         *
         * @return mixed Excel date/time serial value, or string if error
         */
        private static function getTimeValue($timeValue)
        {
        }
        private static function adjustDateByMonths($dateValue = 0, $adjustmentMonths = 0)
        {
        }
        /**
         * DATETIMENOW.
         *
         * Returns the current date and time.
         * The NOW function is useful when you need to display the current date and time on a worksheet or
         * calculate a value based on the current date and time, and have that value updated each time you
         * open the worksheet.
         *
         * NOTE: When used in a Cell Formula, MS Excel changes the cell format so that it matches the date
         * and time format of your regional settings. PhpSpreadsheet does not change cell formatting in this way.
         *
         * Excel Function:
         *        NOW()
         *
         * @return mixed Excel date/time serial value, PHP date/time serial value or PHP date/time object,
         *                        depending on the value of the ReturnDateType flag
         */
        public static function DATETIMENOW()
        {
        }
        /**
         * DATENOW.
         *
         * Returns the current date.
         * The NOW function is useful when you need to display the current date and time on a worksheet or
         * calculate a value based on the current date and time, and have that value updated each time you
         * open the worksheet.
         *
         * NOTE: When used in a Cell Formula, MS Excel changes the cell format so that it matches the date
         * and time format of your regional settings. PhpSpreadsheet does not change cell formatting in this way.
         *
         * Excel Function:
         *        TODAY()
         *
         * @return mixed Excel date/time serial value, PHP date/time serial value or PHP date/time object,
         *                        depending on the value of the ReturnDateType flag
         */
        public static function DATENOW()
        {
        }
        /**
         * DATE.
         *
         * The DATE function returns a value that represents a particular date.
         *
         * NOTE: When used in a Cell Formula, MS Excel changes the cell format so that it matches the date
         * format of your regional settings. PhpSpreadsheet does not change cell formatting in this way.
         *
         * Excel Function:
         *        DATE(year,month,day)
         *
         * PhpSpreadsheet is a lot more forgiving than MS Excel when passing non numeric values to this function.
         * A Month name or abbreviation (English only at this point) such as 'January' or 'Jan' will still be accepted,
         *     as will a day value with a suffix (e.g. '21st' rather than simply 21); again only English language.
         *
         * @param int $year The value of the year argument can include one to four digits.
         *                                Excel interprets the year argument according to the configured
         *                                date system: 1900 or 1904.
         *                                If year is between 0 (zero) and 1899 (inclusive), Excel adds that
         *                                value to 1900 to calculate the year. For example, DATE(108,1,2)
         *                                returns January 2, 2008 (1900+108).
         *                                If year is between 1900 and 9999 (inclusive), Excel uses that
         *                                value as the year. For example, DATE(2008,1,2) returns January 2,
         *                                2008.
         *                                If year is less than 0 or is 10000 or greater, Excel returns the
         *                                #NUM! error value.
         * @param int $month A positive or negative integer representing the month of the year
         *                                from 1 to 12 (January to December).
         *                                If month is greater than 12, month adds that number of months to
         *                                the first month in the year specified. For example, DATE(2008,14,2)
         *                                returns the serial number representing February 2, 2009.
         *                                If month is less than 1, month subtracts the magnitude of that
         *                                number of months, plus 1, from the first month in the year
         *                                specified. For example, DATE(2008,-3,2) returns the serial number
         *                                representing September 2, 2007.
         * @param int $day A positive or negative integer representing the day of the month
         *                                from 1 to 31.
         *                                If day is greater than the number of days in the month specified,
         *                                day adds that number of days to the first day in the month. For
         *                                example, DATE(2008,1,35) returns the serial number representing
         *                                February 4, 2008.
         *                                If day is less than 1, day subtracts the magnitude that number of
         *                                days, plus one, from the first day of the month specified. For
         *                                example, DATE(2008,1,-15) returns the serial number representing
         *                                December 16, 2007.
         *
         * @return mixed Excel date/time serial value, PHP date/time serial value or PHP date/time object,
         *                        depending on the value of the ReturnDateType flag
         */
        public static function DATE($year = 0, $month = 1, $day = 1)
        {
        }
        /**
         * TIME.
         *
         * The TIME function returns a value that represents a particular time.
         *
         * NOTE: When used in a Cell Formula, MS Excel changes the cell format so that it matches the time
         * format of your regional settings. PhpSpreadsheet does not change cell formatting in this way.
         *
         * Excel Function:
         *        TIME(hour,minute,second)
         *
         * @param int $hour A number from 0 (zero) to 32767 representing the hour.
         *                                    Any value greater than 23 will be divided by 24 and the remainder
         *                                    will be treated as the hour value. For example, TIME(27,0,0) =
         *                                    TIME(3,0,0) = .125 or 3:00 AM.
         * @param int $minute A number from 0 to 32767 representing the minute.
         *                                    Any value greater than 59 will be converted to hours and minutes.
         *                                    For example, TIME(0,750,0) = TIME(12,30,0) = .520833 or 12:30 PM.
         * @param int $second A number from 0 to 32767 representing the second.
         *                                    Any value greater than 59 will be converted to hours, minutes,
         *                                    and seconds. For example, TIME(0,0,2000) = TIME(0,33,22) = .023148
         *                                    or 12:33:20 AM
         *
         * @return mixed Excel date/time serial value, PHP date/time serial value or PHP date/time object,
         *                        depending on the value of the ReturnDateType flag
         */
        public static function TIME($hour = 0, $minute = 0, $second = 0)
        {
        }
        /**
         * DATEVALUE.
         *
         * Returns a value that represents a particular date.
         * Use DATEVALUE to convert a date represented by a text string to an Excel or PHP date/time stamp
         * value.
         *
         * NOTE: When used in a Cell Formula, MS Excel changes the cell format so that it matches the date
         * format of your regional settings. PhpSpreadsheet does not change cell formatting in this way.
         *
         * Excel Function:
         *        DATEVALUE(dateValue)
         *
         * @param string $dateValue Text that represents a date in a Microsoft Excel date format.
         *                                    For example, "1/30/2008" or "30-Jan-2008" are text strings within
         *                                    quotation marks that represent dates. Using the default date
         *                                    system in Excel for Windows, date_text must represent a date from
         *                                    January 1, 1900, to December 31, 9999. Using the default date
         *                                    system in Excel for the Macintosh, date_text must represent a date
         *                                    from January 1, 1904, to December 31, 9999. DATEVALUE returns the
         *                                    #VALUE! error value if date_text is out of this range.
         *
         * @return mixed Excel date/time serial value, PHP date/time serial value or PHP date/time object,
         *                        depending on the value of the ReturnDateType flag
         */
        public static function DATEVALUE($dateValue = 1)
        {
        }
        /**
         * TIMEVALUE.
         *
         * Returns a value that represents a particular time.
         * Use TIMEVALUE to convert a time represented by a text string to an Excel or PHP date/time stamp
         * value.
         *
         * NOTE: When used in a Cell Formula, MS Excel changes the cell format so that it matches the time
         * format of your regional settings. PhpSpreadsheet does not change cell formatting in this way.
         *
         * Excel Function:
         *        TIMEVALUE(timeValue)
         *
         * @param string $timeValue A text string that represents a time in any one of the Microsoft
         *                                    Excel time formats; for example, "6:45 PM" and "18:45" text strings
         *                                    within quotation marks that represent time.
         *                                    Date information in time_text is ignored.
         *
         * @return mixed Excel date/time serial value, PHP date/time serial value or PHP date/time object,
         *                        depending on the value of the ReturnDateType flag
         */
        public static function TIMEVALUE($timeValue)
        {
        }
        /**
         * DATEDIF.
         *
         * @param mixed $startDate Excel date serial value, PHP date/time stamp, PHP DateTime object
         *                                    or a standard date string
         * @param mixed $endDate Excel date serial value, PHP date/time stamp, PHP DateTime object
         *                                    or a standard date string
         * @param string $unit
         *
         * @return int|string Interval between the dates
         */
        public static function DATEDIF($startDate = 0, $endDate = 0, $unit = 'D')
        {
        }
        /**
         * DAYS.
         *
         * Returns the number of days between two dates
         *
         * Excel Function:
         *        DAYS(endDate, startDate)
         *
         * @param DateTimeImmutable|float|int|string $endDate Excel date serial value (float),
         * PHP date timestamp (integer), PHP DateTime object, or a standard date string
         * @param DateTimeImmutable|float|int|string $startDate Excel date serial value (float),
         * PHP date timestamp (integer), PHP DateTime object, or a standard date string
         *
         * @return int|string Number of days between start date and end date or an error
         */
        public static function DAYS($endDate = 0, $startDate = 0)
        {
        }
        /**
         * DAYS360.
         *
         * Returns the number of days between two dates based on a 360-day year (twelve 30-day months),
         * which is used in some accounting calculations. Use this function to help compute payments if
         * your accounting system is based on twelve 30-day months.
         *
         * Excel Function:
         *        DAYS360(startDate,endDate[,method])
         *
         * @param mixed $startDate Excel date serial value (float), PHP date timestamp (integer),
         *                                        PHP DateTime object, or a standard date string
         * @param mixed $endDate Excel date serial value (float), PHP date timestamp (integer),
         *                                        PHP DateTime object, or a standard date string
         * @param bool $method US or European Method
         *                                        FALSE or omitted: U.S. (NASD) method. If the starting date is
         *                                        the last day of a month, it becomes equal to the 30th of the
         *                                        same month. If the ending date is the last day of a month and
         *                                        the starting date is earlier than the 30th of a month, the
         *                                        ending date becomes equal to the 1st of the next month;
         *                                        otherwise the ending date becomes equal to the 30th of the
         *                                        same month.
         *                                        TRUE: European method. Starting dates and ending dates that
         *                                        occur on the 31st of a month become equal to the 30th of the
         *                                        same month.
         *
         * @return int|string Number of days between start date and end date
         */
        public static function DAYS360($startDate = 0, $endDate = 0, $method = false)
        {
        }
        /**
         * YEARFRAC.
         *
         * Calculates the fraction of the year represented by the number of whole days between two dates
         * (the start_date and the end_date).
         * Use the YEARFRAC worksheet function to identify the proportion of a whole year's benefits or
         * obligations to assign to a specific term.
         *
         * Excel Function:
         *        YEARFRAC(startDate,endDate[,method])
         * See https://lists.oasis-open.org/archives/office-formula/200806/msg00039.html
         *     for description of algorithm used in Excel
         *
         * @param mixed $startDate Excel date serial value (float), PHP date timestamp (integer),
         *                                    PHP DateTime object, or a standard date string
         * @param mixed $endDate Excel date serial value (float), PHP date timestamp (integer),
         *                                    PHP DateTime object, or a standard date string
         * @param int $method Method used for the calculation
         *                                        0 or omitted    US (NASD) 30/360
         *                                        1                Actual/actual
         *                                        2                Actual/360
         *                                        3                Actual/365
         *                                        4                European 30/360
         *
         * @return float|string fraction of the year, or a string containing an error
         */
        public static function YEARFRAC($startDate = 0, $endDate = 0, $method = 0)
        {
        }
        /**
         * NETWORKDAYS.
         *
         * Returns the number of whole working days between start_date and end_date. Working days
         * exclude weekends and any dates identified in holidays.
         * Use NETWORKDAYS to calculate employee benefits that accrue based on the number of days
         * worked during a specific term.
         *
         * Excel Function:
         *        NETWORKDAYS(startDate,endDate[,holidays[,holiday[,...]]])
         *
         * @param mixed $startDate Excel date serial value (float), PHP date timestamp (integer),
         *                                            PHP DateTime object, or a standard date string
         * @param mixed $endDate Excel date serial value (float), PHP date timestamp (integer),
         *                                            PHP DateTime object, or a standard date string
         *
         * @return int|string Interval between the dates
         */
        public static function NETWORKDAYS($startDate, $endDate, ...$dateArgs)
        {
        }
        /**
         * WORKDAY.
         *
         * Returns the date that is the indicated number of working days before or after a date (the
         * starting date). Working days exclude weekends and any dates identified as holidays.
         * Use WORKDAY to exclude weekends or holidays when you calculate invoice due dates, expected
         * delivery times, or the number of days of work performed.
         *
         * Excel Function:
         *        WORKDAY(startDate,endDays[,holidays[,holiday[,...]]])
         *
         * @param mixed $startDate Excel date serial value (float), PHP date timestamp (integer),
         *                                        PHP DateTime object, or a standard date string
         * @param int $endDays The number of nonweekend and nonholiday days before or after
         *                                        startDate. A positive value for days yields a future date; a
         *                                        negative value yields a past date.
         *
         * @return mixed Excel date/time serial value, PHP date/time serial value or PHP date/time object,
         *                        depending on the value of the ReturnDateType flag
         */
        public static function WORKDAY($startDate, $endDays, ...$dateArgs)
        {
        }
        /**
         * DAYOFMONTH.
         *
         * Returns the day of the month, for a specified date. The day is given as an integer
         * ranging from 1 to 31.
         *
         * Excel Function:
         *        DAY(dateValue)
         *
         * @param mixed $dateValue Excel date serial value (float), PHP date timestamp (integer),
         *                                    PHP DateTime object, or a standard date string
         *
         * @return int|string Day of the month
         */
        public static function DAYOFMONTH($dateValue = 1)
        {
        }
        /**
         * WEEKDAY.
         *
         * Returns the day of the week for a specified date. The day is given as an integer
         * ranging from 0 to 7 (dependent on the requested style).
         *
         * Excel Function:
         *        WEEKDAY(dateValue[,style])
         *
         * @param int $dateValue Excel date serial value (float), PHP date timestamp (integer),
         *                                    PHP DateTime object, or a standard date string
         * @param int $style A number that determines the type of return value
         *                                        1 or omitted    Numbers 1 (Sunday) through 7 (Saturday).
         *                                        2                Numbers 1 (Monday) through 7 (Sunday).
         *                                        3                Numbers 0 (Monday) through 6 (Sunday).
         *
         * @return int|string Day of the week value
         */
        public static function WEEKDAY($dateValue = 1, $style = 1)
        {
        }
        const STARTWEEK_SUNDAY = 1;
        const STARTWEEK_MONDAY = 2;
        const STARTWEEK_MONDAY_ALT = 11;
        const STARTWEEK_TUESDAY = 12;
        const STARTWEEK_WEDNESDAY = 13;
        const STARTWEEK_THURSDAY = 14;
        const STARTWEEK_FRIDAY = 15;
        const STARTWEEK_SATURDAY = 16;
        const STARTWEEK_SUNDAY_ALT = 17;
        const DOW_SUNDAY = 1;
        const DOW_MONDAY = 2;
        const DOW_TUESDAY = 3;
        const DOW_WEDNESDAY = 4;
        const DOW_THURSDAY = 5;
        const DOW_FRIDAY = 6;
        const DOW_SATURDAY = 7;
        const STARTWEEK_MONDAY_ISO = 21;
        const METHODARR = [self::STARTWEEK_SUNDAY => self::DOW_SUNDAY, self::DOW_MONDAY, self::STARTWEEK_MONDAY_ALT => self::DOW_MONDAY, self::DOW_TUESDAY, self::DOW_WEDNESDAY, self::DOW_THURSDAY, self::DOW_FRIDAY, self::DOW_SATURDAY, self::DOW_SUNDAY, self::STARTWEEK_MONDAY_ISO => self::STARTWEEK_MONDAY_ISO];
        /**
         * WEEKNUM.
         *
         * Returns the week of the year for a specified date.
         * The WEEKNUM function considers the week containing January 1 to be the first week of the year.
         * However, there is a European standard that defines the first week as the one with the majority
         * of days (four or more) falling in the new year. This means that for years in which there are
         * three days or less in the first week of January, the WEEKNUM function returns week numbers
         * that are incorrect according to the European standard.
         *
         * Excel Function:
         *        WEEKNUM(dateValue[,style])
         *
         * @param mixed $dateValue Excel date serial value (float), PHP date timestamp (integer),
         *                                    PHP DateTime object, or a standard date string
         * @param int $method Week begins on Sunday or Monday
         *                                        1 or omitted    Week begins on Sunday.
         *                                        2                Week begins on Monday.
         *                                        11               Week begins on Monday.
         *                                        12               Week begins on Tuesday.
         *                                        13               Week begins on Wednesday.
         *                                        14               Week begins on Thursday.
         *                                        15               Week begins on Friday.
         *                                        16               Week begins on Saturday.
         *                                        17               Week begins on Sunday.
         *                                        21               ISO (Jan. 4 is week 1, begins on Monday).
         *
         * @return int|string Week Number
         */
        public static function WEEKNUM($dateValue = 1, $method = self::STARTWEEK_SUNDAY)
        {
        }
        /**
         * ISOWEEKNUM.
         *
         * Returns the ISO 8601 week number of the year for a specified date.
         *
         * Excel Function:
         *        ISOWEEKNUM(dateValue)
         *
         * @param mixed $dateValue Excel date serial value (float), PHP date timestamp (integer),
         *                                    PHP DateTime object, or a standard date string
         *
         * @return int|string Week Number
         */
        public static function ISOWEEKNUM($dateValue = 1)
        {
        }
        /**
         * MONTHOFYEAR.
         *
         * Returns the month of a date represented by a serial number.
         * The month is given as an integer, ranging from 1 (January) to 12 (December).
         *
         * Excel Function:
         *        MONTH(dateValue)
         *
         * @param mixed $dateValue Excel date serial value (float), PHP date timestamp (integer),
         *                                    PHP DateTime object, or a standard date string
         *
         * @return int|string Month of the year
         */
        public static function MONTHOFYEAR($dateValue = 1)
        {
        }
        /**
         * YEAR.
         *
         * Returns the year corresponding to a date.
         * The year is returned as an integer in the range 1900-9999.
         *
         * Excel Function:
         *        YEAR(dateValue)
         *
         * @param mixed $dateValue Excel date serial value (float), PHP date timestamp (integer),
         *                                    PHP DateTime object, or a standard date string
         *
         * @return int|string Year
         */
        public static function YEAR($dateValue = 1)
        {
        }
        /**
         * HOUROFDAY.
         *
         * Returns the hour of a time value.
         * The hour is given as an integer, ranging from 0 (12:00 A.M.) to 23 (11:00 P.M.).
         *
         * Excel Function:
         *        HOUR(timeValue)
         *
         * @param mixed $timeValue Excel date serial value (float), PHP date timestamp (integer),
         *                                    PHP DateTime object, or a standard time string
         *
         * @return int|string Hour
         */
        public static function HOUROFDAY($timeValue = 0)
        {
        }
        /**
         * MINUTE.
         *
         * Returns the minutes of a time value.
         * The minute is given as an integer, ranging from 0 to 59.
         *
         * Excel Function:
         *        MINUTE(timeValue)
         *
         * @param mixed $timeValue Excel date serial value (float), PHP date timestamp (integer),
         *                                    PHP DateTime object, or a standard time string
         *
         * @return int|string Minute
         */
        public static function MINUTE($timeValue = 0)
        {
        }
        /**
         * SECOND.
         *
         * Returns the seconds of a time value.
         * The second is given as an integer in the range 0 (zero) to 59.
         *
         * Excel Function:
         *        SECOND(timeValue)
         *
         * @param mixed $timeValue Excel date serial value (float), PHP date timestamp (integer),
         *                                    PHP DateTime object, or a standard time string
         *
         * @return int|string Second
         */
        public static function SECOND($timeValue = 0)
        {
        }
        /**
         * EDATE.
         *
         * Returns the serial number that represents the date that is the indicated number of months
         * before or after a specified date (the start_date).
         * Use EDATE to calculate maturity dates or due dates that fall on the same day of the month
         * as the date of issue.
         *
         * Excel Function:
         *        EDATE(dateValue,adjustmentMonths)
         *
         * @param mixed $dateValue Excel date serial value (float), PHP date timestamp (integer),
         *                                        PHP DateTime object, or a standard date string
         * @param int $adjustmentMonths The number of months before or after start_date.
         *                                        A positive value for months yields a future date;
         *                                        a negative value yields a past date.
         *
         * @return mixed Excel date/time serial value, PHP date/time serial value or PHP date/time object,
         *                        depending on the value of the ReturnDateType flag
         */
        public static function EDATE($dateValue = 1, $adjustmentMonths = 0)
        {
        }
        /**
         * EOMONTH.
         *
         * Returns the date value for the last day of the month that is the indicated number of months
         * before or after start_date.
         * Use EOMONTH to calculate maturity dates or due dates that fall on the last day of the month.
         *
         * Excel Function:
         *        EOMONTH(dateValue,adjustmentMonths)
         *
         * @param mixed $dateValue Excel date serial value (float), PHP date timestamp (integer),
         *                                        PHP DateTime object, or a standard date string
         * @param int $adjustmentMonths The number of months before or after start_date.
         *                                        A positive value for months yields a future date;
         *                                        a negative value yields a past date.
         *
         * @return mixed Excel date/time serial value, PHP date/time serial value or PHP date/time object,
         *                        depending on the value of the ReturnDateType flag
         */
        public static function EOMONTH($dateValue = 1, $adjustmentMonths = 0)
        {
        }
    }
    class Functions
    {
        const PRECISION = 8.88E-16;
        /**
         * 2 / PI.
         */
        const M_2DIVPI = 0.6366197723675814;
        /** constants */
        const COMPATIBILITY_EXCEL = 'Excel';
        const COMPATIBILITY_GNUMERIC = 'Gnumeric';
        const COMPATIBILITY_OPENOFFICE = 'OpenOfficeCalc';
        const RETURNDATE_PHP_NUMERIC = 'P';
        const RETURNDATE_UNIX_TIMESTAMP = 'P';
        const RETURNDATE_PHP_OBJECT = 'O';
        const RETURNDATE_PHP_DATETIME_OBJECT = 'O';
        const RETURNDATE_EXCEL = 'E';
        /**
         * Compatibility mode to use for error checking and responses.
         *
         * @var string
         */
        protected static $compatibilityMode = self::COMPATIBILITY_EXCEL;
        /**
         * Data Type to use when returning date values.
         *
         * @var string
         */
        protected static $returnDateType = self::RETURNDATE_EXCEL;
        /**
         * List of error codes.
         *
         * @var array
         */
        protected static $errorCodes = ['null' => '#NULL!', 'divisionbyzero' => '#DIV/0!', 'value' => '#VALUE!', 'reference' => '#REF!', 'name' => '#NAME?', 'num' => '#NUM!', 'na' => '#N/A', 'gettingdata' => '#GETTING_DATA'];
        /**
         * Set the Compatibility Mode.
         *
         * @param string $compatibilityMode Compatibility Mode
         *                                                Permitted values are:
         *                                                    Functions::COMPATIBILITY_EXCEL            'Excel'
         *                                                    Functions::COMPATIBILITY_GNUMERIC        'Gnumeric'
         *                                                    Functions::COMPATIBILITY_OPENOFFICE    'OpenOfficeCalc'
         *
         * @return bool (Success or Failure)
         */
        public static function setCompatibilityMode($compatibilityMode)
        {
        }
        /**
         * Return the current Compatibility Mode.
         *
         * @return string Compatibility Mode
         *                            Possible Return values are:
         *                                Functions::COMPATIBILITY_EXCEL            'Excel'
         *                                Functions::COMPATIBILITY_GNUMERIC        'Gnumeric'
         *                                Functions::COMPATIBILITY_OPENOFFICE    'OpenOfficeCalc'
         */
        public static function getCompatibilityMode()
        {
        }
        /**
         * Set the Return Date Format used by functions that return a date/time (Excel, PHP Serialized Numeric or PHP Object).
         *
         * @param string $returnDateType Return Date Format
         *                                                Permitted values are:
         *                                                    Functions::RETURNDATE_UNIX_TIMESTAMP        'P'
         *                                                    Functions::RETURNDATE_PHP_DATETIME_OBJECT        'O'
         *                                                    Functions::RETURNDATE_EXCEL            'E'
         *
         * @return bool Success or failure
         */
        public static function setReturnDateType($returnDateType)
        {
        }
        /**
         * Return the current Return Date Format for functions that return a date/time (Excel, PHP Serialized Numeric or PHP Object).
         *
         * @return string Return Date Format
         *                            Possible Return values are:
         *                                Functions::RETURNDATE_UNIX_TIMESTAMP        'P'
         *                                Functions::RETURNDATE_PHP_DATETIME_OBJECT        'O'
         *                                Functions::RETURNDATE_EXCEL            'E'
         */
        public static function getReturnDateType()
        {
        }
        /**
         * DUMMY.
         *
         * @return string #Not Yet Implemented
         */
        public static function DUMMY()
        {
        }
        /**
         * DIV0.
         *
         * @return string #Not Yet Implemented
         */
        public static function DIV0()
        {
        }
        /**
         * NA.
         *
         * Excel Function:
         *        =NA()
         *
         * Returns the error value #N/A
         *        #N/A is the error value that means "no value is available."
         *
         * @return string #N/A!
         */
        public static function NA()
        {
        }
        /**
         * NaN.
         *
         * Returns the error value #NUM!
         *
         * @return string #NUM!
         */
        public static function NAN()
        {
        }
        /**
         * NAME.
         *
         * Returns the error value #NAME?
         *
         * @return string #NAME?
         */
        public static function NAME()
        {
        }
        /**
         * REF.
         *
         * Returns the error value #REF!
         *
         * @return string #REF!
         */
        public static function REF()
        {
        }
        /**
         * NULL.
         *
         * Returns the error value #NULL!
         *
         * @return string #NULL!
         */
        public static function null()
        {
        }
        /**
         * VALUE.
         *
         * Returns the error value #VALUE!
         *
         * @return string #VALUE!
         */
        public static function VALUE()
        {
        }
        public static function isMatrixValue($idx)
        {
        }
        public static function isValue($idx)
        {
        }
        public static function isCellValue($idx)
        {
        }
        public static function ifCondition($condition)
        {
        }
        /**
         * ERROR_TYPE.
         *
         * @param mixed $value Value to check
         *
         * @return bool
         */
        public static function errorType($value = '')
        {
        }
        /**
         * IS_BLANK.
         *
         * @param mixed $value Value to check
         *
         * @return bool
         */
        public static function isBlank($value = null)
        {
        }
        /**
         * IS_ERR.
         *
         * @param mixed $value Value to check
         *
         * @return bool
         */
        public static function isErr($value = '')
        {
        }
        /**
         * IS_ERROR.
         *
         * @param mixed $value Value to check
         *
         * @return bool
         */
        public static function isError($value = '')
        {
        }
        /**
         * IS_NA.
         *
         * @param mixed $value Value to check
         *
         * @return bool
         */
        public static function isNa($value = '')
        {
        }
        /**
         * IS_EVEN.
         *
         * @param mixed $value Value to check
         *
         * @return bool|string
         */
        public static function isEven($value = null)
        {
        }
        /**
         * IS_ODD.
         *
         * @param mixed $value Value to check
         *
         * @return bool|string
         */
        public static function isOdd($value = null)
        {
        }
        /**
         * IS_NUMBER.
         *
         * @param mixed $value Value to check
         *
         * @return bool
         */
        public static function isNumber($value = null)
        {
        }
        /**
         * IS_LOGICAL.
         *
         * @param mixed $value Value to check
         *
         * @return bool
         */
        public static function isLogical($value = null)
        {
        }
        /**
         * IS_TEXT.
         *
         * @param mixed $value Value to check
         *
         * @return bool
         */
        public static function isText($value = null)
        {
        }
        /**
         * IS_NONTEXT.
         *
         * @param mixed $value Value to check
         *
         * @return bool
         */
        public static function isNonText($value = null)
        {
        }
        /**
         * N.
         *
         * Returns a value converted to a number
         *
         * @param null|mixed $value The value you want converted
         *
         * @return number N converts values listed in the following table
         *        If value is or refers to N returns
         *        A number            That number
         *        A date                The serial number of that date
         *        TRUE                1
         *        FALSE                0
         *        An error value        The error value
         *        Anything else        0
         */
        public static function n($value = null)
        {
        }
        /**
         * TYPE.
         *
         * Returns a number that identifies the type of a value
         *
         * @param null|mixed $value The value you want tested
         *
         * @return number N converts values listed in the following table
         *        If value is or refers to N returns
         *        A number            1
         *        Text                2
         *        Logical Value        4
         *        An error value        16
         *        Array or Matrix        64
         */
        public static function TYPE($value = null)
        {
        }
        /**
         * Convert a multi-dimensional array to a simple 1-dimensional array.
         *
         * @param array $array Array to be flattened
         *
         * @return array Flattened array
         */
        public static function flattenArray($array)
        {
        }
        /**
         * Convert a multi-dimensional array to a simple 1-dimensional array, but retain an element of indexing.
         *
         * @param array $array Array to be flattened
         *
         * @return array Flattened array
         */
        public static function flattenArrayIndexed($array)
        {
        }
        /**
         * Convert an array to a single scalar value by extracting the first element.
         *
         * @param mixed $value Array or scalar value
         *
         * @return mixed
         */
        public static function flattenSingleValue($value = '')
        {
        }
        /**
         * ISFORMULA.
         *
         * @param mixed $cellReference The cell to check
         * @param Cell $pCell The current cell (containing this formula)
         *
         * @return bool|string
         */
        public static function isFormula($cellReference = '', ?\PhpOffice\PhpSpreadsheet\Cell\Cell $pCell = null)
        {
        }
    }
    class ExceptionHandler
    {
        /**
         * Register errorhandler.
         */
        public function __construct()
        {
        }
        /**
         * Unregister errorhandler.
         */
        public function __destruct()
        {
        }
    }
    class Engineering
    {
        /**
         * EULER.
         */
        const EULER = 2.718281828459045;
        /**
         * Details of the Units of measure that can be used in CONVERTUOM().
         *
         * @var mixed[]
         */
        private static $conversionUnits = ['g' => ['Group' => 'Mass', 'Unit Name' => 'Gram', 'AllowPrefix' => true], 'sg' => ['Group' => 'Mass', 'Unit Name' => 'Slug', 'AllowPrefix' => false], 'lbm' => ['Group' => 'Mass', 'Unit Name' => 'Pound mass (avoirdupois)', 'AllowPrefix' => false], 'u' => ['Group' => 'Mass', 'Unit Name' => 'U (atomic mass unit)', 'AllowPrefix' => true], 'ozm' => ['Group' => 'Mass', 'Unit Name' => 'Ounce mass (avoirdupois)', 'AllowPrefix' => false], 'm' => ['Group' => 'Distance', 'Unit Name' => 'Meter', 'AllowPrefix' => true], 'mi' => ['Group' => 'Distance', 'Unit Name' => 'Statute mile', 'AllowPrefix' => false], 'Nmi' => ['Group' => 'Distance', 'Unit Name' => 'Nautical mile', 'AllowPrefix' => false], 'in' => ['Group' => 'Distance', 'Unit Name' => 'Inch', 'AllowPrefix' => false], 'ft' => ['Group' => 'Distance', 'Unit Name' => 'Foot', 'AllowPrefix' => false], 'yd' => ['Group' => 'Distance', 'Unit Name' => 'Yard', 'AllowPrefix' => false], 'ang' => ['Group' => 'Distance', 'Unit Name' => 'Angstrom', 'AllowPrefix' => true], 'Pica' => ['Group' => 'Distance', 'Unit Name' => 'Pica (1/72 in)', 'AllowPrefix' => false], 'yr' => ['Group' => 'Time', 'Unit Name' => 'Year', 'AllowPrefix' => false], 'day' => ['Group' => 'Time', 'Unit Name' => 'Day', 'AllowPrefix' => false], 'hr' => ['Group' => 'Time', 'Unit Name' => 'Hour', 'AllowPrefix' => false], 'mn' => ['Group' => 'Time', 'Unit Name' => 'Minute', 'AllowPrefix' => false], 'sec' => ['Group' => 'Time', 'Unit Name' => 'Second', 'AllowPrefix' => true], 'Pa' => ['Group' => 'Pressure', 'Unit Name' => 'Pascal', 'AllowPrefix' => true], 'p' => ['Group' => 'Pressure', 'Unit Name' => 'Pascal', 'AllowPrefix' => true], 'atm' => ['Group' => 'Pressure', 'Unit Name' => 'Atmosphere', 'AllowPrefix' => true], 'at' => ['Group' => 'Pressure', 'Unit Name' => 'Atmosphere', 'AllowPrefix' => true], 'mmHg' => ['Group' => 'Pressure', 'Unit Name' => 'mm of Mercury', 'AllowPrefix' => true], 'N' => ['Group' => 'Force', 'Unit Name' => 'Newton', 'AllowPrefix' => true], 'dyn' => ['Group' => 'Force', 'Unit Name' => 'Dyne', 'AllowPrefix' => true], 'dy' => ['Group' => 'Force', 'Unit Name' => 'Dyne', 'AllowPrefix' => true], 'lbf' => ['Group' => 'Force', 'Unit Name' => 'Pound force', 'AllowPrefix' => false], 'J' => ['Group' => 'Energy', 'Unit Name' => 'Joule', 'AllowPrefix' => true], 'e' => ['Group' => 'Energy', 'Unit Name' => 'Erg', 'AllowPrefix' => true], 'c' => ['Group' => 'Energy', 'Unit Name' => 'Thermodynamic calorie', 'AllowPrefix' => true], 'cal' => ['Group' => 'Energy', 'Unit Name' => 'IT calorie', 'AllowPrefix' => true], 'eV' => ['Group' => 'Energy', 'Unit Name' => 'Electron volt', 'AllowPrefix' => true], 'ev' => ['Group' => 'Energy', 'Unit Name' => 'Electron volt', 'AllowPrefix' => true], 'HPh' => ['Group' => 'Energy', 'Unit Name' => 'Horsepower-hour', 'AllowPrefix' => false], 'hh' => ['Group' => 'Energy', 'Unit Name' => 'Horsepower-hour', 'AllowPrefix' => false], 'Wh' => ['Group' => 'Energy', 'Unit Name' => 'Watt-hour', 'AllowPrefix' => true], 'wh' => ['Group' => 'Energy', 'Unit Name' => 'Watt-hour', 'AllowPrefix' => true], 'flb' => ['Group' => 'Energy', 'Unit Name' => 'Foot-pound', 'AllowPrefix' => false], 'BTU' => ['Group' => 'Energy', 'Unit Name' => 'BTU', 'AllowPrefix' => false], 'btu' => ['Group' => 'Energy', 'Unit Name' => 'BTU', 'AllowPrefix' => false], 'HP' => ['Group' => 'Power', 'Unit Name' => 'Horsepower', 'AllowPrefix' => false], 'h' => ['Group' => 'Power', 'Unit Name' => 'Horsepower', 'AllowPrefix' => false], 'W' => ['Group' => 'Power', 'Unit Name' => 'Watt', 'AllowPrefix' => true], 'w' => ['Group' => 'Power', 'Unit Name' => 'Watt', 'AllowPrefix' => true], 'T' => ['Group' => 'Magnetism', 'Unit Name' => 'Tesla', 'AllowPrefix' => true], 'ga' => ['Group' => 'Magnetism', 'Unit Name' => 'Gauss', 'AllowPrefix' => true], 'C' => ['Group' => 'Temperature', 'Unit Name' => 'Celsius', 'AllowPrefix' => false], 'cel' => ['Group' => 'Temperature', 'Unit Name' => 'Celsius', 'AllowPrefix' => false], 'F' => ['Group' => 'Temperature', 'Unit Name' => 'Fahrenheit', 'AllowPrefix' => false], 'fah' => ['Group' => 'Temperature', 'Unit Name' => 'Fahrenheit', 'AllowPrefix' => false], 'K' => ['Group' => 'Temperature', 'Unit Name' => 'Kelvin', 'AllowPrefix' => false], 'kel' => ['Group' => 'Temperature', 'Unit Name' => 'Kelvin', 'AllowPrefix' => false], 'tsp' => ['Group' => 'Liquid', 'Unit Name' => 'Teaspoon', 'AllowPrefix' => false], 'tbs' => ['Group' => 'Liquid', 'Unit Name' => 'Tablespoon', 'AllowPrefix' => false], 'oz' => ['Group' => 'Liquid', 'Unit Name' => 'Fluid Ounce', 'AllowPrefix' => false], 'cup' => ['Group' => 'Liquid', 'Unit Name' => 'Cup', 'AllowPrefix' => false], 'pt' => ['Group' => 'Liquid', 'Unit Name' => 'U.S. Pint', 'AllowPrefix' => false], 'us_pt' => ['Group' => 'Liquid', 'Unit Name' => 'U.S. Pint', 'AllowPrefix' => false], 'uk_pt' => ['Group' => 'Liquid', 'Unit Name' => 'U.K. Pint', 'AllowPrefix' => false], 'qt' => ['Group' => 'Liquid', 'Unit Name' => 'Quart', 'AllowPrefix' => false], 'gal' => ['Group' => 'Liquid', 'Unit Name' => 'Gallon', 'AllowPrefix' => false], 'l' => ['Group' => 'Liquid', 'Unit Name' => 'Litre', 'AllowPrefix' => true], 'lt' => ['Group' => 'Liquid', 'Unit Name' => 'Litre', 'AllowPrefix' => true]];
        /**
         * Details of the Multiplier prefixes that can be used with Units of Measure in CONVERTUOM().
         *
         * @var mixed[]
         */
        private static $conversionMultipliers = ['Y' => ['multiplier' => 1.0E+24, 'name' => 'yotta'], 'Z' => ['multiplier' => 1.0E+21, 'name' => 'zetta'], 'E' => ['multiplier' => 1.0E+18, 'name' => 'exa'], 'P' => ['multiplier' => 1000000000000000.0, 'name' => 'peta'], 'T' => ['multiplier' => 1000000000000.0, 'name' => 'tera'], 'G' => ['multiplier' => 1000000000.0, 'name' => 'giga'], 'M' => ['multiplier' => 1000000.0, 'name' => 'mega'], 'k' => ['multiplier' => 1000.0, 'name' => 'kilo'], 'h' => ['multiplier' => 100.0, 'name' => 'hecto'], 'e' => ['multiplier' => 10.0, 'name' => 'deka'], 'd' => ['multiplier' => 0.1, 'name' => 'deci'], 'c' => ['multiplier' => 0.01, 'name' => 'centi'], 'm' => ['multiplier' => 0.001, 'name' => 'milli'], 'u' => ['multiplier' => 1.0E-6, 'name' => 'micro'], 'n' => ['multiplier' => 1.0E-9, 'name' => 'nano'], 'p' => ['multiplier' => 1.0E-12, 'name' => 'pico'], 'f' => ['multiplier' => 1.0E-15, 'name' => 'femto'], 'a' => ['multiplier' => 1.0E-18, 'name' => 'atto'], 'z' => ['multiplier' => 9.999999999999999E-22, 'name' => 'zepto'], 'y' => ['multiplier' => 9.999999999999999E-25, 'name' => 'yocto']];
        /**
         * Details of the Units of measure conversion factors, organised by group.
         *
         * @var mixed[]
         */
        private static $unitConversions = ['Mass' => ['g' => ['g' => 1.0, 'sg' => 6.85220500053478E-5, 'lbm' => 0.00220462291469134, 'u' => 6.02217E+23, 'ozm' => 0.0352739718003627], 'sg' => ['g' => 14593.8424189287, 'sg' => 1.0, 'lbm' => 32.1739194101647, 'u' => 8.788659999999999E+27, 'ozm' => 514.782785944229], 'lbm' => ['g' => 453.5923097488115, 'sg' => 0.0310810749306493, 'lbm' => 1.0, 'u' => 2.73161E+26, 'ozm' => 16.000002342941], 'u' => ['g' => 1.66053100460465E-24, 'sg' => 1.1378298853295E-28, 'lbm' => 3.66084470330684E-27, 'u' => 1.0, 'ozm' => 5.85735238300524E-26], 'ozm' => ['g' => 28.3495152079732, 'sg' => 0.00194256689870811, 'lbm' => 0.0624999908478882, 'u' => 1.707256E+25, 'ozm' => 1.0]], 'Distance' => ['m' => ['m' => 1.0, 'mi' => 0.000621371192237334, 'Nmi' => 0.000539956803455724, 'in' => 39.3700787401575, 'ft' => 3.28083989501312, 'yd' => 1.09361329797891, 'ang' => 10000000000.0, 'Pica' => 2834.64566929116], 'mi' => ['m' => 1609.344, 'mi' => 1.0, 'Nmi' => 0.868976241900648, 'in' => 63360.0, 'ft' => 5280.0, 'yd' => 1760.0, 'ang' => 16093440000000.0, 'Pica' => 4561919.99999971], 'Nmi' => ['m' => 1852.0, 'mi' => 1.15077944802354, 'Nmi' => 1.0, 'in' => 72913.3858267717, 'ft' => 6076.1154855643, 'yd' => 2025.37182785694, 'ang' => 18520000000000.0, 'Pica' => 5249763.77952723], 'in' => ['m' => 0.0254, 'mi' => 1.57828282828283E-5, 'Nmi' => 1.37149028077754E-5, 'in' => 1.0, 'ft' => 0.0833333333333333, 'yd' => 0.0277777777686643, 'ang' => 254000000.0, 'Pica' => 71.9999999999955], 'ft' => ['m' => 0.3048, 'mi' => 0.000189393939393939, 'Nmi' => 0.000164578833693305, 'in' => 12.0, 'ft' => 1.0, 'yd' => 0.333333333223972, 'ang' => 3048000000.0, 'Pica' => 863.999999999946], 'yd' => ['m' => 0.9144000003, 'mi' => 0.00056818181836823, 'Nmi' => 0.000493736501241901, 'in' => 36.000000011811, 'ft' => 3.0, 'yd' => 1.0, 'ang' => 9144000003.0, 'Pica' => 2592.00000085023], 'ang' => ['m' => 1.0E-10, 'mi' => 6.213711922373341E-14, 'Nmi' => 5.39956803455724E-14, 'in' => 3.93700787401575E-9, 'ft' => 3.28083989501312E-10, 'yd' => 1.09361329797891E-10, 'ang' => 1.0, 'Pica' => 2.83464566929116E-7], 'Pica' => ['m' => 0.0003527777777778, 'mi' => 2.19205948372629E-7, 'Nmi' => 1.90484761219114E-7, 'in' => 0.0138888888888898, 'ft' => 0.00115740740740748, 'yd' => 0.000385802469009251, 'ang' => 3527777.777778, 'Pica' => 1.0]], 'Time' => ['yr' => ['yr' => 1.0, 'day' => 365.25, 'hr' => 8766.0, 'mn' => 525960.0, 'sec' => 31557600.0], 'day' => ['yr' => 0.0027378507871321, 'day' => 1.0, 'hr' => 24.0, 'mn' => 1440.0, 'sec' => 86400.0], 'hr' => ['yr' => 0.000114077116130504, 'day' => 0.0416666666666667, 'hr' => 1.0, 'mn' => 60.0, 'sec' => 3600.0], 'mn' => ['yr' => 1.90128526884174E-6, 'day' => 0.000694444444444444, 'hr' => 0.0166666666666667, 'mn' => 1.0, 'sec' => 60.0], 'sec' => ['yr' => 3.16880878140289E-8, 'day' => 1.15740740740741E-5, 'hr' => 0.000277777777777778, 'mn' => 0.0166666666666667, 'sec' => 1.0]], 'Pressure' => ['Pa' => ['Pa' => 1.0, 'p' => 1.0, 'atm' => 9.86923299998193E-6, 'at' => 9.86923299998193E-6, 'mmHg' => 0.00750061707998627], 'p' => ['Pa' => 1.0, 'p' => 1.0, 'atm' => 9.86923299998193E-6, 'at' => 9.86923299998193E-6, 'mmHg' => 0.00750061707998627], 'atm' => ['Pa' => 101324.996583, 'p' => 101324.996583, 'atm' => 1.0, 'at' => 1.0, 'mmHg' => 760.0], 'at' => ['Pa' => 101324.996583, 'p' => 101324.996583, 'atm' => 1.0, 'at' => 1.0, 'mmHg' => 760.0], 'mmHg' => ['Pa' => 133.322363925, 'p' => 133.322363925, 'atm' => 0.00131578947368421, 'at' => 0.00131578947368421, 'mmHg' => 1.0]], 'Force' => ['N' => ['N' => 1.0, 'dyn' => 100000.0, 'dy' => 100000.0, 'lbf' => 0.224808923655339], 'dyn' => ['N' => 1.0E-5, 'dyn' => 1.0, 'dy' => 1.0, 'lbf' => 2.24808923655339E-6], 'dy' => ['N' => 1.0E-5, 'dyn' => 1.0, 'dy' => 1.0, 'lbf' => 2.24808923655339E-6], 'lbf' => ['N' => 4.448222, 'dyn' => 444822.2, 'dy' => 444822.2, 'lbf' => 1.0]], 'Energy' => ['J' => ['J' => 1.0, 'e' => 9999995.193432311, 'c' => 0.239006249473467, 'cal' => 0.238846190642017, 'eV' => 6.241457E+18, 'ev' => 6.241457E+18, 'HPh' => 3.72506430801E-7, 'hh' => 3.72506430801E-7, 'Wh' => 0.000277777916238711, 'wh' => 0.000277777916238711, 'flb' => 23.7304222192651, 'BTU' => 0.000947815067349015, 'btu' => 0.000947815067349015], 'e' => ['J' => 1.000000480657E-7, 'e' => 1.0, 'c' => 2.39006364353494E-8, 'cal' => 2.38846305445111E-8, 'eV' => 624146000000.0, 'ev' => 624146000000.0, 'HPh' => 3.72506609848824E-14, 'hh' => 3.72506609848824E-14, 'Wh' => 2.77778049754611E-11, 'wh' => 2.77778049754611E-11, 'flb' => 2.37304336254586E-6, 'BTU' => 9.47815522922962E-11, 'btu' => 9.47815522922962E-11], 'c' => ['J' => 4.18399101363672, 'e' => 41839890.0257312, 'c' => 1.0, 'cal' => 0.999330315287563, 'eV' => 2.61142E+19, 'ev' => 2.61142E+19, 'HPh' => 1.55856355899327E-6, 'hh' => 1.55856355899327E-6, 'Wh' => 0.0011622203053295, 'wh' => 0.0011622203053295, 'flb' => 99.28787331521021, 'BTU' => 0.00396564972437776, 'btu' => 0.00396564972437776], 'cal' => ['J' => 4.18679484613929, 'e' => 41867928.3372801, 'c' => 1.00067013349059, 'cal' => 1.0, 'eV' => 2.61317E+19, 'ev' => 2.61317E+19, 'HPh' => 1.55960800463137E-6, 'hh' => 1.55960800463137E-6, 'Wh' => 0.00116299914807955, 'wh' => 0.00116299914807955, 'flb' => 99.3544094443283, 'BTU' => 0.00396830723907002, 'btu' => 0.00396830723907002], 'eV' => ['J' => 1.60219000146921E-19, 'e' => 1.60218923136574E-12, 'c' => 3.82933423195043E-20, 'cal' => 3.82676978535648E-20, 'eV' => 1.0, 'ev' => 1.0, 'HPh' => 5.968260789123441E-26, 'hh' => 5.968260789123441E-26, 'Wh' => 4.45053000026614E-23, 'wh' => 4.45053000026614E-23, 'flb' => 3.80206452103492E-18, 'BTU' => 1.51857982414846E-22, 'btu' => 1.51857982414846E-22], 'ev' => ['J' => 1.60219000146921E-19, 'e' => 1.60218923136574E-12, 'c' => 3.82933423195043E-20, 'cal' => 3.82676978535648E-20, 'eV' => 1.0, 'ev' => 1.0, 'HPh' => 5.968260789123441E-26, 'hh' => 5.968260789123441E-26, 'Wh' => 4.45053000026614E-23, 'wh' => 4.45053000026614E-23, 'flb' => 3.80206452103492E-18, 'BTU' => 1.51857982414846E-22, 'btu' => 1.51857982414846E-22], 'HPh' => ['J' => 2684517.4131617, 'e' => 26845161228302.4, 'c' => 641616.438565991, 'cal' => 641186.7578458349, 'eV' => 1.67553E+25, 'ev' => 1.67553E+25, 'HPh' => 1.0, 'hh' => 1.0, 'Wh' => 745.6996531345929, 'wh' => 745.6996531345929, 'flb' => 63704731.6692964, 'BTU' => 2544.42605275546, 'btu' => 2544.42605275546], 'hh' => ['J' => 2684517.4131617, 'e' => 26845161228302.4, 'c' => 641616.438565991, 'cal' => 641186.7578458349, 'eV' => 1.67553E+25, 'ev' => 1.67553E+25, 'HPh' => 1.0, 'hh' => 1.0, 'Wh' => 745.6996531345929, 'wh' => 745.6996531345929, 'flb' => 63704731.6692964, 'BTU' => 2544.42605275546, 'btu' => 2544.42605275546], 'Wh' => ['J' => 3599.9982055472, 'e' => 35999964751.8369, 'c' => 860.422069219046, 'cal' => 859.845857713046, 'eV' => 2.2469234E+22, 'ev' => 2.2469234E+22, 'HPh' => 0.00134102248243839, 'hh' => 0.00134102248243839, 'Wh' => 1.0, 'wh' => 1.0, 'flb' => 85429.4774062316, 'BTU' => 3.41213254164705, 'btu' => 3.41213254164705], 'wh' => ['J' => 3599.9982055472, 'e' => 35999964751.8369, 'c' => 860.422069219046, 'cal' => 859.845857713046, 'eV' => 2.2469234E+22, 'ev' => 2.2469234E+22, 'HPh' => 0.00134102248243839, 'hh' => 0.00134102248243839, 'Wh' => 1.0, 'wh' => 1.0, 'flb' => 85429.4774062316, 'BTU' => 3.41213254164705, 'btu' => 3.41213254164705], 'flb' => ['J' => 0.0421400003236424, 'e' => 421399.80068766, 'c' => 0.0100717234301644, 'cal' => 0.0100649785509554, 'eV' => 2.63015E+17, 'ev' => 2.63015E+17, 'HPh' => 1.5697421114513E-8, 'hh' => 1.5697421114513E-8, 'Wh' => 1.17055614802E-5, 'wh' => 1.17055614802E-5, 'flb' => 1.0, 'BTU' => 3.99409272448406E-5, 'btu' => 3.99409272448406E-5], 'BTU' => ['J' => 1055.05813786749, 'e' => 10550576307.4665, 'c' => 252.165488508168, 'cal' => 251.99661713551, 'eV' => 6.5851E+21, 'ev' => 6.5851E+21, 'HPh' => 0.000393015941224568, 'hh' => 0.000393015941224568, 'Wh' => 0.293071851047526, 'wh' => 0.293071851047526, 'flb' => 25036.9750774671, 'BTU' => 1.0, 'btu' => 1.0], 'btu' => ['J' => 1055.05813786749, 'e' => 10550576307.4665, 'c' => 252.165488508168, 'cal' => 251.99661713551, 'eV' => 6.5851E+21, 'ev' => 6.5851E+21, 'HPh' => 0.000393015941224568, 'hh' => 0.000393015941224568, 'Wh' => 0.293071851047526, 'wh' => 0.293071851047526, 'flb' => 25036.9750774671, 'BTU' => 1.0, 'btu' => 1.0]], 'Power' => ['HP' => ['HP' => 1.0, 'h' => 1.0, 'W' => 745.701, 'w' => 745.701], 'h' => ['HP' => 1.0, 'h' => 1.0, 'W' => 745.701, 'w' => 745.701], 'W' => ['HP' => 0.00134102006031908, 'h' => 0.00134102006031908, 'W' => 1.0, 'w' => 1.0], 'w' => ['HP' => 0.00134102006031908, 'h' => 0.00134102006031908, 'W' => 1.0, 'w' => 1.0]], 'Magnetism' => ['T' => ['T' => 1.0, 'ga' => 10000.0], 'ga' => ['T' => 0.0001, 'ga' => 1.0]], 'Liquid' => ['tsp' => ['tsp' => 1.0, 'tbs' => 0.333333333333333, 'oz' => 0.166666666666667, 'cup' => 0.0208333333333333, 'pt' => 0.0104166666666667, 'us_pt' => 0.0104166666666667, 'uk_pt' => 0.008675585168219599, 'qt' => 0.00520833333333333, 'gal' => 0.00130208333333333, 'l' => 0.0049299940840071, 'lt' => 0.0049299940840071], 'tbs' => ['tsp' => 3.0, 'tbs' => 1.0, 'oz' => 0.5, 'cup' => 0.0625, 'pt' => 0.03125, 'us_pt' => 0.03125, 'uk_pt' => 0.0260267555046588, 'qt' => 0.015625, 'gal' => 0.00390625, 'l' => 0.0147899822520213, 'lt' => 0.0147899822520213], 'oz' => ['tsp' => 6.0, 'tbs' => 2.0, 'oz' => 1.0, 'cup' => 0.125, 'pt' => 0.0625, 'us_pt' => 0.0625, 'uk_pt' => 0.0520535110093176, 'qt' => 0.03125, 'gal' => 0.0078125, 'l' => 0.0295799645040426, 'lt' => 0.0295799645040426], 'cup' => ['tsp' => 48.0, 'tbs' => 16.0, 'oz' => 8.0, 'cup' => 1.0, 'pt' => 0.5, 'us_pt' => 0.5, 'uk_pt' => 0.416428088074541, 'qt' => 0.25, 'gal' => 0.0625, 'l' => 0.236639716032341, 'lt' => 0.236639716032341], 'pt' => ['tsp' => 96.0, 'tbs' => 32.0, 'oz' => 16.0, 'cup' => 2.0, 'pt' => 1.0, 'us_pt' => 1.0, 'uk_pt' => 0.832856176149081, 'qt' => 0.5, 'gal' => 0.125, 'l' => 0.473279432064682, 'lt' => 0.473279432064682], 'us_pt' => ['tsp' => 96.0, 'tbs' => 32.0, 'oz' => 16.0, 'cup' => 2.0, 'pt' => 1.0, 'us_pt' => 1.0, 'uk_pt' => 0.832856176149081, 'qt' => 0.5, 'gal' => 0.125, 'l' => 0.473279432064682, 'lt' => 0.473279432064682], 'uk_pt' => ['tsp' => 115.266, 'tbs' => 38.422, 'oz' => 19.211, 'cup' => 2.401375, 'pt' => 1.2006875, 'us_pt' => 1.2006875, 'uk_pt' => 1.0, 'qt' => 0.60034375, 'gal' => 0.1500859375, 'l' => 0.568260698087162, 'lt' => 0.568260698087162], 'qt' => ['tsp' => 192.0, 'tbs' => 64.0, 'oz' => 32.0, 'cup' => 4.0, 'pt' => 2.0, 'us_pt' => 2.0, 'uk_pt' => 1.66571235229816, 'qt' => 1.0, 'gal' => 0.25, 'l' => 0.946558864129363, 'lt' => 0.946558864129363], 'gal' => ['tsp' => 768.0, 'tbs' => 256.0, 'oz' => 128.0, 'cup' => 16.0, 'pt' => 8.0, 'us_pt' => 8.0, 'uk_pt' => 6.66284940919265, 'qt' => 4.0, 'gal' => 1.0, 'l' => 3.78623545651745, 'lt' => 3.78623545651745], 'l' => ['tsp' => 202.84, 'tbs' => 67.6133333333333, 'oz' => 33.8066666666667, 'cup' => 4.22583333333333, 'pt' => 2.11291666666667, 'us_pt' => 2.11291666666667, 'uk_pt' => 1.75975569552166, 'qt' => 1.05645833333333, 'gal' => 0.264114583333333, 'l' => 1.0, 'lt' => 1.0], 'lt' => ['tsp' => 202.84, 'tbs' => 67.6133333333333, 'oz' => 33.8066666666667, 'cup' => 4.22583333333333, 'pt' => 2.11291666666667, 'us_pt' => 2.11291666666667, 'uk_pt' => 1.75975569552166, 'qt' => 1.05645833333333, 'gal' => 0.264114583333333, 'l' => 1.0, 'lt' => 1.0]]];
        /**
         * parseComplex.
         *
         * Parses a complex number into its real and imaginary parts, and an I or J suffix
         *
         * @deprecated 2.0.0 No longer used by internal code. Please use the Complex\Complex class instead
         *
         * @param string $complexNumber The complex number
         *
         * @return mixed[] Indexed on "real", "imaginary" and "suffix"
         */
        public static function parseComplex($complexNumber)
        {
        }
        /**
         * Formats a number base string value with leading zeroes.
         *
         * @param string $xVal The "number" to pad
         * @param int $places The length that we want to pad this value
         *
         * @return string The padded "number"
         */
        private static function nbrConversionFormat($xVal, $places)
        {
        }
        /**
         * BESSELI.
         *
         *    Returns the modified Bessel function In(x), which is equivalent to the Bessel function evaluated
         *        for purely imaginary arguments
         *
         *    Excel Function:
         *        BESSELI(x,ord)
         *
         * @param float $x The value at which to evaluate the function.
         *                                If x is nonnumeric, BESSELI returns the #VALUE! error value.
         * @param int $ord The order of the Bessel function.
         *                                If ord is not an integer, it is truncated.
         *                                If $ord is nonnumeric, BESSELI returns the #VALUE! error value.
         *                                If $ord < 0, BESSELI returns the #NUM! error value.
         *
         * @return float|string Result, or a string containing an error
         */
        public static function BESSELI($x, $ord)
        {
        }
        /**
         * BESSELJ.
         *
         *    Returns the Bessel function
         *
         *    Excel Function:
         *        BESSELJ(x,ord)
         *
         * @param float $x The value at which to evaluate the function.
         *                                If x is nonnumeric, BESSELJ returns the #VALUE! error value.
         * @param int $ord The order of the Bessel function. If n is not an integer, it is truncated.
         *                                If $ord is nonnumeric, BESSELJ returns the #VALUE! error value.
         *                                If $ord < 0, BESSELJ returns the #NUM! error value.
         *
         * @return float|string Result, or a string containing an error
         */
        public static function BESSELJ($x, $ord)
        {
        }
        private static function besselK0($fNum)
        {
        }
        private static function besselK1($fNum)
        {
        }
        /**
         * BESSELK.
         *
         *    Returns the modified Bessel function Kn(x), which is equivalent to the Bessel functions evaluated
         *        for purely imaginary arguments.
         *
         *    Excel Function:
         *        BESSELK(x,ord)
         *
         * @param float $x The value at which to evaluate the function.
         *                                If x is nonnumeric, BESSELK returns the #VALUE! error value.
         * @param int $ord The order of the Bessel function. If n is not an integer, it is truncated.
         *                                If $ord is nonnumeric, BESSELK returns the #VALUE! error value.
         *                                If $ord < 0, BESSELK returns the #NUM! error value.
         *
         * @return float|string Result, or a string containing an error
         */
        public static function BESSELK($x, $ord)
        {
        }
        private static function besselY0($fNum)
        {
        }
        private static function besselY1($fNum)
        {
        }
        /**
         * BESSELY.
         *
         * Returns the Bessel function, which is also called the Weber function or the Neumann function.
         *
         *    Excel Function:
         *        BESSELY(x,ord)
         *
         * @param float $x The value at which to evaluate the function.
         *                                If x is nonnumeric, BESSELK returns the #VALUE! error value.
         * @param int $ord The order of the Bessel function. If n is not an integer, it is truncated.
         *                                If $ord is nonnumeric, BESSELK returns the #VALUE! error value.
         *                                If $ord < 0, BESSELK returns the #NUM! error value.
         *
         * @return float|string Result, or a string containing an error
         */
        public static function BESSELY($x, $ord)
        {
        }
        /**
         * BINTODEC.
         *
         * Return a binary value as decimal.
         *
         * Excel Function:
         *        BIN2DEC(x)
         *
         * @param string $x The binary number (as a string) that you want to convert. The number
         *                                cannot contain more than 10 characters (10 bits). The most significant
         *                                bit of number is the sign bit. The remaining 9 bits are magnitude bits.
         *                                Negative numbers are represented using two's-complement notation.
         *                                If number is not a valid binary number, or if number contains more than
         *                                10 characters (10 bits), BIN2DEC returns the #NUM! error value.
         *
         * @return string
         */
        public static function BINTODEC($x)
        {
        }
        /**
         * BINTOHEX.
         *
         * Return a binary value as hex.
         *
         * Excel Function:
         *        BIN2HEX(x[,places])
         *
         * @param string $x The binary number (as a string) that you want to convert. The number
         *                                cannot contain more than 10 characters (10 bits). The most significant
         *                                bit of number is the sign bit. The remaining 9 bits are magnitude bits.
         *                                Negative numbers are represented using two's-complement notation.
         *                                If number is not a valid binary number, or if number contains more than
         *                                10 characters (10 bits), BIN2HEX returns the #NUM! error value.
         * @param int $places The number of characters to use. If places is omitted, BIN2HEX uses the
         *                                minimum number of characters necessary. Places is useful for padding the
         *                                return value with leading 0s (zeros).
         *                                If places is not an integer, it is truncated.
         *                                If places is nonnumeric, BIN2HEX returns the #VALUE! error value.
         *                                If places is negative, BIN2HEX returns the #NUM! error value.
         *
         * @return string
         */
        public static function BINTOHEX($x, $places = null)
        {
        }
        /**
         * BINTOOCT.
         *
         * Return a binary value as octal.
         *
         * Excel Function:
         *        BIN2OCT(x[,places])
         *
         * @param string $x The binary number (as a string) that you want to convert. The number
         *                                cannot contain more than 10 characters (10 bits). The most significant
         *                                bit of number is the sign bit. The remaining 9 bits are magnitude bits.
         *                                Negative numbers are represented using two's-complement notation.
         *                                If number is not a valid binary number, or if number contains more than
         *                                10 characters (10 bits), BIN2OCT returns the #NUM! error value.
         * @param int $places The number of characters to use. If places is omitted, BIN2OCT uses the
         *                                minimum number of characters necessary. Places is useful for padding the
         *                                return value with leading 0s (zeros).
         *                                If places is not an integer, it is truncated.
         *                                If places is nonnumeric, BIN2OCT returns the #VALUE! error value.
         *                                If places is negative, BIN2OCT returns the #NUM! error value.
         *
         * @return string
         */
        public static function BINTOOCT($x, $places = null)
        {
        }
        /**
         * DECTOBIN.
         *
         * Return a decimal value as binary.
         *
         * Excel Function:
         *        DEC2BIN(x[,places])
         *
         * @param string $x The decimal integer you want to convert. If number is negative,
         *                                valid place values are ignored and DEC2BIN returns a 10-character
         *                                (10-bit) binary number in which the most significant bit is the sign
         *                                bit. The remaining 9 bits are magnitude bits. Negative numbers are
         *                                represented using two's-complement notation.
         *                                If number < -512 or if number > 511, DEC2BIN returns the #NUM! error
         *                                value.
         *                                If number is nonnumeric, DEC2BIN returns the #VALUE! error value.
         *                                If DEC2BIN requires more than places characters, it returns the #NUM!
         *                                error value.
         * @param int $places The number of characters to use. If places is omitted, DEC2BIN uses
         *                                the minimum number of characters necessary. Places is useful for
         *                                padding the return value with leading 0s (zeros).
         *                                If places is not an integer, it is truncated.
         *                                If places is nonnumeric, DEC2BIN returns the #VALUE! error value.
         *                                If places is zero or negative, DEC2BIN returns the #NUM! error value.
         *
         * @return string
         */
        public static function DECTOBIN($x, $places = null)
        {
        }
        /**
         * DECTOHEX.
         *
         * Return a decimal value as hex.
         *
         * Excel Function:
         *        DEC2HEX(x[,places])
         *
         * @param string $x The decimal integer you want to convert. If number is negative,
         *                                places is ignored and DEC2HEX returns a 10-character (40-bit)
         *                                hexadecimal number in which the most significant bit is the sign
         *                                bit. The remaining 39 bits are magnitude bits. Negative numbers
         *                                are represented using two's-complement notation.
         *                                If number < -549,755,813,888 or if number > 549,755,813,887,
         *                                DEC2HEX returns the #NUM! error value.
         *                                If number is nonnumeric, DEC2HEX returns the #VALUE! error value.
         *                                If DEC2HEX requires more than places characters, it returns the
         *                                #NUM! error value.
         * @param int $places The number of characters to use. If places is omitted, DEC2HEX uses
         *                                the minimum number of characters necessary. Places is useful for
         *                                padding the return value with leading 0s (zeros).
         *                                If places is not an integer, it is truncated.
         *                                If places is nonnumeric, DEC2HEX returns the #VALUE! error value.
         *                                If places is zero or negative, DEC2HEX returns the #NUM! error value.
         *
         * @return string
         */
        public static function DECTOHEX($x, $places = null)
        {
        }
        /**
         * DECTOOCT.
         *
         * Return an decimal value as octal.
         *
         * Excel Function:
         *        DEC2OCT(x[,places])
         *
         * @param string $x The decimal integer you want to convert. If number is negative,
         *                                places is ignored and DEC2OCT returns a 10-character (30-bit)
         *                                octal number in which the most significant bit is the sign bit.
         *                                The remaining 29 bits are magnitude bits. Negative numbers are
         *                                represented using two's-complement notation.
         *                                If number < -536,870,912 or if number > 536,870,911, DEC2OCT
         *                                returns the #NUM! error value.
         *                                If number is nonnumeric, DEC2OCT returns the #VALUE! error value.
         *                                If DEC2OCT requires more than places characters, it returns the
         *                                #NUM! error value.
         * @param int $places The number of characters to use. If places is omitted, DEC2OCT uses
         *                                the minimum number of characters necessary. Places is useful for
         *                                padding the return value with leading 0s (zeros).
         *                                If places is not an integer, it is truncated.
         *                                If places is nonnumeric, DEC2OCT returns the #VALUE! error value.
         *                                If places is zero or negative, DEC2OCT returns the #NUM! error value.
         *
         * @return string
         */
        public static function DECTOOCT($x, $places = null)
        {
        }
        /**
         * HEXTOBIN.
         *
         * Return a hex value as binary.
         *
         * Excel Function:
         *        HEX2BIN(x[,places])
         *
         * @param string $x the hexadecimal number you want to convert.
         *                  Number cannot contain more than 10 characters.
         *                  The most significant bit of number is the sign bit (40th bit from the right).
         *                  The remaining 9 bits are magnitude bits.
         *                  Negative numbers are represented using two's-complement notation.
         *                  If number is negative, HEX2BIN ignores places and returns a 10-character binary number.
         *                  If number is negative, it cannot be less than FFFFFFFE00,
         *                      and if number is positive, it cannot be greater than 1FF.
         *                  If number is not a valid hexadecimal number, HEX2BIN returns the #NUM! error value.
         *                  If HEX2BIN requires more than places characters, it returns the #NUM! error value.
         * @param int $places The number of characters to use. If places is omitted,
         *                                    HEX2BIN uses the minimum number of characters necessary. Places
         *                                    is useful for padding the return value with leading 0s (zeros).
         *                                    If places is not an integer, it is truncated.
         *                                    If places is nonnumeric, HEX2BIN returns the #VALUE! error value.
         *                                    If places is negative, HEX2BIN returns the #NUM! error value.
         *
         * @return string
         */
        public static function HEXTOBIN($x, $places = null)
        {
        }
        /**
         * HEXTODEC.
         *
         * Return a hex value as decimal.
         *
         * Excel Function:
         *        HEX2DEC(x)
         *
         * @param string $x The hexadecimal number you want to convert. This number cannot
         *                                contain more than 10 characters (40 bits). The most significant
         *                                bit of number is the sign bit. The remaining 39 bits are magnitude
         *                                bits. Negative numbers are represented using two's-complement
         *                                notation.
         *                                If number is not a valid hexadecimal number, HEX2DEC returns the
         *                                #NUM! error value.
         *
         * @return string
         */
        public static function HEXTODEC($x)
        {
        }
        /**
         * HEXTOOCT.
         *
         * Return a hex value as octal.
         *
         * Excel Function:
         *        HEX2OCT(x[,places])
         *
         * @param string $x The hexadecimal number you want to convert. Number cannot
         *                                    contain more than 10 characters. The most significant bit of
         *                                    number is the sign bit. The remaining 39 bits are magnitude
         *                                    bits. Negative numbers are represented using two's-complement
         *                                    notation.
         *                                    If number is negative, HEX2OCT ignores places and returns a
         *                                    10-character octal number.
         *                                    If number is negative, it cannot be less than FFE0000000, and
         *                                    if number is positive, it cannot be greater than 1FFFFFFF.
         *                                    If number is not a valid hexadecimal number, HEX2OCT returns
         *                                    the #NUM! error value.
         *                                    If HEX2OCT requires more than places characters, it returns
         *                                    the #NUM! error value.
         * @param int $places The number of characters to use. If places is omitted, HEX2OCT
         *                                    uses the minimum number of characters necessary. Places is
         *                                    useful for padding the return value with leading 0s (zeros).
         *                                    If places is not an integer, it is truncated.
         *                                    If places is nonnumeric, HEX2OCT returns the #VALUE! error
         *                                    value.
         *                                    If places is negative, HEX2OCT returns the #NUM! error value.
         *
         * @return string
         */
        public static function HEXTOOCT($x, $places = null)
        {
        }
        /**
         * OCTTOBIN.
         *
         * Return an octal value as binary.
         *
         * Excel Function:
         *        OCT2BIN(x[,places])
         *
         * @param string $x The octal number you want to convert. Number may not
         *                                    contain more than 10 characters. The most significant
         *                                    bit of number is the sign bit. The remaining 29 bits
         *                                    are magnitude bits. Negative numbers are represented
         *                                    using two's-complement notation.
         *                                    If number is negative, OCT2BIN ignores places and returns
         *                                    a 10-character binary number.
         *                                    If number is negative, it cannot be less than 7777777000,
         *                                    and if number is positive, it cannot be greater than 777.
         *                                    If number is not a valid octal number, OCT2BIN returns
         *                                    the #NUM! error value.
         *                                    If OCT2BIN requires more than places characters, it
         *                                    returns the #NUM! error value.
         * @param int $places The number of characters to use. If places is omitted,
         *                                    OCT2BIN uses the minimum number of characters necessary.
         *                                    Places is useful for padding the return value with
         *                                    leading 0s (zeros).
         *                                    If places is not an integer, it is truncated.
         *                                    If places is nonnumeric, OCT2BIN returns the #VALUE!
         *                                    error value.
         *                                    If places is negative, OCT2BIN returns the #NUM! error
         *                                    value.
         *
         * @return string
         */
        public static function OCTTOBIN($x, $places = null)
        {
        }
        /**
         * OCTTODEC.
         *
         * Return an octal value as decimal.
         *
         * Excel Function:
         *        OCT2DEC(x)
         *
         * @param string $x The octal number you want to convert. Number may not contain
         *                                more than 10 octal characters (30 bits). The most significant
         *                                bit of number is the sign bit. The remaining 29 bits are
         *                                magnitude bits. Negative numbers are represented using
         *                                two's-complement notation.
         *                                If number is not a valid octal number, OCT2DEC returns the
         *                                #NUM! error value.
         *
         * @return string
         */
        public static function OCTTODEC($x)
        {
        }
        /**
         * OCTTOHEX.
         *
         * Return an octal value as hex.
         *
         * Excel Function:
         *        OCT2HEX(x[,places])
         *
         * @param string $x The octal number you want to convert. Number may not contain
         *                                    more than 10 octal characters (30 bits). The most significant
         *                                    bit of number is the sign bit. The remaining 29 bits are
         *                                    magnitude bits. Negative numbers are represented using
         *                                    two's-complement notation.
         *                                    If number is negative, OCT2HEX ignores places and returns a
         *                                    10-character hexadecimal number.
         *                                    If number is not a valid octal number, OCT2HEX returns the
         *                                    #NUM! error value.
         *                                    If OCT2HEX requires more than places characters, it returns
         *                                    the #NUM! error value.
         * @param int $places The number of characters to use. If places is omitted, OCT2HEX
         *                                    uses the minimum number of characters necessary. Places is useful
         *                                    for padding the return value with leading 0s (zeros).
         *                                    If places is not an integer, it is truncated.
         *                                    If places is nonnumeric, OCT2HEX returns the #VALUE! error value.
         *                                    If places is negative, OCT2HEX returns the #NUM! error value.
         *
         * @return string
         */
        public static function OCTTOHEX($x, $places = null)
        {
        }
        /**
         * COMPLEX.
         *
         * Converts real and imaginary coefficients into a complex number of the form x +/- yi or x +/- yj.
         *
         * Excel Function:
         *        COMPLEX(realNumber,imaginary[,suffix])
         *
         * @param float $realNumber the real coefficient of the complex number
         * @param float $imaginary the imaginary coefficient of the complex number
         * @param string $suffix The suffix for the imaginary component of the complex number.
         *                                        If omitted, the suffix is assumed to be "i".
         *
         * @return string
         */
        public static function COMPLEX($realNumber = 0.0, $imaginary = 0.0, $suffix = 'i')
        {
        }
        /**
         * IMAGINARY.
         *
         * Returns the imaginary coefficient of a complex number in x + yi or x + yj text format.
         *
         * Excel Function:
         *        IMAGINARY(complexNumber)
         *
         * @param string $complexNumber the complex number for which you want the imaginary
         *                                         coefficient
         *
         * @return float
         */
        public static function IMAGINARY($complexNumber)
        {
        }
        /**
         * IMREAL.
         *
         * Returns the real coefficient of a complex number in x + yi or x + yj text format.
         *
         * Excel Function:
         *        IMREAL(complexNumber)
         *
         * @param string $complexNumber the complex number for which you want the real coefficient
         *
         * @return float
         */
        public static function IMREAL($complexNumber)
        {
        }
        /**
         * IMABS.
         *
         * Returns the absolute value (modulus) of a complex number in x + yi or x + yj text format.
         *
         * Excel Function:
         *        IMABS(complexNumber)
         *
         * @param string $complexNumber the complex number for which you want the absolute value
         *
         * @return float
         */
        public static function IMABS($complexNumber)
        {
        }
        /**
         * IMARGUMENT.
         *
         * Returns the argument theta of a complex number, i.e. the angle in radians from the real
         * axis to the representation of the number in polar coordinates.
         *
         * Excel Function:
         *        IMARGUMENT(complexNumber)
         *
         * @param string $complexNumber the complex number for which you want the argument theta
         *
         * @return float|string
         */
        public static function IMARGUMENT($complexNumber)
        {
        }
        /**
         * IMCONJUGATE.
         *
         * Returns the complex conjugate of a complex number in x + yi or x + yj text format.
         *
         * Excel Function:
         *        IMCONJUGATE(complexNumber)
         *
         * @param string $complexNumber the complex number for which you want the conjugate
         *
         * @return string
         */
        public static function IMCONJUGATE($complexNumber)
        {
        }
        /**
         * IMCOS.
         *
         * Returns the cosine of a complex number in x + yi or x + yj text format.
         *
         * Excel Function:
         *        IMCOS(complexNumber)
         *
         * @param string $complexNumber the complex number for which you want the cosine
         *
         * @return float|string
         */
        public static function IMCOS($complexNumber)
        {
        }
        /**
         * IMCOSH.
         *
         * Returns the hyperbolic cosine of a complex number in x + yi or x + yj text format.
         *
         * Excel Function:
         *        IMCOSH(complexNumber)
         *
         * @param string $complexNumber the complex number for which you want the hyperbolic cosine
         *
         * @return float|string
         */
        public static function IMCOSH($complexNumber)
        {
        }
        /**
         * IMCOT.
         *
         * Returns the cotangent of a complex number in x + yi or x + yj text format.
         *
         * Excel Function:
         *        IMCOT(complexNumber)
         *
         * @param string $complexNumber the complex number for which you want the cotangent
         *
         * @return float|string
         */
        public static function IMCOT($complexNumber)
        {
        }
        /**
         * IMCSC.
         *
         * Returns the cosecant of a complex number in x + yi or x + yj text format.
         *
         * Excel Function:
         *        IMCSC(complexNumber)
         *
         * @param string $complexNumber the complex number for which you want the cosecant
         *
         * @return float|string
         */
        public static function IMCSC($complexNumber)
        {
        }
        /**
         * IMCSCH.
         *
         * Returns the hyperbolic cosecant of a complex number in x + yi or x + yj text format.
         *
         * Excel Function:
         *        IMCSCH(complexNumber)
         *
         * @param string $complexNumber the complex number for which you want the hyperbolic cosecant
         *
         * @return float|string
         */
        public static function IMCSCH($complexNumber)
        {
        }
        /**
         * IMSIN.
         *
         * Returns the sine of a complex number in x + yi or x + yj text format.
         *
         * Excel Function:
         *        IMSIN(complexNumber)
         *
         * @param string $complexNumber the complex number for which you want the sine
         *
         * @return float|string
         */
        public static function IMSIN($complexNumber)
        {
        }
        /**
         * IMSINH.
         *
         * Returns the hyperbolic sine of a complex number in x + yi or x + yj text format.
         *
         * Excel Function:
         *        IMSINH(complexNumber)
         *
         * @param string $complexNumber the complex number for which you want the hyperbolic sine
         *
         * @return float|string
         */
        public static function IMSINH($complexNumber)
        {
        }
        /**
         * IMSEC.
         *
         * Returns the secant of a complex number in x + yi or x + yj text format.
         *
         * Excel Function:
         *        IMSEC(complexNumber)
         *
         * @param string $complexNumber the complex number for which you want the secant
         *
         * @return float|string
         */
        public static function IMSEC($complexNumber)
        {
        }
        /**
         * IMSECH.
         *
         * Returns the hyperbolic secant of a complex number in x + yi or x + yj text format.
         *
         * Excel Function:
         *        IMSECH(complexNumber)
         *
         * @param string $complexNumber the complex number for which you want the hyperbolic secant
         *
         * @return float|string
         */
        public static function IMSECH($complexNumber)
        {
        }
        /**
         * IMTAN.
         *
         * Returns the tangent of a complex number in x + yi or x + yj text format.
         *
         * Excel Function:
         *        IMTAN(complexNumber)
         *
         * @param string $complexNumber the complex number for which you want the tangent
         *
         * @return float|string
         */
        public static function IMTAN($complexNumber)
        {
        }
        /**
         * IMSQRT.
         *
         * Returns the square root of a complex number in x + yi or x + yj text format.
         *
         * Excel Function:
         *        IMSQRT(complexNumber)
         *
         * @param string $complexNumber the complex number for which you want the square root
         *
         * @return string
         */
        public static function IMSQRT($complexNumber)
        {
        }
        /**
         * IMLN.
         *
         * Returns the natural logarithm of a complex number in x + yi or x + yj text format.
         *
         * Excel Function:
         *        IMLN(complexNumber)
         *
         * @param string $complexNumber the complex number for which you want the natural logarithm
         *
         * @return string
         */
        public static function IMLN($complexNumber)
        {
        }
        /**
         * IMLOG10.
         *
         * Returns the common logarithm (base 10) of a complex number in x + yi or x + yj text format.
         *
         * Excel Function:
         *        IMLOG10(complexNumber)
         *
         * @param string $complexNumber the complex number for which you want the common logarithm
         *
         * @return string
         */
        public static function IMLOG10($complexNumber)
        {
        }
        /**
         * IMLOG2.
         *
         * Returns the base-2 logarithm of a complex number in x + yi or x + yj text format.
         *
         * Excel Function:
         *        IMLOG2(complexNumber)
         *
         * @param string $complexNumber the complex number for which you want the base-2 logarithm
         *
         * @return string
         */
        public static function IMLOG2($complexNumber)
        {
        }
        /**
         * IMEXP.
         *
         * Returns the exponential of a complex number in x + yi or x + yj text format.
         *
         * Excel Function:
         *        IMEXP(complexNumber)
         *
         * @param string $complexNumber the complex number for which you want the exponential
         *
         * @return string
         */
        public static function IMEXP($complexNumber)
        {
        }
        /**
         * IMPOWER.
         *
         * Returns a complex number in x + yi or x + yj text format raised to a power.
         *
         * Excel Function:
         *        IMPOWER(complexNumber,realNumber)
         *
         * @param string $complexNumber the complex number you want to raise to a power
         * @param float $realNumber the power to which you want to raise the complex number
         *
         * @return string
         */
        public static function IMPOWER($complexNumber, $realNumber)
        {
        }
        /**
         * IMDIV.
         *
         * Returns the quotient of two complex numbers in x + yi or x + yj text format.
         *
         * Excel Function:
         *        IMDIV(complexDividend,complexDivisor)
         *
         * @param string $complexDividend the complex numerator or dividend
         * @param string $complexDivisor the complex denominator or divisor
         *
         * @return string
         */
        public static function IMDIV($complexDividend, $complexDivisor)
        {
        }
        /**
         * IMSUB.
         *
         * Returns the difference of two complex numbers in x + yi or x + yj text format.
         *
         * Excel Function:
         *        IMSUB(complexNumber1,complexNumber2)
         *
         * @param string $complexNumber1 the complex number from which to subtract complexNumber2
         * @param string $complexNumber2 the complex number to subtract from complexNumber1
         *
         * @return string
         */
        public static function IMSUB($complexNumber1, $complexNumber2)
        {
        }
        /**
         * IMSUM.
         *
         * Returns the sum of two or more complex numbers in x + yi or x + yj text format.
         *
         * Excel Function:
         *        IMSUM(complexNumber[,complexNumber[,...]])
         *
         * @param string ...$complexNumbers Series of complex numbers to add
         *
         * @return string
         */
        public static function IMSUM(...$complexNumbers)
        {
        }
        /**
         * IMPRODUCT.
         *
         * Returns the product of two or more complex numbers in x + yi or x + yj text format.
         *
         * Excel Function:
         *        IMPRODUCT(complexNumber[,complexNumber[,...]])
         *
         * @param string ...$complexNumbers Series of complex numbers to multiply
         *
         * @return string
         */
        public static function IMPRODUCT(...$complexNumbers)
        {
        }
        /**
         * DELTA.
         *
         * Tests whether two values are equal. Returns 1 if number1 = number2; returns 0 otherwise.
         *    Use this function to filter a set of values. For example, by summing several DELTA
         *    functions you calculate the count of equal pairs. This function is also known as the
         * Kronecker Delta function.
         *
         *    Excel Function:
         *        DELTA(a[,b])
         *
         * @param float $a the first number
         * @param float $b The second number. If omitted, b is assumed to be zero.
         *
         * @return int
         */
        public static function DELTA($a, $b = 0)
        {
        }
        /**
         * GESTEP.
         *
         *    Excel Function:
         *        GESTEP(number[,step])
         *
         *    Returns 1 if number >= step; returns 0 (zero) otherwise
         *    Use this function to filter a set of values. For example, by summing several GESTEP
         * functions you calculate the count of values that exceed a threshold.
         *
         * @param float $number the value to test against step
         * @param float $step The threshold value.
         *                                    If you omit a value for step, GESTEP uses zero.
         *
         * @return int
         */
        public static function GESTEP($number, $step = 0)
        {
        }
        //
        //    Private method to calculate the erf value
        //
        private static $twoSqrtPi = 1.1283791670955126;
        public static function erfVal($x)
        {
        }
        /**
         * Validate arguments passed to the bitwise functions.
         *
         * @param mixed $value
         *
         * @return int
         */
        private static function validateBitwiseArgument($value)
        {
        }
        /**
         * BITAND.
         *
         * Returns the bitwise AND of two integer values.
         *
         * Excel Function:
         *        BITAND(number1, number2)
         *
         * @param int $number1
         * @param int $number2
         *
         * @return int|string
         */
        public static function BITAND($number1, $number2)
        {
        }
        /**
         * BITOR.
         *
         * Returns the bitwise OR of two integer values.
         *
         * Excel Function:
         *        BITOR(number1, number2)
         *
         * @param int $number1
         * @param int $number2
         *
         * @return int|string
         */
        public static function BITOR($number1, $number2)
        {
        }
        /**
         * BITXOR.
         *
         * Returns the bitwise XOR of two integer values.
         *
         * Excel Function:
         *        BITXOR(number1, number2)
         *
         * @param int $number1
         * @param int $number2
         *
         * @return int|string
         */
        public static function BITXOR($number1, $number2)
        {
        }
        /**
         * BITLSHIFT.
         *
         * Returns the number value shifted left by shift_amount bits.
         *
         * Excel Function:
         *        BITLSHIFT(number, shift_amount)
         *
         * @param int $number
         * @param int $shiftAmount
         *
         * @return int|string
         */
        public static function BITLSHIFT($number, $shiftAmount)
        {
        }
        /**
         * BITRSHIFT.
         *
         * Returns the number value shifted right by shift_amount bits.
         *
         * Excel Function:
         *        BITRSHIFT(number, shift_amount)
         *
         * @param int $number
         * @param int $shiftAmount
         *
         * @return int|string
         */
        public static function BITRSHIFT($number, $shiftAmount)
        {
        }
        /**
         * ERF.
         *
         * Returns the error function integrated between the lower and upper bound arguments.
         *
         *    Note: In Excel 2007 or earlier, if you input a negative value for the upper or lower bound arguments,
         *            the function would return a #NUM! error. However, in Excel 2010, the function algorithm was
         *            improved, so that it can now calculate the function for both positive and negative ranges.
         *            PhpSpreadsheet follows Excel 2010 behaviour, and accepts negative arguments.
         *
         *    Excel Function:
         *        ERF(lower[,upper])
         *
         * @param float $lower lower bound for integrating ERF
         * @param float $upper upper bound for integrating ERF.
         *                                If omitted, ERF integrates between zero and lower_limit
         *
         * @return float|string
         */
        public static function ERF($lower, $upper = null)
        {
        }
        /**
         * ERFPRECISE.
         *
         * Returns the error function integrated between the lower and upper bound arguments.
         *
         *    Excel Function:
         *        ERF.PRECISE(limit)
         *
         * @param float $limit bound for integrating ERF
         *
         * @return float|string
         */
        public static function ERFPRECISE($limit)
        {
        }
        //
        //    Private method to calculate the erfc value
        //
        private static $oneSqrtPi = 0.5641895835477563;
        private static function erfcVal($x)
        {
        }
        /**
         * ERFC.
         *
         *    Returns the complementary ERF function integrated between x and infinity
         *
         *    Note: In Excel 2007 or earlier, if you input a negative value for the lower bound argument,
         *        the function would return a #NUM! error. However, in Excel 2010, the function algorithm was
         *        improved, so that it can now calculate the function for both positive and negative x values.
         *            PhpSpreadsheet follows Excel 2010 behaviour, and accepts nagative arguments.
         *
         *    Excel Function:
         *        ERFC(x)
         *
         * @param float $x The lower bound for integrating ERFC
         *
         * @return float|string
         */
        public static function ERFC($x)
        {
        }
        /**
         *    getConversionGroups
         * Returns a list of the different conversion groups for UOM conversions.
         *
         * @return array
         */
        public static function getConversionGroups()
        {
        }
        /**
         *    getConversionGroupUnits
         * Returns an array of units of measure, for a specified conversion group, or for all groups.
         *
         * @param string $group The group whose units of measure you want to retrieve
         *
         * @return array
         */
        public static function getConversionGroupUnits($group = null)
        {
        }
        /**
         * getConversionGroupUnitDetails.
         *
         * @param string $group The group whose units of measure you want to retrieve
         *
         * @return array
         */
        public static function getConversionGroupUnitDetails($group = null)
        {
        }
        /**
         *    getConversionMultipliers
         * Returns an array of the Multiplier prefixes that can be used with Units of Measure in CONVERTUOM().
         *
         * @return array of mixed
         */
        public static function getConversionMultipliers()
        {
        }
        /**
         * CONVERTUOM.
         *
         * Converts a number from one measurement system to another.
         *    For example, CONVERT can translate a table of distances in miles to a table of distances
         * in kilometers.
         *
         *    Excel Function:
         *        CONVERT(value,fromUOM,toUOM)
         *
         * @param float $value the value in fromUOM to convert
         * @param string $fromUOM the units for value
         * @param string $toUOM the units for the result
         *
         * @return float|string
         */
        public static function CONVERTUOM($value, $fromUOM, $toUOM)
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Calculation\Engine {
    class CyclicReferenceStack
    {
        /**
         * The call stack for calculated cells.
         *
         * @var mixed[]
         */
        private $stack = [];
        /**
         * Return the number of entries on the stack.
         *
         * @return int
         */
        public function count()
        {
        }
        /**
         * Push a new entry onto the stack.
         *
         * @param mixed $value
         */
        public function push($value) : void
        {
        }
        /**
         * Pop the last entry from the stack.
         *
         * @return mixed
         */
        public function pop()
        {
        }
        /**
         * Test to see if a specified entry exists on the stack.
         *
         * @param mixed $value The value to test
         *
         * @return bool
         */
        public function onStack($value)
        {
        }
        /**
         * Clear the stack.
         */
        public function clear() : void
        {
        }
        /**
         * Return an array of all entries on the stack.
         *
         * @return mixed[]
         */
        public function showStack()
        {
        }
    }
    class Logger
    {
        /**
         * Flag to determine whether a debug log should be generated by the calculation engine
         *        If true, then a debug log will be generated
         *        If false, then a debug log will not be generated.
         *
         * @var bool
         */
        private $writeDebugLog = false;
        /**
         * Flag to determine whether a debug log should be echoed by the calculation engine
         *        If true, then a debug log will be echoed
         *        If false, then a debug log will not be echoed
         * A debug log can only be echoed if it is generated.
         *
         * @var bool
         */
        private $echoDebugLog = false;
        /**
         * The debug log generated by the calculation engine.
         *
         * @var string[]
         */
        private $debugLog = [];
        /**
         * The calculation engine cell reference stack.
         *
         * @var CyclicReferenceStack
         */
        private $cellStack;
        /**
         * Instantiate a Calculation engine logger.
         */
        public function __construct(\PhpOffice\PhpSpreadsheet\Calculation\Engine\CyclicReferenceStack $stack)
        {
        }
        /**
         * Enable/Disable Calculation engine logging.
         *
         * @param bool $pValue
         */
        public function setWriteDebugLog($pValue) : void
        {
        }
        /**
         * Return whether calculation engine logging is enabled or disabled.
         *
         * @return bool
         */
        public function getWriteDebugLog()
        {
        }
        /**
         * Enable/Disable echoing of debug log information.
         *
         * @param bool $pValue
         */
        public function setEchoDebugLog($pValue) : void
        {
        }
        /**
         * Return whether echoing of debug log information is enabled or disabled.
         *
         * @return bool
         */
        public function getEchoDebugLog()
        {
        }
        /**
         * Write an entry to the calculation engine debug log.
         */
        public function writeDebugLog(...$args) : void
        {
        }
        /**
         * Clear the calculation engine debug log.
         */
        public function clearLog() : void
        {
        }
        /**
         * Return the calculation engine debug log.
         *
         * @return string[]
         */
        public function getLog()
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Calculation\Token {
    class Stack
    {
        /**
         * The parser stack for formulae.
         *
         * @var mixed[]
         */
        private $stack = [];
        /**
         * Count of entries in the parser stack.
         *
         * @var int
         */
        private $count = 0;
        /**
         * Return the number of entries on the stack.
         *
         * @return int
         */
        public function count()
        {
        }
        /**
         * Push a new entry onto the stack.
         *
         * @param mixed $type
         * @param mixed $value
         * @param mixed $reference
         * @param null|string $storeKey will store the result under this alias
         * @param null|string $onlyIf will only run computation if the matching
         *      store key is true
         * @param null|string $onlyIfNot will only run computation if the matching
         *      store key is false
         */
        public function push($type, $value, $reference = null, $storeKey = null, $onlyIf = null, $onlyIfNot = null) : void
        {
        }
        public function getStackItem($type, $value, $reference = null, $storeKey = null, $onlyIf = null, $onlyIfNot = null)
        {
        }
        /**
         * Pop the last entry from the stack.
         *
         * @return mixed
         */
        public function pop()
        {
        }
        /**
         * Return an entry from the stack without removing it.
         *
         * @param int $n number indicating how far back in the stack we want to look
         *
         * @return mixed
         */
        public function last($n = 1)
        {
        }
        /**
         * Clear the stack.
         */
        public function clear() : void
        {
        }
        public function __toString()
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Calculation {
    class Logical
    {
        /**
         * TRUE.
         *
         * Returns the boolean TRUE.
         *
         * Excel Function:
         *        =TRUE()
         *
         * @return bool True
         */
        public static function true()
        {
        }
        /**
         * FALSE.
         *
         * Returns the boolean FALSE.
         *
         * Excel Function:
         *        =FALSE()
         *
         * @return bool False
         */
        public static function false()
        {
        }
        private static function countTrueValues(array $args)
        {
        }
        /**
         * LOGICAL_AND.
         *
         * Returns boolean TRUE if all its arguments are TRUE; returns FALSE if one or more argument is FALSE.
         *
         * Excel Function:
         *        =AND(logical1[,logical2[, ...]])
         *
         *        The arguments must evaluate to logical values such as TRUE or FALSE, or the arguments must be arrays
         *            or references that contain logical values.
         *
         *        Boolean arguments are treated as True or False as appropriate
         *        Integer or floating point arguments are treated as True, except for 0 or 0.0 which are False
         *        If any argument value is a string, or a Null, the function returns a #VALUE! error, unless the string holds
         *            the value TRUE or FALSE, in which case it is evaluated as the corresponding boolean value
         *
         * @param mixed ...$args Data values
         *
         * @return bool|string the logical AND of the arguments
         */
        public static function logicalAnd(...$args)
        {
        }
        /**
         * LOGICAL_OR.
         *
         * Returns boolean TRUE if any argument is TRUE; returns FALSE if all arguments are FALSE.
         *
         * Excel Function:
         *        =OR(logical1[,logical2[, ...]])
         *
         *        The arguments must evaluate to logical values such as TRUE or FALSE, or the arguments must be arrays
         *            or references that contain logical values.
         *
         *        Boolean arguments are treated as True or False as appropriate
         *        Integer or floating point arguments are treated as True, except for 0 or 0.0 which are False
         *        If any argument value is a string, or a Null, the function returns a #VALUE! error, unless the string holds
         *            the value TRUE or FALSE, in which case it is evaluated as the corresponding boolean value
         *
         * @param mixed $args Data values
         *
         * @return bool|string the logical OR of the arguments
         */
        public static function logicalOr(...$args)
        {
        }
        /**
         * LOGICAL_XOR.
         *
         * Returns the Exclusive Or logical operation for one or more supplied conditions.
         * i.e. the Xor function returns TRUE if an odd number of the supplied conditions evaluate to TRUE, and FALSE otherwise.
         *
         * Excel Function:
         *        =XOR(logical1[,logical2[, ...]])
         *
         *        The arguments must evaluate to logical values such as TRUE or FALSE, or the arguments must be arrays
         *            or references that contain logical values.
         *
         *        Boolean arguments are treated as True or False as appropriate
         *        Integer or floating point arguments are treated as True, except for 0 or 0.0 which are False
         *        If any argument value is a string, or a Null, the function returns a #VALUE! error, unless the string holds
         *            the value TRUE or FALSE, in which case it is evaluated as the corresponding boolean value
         *
         * @param mixed $args Data values
         *
         * @return bool|string the logical XOR of the arguments
         */
        public static function logicalXor(...$args)
        {
        }
        /**
         * NOT.
         *
         * Returns the boolean inverse of the argument.
         *
         * Excel Function:
         *        =NOT(logical)
         *
         *        The argument must evaluate to a logical value such as TRUE or FALSE
         *
         *        Boolean arguments are treated as True or False as appropriate
         *        Integer or floating point arguments are treated as True, except for 0 or 0.0 which are False
         *        If any argument value is a string, or a Null, the function returns a #VALUE! error, unless the string holds
         *            the value TRUE or FALSE, in which case it is evaluated as the corresponding boolean value
         *
         * @param mixed $logical A value or expression that can be evaluated to TRUE or FALSE
         *
         * @return bool|string the boolean inverse of the argument
         */
        public static function NOT($logical = false)
        {
        }
        /**
         * STATEMENT_IF.
         *
         * Returns one value if a condition you specify evaluates to TRUE and another value if it evaluates to FALSE.
         *
         * Excel Function:
         *        =IF(condition[,returnIfTrue[,returnIfFalse]])
         *
         *        Condition is any value or expression that can be evaluated to TRUE or FALSE.
         *            For example, A10=100 is a logical expression; if the value in cell A10 is equal to 100,
         *            the expression evaluates to TRUE. Otherwise, the expression evaluates to FALSE.
         *            This argument can use any comparison calculation operator.
         *        ReturnIfTrue is the value that is returned if condition evaluates to TRUE.
         *            For example, if this argument is the text string "Within budget" and the condition argument evaluates to TRUE,
         *            then the IF function returns the text "Within budget"
         *            If condition is TRUE and ReturnIfTrue is blank, this argument returns 0 (zero). To display the word TRUE, use
         *            the logical value TRUE for this argument.
         *            ReturnIfTrue can be another formula.
         *        ReturnIfFalse is the value that is returned if condition evaluates to FALSE.
         *            For example, if this argument is the text string "Over budget" and the condition argument evaluates to FALSE,
         *            then the IF function returns the text "Over budget".
         *            If condition is FALSE and ReturnIfFalse is omitted, then the logical value FALSE is returned.
         *            If condition is FALSE and ReturnIfFalse is blank, then the value 0 (zero) is returned.
         *            ReturnIfFalse can be another formula.
         *
         * @param mixed $condition Condition to evaluate
         * @param mixed $returnIfTrue Value to return when condition is true
         * @param mixed $returnIfFalse Optional value to return when condition is false
         *
         * @return mixed The value of returnIfTrue or returnIfFalse determined by condition
         */
        public static function statementIf($condition = true, $returnIfTrue = 0, $returnIfFalse = false)
        {
        }
        /**
         * STATEMENT_SWITCH.
         *
         * Returns corresponding with first match (any data type such as a string, numeric, date, etc).
         *
         * Excel Function:
         *        =SWITCH (expression, value1, result1, value2, result2, ... value_n, result_n [, default])
         *
         *        Expression
         *              The expression to compare to a list of values.
         *        value1, value2, ... value_n
         *              A list of values that are compared to expression. The SWITCH function is looking for the first value that matches the expression.
         *        result1, result2, ... result_n
         *              A list of results. The SWITCH function returns the corresponding result when a value matches expression.
         *         default
         *              Optional. It is the default to return if expression does not match any of the values (value1, value2, ... value_n).
         *
         * @param mixed $arguments Statement arguments
         *
         * @return mixed The value of matched expression
         */
        public static function statementSwitch(...$arguments)
        {
        }
        /**
         * IFERROR.
         *
         * Excel Function:
         *        =IFERROR(testValue,errorpart)
         *
         * @param mixed $testValue Value to check, is also the value returned when no error
         * @param mixed $errorpart Value to return when testValue is an error condition
         *
         * @return mixed The value of errorpart or testValue determined by error condition
         */
        public static function IFERROR($testValue = '', $errorpart = '')
        {
        }
        /**
         * IFNA.
         *
         * Excel Function:
         *        =IFNA(testValue,napart)
         *
         * @param mixed $testValue Value to check, is also the value returned when not an NA
         * @param mixed $napart Value to return when testValue is an NA condition
         *
         * @return mixed The value of errorpart or testValue determined by error condition
         */
        public static function IFNA($testValue = '', $napart = '')
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet {
    class Spreadsheet
    {
        // Allowable values for workbook window visilbity
        const VISIBILITY_VISIBLE = 'visible';
        const VISIBILITY_HIDDEN = 'hidden';
        const VISIBILITY_VERY_HIDDEN = 'veryHidden';
        private static $workbookViewVisibilityValues = [self::VISIBILITY_VISIBLE, self::VISIBILITY_HIDDEN, self::VISIBILITY_VERY_HIDDEN];
        /**
         * Unique ID.
         *
         * @var string
         */
        private $uniqueID;
        /**
         * Document properties.
         *
         * @var Document\Properties
         */
        private $properties;
        /**
         * Document security.
         *
         * @var Document\Security
         */
        private $security;
        /**
         * Collection of Worksheet objects.
         *
         * @var Worksheet[]
         */
        private $workSheetCollection = [];
        /**
         * Calculation Engine.
         *
         * @var Calculation
         */
        private $calculationEngine;
        /**
         * Active sheet index.
         *
         * @var int
         */
        private $activeSheetIndex = 0;
        /**
         * Named ranges.
         *
         * @var NamedRange[]
         */
        private $namedRanges = [];
        /**
         * CellXf supervisor.
         *
         * @var Style
         */
        private $cellXfSupervisor;
        /**
         * CellXf collection.
         *
         * @var Style[]
         */
        private $cellXfCollection = [];
        /**
         * CellStyleXf collection.
         *
         * @var Style[]
         */
        private $cellStyleXfCollection = [];
        /**
         * hasMacros : this workbook have macros ?
         *
         * @var bool
         */
        private $hasMacros = false;
        /**
         * macrosCode : all macros code as binary data (the vbaProject.bin file, this include form, code,  etc.), null if no macro.
         *
         * @var string
         */
        private $macrosCode;
        /**
         * macrosCertificate : if macros are signed, contains binary data vbaProjectSignature.bin file, null if not signed.
         *
         * @var string
         */
        private $macrosCertificate;
        /**
         * ribbonXMLData : null if workbook is'nt Excel 2007 or not contain a customized UI.
         *
         * @var null|string
         */
        private $ribbonXMLData;
        /**
         * ribbonBinObjects : null if workbook is'nt Excel 2007 or not contain embedded objects (picture(s)) for Ribbon Elements
         * ignored if $ribbonXMLData is null.
         *
         * @var null|array
         */
        private $ribbonBinObjects;
        /**
         * List of unparsed loaded data for export to same format with better compatibility.
         * It has to be minimized when the library start to support currently unparsed data.
         *
         * @var array
         */
        private $unparsedLoadedData = [];
        /**
         * Controls visibility of the horizonal scroll bar in the application.
         *
         * @var bool
         */
        private $showHorizontalScroll = true;
        /**
         * Controls visibility of the horizonal scroll bar in the application.
         *
         * @var bool
         */
        private $showVerticalScroll = true;
        /**
         * Controls visibility of the sheet tabs in the application.
         *
         * @var bool
         */
        private $showSheetTabs = true;
        /**
         * Specifies a boolean value that indicates whether the workbook window
         * is minimized.
         *
         * @var bool
         */
        private $minimized = false;
        /**
         * Specifies a boolean value that indicates whether to group dates
         * when presenting the user with filtering optiomd in the user
         * interface.
         *
         * @var bool
         */
        private $autoFilterDateGrouping = true;
        /**
         * Specifies the index to the first sheet in the book view.
         *
         * @var int
         */
        private $firstSheetIndex = 0;
        /**
         * Specifies the visible status of the workbook.
         *
         * @var string
         */
        private $visibility = self::VISIBILITY_VISIBLE;
        /**
         * Specifies the ratio between the workbook tabs bar and the horizontal
         * scroll bar.  TabRatio is assumed to be out of 1000 of the horizontal
         * window width.
         *
         * @var int
         */
        private $tabRatio = 600;
        /**
         * The workbook has macros ?
         *
         * @return bool
         */
        public function hasMacros()
        {
        }
        /**
         * Define if a workbook has macros.
         *
         * @param bool $hasMacros true|false
         */
        public function setHasMacros($hasMacros) : void
        {
        }
        /**
         * Set the macros code.
         *
         * @param string $macroCode string|null
         */
        public function setMacrosCode($macroCode) : void
        {
        }
        /**
         * Return the macros code.
         *
         * @return null|string
         */
        public function getMacrosCode()
        {
        }
        /**
         * Set the macros certificate.
         *
         * @param null|string $certificate
         */
        public function setMacrosCertificate($certificate) : void
        {
        }
        /**
         * Is the project signed ?
         *
         * @return bool true|false
         */
        public function hasMacrosCertificate()
        {
        }
        /**
         * Return the macros certificate.
         *
         * @return null|string
         */
        public function getMacrosCertificate()
        {
        }
        /**
         * Remove all macros, certificate from spreadsheet.
         */
        public function discardMacros() : void
        {
        }
        /**
         * set ribbon XML data.
         *
         * @param null|mixed $target
         * @param null|mixed $xmlData
         */
        public function setRibbonXMLData($target, $xmlData) : void
        {
        }
        /**
         * retrieve ribbon XML Data.
         *
         * return string|null|array
         *
         * @param string $what
         *
         * @return string
         */
        public function getRibbonXMLData($what = 'all')
        {
        }
        /**
         * store binaries ribbon objects (pictures).
         *
         * @param null|mixed $BinObjectsNames
         * @param null|mixed $BinObjectsData
         */
        public function setRibbonBinObjects($BinObjectsNames, $BinObjectsData) : void
        {
        }
        /**
         * List of unparsed loaded data for export to same format with better compatibility.
         * It has to be minimized when the library start to support currently unparsed data.
         *
         * @internal
         *
         * @return array
         */
        public function getUnparsedLoadedData()
        {
        }
        /**
         * List of unparsed loaded data for export to same format with better compatibility.
         * It has to be minimized when the library start to support currently unparsed data.
         *
         * @internal
         */
        public function setUnparsedLoadedData(array $unparsedLoadedData) : void
        {
        }
        /**
         * return the extension of a filename. Internal use for a array_map callback (php<5.3 don't like lambda function).
         *
         * @param mixed $path
         *
         * @return string
         */
        private function getExtensionOnly($path)
        {
        }
        /**
         * retrieve Binaries Ribbon Objects.
         *
         * @param string $what
         *
         * @return null|array
         */
        public function getRibbonBinObjects($what = 'all')
        {
        }
        /**
         * This workbook have a custom UI ?
         *
         * @return bool
         */
        public function hasRibbon()
        {
        }
        /**
         * This workbook have additionnal object for the ribbon ?
         *
         * @return bool
         */
        public function hasRibbonBinObjects()
        {
        }
        /**
         * Check if a sheet with a specified code name already exists.
         *
         * @param string $pSheetCodeName Name of the worksheet to check
         *
         * @return bool
         */
        public function sheetCodeNameExists($pSheetCodeName)
        {
        }
        /**
         * Get sheet by code name. Warning : sheet don't have always a code name !
         *
         * @param string $pName Sheet name
         *
         * @return Worksheet
         */
        public function getSheetByCodeName($pName)
        {
        }
        /**
         * Create a new PhpSpreadsheet with one Worksheet.
         */
        public function __construct()
        {
        }
        /**
         * Code to execute when this worksheet is unset().
         */
        public function __destruct()
        {
        }
        /**
         * Disconnect all worksheets from this PhpSpreadsheet workbook object,
         * typically so that the PhpSpreadsheet object can be unset.
         */
        public function disconnectWorksheets() : void
        {
        }
        /**
         * Return the calculation engine for this worksheet.
         *
         * @return Calculation
         */
        public function getCalculationEngine()
        {
        }
        /**
         * Get properties.
         *
         * @return Document\Properties
         */
        public function getProperties()
        {
        }
        /**
         * Set properties.
         */
        public function setProperties(\PhpOffice\PhpSpreadsheet\Document\Properties $pValue) : void
        {
        }
        /**
         * Get security.
         *
         * @return Document\Security
         */
        public function getSecurity()
        {
        }
        /**
         * Set security.
         */
        public function setSecurity(\PhpOffice\PhpSpreadsheet\Document\Security $pValue) : void
        {
        }
        /**
         * Get active sheet.
         *
         * @return Worksheet
         */
        public function getActiveSheet()
        {
        }
        /**
         * Create sheet and add it to this workbook.
         *
         * @param null|int $sheetIndex Index where sheet should go (0,1,..., or null for last)
         *
         * @return Worksheet
         */
        public function createSheet($sheetIndex = null)
        {
        }
        /**
         * Check if a sheet with a specified name already exists.
         *
         * @param string $pSheetName Name of the worksheet to check
         *
         * @return bool
         */
        public function sheetNameExists($pSheetName)
        {
        }
        /**
         * Add sheet.
         *
         * @param null|int $iSheetIndex Index where sheet should go (0,1,..., or null for last)
         *
         * @return Worksheet
         */
        public function addSheet(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet, $iSheetIndex = null)
        {
        }
        /**
         * Remove sheet by index.
         *
         * @param int $pIndex Active sheet index
         */
        public function removeSheetByIndex($pIndex) : void
        {
        }
        /**
         * Get sheet by index.
         *
         * @param int $pIndex Sheet index
         *
         * @return Worksheet
         */
        public function getSheet($pIndex)
        {
        }
        /**
         * Get all sheets.
         *
         * @return Worksheet[]
         */
        public function getAllSheets()
        {
        }
        /**
         * Get sheet by name.
         *
         * @param string $pName Sheet name
         *
         * @return null|Worksheet
         */
        public function getSheetByName($pName)
        {
        }
        /**
         * Get index for sheet.
         *
         * @return int index
         */
        public function getIndex(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet)
        {
        }
        /**
         * Set index for sheet by sheet name.
         *
         * @param string $sheetName Sheet name to modify index for
         * @param int $newIndex New index for the sheet
         *
         * @return int New sheet index
         */
        public function setIndexByName($sheetName, $newIndex)
        {
        }
        /**
         * Get sheet count.
         *
         * @return int
         */
        public function getSheetCount()
        {
        }
        /**
         * Get active sheet index.
         *
         * @return int Active sheet index
         */
        public function getActiveSheetIndex()
        {
        }
        /**
         * Set active sheet index.
         *
         * @param int $pIndex Active sheet index
         *
         * @return Worksheet
         */
        public function setActiveSheetIndex($pIndex)
        {
        }
        /**
         * Set active sheet index by name.
         *
         * @param string $pValue Sheet title
         *
         * @return Worksheet
         */
        public function setActiveSheetIndexByName($pValue)
        {
        }
        /**
         * Get sheet names.
         *
         * @return string[]
         */
        public function getSheetNames()
        {
        }
        /**
         * Add external sheet.
         *
         * @param Worksheet $pSheet External sheet to add
         * @param null|int $iSheetIndex Index where sheet should go (0,1,..., or null for last)
         *
         * @return Worksheet
         */
        public function addExternalSheet(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet, $iSheetIndex = null)
        {
        }
        /**
         * Get named ranges.
         *
         * @return NamedRange[]
         */
        public function getNamedRanges()
        {
        }
        /**
         * Add named range.
         *
         * @return bool
         */
        public function addNamedRange(\PhpOffice\PhpSpreadsheet\NamedRange $namedRange)
        {
        }
        /**
         * Get named range.
         *
         * @param string $namedRange
         * @param null|Worksheet $pSheet Scope. Use null for global scope
         *
         * @return null|NamedRange
         */
        public function getNamedRange($namedRange, ?\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet = null)
        {
        }
        /**
         * Remove named range.
         *
         * @param string $namedRange
         * @param null|Worksheet $pSheet scope: use null for global scope
         *
         * @return $this
         */
        public function removeNamedRange($namedRange, ?\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $pSheet = null)
        {
        }
        /**
         * Get worksheet iterator.
         *
         * @return Iterator
         */
        public function getWorksheetIterator()
        {
        }
        /**
         * Copy workbook (!= clone!).
         *
         * @return Spreadsheet
         */
        public function copy()
        {
        }
        /**
         * Implement PHP __clone to create a deep clone, not just a shallow copy.
         */
        public function __clone()
        {
        }
        /**
         * Get the workbook collection of cellXfs.
         *
         * @return Style[]
         */
        public function getCellXfCollection()
        {
        }
        /**
         * Get cellXf by index.
         *
         * @param int $pIndex
         *
         * @return Style
         */
        public function getCellXfByIndex($pIndex)
        {
        }
        /**
         * Get cellXf by hash code.
         *
         * @param string $pValue
         *
         * @return false|Style
         */
        public function getCellXfByHashCode($pValue)
        {
        }
        /**
         * Check if style exists in style collection.
         *
         * @param Style $pCellStyle
         *
         * @return bool
         */
        public function cellXfExists($pCellStyle)
        {
        }
        /**
         * Get default style.
         *
         * @return Style
         */
        public function getDefaultStyle()
        {
        }
        /**
         * Add a cellXf to the workbook.
         */
        public function addCellXf(\PhpOffice\PhpSpreadsheet\Style\Style $style) : void
        {
        }
        /**
         * Remove cellXf by index. It is ensured that all cells get their xf index updated.
         *
         * @param int $pIndex Index to cellXf
         */
        public function removeCellXfByIndex($pIndex) : void
        {
        }
        /**
         * Get the cellXf supervisor.
         *
         * @return Style
         */
        public function getCellXfSupervisor()
        {
        }
        /**
         * Get the workbook collection of cellStyleXfs.
         *
         * @return Style[]
         */
        public function getCellStyleXfCollection()
        {
        }
        /**
         * Get cellStyleXf by index.
         *
         * @param int $pIndex Index to cellXf
         *
         * @return Style
         */
        public function getCellStyleXfByIndex($pIndex)
        {
        }
        /**
         * Get cellStyleXf by hash code.
         *
         * @param string $pValue
         *
         * @return false|Style
         */
        public function getCellStyleXfByHashCode($pValue)
        {
        }
        /**
         * Add a cellStyleXf to the workbook.
         */
        public function addCellStyleXf(\PhpOffice\PhpSpreadsheet\Style\Style $pStyle) : void
        {
        }
        /**
         * Remove cellStyleXf by index.
         *
         * @param int $pIndex Index to cellXf
         */
        public function removeCellStyleXfByIndex($pIndex) : void
        {
        }
        /**
         * Eliminate all unneeded cellXf and afterwards update the xfIndex for all cells
         * and columns in the workbook.
         */
        public function garbageCollect() : void
        {
        }
        /**
         * Return the unique ID value assigned to this spreadsheet workbook.
         *
         * @return string
         */
        public function getID()
        {
        }
        /**
         * Get the visibility of the horizonal scroll bar in the application.
         *
         * @return bool True if horizonal scroll bar is visible
         */
        public function getShowHorizontalScroll()
        {
        }
        /**
         * Set the visibility of the horizonal scroll bar in the application.
         *
         * @param bool $showHorizontalScroll True if horizonal scroll bar is visible
         */
        public function setShowHorizontalScroll($showHorizontalScroll) : void
        {
        }
        /**
         * Get the visibility of the vertical scroll bar in the application.
         *
         * @return bool True if vertical scroll bar is visible
         */
        public function getShowVerticalScroll()
        {
        }
        /**
         * Set the visibility of the vertical scroll bar in the application.
         *
         * @param bool $showVerticalScroll True if vertical scroll bar is visible
         */
        public function setShowVerticalScroll($showVerticalScroll) : void
        {
        }
        /**
         * Get the visibility of the sheet tabs in the application.
         *
         * @return bool True if the sheet tabs are visible
         */
        public function getShowSheetTabs()
        {
        }
        /**
         * Set the visibility of the sheet tabs  in the application.
         *
         * @param bool $showSheetTabs True if sheet tabs are visible
         */
        public function setShowSheetTabs($showSheetTabs) : void
        {
        }
        /**
         * Return whether the workbook window is minimized.
         *
         * @return bool true if workbook window is minimized
         */
        public function getMinimized()
        {
        }
        /**
         * Set whether the workbook window is minimized.
         *
         * @param bool $minimized true if workbook window is minimized
         */
        public function setMinimized($minimized) : void
        {
        }
        /**
         * Return whether to group dates when presenting the user with
         * filtering optiomd in the user interface.
         *
         * @return bool true if workbook window is minimized
         */
        public function getAutoFilterDateGrouping()
        {
        }
        /**
         * Set whether to group dates when presenting the user with
         * filtering optiomd in the user interface.
         *
         * @param bool $autoFilterDateGrouping true if workbook window is minimized
         */
        public function setAutoFilterDateGrouping($autoFilterDateGrouping) : void
        {
        }
        /**
         * Return the first sheet in the book view.
         *
         * @return int First sheet in book view
         */
        public function getFirstSheetIndex()
        {
        }
        /**
         * Set the first sheet in the book view.
         *
         * @param int $firstSheetIndex First sheet in book view
         */
        public function setFirstSheetIndex($firstSheetIndex) : void
        {
        }
        /**
         * Return the visibility status of the workbook.
         *
         * This may be one of the following three values:
         * - visibile
         *
         * @return string Visible status
         */
        public function getVisibility()
        {
        }
        /**
         * Set the visibility status of the workbook.
         *
         * Valid values are:
         *  - 'visible' (self::VISIBILITY_VISIBLE):
         *       Workbook window is visible
         *  - 'hidden' (self::VISIBILITY_HIDDEN):
         *       Workbook window is hidden, but can be shown by the user
         *       via the user interface
         *  - 'veryHidden' (self::VISIBILITY_VERY_HIDDEN):
         *       Workbook window is hidden and cannot be shown in the
         *       user interface.
         *
         * @param string $visibility visibility status of the workbook
         */
        public function setVisibility($visibility) : void
        {
        }
        /**
         * Get the ratio between the workbook tabs bar and the horizontal scroll bar.
         * TabRatio is assumed to be out of 1000 of the horizontal window width.
         *
         * @return int Ratio between the workbook tabs bar and the horizontal scroll bar
         */
        public function getTabRatio()
        {
        }
        /**
         * Set the ratio between the workbook tabs bar and the horizontal scroll bar
         * TabRatio is assumed to be out of 1000 of the horizontal window width.
         *
         * @param int $tabRatio Ratio between the tabs bar and the horizontal scroll bar
         */
        public function setTabRatio($tabRatio) : void
        {
        }
    }
    class Settings
    {
        /**
         * Class name of the chart renderer used for rendering charts
         * eg: PhpOffice\PhpSpreadsheet\Chart\Renderer\JpGraph.
         *
         * @var string
         */
        private static $chartRenderer;
        /**
         * Default options for libxml loader.
         *
         * @var int
         */
        private static $libXmlLoaderOptions = null;
        /**
         * Allow/disallow libxml_disable_entity_loader() call when not thread safe.
         * Default behaviour is to do the check, but if you're running PHP versions
         *      7.2 < 7.2.1
         * then you may need to disable this check to prevent unwanted behaviour in other threads
         * SECURITY WARNING: Changing this flag is not recommended.
         *
         * @var bool
         */
        private static $libXmlDisableEntityLoader = true;
        /**
         * The cache implementation to be used for cell collection.
         *
         * @var CacheInterface
         */
        private static $cache;
        /**
         * Set the locale code to use for formula translations and any special formatting.
         *
         * @param string $locale The locale code to use (e.g. "fr" or "pt_br" or "en_uk")
         *
         * @return bool Success or failure
         */
        public static function setLocale($locale)
        {
        }
        /**
         * Identify to PhpSpreadsheet the external library to use for rendering charts.
         *
         * @param string $rendererClass Class name of the chart renderer
         *    eg: PhpOffice\PhpSpreadsheet\Chart\Renderer\JpGraph
         */
        public static function setChartRenderer($rendererClass) : void
        {
        }
        /**
         * Return the Chart Rendering Library that PhpSpreadsheet is currently configured to use.
         *
         * @return null|string Class name of the chart renderer
         *    eg: PhpOffice\PhpSpreadsheet\Chart\Renderer\JpGraph
         */
        public static function getChartRenderer()
        {
        }
        /**
         * Set default options for libxml loader.
         *
         * @param int $options Default options for libxml loader
         */
        public static function setLibXmlLoaderOptions($options) : void
        {
        }
        /**
         * Get default options for libxml loader.
         * Defaults to LIBXML_DTDLOAD | LIBXML_DTDATTR when not set explicitly.
         *
         * @return int Default options for libxml loader
         */
        public static function getLibXmlLoaderOptions()
        {
        }
        /**
         * Enable/Disable the entity loader for libxml loader.
         * Allow/disallow libxml_disable_entity_loader() call when not thread safe.
         * Default behaviour is to do the check, but if you're running PHP versions
         *      7.2 < 7.2.1
         * then you may need to disable this check to prevent unwanted behaviour in other threads
         * SECURITY WARNING: Changing this flag to false is not recommended.
         *
         * @param bool $state
         */
        public static function setLibXmlDisableEntityLoader($state) : void
        {
        }
        /**
         * Return the state of the entity loader (disabled/enabled) for libxml loader.
         *
         * @return bool $state
         */
        public static function getLibXmlDisableEntityLoader()
        {
        }
        /**
         * Sets the implementation of cache that should be used for cell collection.
         */
        public static function setCache(\Psr\SimpleCache\CacheInterface $cache) : void
        {
        }
        /**
         * Gets the implementation of cache that should be used for cell collection.
         *
         * @return CacheInterface
         */
        public static function getCache()
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Shared\OLE {
    /**
     * Class for creating PPS's for OLE containers.
     *
     * @author   Xavier Noguer <xnoguer@php.net>
     */
    class PPS
    {
        /**
         * The PPS index.
         *
         * @var int
         */
        public $No;
        /**
         * The PPS name (in Unicode).
         *
         * @var string
         */
        public $Name;
        /**
         * The PPS type. Dir, Root or File.
         *
         * @var int
         */
        public $Type;
        /**
         * The index of the previous PPS.
         *
         * @var int
         */
        public $PrevPps;
        /**
         * The index of the next PPS.
         *
         * @var int
         */
        public $NextPps;
        /**
         * The index of it's first child if this is a Dir or Root PPS.
         *
         * @var int
         */
        public $DirPps;
        /**
         * A timestamp.
         *
         * @var int
         */
        public $Time1st;
        /**
         * A timestamp.
         *
         * @var int
         */
        public $Time2nd;
        /**
         * Starting block (small or big) for this PPS's data  inside the container.
         *
         * @var int
         */
        public $startBlock;
        /**
         * The size of the PPS's data (in bytes).
         *
         * @var int
         */
        public $Size;
        /**
         * The PPS's data (only used if it's not using a temporary file).
         *
         * @var string
         */
        public $_data;
        /**
         * Array of child PPS's (only used by Root and Dir PPS's).
         *
         * @var array
         */
        public $children = [];
        /**
         * Pointer to OLE container.
         *
         * @var OLE
         */
        public $ole;
        /**
         * The constructor.
         *
         * @param int $No The PPS index
         * @param string $name The PPS name
         * @param int $type The PPS type. Dir, Root or File
         * @param int $prev The index of the previous PPS
         * @param int $next The index of the next PPS
         * @param int $dir The index of it's first child if this is a Dir or Root PPS
         * @param int $time_1st A timestamp
         * @param int $time_2nd A timestamp
         * @param string $data The (usually binary) source data of the PPS
         * @param array $children Array containing children PPS for this PPS
         */
        public function __construct($No, $name, $type, $prev, $next, $dir, $time_1st, $time_2nd, $data, $children)
        {
        }
        /**
         * Returns the amount of data saved for this PPS.
         *
         * @return int The amount of data (in bytes)
         */
        public function getDataLen()
        {
        }
        /**
         * Returns a string with the PPS's WK (What is a WK?).
         *
         * @return string The binary string
         */
        public function _getPpsWk()
        {
        }
        /**
         * Updates index and pointers to previous, next and children PPS's for this
         * PPS. I don't think it'll work with Dir PPS's.
         *
         * @param array &$raList Reference to the array of PPS's for the whole OLE
         *                          container
         * @param mixed $to_save
         * @param mixed $depth
         *
         * @return int The index for this PPS
         */
        public static function _savePpsSetPnt(&$raList, $to_save, $depth = 0)
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Shared\OLE\PPS {
    /**
     * Class for creating Root PPS's for OLE containers.
     *
     * @author   Xavier Noguer <xnoguer@php.net>
     */
    class Root extends \PhpOffice\PhpSpreadsheet\Shared\OLE\PPS
    {
        /**
         * @var resource
         */
        private $fileHandle;
        /**
         * @var int
         */
        private $smallBlockSize;
        /**
         * @var int
         */
        private $bigBlockSize;
        /**
         * @param int $time_1st A timestamp
         * @param int $time_2nd A timestamp
         * @param File[] $raChild
         */
        public function __construct($time_1st, $time_2nd, $raChild)
        {
        }
        /**
         * Method for saving the whole OLE container (including files).
         * In fact, if called with an empty argument (or '-'), it saves to a
         * temporary file and then outputs it's contents to stdout.
         * If a resource pointer to a stream created by fopen() is passed
         * it will be used, but you have to close such stream by yourself.
         *
         * @param resource $fileHandle the name of the file or stream where to save the OLE container
         *
         * @return bool true on success
         */
        public function save($fileHandle)
        {
        }
        /**
         * Calculate some numbers.
         *
         * @param array $raList Reference to an array of PPS's
         *
         * @return float[] The array of numbers
         */
        public function _calcSize(&$raList)
        {
        }
        /**
         * Helper function for caculating a magic value for block sizes.
         *
         * @param int $i2 The argument
         *
         * @return float
         *
         * @see save()
         */
        private static function adjust2($i2)
        {
        }
        /**
         * Save OLE header.
         *
         * @param int $iSBDcnt
         * @param int $iBBcnt
         * @param int $iPPScnt
         */
        public function _saveHeader($iSBDcnt, $iBBcnt, $iPPScnt) : void
        {
        }
        /**
         * Saving big data (PPS's with data bigger than \PhpOffice\PhpSpreadsheet\Shared\OLE::OLE_DATA_SIZE_SMALL).
         *
         * @param int $iStBlk
         * @param array &$raList Reference to array of PPS's
         */
        public function _saveBigData($iStBlk, &$raList) : void
        {
        }
        /**
         * get small data (PPS's with data smaller than \PhpOffice\PhpSpreadsheet\Shared\OLE::OLE_DATA_SIZE_SMALL).
         *
         * @param array &$raList Reference to array of PPS's
         *
         * @return string
         */
        public function _makeSmallData(&$raList)
        {
        }
        /**
         * Saves all the PPS's WKs.
         *
         * @param array $raList Reference to an array with all PPS's
         */
        public function _savePps(&$raList) : void
        {
        }
        /**
         * Saving Big Block Depot.
         *
         * @param int $iSbdSize
         * @param int $iBsize
         * @param int $iPpsCnt
         */
        public function _saveBbd($iSbdSize, $iBsize, $iPpsCnt) : void
        {
        }
    }
    /**
     * Class for creating File PPS's for OLE containers.
     *
     * @author   Xavier Noguer <xnoguer@php.net>
     */
    class File extends \PhpOffice\PhpSpreadsheet\Shared\OLE\PPS
    {
        /**
         * The constructor.
         *
         * @param string $name The name of the file (in Unicode)
         *
         * @see OLE::ascToUcs()
         */
        public function __construct($name)
        {
        }
        /**
         * Initialization method. Has to be called right after OLE_PPS_File().
         *
         * @return mixed true on success
         */
        public function init()
        {
        }
        /**
         * Append data to PPS.
         *
         * @param string $data The data to append
         */
        public function append($data) : void
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Shared\OLE {
    class ChainedBlockStream
    {
        /**
         * The OLE container of the file that is being read.
         *
         * @var OLE
         */
        public $ole;
        /**
         * Parameters specified by fopen().
         *
         * @var array
         */
        public $params;
        /**
         * The binary data of the file.
         *
         * @var string
         */
        public $data;
        /**
         * The file pointer.
         *
         * @var int byte offset
         */
        public $pos;
        /**
         * Implements support for fopen().
         * For creating streams using this wrapper, use OLE_PPS_File::getStream().
         *
         * @param string $path resource name including scheme, e.g.
         *                                    ole-chainedblockstream://oleInstanceId=1
         * @param string $mode only "r" is supported
         * @param int $options mask of STREAM_REPORT_ERRORS and STREAM_USE_PATH
         * @param string &$openedPath absolute path of the opened stream (out parameter)
         *
         * @return bool true on success
         */
        public function stream_open($path, $mode, $options, &$openedPath)
        {
        }
        /**
         * Implements support for fclose().
         */
        public function stream_close() : void
        {
        }
        /**
         * Implements support for fread(), fgets() etc.
         *
         * @param int $count maximum number of bytes to read
         *
         * @return string
         */
        public function stream_read($count)
        {
        }
        /**
         * Implements support for feof().
         *
         * @return bool TRUE if the file pointer is at EOF; otherwise FALSE
         */
        public function stream_eof()
        {
        }
        /**
         * Returns the position of the file pointer, i.e. its offset into the file
         * stream. Implements support for ftell().
         *
         * @return int
         */
        public function stream_tell()
        {
        }
        /**
         * Implements support for fseek().
         *
         * @param int $offset byte offset
         * @param int $whence SEEK_SET, SEEK_CUR or SEEK_END
         *
         * @return bool
         */
        public function stream_seek($offset, $whence)
        {
        }
        /**
         * Implements support for fstat(). Currently the only supported field is
         * "size".
         *
         * @return array
         */
        public function stream_stat()
        {
        }
        // Methods used by stream_wrapper_register() that are not implemented:
        // bool stream_flush ( void )
        // int stream_write ( string data )
        // bool rename ( string path_from, string path_to )
        // bool mkdir ( string path, int mode, int options )
        // bool rmdir ( string path, int options )
        // bool dir_opendir ( string path, int options )
        // array url_stat ( string path, int flags )
        // string dir_readdir ( void )
        // bool dir_rewinddir ( void )
        // bool dir_closedir ( void )
    }
}
namespace PhpOffice\PhpSpreadsheet\Shared {
    class CodePage
    {
        private static $pageArray = [
            0 => 'CP1252',
            //    CodePage is not always correctly set when the xls file was saved by Apple's Numbers program
            367 => 'ASCII',
            //    ASCII
            437 => 'CP437',
            //    OEM US
            //720 => 'notsupported', //    OEM Arabic
            737 => 'CP737',
            //    OEM Greek
            775 => 'CP775',
            //    OEM Baltic
            850 => 'CP850',
            //    OEM Latin I
            852 => 'CP852',
            //    OEM Latin II (Central European)
            855 => 'CP855',
            //    OEM Cyrillic
            857 => 'CP857',
            //    OEM Turkish
            858 => 'CP858',
            //    OEM Multilingual Latin I with Euro
            860 => 'CP860',
            //    OEM Portugese
            861 => 'CP861',
            //    OEM Icelandic
            862 => 'CP862',
            //    OEM Hebrew
            863 => 'CP863',
            //    OEM Canadian (French)
            864 => 'CP864',
            //    OEM Arabic
            865 => 'CP865',
            //    OEM Nordic
            866 => 'CP866',
            //    OEM Cyrillic (Russian)
            869 => 'CP869',
            //    OEM Greek (Modern)
            874 => 'CP874',
            //    ANSI Thai
            932 => 'CP932',
            //    ANSI Japanese Shift-JIS
            936 => 'CP936',
            //    ANSI Chinese Simplified GBK
            949 => 'CP949',
            //    ANSI Korean (Wansung)
            950 => 'CP950',
            //    ANSI Chinese Traditional BIG5
            1200 => 'UTF-16LE',
            //    UTF-16 (BIFF8)
            1250 => 'CP1250',
            //    ANSI Latin II (Central European)
            1251 => 'CP1251',
            //    ANSI Cyrillic
            1252 => 'CP1252',
            //    ANSI Latin I (BIFF4-BIFF7)
            1253 => 'CP1253',
            //    ANSI Greek
            1254 => 'CP1254',
            //    ANSI Turkish
            1255 => 'CP1255',
            //    ANSI Hebrew
            1256 => 'CP1256',
            //    ANSI Arabic
            1257 => 'CP1257',
            //    ANSI Baltic
            1258 => 'CP1258',
            //    ANSI Vietnamese
            1361 => 'CP1361',
            //    ANSI Korean (Johab)
            10000 => 'MAC',
            //    Apple Roman
            10001 => 'CP932',
            //    Macintosh Japanese
            10002 => 'CP950',
            //    Macintosh Chinese Traditional
            10003 => 'CP1361',
            //    Macintosh Korean
            10004 => 'MACARABIC',
            //    Apple Arabic
            10005 => 'MACHEBREW',
            //    Apple Hebrew
            10006 => 'MACGREEK',
            //    Macintosh Greek
            10007 => 'MACCYRILLIC',
            //    Macintosh Cyrillic
            10008 => 'CP936',
            //    Macintosh - Simplified Chinese (GB 2312)
            10010 => 'MACROMANIA',
            //    Macintosh Romania
            10017 => 'MACUKRAINE',
            //    Macintosh Ukraine
            10021 => 'MACTHAI',
            //    Macintosh Thai
            10029 => 'MACCENTRALEUROPE',
            //    Macintosh Central Europe
            10079 => 'MACICELAND',
            //    Macintosh Icelandic
            10081 => 'MACTURKISH',
            //    Macintosh Turkish
            10082 => 'MACCROATIAN',
            //    Macintosh Croatian
            21010 => 'UTF-16LE',
            //    UTF-16 (BIFF8) This isn't correct, but some Excel writer libraries erroneously use Codepage 21010 for UTF-16LE
            32768 => 'MAC',
            //    Apple Roman
            //32769 => 'unsupported', //    ANSI Latin I (BIFF2-BIFF3)
            65000 => 'UTF-7',
            //    Unicode (UTF-7)
            65001 => 'UTF-8',
        ];
        /**
         * Convert Microsoft Code Page Identifier to Code Page Name which iconv
         * and mbstring understands.
         *
         * @param int $codePage Microsoft Code Page Indentifier
         *
         * @return string Code Page Name
         */
        public static function numberToName(int $codePage) : string
        {
        }
        public static function getEncodings() : array
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Shared\Trend {
    class Trend
    {
        const TREND_LINEAR = 'Linear';
        const TREND_LOGARITHMIC = 'Logarithmic';
        const TREND_EXPONENTIAL = 'Exponential';
        const TREND_POWER = 'Power';
        const TREND_POLYNOMIAL_2 = 'Polynomial_2';
        const TREND_POLYNOMIAL_3 = 'Polynomial_3';
        const TREND_POLYNOMIAL_4 = 'Polynomial_4';
        const TREND_POLYNOMIAL_5 = 'Polynomial_5';
        const TREND_POLYNOMIAL_6 = 'Polynomial_6';
        const TREND_BEST_FIT = 'Bestfit';
        const TREND_BEST_FIT_NO_POLY = 'Bestfit_no_Polynomials';
        /**
         * Names of the best-fit Trend analysis methods.
         *
         * @var string[]
         */
        private static $trendTypes = [self::TREND_LINEAR, self::TREND_LOGARITHMIC, self::TREND_EXPONENTIAL, self::TREND_POWER];
        /**
         * Names of the best-fit Trend polynomial orders.
         *
         * @var string[]
         */
        private static $trendTypePolynomialOrders = [self::TREND_POLYNOMIAL_2, self::TREND_POLYNOMIAL_3, self::TREND_POLYNOMIAL_4, self::TREND_POLYNOMIAL_5, self::TREND_POLYNOMIAL_6];
        /**
         * Cached results for each method when trying to identify which provides the best fit.
         *
         * @var bestFit[]
         */
        private static $trendCache = [];
        public static function calculate($trendType = self::TREND_BEST_FIT, $yValues = [], $xValues = [], $const = true)
        {
        }
    }
    class BestFit
    {
        /**
         * Indicator flag for a calculation error.
         *
         * @var bool
         */
        protected $error = false;
        /**
         * Algorithm type to use for best-fit.
         *
         * @var string
         */
        protected $bestFitType = 'undetermined';
        /**
         * Number of entries in the sets of x- and y-value arrays.
         *
         * @var int
         */
        protected $valueCount = 0;
        /**
         * X-value dataseries of values.
         *
         * @var float[]
         */
        protected $xValues = [];
        /**
         * Y-value dataseries of values.
         *
         * @var float[]
         */
        protected $yValues = [];
        /**
         * Flag indicating whether values should be adjusted to Y=0.
         *
         * @var bool
         */
        protected $adjustToZero = false;
        /**
         * Y-value series of best-fit values.
         *
         * @var float[]
         */
        protected $yBestFitValues = [];
        protected $goodnessOfFit = 1;
        protected $stdevOfResiduals = 0;
        protected $covariance = 0;
        protected $correlation = 0;
        protected $SSRegression = 0;
        protected $SSResiduals = 0;
        protected $DFResiduals = 0;
        protected $f = 0;
        protected $slope = 0;
        protected $slopeSE = 0;
        protected $intersect = 0;
        protected $intersectSE = 0;
        protected $xOffset = 0;
        protected $yOffset = 0;
        public function getError()
        {
        }
        public function getBestFitType()
        {
        }
        /**
         * Return the Y-Value for a specified value of X.
         *
         * @param float $xValue X-Value
         *
         * @return bool Y-Value
         */
        public function getValueOfYForX($xValue)
        {
        }
        /**
         * Return the X-Value for a specified value of Y.
         *
         * @param float $yValue Y-Value
         *
         * @return bool X-Value
         */
        public function getValueOfXForY($yValue)
        {
        }
        /**
         * Return the original set of X-Values.
         *
         * @return float[] X-Values
         */
        public function getXValues()
        {
        }
        /**
         * Return the Equation of the best-fit line.
         *
         * @param int $dp Number of places of decimal precision to display
         *
         * @return bool
         */
        public function getEquation($dp = 0)
        {
        }
        /**
         * Return the Slope of the line.
         *
         * @param int $dp Number of places of decimal precision to display
         *
         * @return float
         */
        public function getSlope($dp = 0)
        {
        }
        /**
         * Return the standard error of the Slope.
         *
         * @param int $dp Number of places of decimal precision to display
         *
         * @return float
         */
        public function getSlopeSE($dp = 0)
        {
        }
        /**
         * Return the Value of X where it intersects Y = 0.
         *
         * @param int $dp Number of places of decimal precision to display
         *
         * @return float
         */
        public function getIntersect($dp = 0)
        {
        }
        /**
         * Return the standard error of the Intersect.
         *
         * @param int $dp Number of places of decimal precision to display
         *
         * @return float
         */
        public function getIntersectSE($dp = 0)
        {
        }
        /**
         * Return the goodness of fit for this regression.
         *
         * @param int $dp Number of places of decimal precision to return
         *
         * @return float
         */
        public function getGoodnessOfFit($dp = 0)
        {
        }
        /**
         * Return the goodness of fit for this regression.
         *
         * @param int $dp Number of places of decimal precision to return
         *
         * @return float
         */
        public function getGoodnessOfFitPercent($dp = 0)
        {
        }
        /**
         * Return the standard deviation of the residuals for this regression.
         *
         * @param int $dp Number of places of decimal precision to return
         *
         * @return float
         */
        public function getStdevOfResiduals($dp = 0)
        {
        }
        /**
         * @param int $dp Number of places of decimal precision to return
         *
         * @return float
         */
        public function getSSRegression($dp = 0)
        {
        }
        /**
         * @param int $dp Number of places of decimal precision to return
         *
         * @return float
         */
        public function getSSResiduals($dp = 0)
        {
        }
        /**
         * @param int $dp Number of places of decimal precision to return
         *
         * @return float
         */
        public function getDFResiduals($dp = 0)
        {
        }
        /**
         * @param int $dp Number of places of decimal precision to return
         *
         * @return float
         */
        public function getF($dp = 0)
        {
        }
        /**
         * @param int $dp Number of places of decimal precision to return
         *
         * @return float
         */
        public function getCovariance($dp = 0)
        {
        }
        /**
         * @param int $dp Number of places of decimal precision to return
         *
         * @return float
         */
        public function getCorrelation($dp = 0)
        {
        }
        /**
         * @return float[]
         */
        public function getYBestFitValues()
        {
        }
        protected function calculateGoodnessOfFit($sumX, $sumY, $sumX2, $sumY2, $sumXY, $meanX, $meanY, $const) : void
        {
        }
        /**
         * @param float[] $yValues
         * @param float[] $xValues
         * @param bool $const
         */
        protected function leastSquareFit(array $yValues, array $xValues, $const) : void
        {
        }
        /**
         * Define the regression.
         *
         * @param float[] $yValues The set of Y-values for this regression
         * @param float[] $xValues The set of X-values for this regression
         * @param bool $const
         */
        public function __construct($yValues, $xValues = [], $const = true)
        {
        }
    }
    class PowerBestFit extends \PhpOffice\PhpSpreadsheet\Shared\Trend\BestFit
    {
        /**
         * Algorithm type to use for best-fit
         * (Name of this Trend class).
         *
         * @var string
         */
        protected $bestFitType = 'power';
        /**
         * Return the Y-Value for a specified value of X.
         *
         * @param float $xValue X-Value
         *
         * @return float Y-Value
         */
        public function getValueOfYForX($xValue)
        {
        }
        /**
         * Return the X-Value for a specified value of Y.
         *
         * @param float $yValue Y-Value
         *
         * @return float X-Value
         */
        public function getValueOfXForY($yValue)
        {
        }
        /**
         * Return the Equation of the best-fit line.
         *
         * @param int $dp Number of places of decimal precision to display
         *
         * @return string
         */
        public function getEquation($dp = 0)
        {
        }
        /**
         * Return the Value of X where it intersects Y = 0.
         *
         * @param int $dp Number of places of decimal precision to display
         *
         * @return float
         */
        public function getIntersect($dp = 0)
        {
        }
        /**
         * Execute the regression and calculate the goodness of fit for a set of X and Y data values.
         *
         * @param float[] $yValues The set of Y-values for this regression
         * @param float[] $xValues The set of X-values for this regression
         * @param bool $const
         */
        private function powerRegression($yValues, $xValues, $const) : void
        {
        }
        /**
         * Define the regression and calculate the goodness of fit for a set of X and Y data values.
         *
         * @param float[] $yValues The set of Y-values for this regression
         * @param float[] $xValues The set of X-values for this regression
         * @param bool $const
         */
        public function __construct($yValues, $xValues = [], $const = true)
        {
        }
    }
    class PolynomialBestFit extends \PhpOffice\PhpSpreadsheet\Shared\Trend\BestFit
    {
        /**
         * Algorithm type to use for best-fit
         * (Name of this Trend class).
         *
         * @var string
         */
        protected $bestFitType = 'polynomial';
        /**
         * Polynomial order.
         *
         * @var int
         */
        protected $order = 0;
        /**
         * Return the order of this polynomial.
         *
         * @return int
         */
        public function getOrder()
        {
        }
        /**
         * Return the Y-Value for a specified value of X.
         *
         * @param float $xValue X-Value
         *
         * @return float Y-Value
         */
        public function getValueOfYForX($xValue)
        {
        }
        /**
         * Return the X-Value for a specified value of Y.
         *
         * @param float $yValue Y-Value
         *
         * @return float X-Value
         */
        public function getValueOfXForY($yValue)
        {
        }
        /**
         * Return the Equation of the best-fit line.
         *
         * @param int $dp Number of places of decimal precision to display
         *
         * @return string
         */
        public function getEquation($dp = 0)
        {
        }
        /**
         * Return the Slope of the line.
         *
         * @param int $dp Number of places of decimal precision to display
         *
         * @return string
         */
        public function getSlope($dp = 0)
        {
        }
        public function getCoefficients($dp = 0)
        {
        }
        /**
         * Execute the regression and calculate the goodness of fit for a set of X and Y data values.
         *
         * @param int $order Order of Polynomial for this regression
         * @param float[] $yValues The set of Y-values for this regression
         * @param float[] $xValues The set of X-values for this regression
         */
        private function polynomialRegression($order, $yValues, $xValues) : void
        {
        }
        /**
         * Define the regression and calculate the goodness of fit for a set of X and Y data values.
         *
         * @param int $order Order of Polynomial for this regression
         * @param float[] $yValues The set of Y-values for this regression
         * @param float[] $xValues The set of X-values for this regression
         * @param bool $const
         */
        public function __construct($order, $yValues, $xValues = [], $const = true)
        {
        }
    }
    class LinearBestFit extends \PhpOffice\PhpSpreadsheet\Shared\Trend\BestFit
    {
        /**
         * Algorithm type to use for best-fit
         * (Name of this Trend class).
         *
         * @var string
         */
        protected $bestFitType = 'linear';
        /**
         * Return the Y-Value for a specified value of X.
         *
         * @param float $xValue X-Value
         *
         * @return float Y-Value
         */
        public function getValueOfYForX($xValue)
        {
        }
        /**
         * Return the X-Value for a specified value of Y.
         *
         * @param float $yValue Y-Value
         *
         * @return float X-Value
         */
        public function getValueOfXForY($yValue)
        {
        }
        /**
         * Return the Equation of the best-fit line.
         *
         * @param int $dp Number of places of decimal precision to display
         *
         * @return string
         */
        public function getEquation($dp = 0)
        {
        }
        /**
         * Execute the regression and calculate the goodness of fit for a set of X and Y data values.
         *
         * @param float[] $yValues The set of Y-values for this regression
         * @param float[] $xValues The set of X-values for this regression
         * @param bool $const
         */
        private function linearRegression($yValues, $xValues, $const) : void
        {
        }
        /**
         * Define the regression and calculate the goodness of fit for a set of X and Y data values.
         *
         * @param float[] $yValues The set of Y-values for this regression
         * @param float[] $xValues The set of X-values for this regression
         * @param bool $const
         */
        public function __construct($yValues, $xValues = [], $const = true)
        {
        }
    }
    class ExponentialBestFit extends \PhpOffice\PhpSpreadsheet\Shared\Trend\BestFit
    {
        /**
         * Algorithm type to use for best-fit
         * (Name of this Trend class).
         *
         * @var string
         */
        protected $bestFitType = 'exponential';
        /**
         * Return the Y-Value for a specified value of X.
         *
         * @param float $xValue X-Value
         *
         * @return float Y-Value
         */
        public function getValueOfYForX($xValue)
        {
        }
        /**
         * Return the X-Value for a specified value of Y.
         *
         * @param float $yValue Y-Value
         *
         * @return float X-Value
         */
        public function getValueOfXForY($yValue)
        {
        }
        /**
         * Return the Equation of the best-fit line.
         *
         * @param int $dp Number of places of decimal precision to display
         *
         * @return string
         */
        public function getEquation($dp = 0)
        {
        }
        /**
         * Return the Slope of the line.
         *
         * @param int $dp Number of places of decimal precision to display
         *
         * @return float
         */
        public function getSlope($dp = 0)
        {
        }
        /**
         * Return the Value of X where it intersects Y = 0.
         *
         * @param int $dp Number of places of decimal precision to display
         *
         * @return float
         */
        public function getIntersect($dp = 0)
        {
        }
        /**
         * Execute the regression and calculate the goodness of fit for a set of X and Y data values.
         *
         * @param float[] $yValues The set of Y-values for this regression
         * @param float[] $xValues The set of X-values for this regression
         * @param bool $const
         */
        private function exponentialRegression($yValues, $xValues, $const) : void
        {
        }
        /**
         * Define the regression and calculate the goodness of fit for a set of X and Y data values.
         *
         * @param float[] $yValues The set of Y-values for this regression
         * @param float[] $xValues The set of X-values for this regression
         * @param bool $const
         */
        public function __construct($yValues, $xValues = [], $const = true)
        {
        }
    }
    class LogarithmicBestFit extends \PhpOffice\PhpSpreadsheet\Shared\Trend\BestFit
    {
        /**
         * Algorithm type to use for best-fit
         * (Name of this Trend class).
         *
         * @var string
         */
        protected $bestFitType = 'logarithmic';
        /**
         * Return the Y-Value for a specified value of X.
         *
         * @param float $xValue X-Value
         *
         * @return float Y-Value
         */
        public function getValueOfYForX($xValue)
        {
        }
        /**
         * Return the X-Value for a specified value of Y.
         *
         * @param float $yValue Y-Value
         *
         * @return float X-Value
         */
        public function getValueOfXForY($yValue)
        {
        }
        /**
         * Return the Equation of the best-fit line.
         *
         * @param int $dp Number of places of decimal precision to display
         *
         * @return string
         */
        public function getEquation($dp = 0)
        {
        }
        /**
         * Execute the regression and calculate the goodness of fit for a set of X and Y data values.
         *
         * @param float[] $yValues The set of Y-values for this regression
         * @param float[] $xValues The set of X-values for this regression
         * @param bool $const
         */
        private function logarithmicRegression($yValues, $xValues, $const) : void
        {
        }
        /**
         * Define the regression and calculate the goodness of fit for a set of X and Y data values.
         *
         * @param float[] $yValues The set of Y-values for this regression
         * @param float[] $xValues The set of X-values for this regression
         * @param bool $const
         */
        public function __construct($yValues, $xValues = [], $const = true)
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Shared {
    class XMLWriter extends \XMLWriter
    {
        public static $debugEnabled = false;
        /** Temporary storage method */
        const STORAGE_MEMORY = 1;
        const STORAGE_DISK = 2;
        /**
         * Temporary filename.
         *
         * @var string
         */
        private $tempFileName = '';
        /**
         * Create a new XMLWriter instance.
         *
         * @param int $pTemporaryStorage Temporary storage location
         * @param string $pTemporaryStorageFolder Temporary storage folder
         */
        public function __construct($pTemporaryStorage = self::STORAGE_MEMORY, $pTemporaryStorageFolder = null)
        {
        }
        /**
         * Destructor.
         */
        public function __destruct()
        {
        }
        /**
         * Get written data.
         *
         * @return string
         */
        public function getData()
        {
        }
        /**
         * Wrapper method for writeRaw.
         *
         * @param string|string[] $text
         *
         * @return bool
         */
        public function writeRawData($text)
        {
        }
    }
    class Date
    {
        /** constants */
        const CALENDAR_WINDOWS_1900 = 1900;
        //    Base date of 1st Jan 1900 = 1.0
        const CALENDAR_MAC_1904 = 1904;
        //    Base date of 2nd Jan 1904 = 1.0
        /**
         * Names of the months of the year, indexed by shortname
         * Planned usage for locale settings.
         *
         * @var string[]
         */
        public static $monthNames = ['Jan' => 'January', 'Feb' => 'February', 'Mar' => 'March', 'Apr' => 'April', 'May' => 'May', 'Jun' => 'June', 'Jul' => 'July', 'Aug' => 'August', 'Sep' => 'September', 'Oct' => 'October', 'Nov' => 'November', 'Dec' => 'December'];
        /**
         * @var string[]
         */
        public static $numberSuffixes = ['st', 'nd', 'rd', 'th'];
        /**
         * Base calendar year to use for calculations
         * Value is either CALENDAR_WINDOWS_1900 (1900) or CALENDAR_MAC_1904 (1904).
         *
         * @var int
         */
        protected static $excelCalendar = self::CALENDAR_WINDOWS_1900;
        /**
         * Default timezone to use for DateTime objects.
         *
         * @var null|DateTimeZone
         */
        protected static $defaultTimeZone;
        /**
         * Set the Excel calendar (Windows 1900 or Mac 1904).
         *
         * @param int $baseDate Excel base date (1900 or 1904)
         *
         * @return bool Success or failure
         */
        public static function setExcelCalendar($baseDate)
        {
        }
        /**
         * Return the Excel calendar (Windows 1900 or Mac 1904).
         *
         * @return int Excel base date (1900 or 1904)
         */
        public static function getExcelCalendar()
        {
        }
        /**
         * Set the Default timezone to use for dates.
         *
         * @param DateTimeZone|string $timeZone The timezone to set for all Excel datetimestamp to PHP DateTime Object conversions
         *
         * @return bool Success or failure
         */
        public static function setDefaultTimezone($timeZone)
        {
        }
        /**
         * Return the Default timezone being used for dates.
         *
         * @return DateTimeZone The timezone being used as default for Excel timestamp to PHP DateTime object
         */
        public static function getDefaultTimezone()
        {
        }
        /**
         * Validate a timezone.
         *
         * @param DateTimeZone|string $timeZone The timezone to validate, either as a timezone string or object
         *
         * @return DateTimeZone The timezone as a timezone object
         */
        private static function validateTimeZone($timeZone)
        {
        }
        /**
         * Convert a MS serialized datetime value from Excel to a PHP Date/Time object.
         *
         * @param float|int $excelTimestamp MS Excel serialized date/time value
         * @param null|DateTimeZone|string $timeZone The timezone to assume for the Excel timestamp,
         *                                                                        if you don't want to treat it as a UTC value
         *                                                                    Use the default (UST) unless you absolutely need a conversion
         *
         * @return \DateTime PHP date/time object
         */
        public static function excelToDateTimeObject($excelTimestamp, $timeZone = null)
        {
        }
        /**
         * Convert a MS serialized datetime value from Excel to a unix timestamp.
         *
         * @param float|int $excelTimestamp MS Excel serialized date/time value
         * @param null|DateTimeZone|string $timeZone The timezone to assume for the Excel timestamp,
         *                                                                        if you don't want to treat it as a UTC value
         *                                                                    Use the default (UST) unless you absolutely need a conversion
         *
         * @return int Unix timetamp for this date/time
         */
        public static function excelToTimestamp($excelTimestamp, $timeZone = null)
        {
        }
        /**
         * Convert a date from PHP to an MS Excel serialized date/time value.
         *
         * @param mixed $dateValue Unix Timestamp or PHP DateTime object or a string
         *
         * @return bool|float Excel date/time value
         *                                  or boolean FALSE on failure
         */
        public static function PHPToExcel($dateValue)
        {
        }
        /**
         * Convert a PHP DateTime object to an MS Excel serialized date/time value.
         *
         * @param DateTimeInterface $dateValue PHP DateTime object
         *
         * @return float MS Excel serialized date/time value
         */
        public static function dateTimeToExcel(\DateTimeInterface $dateValue)
        {
        }
        /**
         * Convert a Unix timestamp to an MS Excel serialized date/time value.
         *
         * @param int $dateValue Unix Timestamp
         *
         * @return float MS Excel serialized date/time value
         */
        public static function timestampToExcel($dateValue)
        {
        }
        /**
         * formattedPHPToExcel.
         *
         * @param int $year
         * @param int $month
         * @param int $day
         * @param int $hours
         * @param int $minutes
         * @param int $seconds
         *
         * @return float Excel date/time value
         */
        public static function formattedPHPToExcel($year, $month, $day, $hours = 0, $minutes = 0, $seconds = 0)
        {
        }
        /**
         * Is a given cell a date/time?
         *
         * @return bool
         */
        public static function isDateTime(\PhpOffice\PhpSpreadsheet\Cell\Cell $pCell)
        {
        }
        /**
         * Is a given number format a date/time?
         *
         * @return bool
         */
        public static function isDateTimeFormat(\PhpOffice\PhpSpreadsheet\Style\NumberFormat $pFormat)
        {
        }
        private static $possibleDateFormatCharacters = 'eymdHs';
        /**
         * Is a given number format code a date/time?
         *
         * @param string $pFormatCode
         *
         * @return bool
         */
        public static function isDateTimeFormatCode($pFormatCode)
        {
        }
        /**
         * Convert a date/time string to Excel time.
         *
         * @param string $dateValue Examples: '2009-12-31', '2009-12-31 15:59', '2009-12-31 15:59:10'
         *
         * @return false|float Excel date/time serial value
         */
        public static function stringToExcel($dateValue)
        {
        }
        /**
         * Converts a month name (either a long or a short name) to a month number.
         *
         * @param string $month Month name or abbreviation
         *
         * @return int|string Month number (1 - 12), or the original string argument if it isn't a valid month name
         */
        public static function monthStringToNumber($month)
        {
        }
        /**
         * Strips an ordinal from a numeric value.
         *
         * @param string $day Day number with an ordinal
         *
         * @return int|string The integer value with any ordinal stripped, or the original string argument if it isn't a valid numeric
         */
        public static function dayStringToNumber($day)
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Shared\JAMA {
    /**
     *    Class to obtain eigenvalues and eigenvectors of a real matrix.
     *
     *    If A is symmetric, then A = V*D*V' where the eigenvalue matrix D
     *    is diagonal and the eigenvector matrix V is orthogonal (i.e.
     *    A = V.times(D.times(V.transpose())) and V.times(V.transpose())
     *    equals the identity matrix).
     *
     *    If A is not symmetric, then the eigenvalue matrix D is block diagonal
     *    with the real eigenvalues in 1-by-1 blocks and any complex eigenvalues,
     *    lambda + i*mu, in 2-by-2 blocks, [lambda, mu; -mu, lambda].  The
     *    columns of V represent the eigenvectors in the sense that A*V = V*D,
     *    i.e. A.times(V) equals V.times(D).  The matrix V may be badly
     *    conditioned, or even singular, so the validity of the equation
     *    A = V*D*inverse(V) depends upon V.cond().
     *
     *    @author  Paul Meagher
     *
     *    @version 1.1
     */
    class EigenvalueDecomposition
    {
        /**
         * Row and column dimension (square matrix).
         *
         * @var int
         */
        private $n;
        /**
         * Arrays for internal storage of eigenvalues.
         *
         * @var array
         */
        private $d = [];
        private $e = [];
        /**
         * Array for internal storage of eigenvectors.
         *
         * @var array
         */
        private $V = [];
        /**
         * Array for internal storage of nonsymmetric Hessenberg form.
         *
         * @var array
         */
        private $H = [];
        /**
         * Working storage for nonsymmetric algorithm.
         *
         * @var array
         */
        private $ort;
        /**
         * Used for complex scalar division.
         *
         * @var float
         */
        private $cdivr;
        private $cdivi;
        /**
         * Symmetric Householder reduction to tridiagonal form.
         */
        private function tred2() : void
        {
        }
        /**
         * Symmetric tridiagonal QL algorithm.
         *
         *    This is derived from the Algol procedures tql2, by
         *    Bowdler, Martin, Reinsch, and Wilkinson, Handbook for
         *    Auto. Comp., Vol.ii-Linear Algebra, and the corresponding
         * Fortran subroutine in EISPACK.
         */
        private function tql2() : void
        {
        }
        /**
         * Nonsymmetric reduction to Hessenberg form.
         *
         *    This is derived from the Algol procedures orthes and ortran,
         *    by Martin and Wilkinson, Handbook for Auto. Comp.,
         *    Vol.ii-Linear Algebra, and the corresponding
         * Fortran subroutines in EISPACK.
         */
        private function orthes() : void
        {
        }
        /**
         * Performs complex division.
         *
         * @param mixed $xr
         * @param mixed $xi
         * @param mixed $yr
         * @param mixed $yi
         */
        private function cdiv($xr, $xi, $yr, $yi) : void
        {
        }
        /**
         * Nonsymmetric reduction from Hessenberg to real Schur form.
         *
         *    Code is derived from the Algol procedure hqr2,
         *    by Martin and Wilkinson, Handbook for Auto. Comp.,
         *    Vol.ii-Linear Algebra, and the corresponding
         * Fortran subroutine in EISPACK.
         */
        private function hqr2() : void
        {
        }
        // end hqr2
        /**
         * Constructor: Check for symmetry, then construct the eigenvalue decomposition.
         *
         * @param mixed $Arg A Square matrix
         */
        public function __construct($Arg)
        {
        }
        /**
         * Return the eigenvector matrix.
         *
         * @return Matrix V
         */
        public function getV()
        {
        }
        /**
         * Return the real parts of the eigenvalues.
         *
         * @return array real(diag(D))
         */
        public function getRealEigenvalues()
        {
        }
        /**
         * Return the imaginary parts of the eigenvalues.
         *
         * @return array imag(diag(D))
         */
        public function getImagEigenvalues()
        {
        }
        /**
         * Return the block diagonal eigenvalue matrix.
         *
         * @return Matrix D
         */
        public function getD()
        {
        }
    }
    /**
     *    For an m-by-n matrix A with m >= n, the singular value decomposition is
     *    an m-by-n orthogonal matrix U, an n-by-n diagonal matrix S, and
     *    an n-by-n orthogonal matrix V so that A = U*S*V'.
     *
     *    The singular values, sigma[$k] = S[$k][$k], are ordered so that
     *    sigma[0] >= sigma[1] >= ... >= sigma[n-1].
     *
     *    The singular value decompostion always exists, so the constructor will
     *    never fail.  The matrix condition number and the effective numerical
     *    rank can be computed from this decomposition.
     *
     *    @author  Paul Meagher
     *
     *    @version 1.1
     */
    class SingularValueDecomposition
    {
        /**
         * Internal storage of U.
         *
         * @var array
         */
        private $U = [];
        /**
         * Internal storage of V.
         *
         * @var array
         */
        private $V = [];
        /**
         * Internal storage of singular values.
         *
         * @var array
         */
        private $s = [];
        /**
         * Row dimension.
         *
         * @var int
         */
        private $m;
        /**
         * Column dimension.
         *
         * @var int
         */
        private $n;
        /**
         * Construct the singular value decomposition.
         *
         * Derived from LINPACK code.
         *
         * @param mixed $Arg Rectangular matrix
         */
        public function __construct($Arg)
        {
        }
        /**
         * Return the left singular vectors.
         *
         * @return Matrix U
         */
        public function getU()
        {
        }
        /**
         * Return the right singular vectors.
         *
         * @return Matrix V
         */
        public function getV()
        {
        }
        /**
         * Return the one-dimensional array of singular values.
         *
         * @return array diagonal of S
         */
        public function getSingularValues()
        {
        }
        /**
         * Return the diagonal matrix of singular values.
         *
         * @return Matrix S
         */
        public function getS()
        {
        }
        /**
         * Two norm.
         *
         * @return float max(S)
         */
        public function norm2()
        {
        }
        /**
         * Two norm condition number.
         *
         * @return float max(S)/min(S)
         */
        public function cond()
        {
        }
        /**
         * Effective numerical matrix rank.
         *
         * @return int Number of nonnegligible singular values
         */
        public function rank()
        {
        }
    }
    /**
     * Matrix class.
     *
     * @author Paul Meagher
     * @author Michael Bommarito
     * @author Lukasz Karapuda
     * @author Bartek Matosiuk
     *
     * @version 1.8
     *
     * @see https://math.nist.gov/javanumerics/jama/
     */
    class Matrix
    {
        const POLYMORPHIC_ARGUMENT_EXCEPTION = 'Invalid argument pattern for polymorphic function.';
        const ARGUMENT_TYPE_EXCEPTION = 'Invalid argument type.';
        const ARGUMENT_BOUNDS_EXCEPTION = 'Invalid argument range.';
        const MATRIX_DIMENSION_EXCEPTION = 'Matrix dimensions are not equal.';
        const ARRAY_LENGTH_EXCEPTION = 'Array length must be a multiple of m.';
        const MATRIX_SPD_EXCEPTION = 'Can only perform operation on symmetric positive definite matrix.';
        /**
         * Matrix storage.
         *
         * @var array
         */
        public $A = [];
        /**
         * Matrix row dimension.
         *
         * @var int
         */
        private $m;
        /**
         * Matrix column dimension.
         *
         * @var int
         */
        private $n;
        /**
         * Polymorphic constructor.
         *
         * As PHP has no support for polymorphic constructors, we use tricks to make our own sort of polymorphism using func_num_args, func_get_arg, and gettype. In essence, we're just implementing a simple RTTI filter and calling the appropriate constructor.
         */
        public function __construct(...$args)
        {
        }
        /**
         * getArray.
         *
         * @return array Matrix array
         */
        public function getArray()
        {
        }
        /**
         * getRowDimension.
         *
         * @return int Row dimension
         */
        public function getRowDimension()
        {
        }
        /**
         * getColumnDimension.
         *
         * @return int Column dimension
         */
        public function getColumnDimension()
        {
        }
        /**
         * get.
         *
         * Get the i,j-th element of the matrix.
         *
         * @param int $i Row position
         * @param int $j Column position
         *
         * @return mixed Element (int/float/double)
         */
        public function get($i = null, $j = null)
        {
        }
        /**
         * getMatrix.
         *
         *    Get a submatrix
         *
         * @return Matrix Submatrix
         */
        public function getMatrix(...$args)
        {
        }
        /**
         * checkMatrixDimensions.
         *
         *    Is matrix B the same size?
         *
         * @param Matrix $B Matrix B
         *
         * @return bool
         */
        public function checkMatrixDimensions($B = null)
        {
        }
        //    function checkMatrixDimensions()
        /**
         * set.
         *
         * Set the i,j-th element of the matrix.
         *
         * @param int $i Row position
         * @param int $j Column position
         * @param mixed $c Int/float/double value
         *
         * @return mixed Element (int/float/double)
         */
        public function set($i = null, $j = null, $c = null)
        {
        }
        //    function set()
        /**
         * identity.
         *
         * Generate an identity matrix.
         *
         * @param int $m Row dimension
         * @param int $n Column dimension
         *
         * @return Matrix Identity matrix
         */
        public function identity($m = null, $n = null)
        {
        }
        /**
         * diagonal.
         *
         *    Generate a diagonal matrix
         *
         * @param int $m Row dimension
         * @param int $n Column dimension
         * @param mixed $c Diagonal value
         *
         * @return Matrix Diagonal matrix
         */
        public function diagonal($m = null, $n = null, $c = 1)
        {
        }
        /**
         * getMatrixByRow.
         *
         *    Get a submatrix by row index/range
         *
         * @param int $i0 Initial row index
         * @param int $iF Final row index
         *
         * @return Matrix Submatrix
         */
        public function getMatrixByRow($i0 = null, $iF = null)
        {
        }
        /**
         * getMatrixByCol.
         *
         *    Get a submatrix by column index/range
         *
         * @param int $j0 Initial column index
         * @param int $jF Final column index
         *
         * @return Matrix Submatrix
         */
        public function getMatrixByCol($j0 = null, $jF = null)
        {
        }
        /**
         * transpose.
         *
         *    Tranpose matrix
         *
         * @return Matrix Transposed matrix
         */
        public function transpose()
        {
        }
        //    function transpose()
        /**
         * trace.
         *
         *    Sum of diagonal elements
         *
         * @return float Sum of diagonal elements
         */
        public function trace()
        {
        }
        /**
         * uminus.
         *
         *    Unary minus matrix -A
         *
         * @return Matrix Unary minus matrix
         */
        public function uminus()
        {
        }
        /**
         * plus.
         *
         *    A + B
         *
         * @return Matrix Sum
         */
        public function plus(...$args)
        {
        }
        /**
         * plusEquals.
         *
         *    A = A + B
         *
         * @return $this
         */
        public function plusEquals(...$args)
        {
        }
        /**
         * minus.
         *
         *    A - B
         *
         * @return Matrix Sum
         */
        public function minus(...$args)
        {
        }
        /**
         * minusEquals.
         *
         *    A = A - B
         *
         * @return $this
         */
        public function minusEquals(...$args)
        {
        }
        /**
         * arrayTimes.
         *
         *    Element-by-element multiplication
         *    Cij = Aij * Bij
         *
         * @return Matrix Matrix Cij
         */
        public function arrayTimes(...$args)
        {
        }
        /**
         * arrayTimesEquals.
         *
         *    Element-by-element multiplication
         *    Aij = Aij * Bij
         *
         * @return $this
         */
        public function arrayTimesEquals(...$args)
        {
        }
        /**
         * arrayRightDivide.
         *
         *    Element-by-element right division
         *    A / B
         *
         * @return Matrix Division result
         */
        public function arrayRightDivide(...$args)
        {
        }
        /**
         * arrayRightDivideEquals.
         *
         *    Element-by-element right division
         *    Aij = Aij / Bij
         *
         * @return Matrix Matrix Aij
         */
        public function arrayRightDivideEquals(...$args)
        {
        }
        /**
         * arrayLeftDivide.
         *
         *    Element-by-element Left division
         *    A / B
         *
         * @return Matrix Division result
         */
        public function arrayLeftDivide(...$args)
        {
        }
        /**
         * arrayLeftDivideEquals.
         *
         *    Element-by-element Left division
         *    Aij = Aij / Bij
         *
         * @return Matrix Matrix Aij
         */
        public function arrayLeftDivideEquals(...$args)
        {
        }
        /**
         * times.
         *
         *    Matrix multiplication
         *
         * @return Matrix Product
         */
        public function times(...$args)
        {
        }
        /**
         * power.
         *
         *    A = A ^ B
         *
         * @return $this
         */
        public function power(...$args)
        {
        }
        /**
         * concat.
         *
         *    A = A & B
         *
         * @return $this
         */
        public function concat(...$args)
        {
        }
        /**
         * Solve A*X = B.
         *
         * @param Matrix $B Right hand side
         *
         * @return Matrix ... Solution if A is square, least squares solution otherwise
         */
        public function solve($B)
        {
        }
        /**
         * Matrix inverse or pseudoinverse.
         *
         * @return Matrix ... Inverse(A) if A is square, pseudoinverse otherwise.
         */
        public function inverse()
        {
        }
        /**
         * det.
         *
         *    Calculate determinant
         *
         * @return float Determinant
         */
        public function det()
        {
        }
    }
    /**
     *    For an m-by-n matrix A with m >= n, the LU decomposition is an m-by-n
     *    unit lower triangular matrix L, an n-by-n upper triangular matrix U,
     *    and a permutation vector piv of length m so that A(piv,:) = L*U.
     *    If m < n, then L is m-by-m and U is m-by-n.
     *
     *    The LU decompostion with pivoting always exists, even if the matrix is
     *    singular, so the constructor will never fail. The primary use of the
     *    LU decomposition is in the solution of square systems of simultaneous
     *    linear equations. This will fail if isNonsingular() returns false.
     *
     *    @author Paul Meagher
     *    @author Bartosz Matosiuk
     *    @author Michael Bommarito
     *
     *    @version 1.1
     */
    class LUDecomposition
    {
        const MATRIX_SINGULAR_EXCEPTION = 'Can only perform operation on singular matrix.';
        const MATRIX_SQUARE_EXCEPTION = 'Mismatched Row dimension';
        /**
         * Decomposition storage.
         *
         * @var array
         */
        private $LU = [];
        /**
         * Row dimension.
         *
         * @var int
         */
        private $m;
        /**
         * Column dimension.
         *
         * @var int
         */
        private $n;
        /**
         * Pivot sign.
         *
         * @var int
         */
        private $pivsign;
        /**
         * Internal storage of pivot vector.
         *
         * @var array
         */
        private $piv = [];
        /**
         * LU Decomposition constructor.
         *
         * @param Matrix $A Rectangular matrix
         */
        public function __construct($A)
        {
        }
        //    function __construct()
        /**
         * Get lower triangular factor.
         *
         * @return Matrix Lower triangular factor
         */
        public function getL()
        {
        }
        //    function getL()
        /**
         * Get upper triangular factor.
         *
         * @return Matrix Upper triangular factor
         */
        public function getU()
        {
        }
        //    function getU()
        /**
         * Return pivot permutation vector.
         *
         * @return array Pivot vector
         */
        public function getPivot()
        {
        }
        //    function getPivot()
        /**
         * Alias for getPivot.
         *
         *    @see getPivot
         */
        public function getDoublePivot()
        {
        }
        //    function getDoublePivot()
        /**
         *    Is the matrix nonsingular?
         *
         * @return bool true if U, and hence A, is nonsingular
         */
        public function isNonsingular()
        {
        }
        //    function isNonsingular()
        /**
         * Count determinants.
         *
         * @return array d matrix deterninat
         */
        public function det()
        {
        }
        //    function det()
        /**
         * Solve A*X = B.
         *
         * @param mixed $B a Matrix with as many rows as A and any number of columns
         *
         * @return Matrix X so that L*U*X = B(piv,:)
         */
        public function solve($B)
        {
        }
    }
    /**
     *    For an m-by-n matrix A with m >= n, the QR decomposition is an m-by-n
     *    orthogonal matrix Q and an n-by-n upper triangular matrix R so that
     *    A = Q*R.
     *
     *    The QR decompostion always exists, even if the matrix does not have
     *    full rank, so the constructor will never fail.  The primary use of the
     *    QR decomposition is in the least squares solution of nonsquare systems
     *    of simultaneous linear equations.  This will fail if isFullRank()
     *    returns false.
     *
     *    @author  Paul Meagher
     *
     *    @version 1.1
     */
    class QRDecomposition
    {
        const MATRIX_RANK_EXCEPTION = 'Can only perform operation on full-rank matrix.';
        /**
         * Array for internal storage of decomposition.
         *
         * @var array
         */
        private $QR = [];
        /**
         * Row dimension.
         *
         * @var int
         */
        private $m;
        /**
         * Column dimension.
         *
         * @var int
         */
        private $n;
        /**
         * Array for internal storage of diagonal of R.
         *
         * @var array
         */
        private $Rdiag = [];
        /**
         * QR Decomposition computed by Householder reflections.
         *
         * @param matrix $A Rectangular matrix
         */
        public function __construct($A)
        {
        }
        //    function __construct()
        /**
         *    Is the matrix full rank?
         *
         * @return bool true if R, and hence A, has full rank, else false
         */
        public function isFullRank()
        {
        }
        //    function isFullRank()
        /**
         * Return the Householder vectors.
         *
         * @return Matrix Lower trapezoidal matrix whose columns define the reflections
         */
        public function getH()
        {
        }
        //    function getH()
        /**
         * Return the upper triangular factor.
         *
         * @return Matrix upper triangular factor
         */
        public function getR()
        {
        }
        //    function getR()
        /**
         * Generate and return the (economy-sized) orthogonal factor.
         *
         * @return Matrix orthogonal factor
         */
        public function getQ()
        {
        }
        //    function getQ()
        /**
         * Least squares solution of A*X = B.
         *
         * @param Matrix $B a Matrix with as many rows as A and any number of columns
         *
         * @return Matrix matrix that minimizes the two norm of Q*R*X-B
         */
        public function solve($B)
        {
        }
    }
    /**
     *    Cholesky decomposition class.
     *
     *    For a symmetric, positive definite matrix A, the Cholesky decomposition
     *    is an lower triangular matrix L so that A = L*L'.
     *
     *    If the matrix is not symmetric or positive definite, the constructor
     *    returns a partial decomposition and sets an internal flag that may
     *    be queried by the isSPD() method.
     *
     *    @author Paul Meagher
     *    @author Michael Bommarito
     *
     *    @version 1.2
     */
    class CholeskyDecomposition
    {
        /**
         * Decomposition storage.
         *
         * @var array
         */
        private $L = [];
        /**
         * Matrix row and column dimension.
         *
         * @var int
         */
        private $m;
        /**
         * Symmetric positive definite flag.
         *
         * @var bool
         */
        private $isspd = true;
        /**
         * CholeskyDecomposition.
         *
         *    Class constructor - decomposes symmetric positive definite matrix
         *
         * @param Matrix $A Matrix square symmetric positive definite matrix
         */
        public function __construct(\PhpOffice\PhpSpreadsheet\Shared\JAMA\Matrix $A)
        {
        }
        /**
         *    Is the matrix symmetric and positive definite?
         *
         * @return bool
         */
        public function isSPD()
        {
        }
        /**
         * getL.
         *
         * Return triangular factor.
         *
         * @return Matrix Lower triangular matrix
         */
        public function getL()
        {
        }
        /**
         * Solve A*X = B.
         *
         * @param $B Row-equal matrix
         *
         * @return Matrix L * L' * X = B
         */
        public function solve(\PhpOffice\PhpSpreadsheet\Shared\JAMA\Matrix $B)
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Shared {
    class TimeZone
    {
        /**
         * Default Timezone used for date/time conversions.
         *
         * @var string
         */
        protected static $timezone = 'UTC';
        /**
         * Validate a Timezone name.
         *
         * @param string $timezone Time zone (e.g. 'Europe/London')
         *
         * @return bool Success or failure
         */
        private static function validateTimeZone($timezone)
        {
        }
        /**
         * Set the Default Timezone used for date/time conversions.
         *
         * @param string $timezone Time zone (e.g. 'Europe/London')
         *
         * @return bool Success or failure
         */
        public static function setTimeZone($timezone)
        {
        }
        /**
         * Return the Default Timezone used for date/time conversions.
         *
         * @return string Timezone (e.g. 'Europe/London')
         */
        public static function getTimeZone()
        {
        }
        /**
         *    Return the Timezone offset used for date/time conversions to/from UST
         * This requires both the timezone and the calculated date/time to allow for local DST.
         *
         * @param string $timezone The timezone for finding the adjustment to UST
         * @param int $timestamp PHP date/time value
         *
         * @return int Number of seconds for timezone adjustment
         */
        public static function getTimeZoneAdjustment($timezone, $timestamp)
        {
        }
    }
    /**
     * OLE package base class.
     *
     * @author   Xavier Noguer <xnoguer@php.net>
     * @author   Christian Schmidt <schmidt@php.net>
     */
    class OLE
    {
        const OLE_PPS_TYPE_ROOT = 5;
        const OLE_PPS_TYPE_DIR = 1;
        const OLE_PPS_TYPE_FILE = 2;
        const OLE_DATA_SIZE_SMALL = 0x1000;
        const OLE_LONG_INT_SIZE = 4;
        const OLE_PPS_SIZE = 0x80;
        /**
         * The file handle for reading an OLE container.
         *
         * @var resource
         */
        public $_file_handle;
        /**
         * Array of PPS's found on the OLE container.
         *
         * @var array
         */
        public $_list = [];
        /**
         * Root directory of OLE container.
         *
         * @var Root
         */
        public $root;
        /**
         * Big Block Allocation Table.
         *
         * @var array (blockId => nextBlockId)
         */
        public $bbat;
        /**
         * Short Block Allocation Table.
         *
         * @var array (blockId => nextBlockId)
         */
        public $sbat;
        /**
         * Size of big blocks. This is usually 512.
         *
         * @var int number of octets per block
         */
        public $bigBlockSize;
        /**
         * Size of small blocks. This is usually 64.
         *
         * @var int number of octets per block
         */
        public $smallBlockSize;
        /**
         * Threshold for big blocks.
         *
         * @var int
         */
        public $bigBlockThreshold;
        /**
         * Reads an OLE container from the contents of the file given.
         *
         * @acces public
         *
         * @param string $file
         *
         * @return bool true on success, PEAR_Error on failure
         */
        public function read($file)
        {
        }
        /**
         * @param int $blockId byte offset from beginning of file
         *
         * @return int
         */
        public function _getBlockOffset($blockId)
        {
        }
        /**
         * Returns a stream for use with fread() etc. External callers should
         * use \PhpOffice\PhpSpreadsheet\Shared\OLE\PPS\File::getStream().
         *
         * @param int|OLE\PPS $blockIdOrPps block id or PPS
         *
         * @return resource read-only stream
         */
        public function getStream($blockIdOrPps)
        {
        }
        /**
         * Reads a signed char.
         *
         * @param resource $fh file handle
         *
         * @return int
         */
        private static function _readInt1($fh)
        {
        }
        /**
         * Reads an unsigned short (2 octets).
         *
         * @param resource $fh file handle
         *
         * @return int
         */
        private static function _readInt2($fh)
        {
        }
        /**
         * Reads an unsigned long (4 octets).
         *
         * @param resource $fh file handle
         *
         * @return int
         */
        private static function _readInt4($fh)
        {
        }
        /**
         * Gets information about all PPS's on the OLE container from the PPS WK's
         * creates an OLE_PPS object for each one.
         *
         * @param int $blockId the block id of the first block
         *
         * @return bool true on success, PEAR_Error on failure
         */
        public function _readPpsWks($blockId)
        {
        }
        /**
         * It checks whether the PPS tree is complete (all PPS's read)
         * starting with the given PPS (not necessarily root).
         *
         * @param int $index The index of the PPS from which we are checking
         *
         * @return bool Whether the PPS tree for the given PPS is complete
         */
        public function _ppsTreeComplete($index)
        {
        }
        /**
         * Checks whether a PPS is a File PPS or not.
         * If there is no PPS for the index given, it will return false.
         *
         * @param int $index The index for the PPS
         *
         * @return bool true if it's a File PPS, false otherwise
         */
        public function isFile($index)
        {
        }
        /**
         * Checks whether a PPS is a Root PPS or not.
         * If there is no PPS for the index given, it will return false.
         *
         * @param int $index the index for the PPS
         *
         * @return bool true if it's a Root PPS, false otherwise
         */
        public function isRoot($index)
        {
        }
        /**
         * Gives the total number of PPS's found in the OLE container.
         *
         * @return int The total number of PPS's found in the OLE container
         */
        public function ppsTotal()
        {
        }
        /**
         * Gets data from a PPS
         * If there is no PPS for the index given, it will return an empty string.
         *
         * @param int $index The index for the PPS
         * @param int $position The position from which to start reading
         *                          (relative to the PPS)
         * @param int $length The amount of bytes to read (at most)
         *
         * @return string The binary string containing the data requested
         *
         * @see OLE_PPS_File::getStream()
         */
        public function getData($index, $position, $length)
        {
        }
        /**
         * Gets the data length from a PPS
         * If there is no PPS for the index given, it will return 0.
         *
         * @param int $index The index for the PPS
         *
         * @return int The amount of bytes in data the PPS has
         */
        public function getDataLength($index)
        {
        }
        /**
         * Utility function to transform ASCII text to Unicode.
         *
         * @param string $ascii The ASCII string to transform
         *
         * @return string The string in Unicode
         */
        public static function ascToUcs($ascii)
        {
        }
        /**
         * Utility function
         * Returns a string for the OLE container with the date given.
         *
         * @param int $date A timestamp
         *
         * @return string The string for the OLE container
         */
        public static function localDateToOLE($date)
        {
        }
        /**
         * Returns a timestamp from an OLE container's date.
         *
         * @param string $oleTimestamp A binary string with the encoded date
         *
         * @return int The Unix timestamp corresponding to the string
         */
        public static function OLE2LocalDate($oleTimestamp)
        {
        }
    }
    class File
    {
        /**
         * Use Temp or File Upload Temp for temporary files.
         *
         * @var bool
         */
        protected static $useUploadTempDirectory = false;
        /**
         * Set the flag indicating whether the File Upload Temp directory should be used for temporary files.
         *
         * @param bool $useUploadTempDir Use File Upload Temporary directory (true or false)
         */
        public static function setUseUploadTempDirectory($useUploadTempDir) : void
        {
        }
        /**
         * Get the flag indicating whether the File Upload Temp directory should be used for temporary files.
         *
         * @return bool Use File Upload Temporary directory (true or false)
         */
        public static function getUseUploadTempDirectory()
        {
        }
        /**
         * Verify if a file exists.
         *
         * @param string $pFilename Filename
         *
         * @return bool
         */
        public static function fileExists($pFilename)
        {
        }
        /**
         * Returns canonicalized absolute pathname, also for ZIP archives.
         *
         * @param string $pFilename
         *
         * @return string
         */
        public static function realpath($pFilename)
        {
        }
        /**
         * Get the systems temporary directory.
         *
         * @return string
         */
        public static function sysGetTempDir()
        {
        }
        /**
         * Assert that given path is an existing file and is readable, otherwise throw exception.
         *
         * @param string $filename
         */
        public static function assertFile($filename) : void
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Shared\Escher {
    class DgContainer
    {
        /**
         * Drawing index, 1-based.
         *
         * @var int
         */
        private $dgId;
        /**
         * Last shape index in this drawing.
         *
         * @var int
         */
        private $lastSpId;
        private $spgrContainer;
        public function getDgId()
        {
        }
        public function setDgId($value) : void
        {
        }
        public function getLastSpId()
        {
        }
        public function setLastSpId($value) : void
        {
        }
        public function getSpgrContainer()
        {
        }
        public function setSpgrContainer($spgrContainer)
        {
        }
    }
    class DggContainer
    {
        /**
         * Maximum shape index of all shapes in all drawings increased by one.
         *
         * @var int
         */
        private $spIdMax;
        /**
         * Total number of drawings saved.
         *
         * @var int
         */
        private $cDgSaved;
        /**
         * Total number of shapes saved (including group shapes).
         *
         * @var int
         */
        private $cSpSaved;
        /**
         * BLIP Store Container.
         *
         * @var DggContainer\BstoreContainer
         */
        private $bstoreContainer;
        /**
         * Array of options for the drawing group.
         *
         * @var array
         */
        private $OPT = [];
        /**
         * Array of identifier clusters containg information about the maximum shape identifiers.
         *
         * @var array
         */
        private $IDCLs = [];
        /**
         * Get maximum shape index of all shapes in all drawings (plus one).
         *
         * @return int
         */
        public function getSpIdMax()
        {
        }
        /**
         * Set maximum shape index of all shapes in all drawings (plus one).
         *
         * @param int $value
         */
        public function setSpIdMax($value) : void
        {
        }
        /**
         * Get total number of drawings saved.
         *
         * @return int
         */
        public function getCDgSaved()
        {
        }
        /**
         * Set total number of drawings saved.
         *
         * @param int $value
         */
        public function setCDgSaved($value) : void
        {
        }
        /**
         * Get total number of shapes saved (including group shapes).
         *
         * @return int
         */
        public function getCSpSaved()
        {
        }
        /**
         * Set total number of shapes saved (including group shapes).
         *
         * @param int $value
         */
        public function setCSpSaved($value) : void
        {
        }
        /**
         * Get BLIP Store Container.
         *
         * @return DggContainer\BstoreContainer
         */
        public function getBstoreContainer()
        {
        }
        /**
         * Set BLIP Store Container.
         *
         * @param DggContainer\BstoreContainer $bstoreContainer
         */
        public function setBstoreContainer($bstoreContainer) : void
        {
        }
        /**
         * Set an option for the drawing group.
         *
         * @param int $property The number specifies the option
         * @param mixed $value
         */
        public function setOPT($property, $value) : void
        {
        }
        /**
         * Get an option for the drawing group.
         *
         * @param int $property The number specifies the option
         *
         * @return mixed
         */
        public function getOPT($property)
        {
        }
        /**
         * Get identifier clusters.
         *
         * @return array
         */
        public function getIDCLs()
        {
        }
        /**
         * Set identifier clusters. [<drawingId> => <max shape id>, ...].
         *
         * @param array $pValue
         */
        public function setIDCLs($pValue) : void
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Shared\Escher\DggContainer {
    class BstoreContainer
    {
        /**
         * BLIP Store Entries. Each of them holds one BLIP (Big Large Image or Picture).
         *
         * @var array
         */
        private $BSECollection = [];
        /**
         * Add a BLIP Store Entry.
         *
         * @param BstoreContainer\BSE $BSE
         */
        public function addBSE($BSE) : void
        {
        }
        /**
         * Get the collection of BLIP Store Entries.
         *
         * @return BstoreContainer\BSE[]
         */
        public function getBSECollection()
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Shared\Escher\DggContainer\BstoreContainer {
    class BSE
    {
        const BLIPTYPE_ERROR = 0x0;
        const BLIPTYPE_UNKNOWN = 0x1;
        const BLIPTYPE_EMF = 0x2;
        const BLIPTYPE_WMF = 0x3;
        const BLIPTYPE_PICT = 0x4;
        const BLIPTYPE_JPEG = 0x5;
        const BLIPTYPE_PNG = 0x6;
        const BLIPTYPE_DIB = 0x7;
        const BLIPTYPE_TIFF = 0x11;
        const BLIPTYPE_CMYKJPEG = 0x12;
        /**
         * The parent BLIP Store Entry Container.
         *
         * @var \PhpOffice\PhpSpreadsheet\Shared\Escher\DggContainer\BstoreContainer
         */
        private $parent;
        /**
         * The BLIP (Big Large Image or Picture).
         *
         * @var BSE\Blip
         */
        private $blip;
        /**
         * The BLIP type.
         *
         * @var int
         */
        private $blipType;
        /**
         * Set parent BLIP Store Entry Container.
         *
         * @param \PhpOffice\PhpSpreadsheet\Shared\Escher\DggContainer\BstoreContainer $parent
         */
        public function setParent($parent) : void
        {
        }
        /**
         * Get the BLIP.
         *
         * @return BSE\Blip
         */
        public function getBlip()
        {
        }
        /**
         * Set the BLIP.
         *
         * @param BSE\Blip $blip
         */
        public function setBlip($blip) : void
        {
        }
        /**
         * Get the BLIP type.
         *
         * @return int
         */
        public function getBlipType()
        {
        }
        /**
         * Set the BLIP type.
         *
         * @param int $blipType
         */
        public function setBlipType($blipType) : void
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Shared\Escher\DggContainer\BstoreContainer\BSE {
    class Blip
    {
        /**
         * The parent BSE.
         *
         * @var \PhpOffice\PhpSpreadsheet\Shared\Escher\DggContainer\BstoreContainer\BSE
         */
        private $parent;
        /**
         * Raw image data.
         *
         * @var string
         */
        private $data;
        /**
         * Get the raw image data.
         *
         * @return string
         */
        public function getData()
        {
        }
        /**
         * Set the raw image data.
         *
         * @param string $data
         */
        public function setData($data) : void
        {
        }
        /**
         * Set parent BSE.
         *
         * @param \PhpOffice\PhpSpreadsheet\Shared\Escher\DggContainer\BstoreContainer\BSE $parent
         */
        public function setParent($parent) : void
        {
        }
        /**
         * Get parent BSE.
         *
         * @return \PhpOffice\PhpSpreadsheet\Shared\Escher\DggContainer\BstoreContainer\BSE $parent
         */
        public function getParent()
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Shared\Escher\DgContainer\SpgrContainer {
    class SpContainer
    {
        /**
         * Parent Shape Group Container.
         *
         * @var SpgrContainer
         */
        private $parent;
        /**
         * Is this a group shape?
         *
         * @var bool
         */
        private $spgr = false;
        /**
         * Shape type.
         *
         * @var int
         */
        private $spType;
        /**
         * Shape flag.
         *
         * @var int
         */
        private $spFlag;
        /**
         * Shape index (usually group shape has index 0, and the rest: 1,2,3...).
         *
         * @var int
         */
        private $spId;
        /**
         * Array of options.
         *
         * @var array
         */
        private $OPT;
        /**
         * Cell coordinates of upper-left corner of shape, e.g. 'A1'.
         *
         * @var string
         */
        private $startCoordinates;
        /**
         * Horizontal offset of upper-left corner of shape measured in 1/1024 of column width.
         *
         * @var int
         */
        private $startOffsetX;
        /**
         * Vertical offset of upper-left corner of shape measured in 1/256 of row height.
         *
         * @var int
         */
        private $startOffsetY;
        /**
         * Cell coordinates of bottom-right corner of shape, e.g. 'B2'.
         *
         * @var string
         */
        private $endCoordinates;
        /**
         * Horizontal offset of bottom-right corner of shape measured in 1/1024 of column width.
         *
         * @var int
         */
        private $endOffsetX;
        /**
         * Vertical offset of bottom-right corner of shape measured in 1/256 of row height.
         *
         * @var int
         */
        private $endOffsetY;
        /**
         * Set parent Shape Group Container.
         *
         * @param SpgrContainer $parent
         */
        public function setParent($parent) : void
        {
        }
        /**
         * Get the parent Shape Group Container.
         *
         * @return SpgrContainer
         */
        public function getParent()
        {
        }
        /**
         * Set whether this is a group shape.
         *
         * @param bool $value
         */
        public function setSpgr($value) : void
        {
        }
        /**
         * Get whether this is a group shape.
         *
         * @return bool
         */
        public function getSpgr()
        {
        }
        /**
         * Set the shape type.
         *
         * @param int $value
         */
        public function setSpType($value) : void
        {
        }
        /**
         * Get the shape type.
         *
         * @return int
         */
        public function getSpType()
        {
        }
        /**
         * Set the shape flag.
         *
         * @param int $value
         */
        public function setSpFlag($value) : void
        {
        }
        /**
         * Get the shape flag.
         *
         * @return int
         */
        public function getSpFlag()
        {
        }
        /**
         * Set the shape index.
         *
         * @param int $value
         */
        public function setSpId($value) : void
        {
        }
        /**
         * Get the shape index.
         *
         * @return int
         */
        public function getSpId()
        {
        }
        /**
         * Set an option for the Shape Group Container.
         *
         * @param int $property The number specifies the option
         * @param mixed $value
         */
        public function setOPT($property, $value) : void
        {
        }
        /**
         * Get an option for the Shape Group Container.
         *
         * @param int $property The number specifies the option
         *
         * @return mixed
         */
        public function getOPT($property)
        {
        }
        /**
         * Get the collection of options.
         *
         * @return array
         */
        public function getOPTCollection()
        {
        }
        /**
         * Set cell coordinates of upper-left corner of shape.
         *
         * @param string $value eg: 'A1'
         */
        public function setStartCoordinates($value) : void
        {
        }
        /**
         * Get cell coordinates of upper-left corner of shape.
         *
         * @return string
         */
        public function getStartCoordinates()
        {
        }
        /**
         * Set offset in x-direction of upper-left corner of shape measured in 1/1024 of column width.
         *
         * @param int $startOffsetX
         */
        public function setStartOffsetX($startOffsetX) : void
        {
        }
        /**
         * Get offset in x-direction of upper-left corner of shape measured in 1/1024 of column width.
         *
         * @return int
         */
        public function getStartOffsetX()
        {
        }
        /**
         * Set offset in y-direction of upper-left corner of shape measured in 1/256 of row height.
         *
         * @param int $startOffsetY
         */
        public function setStartOffsetY($startOffsetY) : void
        {
        }
        /**
         * Get offset in y-direction of upper-left corner of shape measured in 1/256 of row height.
         *
         * @return int
         */
        public function getStartOffsetY()
        {
        }
        /**
         * Set cell coordinates of bottom-right corner of shape.
         *
         * @param string $value eg: 'A1'
         */
        public function setEndCoordinates($value) : void
        {
        }
        /**
         * Get cell coordinates of bottom-right corner of shape.
         *
         * @return string
         */
        public function getEndCoordinates()
        {
        }
        /**
         * Set offset in x-direction of bottom-right corner of shape measured in 1/1024 of column width.
         *
         * @param int $endOffsetX
         */
        public function setEndOffsetX($endOffsetX) : void
        {
        }
        /**
         * Get offset in x-direction of bottom-right corner of shape measured in 1/1024 of column width.
         *
         * @return int
         */
        public function getEndOffsetX()
        {
        }
        /**
         * Set offset in y-direction of bottom-right corner of shape measured in 1/256 of row height.
         *
         * @param int $endOffsetY
         */
        public function setEndOffsetY($endOffsetY) : void
        {
        }
        /**
         * Get offset in y-direction of bottom-right corner of shape measured in 1/256 of row height.
         *
         * @return int
         */
        public function getEndOffsetY()
        {
        }
        /**
         * Get the nesting level of this spContainer. This is the number of spgrContainers between this spContainer and
         * the dgContainer. A value of 1 = immediately within first spgrContainer
         * Higher nesting level occurs if and only if spContainer is part of a shape group.
         *
         * @return int Nesting level
         */
        public function getNestingLevel()
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Shared\Escher\DgContainer {
    class SpgrContainer
    {
        /**
         * Parent Shape Group Container.
         *
         * @var \PhpOffice\PhpSpreadsheet\Shared\Escher\DgContainer\SpgrContainer
         */
        private $parent;
        /**
         * Shape Container collection.
         *
         * @var array
         */
        private $children = [];
        /**
         * Set parent Shape Group Container.
         *
         * @param \PhpOffice\PhpSpreadsheet\Shared\Escher\DgContainer\SpgrContainer $parent
         */
        public function setParent($parent) : void
        {
        }
        /**
         * Get the parent Shape Group Container if any.
         *
         * @return null|\PhpOffice\PhpSpreadsheet\Shared\Escher\DgContainer\SpgrContainer
         */
        public function getParent()
        {
        }
        /**
         * Add a child. This will be either spgrContainer or spContainer.
         *
         * @param mixed $child
         */
        public function addChild($child) : void
        {
        }
        /**
         * Get collection of Shape Containers.
         */
        public function getChildren()
        {
        }
        /**
         * Recursively get all spContainers within this spgrContainer.
         *
         * @return SpgrContainer\SpContainer[]
         */
        public function getAllSpContainers()
        {
        }
    }
}
namespace PhpOffice\PhpSpreadsheet\Shared {
    class Xls
    {
        /**
         * Get the width of a column in pixels. We use the relationship y = ceil(7x) where
         * x is the width in intrinsic Excel units (measuring width in number of normal characters)
         * This holds for Arial 10.
         *
         * @param Worksheet $sheet The sheet
         * @param string $col The column
         *
         * @return int The width in pixels
         */
        public static function sizeCol($sheet, $col = 'A')
        {
        }
        /**
         * Convert the height of a cell from user's units to pixels. By interpolation
         * the relationship is: y = 4/3x. If the height hasn't been set by the user we
         * use the default value. If the row is hidden we use a value of zero.
         *
         * @param Worksheet $sheet The sheet
         * @param int $row The row index (1-based)
         *
         * @return int The width in pixels
         */
        public static function sizeRow($sheet, $row = 1)
        {
        }
        /**
         * Get the horizontal distance in pixels between two anchors
         * The distanceX is found as sum of all the spanning columns widths minus correction for the two offsets.
         *
         * @param string $startColumn
         * @param int $startOffsetX Offset within start cell measured in 1/1024 of the cell width
         * @param string $endColumn
         * @param int $endOffsetX Offset within end cell measured in 1/1024 of the cell width
         *
         * @return int Horizontal measured in pixels
         */
        public static function getDistanceX(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $sheet, $startColumn = 'A', $startOffsetX = 0, $endColumn = 'A', $endOffsetX = 0)
        {
        }
        /**
         * Get the vertical distance in pixels between two anchors
         * The distanceY is found as sum of all the spanning rows minus two offsets.
         *
         * @param int $startRow (1-based)
         * @param int $startOffsetY Offset within start cell measured in 1/256 of the cell height
         * @param int $endRow (1-based)
         * @param int $endOffsetY Offset within end cell measured in 1/256 of the cell height
         *
         * @return int Vertical distance measured in pixels
         */
        public static function getDistanceY(\PhpOffice\PhpSpreadsheet\Worksheet\Worksheet $sheet, $startRow = 1, $startOffsetY = 0, $endRow = 1, $endOffsetY = 0)
        {
        }
        /**
         * Convert 1-cell anchor coordinates to 2-cell anchor coordinates
         * This function is ported from PEAR Spreadsheet_Writer_Excel with small modifications.
         *
         * Calculate the vertices that define the position of the image as required by
         * the OBJ record.
         *
         *         +------------+------------+
         *         |     A      |      B     |
         *   +-----+------------+------------+
         *   |     |(x1,y1)     |            |
         *   |  1  |(A1)._______|______      |
         *   |     |    |              |     |
         *   |     |    |              |     |
         *   +-----+----|    BITMAP    |-----+
         *   |     |    |              |     |
         *   |  2  |    |______________.     |
         *   |     |            |        (B2)|
         *   |     |            |     (x2,y2)|
         *   +---- +------------+------------+
         *
         * Example of a bitmap that covers some of the area from cell A1 to cell B2.
         *
         * Based on the width and height of the bitmap we need to calculate 8 vars:
         *     $col_start, $row_start, $col_end, $row_end, $x1, $y1, $x2, $y2.
         * The width and height of the cells are also variable and have to be taken into
         * account.
         * The values of $col_start and $row_start are passed in from the calling
         * function. The values of $col_end and $row_end are calculated by subtracting
         * the width and height of the bitmap from the width and height of the
         * underlying cells.
         * The vertices are expressed as a percentage of the underlying cell width as
         * follows (rhs values are in pixels):
         *
         *       x1 = X / W *1024
         *       y1 = Y / H *256
         *       x2 = (X-1) / W *1024
         *       y2 = (Y-1) / H *256
         *
         *       Where:  X is distance from the left side of the underlying cell
         *               Y is distance from the top of the underlying cell
         *               W is the width of the cell
         *               H is the height of the cell
         *
         * @param Worksheet $sheet
         * @param string $coordinates E.g. 'A1'
         * @param int $offsetX Horizontal offset in pixels
         * @param int $offsetY Vertical offset in pixels
         * @param int $width Width in pixels
         * @param int $height Height in pixels
         *
         * @return array
         */
        public static function oneAnchor2twoAnchor($sheet, $coordinates, $offsetX, $offsetY, $width, $height)
        {
        }
    }
    class Font
    {
        // Methods for resolving autosize value
        const AUTOSIZE_METHOD_APPROX = 'approx';
        const AUTOSIZE_METHOD_EXACT = 'exact';
        private static $autoSizeMethods = [self::AUTOSIZE_METHOD_APPROX, self::AUTOSIZE_METHOD_EXACT];
        /** Character set codes used by BIFF5-8 in Font records */
        const CHARSET_ANSI_LATIN = 0x0;
        const CHARSET_SYSTEM_DEFAULT = 0x1;
        const CHARSET_SYMBOL = 0x2;
        const CHARSET_APPLE_ROMAN = 0x4d;
        const CHARSET_ANSI_JAPANESE_SHIFTJIS = 0x80;
        const CHARSET_ANSI_KOREAN_HANGUL = 0x81;
        const CHARSET_ANSI_KOREAN_JOHAB = 0x82;
        const CHARSET_ANSI_CHINESE_SIMIPLIFIED = 0x86;
        //    gb2312
        const CHARSET_ANSI_CHINESE_TRADITIONAL = 0x88;
        //    big5
        const CHARSET_ANSI_GREEK = 0xa1;
        const CHARSET_ANSI_TURKISH = 0xa2;
        const CHARSET_ANSI_VIETNAMESE = 0xa3;
        const CHARSET_ANSI_HEBREW = 0xb1;
        const CHARSET_ANSI_ARABIC = 0xb2;
        const CHARSET_ANSI_BALTIC = 0xba;
        const CHARSET_ANSI_CYRILLIC = 0xcc;
        const CHARSET_ANSI_THAI = 0xdd;
        const CHARSET_ANSI_LATIN_II = 0xee;
        const CHARSET_OEM_LATIN_I = 0xff;
        //  XXX: Constants created!
        /** Font filenames */
        const ARIAL = 'arial.ttf';
        const ARIAL_BOLD = 'arialbd.ttf';
        const ARIAL_ITALIC = 'ariali.ttf';
        const ARIAL_BOLD_ITALIC = 'arialbi.ttf';
        const CALIBRI = 'CALIBRI.TTF';
        const CALIBRI_BOLD = 'CALIBRIB.TTF';
        const CALIBRI_ITALIC = 'CALIBRII.TTF';
        const CALIBRI_BOLD_ITALIC = 'CALIBRIZ.TTF';
        const COMIC_SANS_MS = 'comic.ttf';
        const COMIC_SANS_MS_BOLD = 'comicbd.ttf';
        const COURIER_NEW = 'cour.ttf';
        const COURIER_NEW_BOLD = 'courbd.ttf';
        const COURIER_NEW_ITALIC = 'couri.ttf';
        const COURIER_NEW_BOLD_ITALIC = 'courbi.ttf';
        const GEORGIA = 'georgia.ttf';
        const GEORGIA_BOLD = 'georgiab.ttf';
        const GEORGIA_ITALIC = 'georgiai.ttf';
        const GEORGIA_BOLD_ITALIC = 'georgiaz.ttf';
        const IMPACT = 'impact.ttf';
        const LIBERATION_SANS = 'LiberationSans-Regular.ttf';
        const LIBERATION_SANS_BOLD = 'LiberationSans-Bold.ttf';
        const LIBERATION_SANS_ITALIC = 'LiberationSans-Italic.ttf';
        const LIBERATION_SANS_BOLD_ITALIC = 'LiberationSans-BoldItalic.ttf';
        const LUCIDA_CONSOLE = 'lucon.ttf';
        const LUCIDA_SANS_UNICODE = 'l_10646.ttf';
        const MICROSOFT_SANS_SERIF = 'micross.ttf';
        const PALATINO_LINOTYPE = 'pala.ttf';
        const PALATINO_LINOTYPE_BOLD = 'palab.ttf';
        const PALATINO_LINOTYPE_ITALIC = 'palai.ttf';
        const PALATINO_LINOTYPE_BOLD_ITALIC = 'palabi.ttf';
        const SYMBOL = 'symbol.ttf';
        const TAHOMA = 'tahoma.ttf';
        const TAHOMA_BOLD = 'tahomabd.ttf';
        const TIMES_NEW_ROMAN = 'times.ttf';
        const TIMES_NEW_ROMAN_BOLD = 'timesbd.ttf';
        const TIMES_NEW_ROMAN_ITALIC = 'timesi.ttf';
        const TIMES_NEW_ROMAN_BOLD_ITALIC = 'timesbi.ttf';
        const TREBUCHET_MS = 'trebuc.ttf';
        const TREBUCHET_MS_BOLD = 'trebucbd.ttf';
        const TREBUCHET_MS_ITALIC = 'trebucit.ttf';
        const TREBUCHET_MS_BOLD_ITALIC = 'trebucbi.ttf';
        const VERDANA = 'verdana.ttf';
        const VERDANA_BOLD = 'verdanab.ttf';
        const VERDANA_ITALIC = 'verdanai.ttf';
        const VERDANA_BOLD_ITALIC = 'verdanaz.ttf';
        /**
         * AutoSize method.
         *
         * @var string
         */
        private static $autoSizeMethod = self::AUTOSIZE_METHOD_APPROX;
        /**
         * Path to folder containing TrueType font .ttf files.
         *
         * @var string
         */
        private static $trueTypeFontPath = null;
        /**
         * How wide is a default column for a given default font and size?
         * Empirical data found by inspecting real Excel files and reading off the pixel width
         * in Microsoft Office Excel 2007.
         *
         * @var array
         */
        public static $defaultColumnWidths = ['Arial' => [1 => ['px' => 24, 'width' => 12.0], 2 => ['px' => 24, 'width' => 12.0], 3 => ['px' => 32, 'width' => 10.6640625], 4 => ['px' => 32, 'width' => 10.6640625], 5 => ['px' => 40, 'width' => 10.0], 6 => ['px' => 48, 'width' => 9.59765625], 7 => ['px' => 48, 'width' => 9.59765625], 8 => ['px' => 56, 'width' => 9.33203125], 9 => ['px' => 64, 'width' => 9.140625], 10 => ['px' => 64, 'width' => 9.140625]], 'Calibri' => [1 => ['px' => 24, 'width' => 12.0], 2 => ['px' => 24, 'width' => 12.0], 3 => ['px' => 32, 'width' => 10.6640625], 4 => ['px' => 32, 'width' => 10.6640625], 5 => ['px' => 40, 'width' => 10.0], 6 => ['px' => 48, 'width' => 9.59765625], 7 => ['px' => 48, 'width' => 9.59765625], 8 => ['px' => 56, 'width' => 9.33203125], 9 => ['px' => 56, 'width' => 9.33203125], 10 => ['px' => 64, 'width' => 9.140625], 11 => ['px' => 64, 'width' => 9.140625]], 'Verdana' => [1 => ['px' => 24, 'width' => 12.0], 2 => ['px' => 24, 'width' => 12.0], 3 => ['px' => 32, 'width' => 10.6640625], 4 => ['px' => 32, 'width' => 10.6640625], 5 => ['px' => 40, 'width' => 10.0], 6 => ['px' => 48, 'width' => 9.59765625], 7 => ['px' => 48, 'width' => 9.59765625], 8 => ['px' => 64, 'width' => 9.140625], 9 => ['px' => 72, 'width' => 9.0], 10 => ['px' => 72, 'width' => 9.0]]];
        /**
         * Set autoSize method.
         *
         * @param string $pValue see self::AUTOSIZE_METHOD_*
         *
         * @return bool Success or failure
         */
        public static function setAutoSizeMethod($pValue)
        {
        }
        /**
         * Get autoSize method.
         *
         * @return string
         */
        public static function getAutoSizeMethod()
        {
        }
        /**
         * Set the path to the folder containing .ttf files. There should be a trailing slash.
         * Typical locations on variout some platforms:
         *    <ul>
         *        <li>C:/Windows/Fonts/</li>
         *        <li>/usr/share/fonts/truetype/</li>
         *        <li>~/.fonts/</li>
         * </ul>.
         *
         * @param string $pValue
         */
        public static function setTrueTypeFontPath($pValue) : void
        {
        }
        /**
         * Get the path to the folder containing .ttf files.
         *
         * @return string
         */
        public static function getTrueTypeFontPath()
        {
        }
        /**
         * Calculate an (approximate) OpenXML column width, based on font size and text contained.
         *
         * @param \PhpOffice\PhpSpreadsheet\Style\Font $font Font object
         * @param RichText|string $cellText Text to calculate width
         * @param int $rotation Rotation angle
         * @param null|\PhpOffice\PhpSpreadsheet\Style\Font $defaultFont Font object
         *
         * @return int Column width
         */
        public static function calculateColumnWidth(\PhpOffice\PhpSpreadsheet\Style\Font $font, $cellText = '', $rotation = 0, ?\PhpOffice\PhpSpreadsheet\Style\Font $defaultFont = null)
        {
        }
        /**
         * Get GD text width in pixels for a string of text in a certain font at a certain rotation angle.
         *
         * @param string $text
         * @param \PhpOffice\PhpSpreadsheet\Style\Font
         * @param int $rotation
         *
         * @return int
         */
        public static function getTextWidthPixelsExact($text, \PhpOffice\PhpSpreadsheet\Style\Font $font, $rotation = 0)
        {
        }
        /**
         * Get approximate width in pixels for a string of text in a certain font at a certain rotation angle.
         *
         * @param string $columnText
         * @param int $rotation
         *
         * @return int Text width in pixels (no padding added)
         */
        public static function getTextWidthPixelsApprox($columnText, \PhpOffice\PhpSpreadsheet\Style\Font $font, $rotation = 0)
        {
        }
        /**
         * Calculate an (approximate) pixel size, based on a font points size.
         *
         * @param int $fontSizeInPoints Font size (in points)
         *
         * @return int Font size (in pixels)
         */
        public static function fontSizeToPixels($fontSizeInPoints)
        {
        }
        /**
         * Calculate an (approximate) pixel size, based on inch size.
         *
         * @param int $sizeInInch Font size (in inch)
         *
         * @return int Size (in pixels)
         */
        public static function inchSizeToPixels($sizeInInch)
        {
        }
        /**
         * Calculate an (approximate) pixel size, based on centimeter size.
         *
         * @param int $sizeInCm Font size (in centimeters)
         *
         * @return float Size (in pixels)
         */
        public static function centimeterSizeToPixels($sizeInCm)
        {
        }
        /**
         * Returns the font path given the font.
         *
         * @param \PhpOffice\PhpSpreadsheet\Style\Font $font
         *
         * @return string Path to TrueType font file
         */
        public static function getTrueTypeFontFileFromFont($font)
        {
        }
        /**
         * Returns the associated charset for the font name.
         *
         * @param string $name Font name
         *
         * @return int Character set code
         */
        public static function getCharsetFromFontName($name)
        {
        }
        /**
         * Get the effective column width for columns without a column dimension or column with width -1
         * For example, for Calibri 11 this is 9.140625 (64 px).
         *
         * @param \PhpOffice\PhpSpreadsheet\Style\Font $font The workbooks default font
         * @param bool $pPixels true = return column width in pixels, false = return in OOXML units
         *
         * @return mixed Column width
         */
        public static function getDefaultColumnWidthByFont(\PhpOffice\PhpSpreadsheet\Style\Font $font, $pPixels = false)
        {
        }
        /**
         * Get the effective row height for rows without a row dimension or rows with height -1
         * For example, for Calibri 11 this is 15 points.
         *
         * @param \PhpOffice\PhpSpreadsheet\Style\Font $font The workbooks default font
         *
         * @return float Row height in points
         */
        public static function getDefaultRowHeightByFont(\PhpOffice\PhpSpreadsheet\Style\Font $font)
        {
        }
    }
    class Drawing
    {
        /**
         * Convert pixels to EMU.
         *
         * @param int $pValue Value in pixels
         *
         * @return int Value in EMU
         */
        public static function pixelsToEMU($pValue)
        {
        }
        /**
         * Convert EMU to pixels.
         *
         * @param int $pValue Value in EMU
         *
         * @return int Value in pixels
         */
        public static function EMUToPixels($pValue)
        {
        }
        /**
         * Convert pixels to column width. Exact algorithm not known.
         * By inspection of a real Excel file using Calibri 11, one finds 1000px ~ 142.85546875
         * This gives a conversion factor of 7. Also, we assume that pixels and font size are proportional.
         *
         * @param int $pValue Value in pixels
         * @param \PhpOffice\PhpSpreadsheet\Style\Font $pDefaultFont Default font of the workbook
         *
         * @return int Value in cell dimension
         */
        public static function pixelsToCellDimension($pValue, \PhpOffice\PhpSpreadsheet\Style\Font $pDefaultFont)
        {
        }
        /**
         * Convert column width from (intrinsic) Excel units to pixels.
         *
         * @param float $pValue Value in cell dimension
         * @param \PhpOffice\PhpSpreadsheet\Style\Font $pDefaultFont Default font of the workbook
         *
         * @return int Value in pixels
         */
        public static function cellDimensionToPixels($pValue, \PhpOffice\PhpSpreadsheet\Style\Font $pDefaultFont)
        {
        }
        /**
         * Convert pixels to points.
         *
         * @param int $pValue Value in pixels
         *
         * @return float Value in points
         */
        public static function pixelsToPoints($pValue)
        {
        }
        /**
         * Convert points to pixels.
         *
         * @param int $pValue Value in points
         *
         * @return int Value in pixels
         */
        public static function pointsToPixels($pValue)
        {
        }
        /**
         * Convert degrees to angle.
         *
         * @param int $pValue Degrees
         *
         * @return int Angle
         */
        public static function degreesToAngle($pValue)
        {
        }
        /**
         * Convert angle to degrees.
         *
         * @param int $pValue Angle
         *
         * @return int Degrees
         */
        public static function angleToDegrees($pValue)
        {
        }
        /**
         * Create a new image from file. By alexander at alexauto dot nl.
         *
         * @see http://www.php.net/manual/en/function.imagecreatefromwbmp.php#86214
         *
         * @param string $p_sFile Path to Windows DIB (BMP) image
         *
         * @return resource
         */
        public static function imagecreatefrombmp($p_sFile)
        {
        }
    }
    class Escher
    {
        /**
         * Drawing Group Container.
         *
         * @var Escher\DggContainer
         */
        private $dggContainer;
        /**
         * Drawing Container.
         *
         * @var Escher\DgContainer
         */
        private $dgContainer;
        /**
         * Get Drawing Group Container.
         *
         * @return Escher\DggContainer
         */
        public function getDggContainer()
        {
        }
        /**
         * Set Drawing Group Container.
         *
         * @param Escher\DggContainer $dggContainer
         *
         * @return Escher\DggContainer
         */
        public function setDggContainer($dggContainer)
        {
        }
        /**
         * Get Drawing Container.
         *
         * @return Escher\DgContainer
         */
        public function getDgContainer()
        {
        }
        /**
         * Set Drawing Container.
         *
         * @param Escher\DgContainer $dgContainer
         *
         * @return Escher\DgContainer
         */
        public function setDgContainer($dgContainer)
        {
        }
    }
    class StringHelper
    {
        /**    Constants                */
        /**    Regular Expressions        */
        //    Fraction
        const STRING_REGEXP_FRACTION = '(-?)(\\d+)\\s+(\\d+\\/\\d+)';
        /**
         * Control characters array.
         *
         * @var string[]
         */
        private static $controlCharacters = [];
        /**
         * SYLK Characters array.
         *
         * @var array
         */
        private static $SYLKCharacters = [];
        /**
         * Decimal separator.
         *
         * @var string
         */
        private static $decimalSeparator;
        /**
         * Thousands separator.
         *
         * @var string
         */
        private static $thousandsSeparator;
        /**
         * Currency code.
         *
         * @var string
         */
        private static $currencyCode;
        /**
         * Is iconv extension avalable?
         *
         * @var bool
         */
        private static $isIconvEnabled;
        /**
         * iconv options.
         *
         * @var string
         */
        private static $iconvOptions = '//IGNORE//TRANSLIT';
        /**
         * Build control characters array.
         */
        private static function buildControlCharacters() : void
        {
        }
        /**
         * Build SYLK characters array.
         */
        private static function buildSYLKCharacters() : void
        {
        }
        /**
         * Get whether iconv extension is available.
         *
         * @return bool
         */
        public static function getIsIconvEnabled()
        {
        }
        private static function buildCharacterSets() : void
        {
        }
        /**
         * Convert from OpenXML escaped control character to PHP control character.
         *
         * Excel 2007 team:
         * ----------------
         * That's correct, control characters are stored directly in the shared-strings table.
         * We do encode characters that cannot be represented in XML using the following escape sequence:
         * _xHHHH_ where H represents a hexadecimal character in the character's value...
         * So you could end up with something like _x0008_ in a string (either in a cell value (<v>)
         * element or in the shared string <t> element.
         *
         * @param string $value Value to unescape
         *
         * @return string
         */
        public static function controlCharacterOOXML2PHP($value)
        {
        }
        /**
         * Convert from PHP control character to OpenXML escaped control character.
         *
         * Excel 2007 team:
         * ----------------
         * That's correct, control characters are stored directly in the shared-strings table.
         * We do encode characters that cannot be represented in XML using the following escape sequence:
         * _xHHHH_ where H represents a hexadecimal character in the character's value...
         * So you could end up with something like _x0008_ in a string (either in a cell value (<v>)
         * element or in the shared string <t> element.
         *
         * @param string $value Value to escape
         *
         * @return string
         */
        public static function controlCharacterPHP2OOXML($value)
        {
        }
        /**
         * Try to sanitize UTF8, stripping invalid byte sequences. Not perfect. Does not surrogate characters.
         *
         * @param string $value
         *
         * @return string
         */
        public static function sanitizeUTF8($value)
        {
        }
        /**
         * Check if a string contains UTF8 data.
         *
         * @param string $value
         *
         * @return bool
         */
        public static function isUTF8($value)
        {
        }
        /**
         * Formats a numeric value as a string for output in various output writers forcing
         * point as decimal separator in case locale is other than English.
         *
         * @param mixed $value
         *
         * @return string
         */
        public static function formatNumber($value)
        {
        }
        /**
         * Converts a UTF-8 string into BIFF8 Unicode string data (8-bit string length)
         * Writes the string using uncompressed notation, no rich text, no Asian phonetics
         * If mbstring extension is not available, ASCII is assumed, and compressed notation is used
         * although this will give wrong results for non-ASCII strings
         * see OpenOffice.org's Documentation of the Microsoft Excel File Format, sect. 2.5.3.
         *
         * @param string $value UTF-8 encoded string
         * @param mixed[] $arrcRuns Details of rich text runs in $value
         *
         * @return string
         */
        public static function UTF8toBIFF8UnicodeShort($value, $arrcRuns = [])
        {
        }
        /**
         * Converts a UTF-8 string into BIFF8 Unicode string data (16-bit string length)
         * Writes the string using uncompressed notation, no rich text, no Asian phonetics
         * If mbstring extension is not available, ASCII is assumed, and compressed notation is used
         * although this will give wrong results for non-ASCII strings
         * see OpenOffice.org's Documentation of the Microsoft Excel File Format, sect. 2.5.3.
         *
         * @param string $value UTF-8 encoded string
         *
         * @return string
         */
        public static function UTF8toBIFF8UnicodeLong($value)
        {
        }
        /**
         * Convert string from one encoding to another.
         *
         * @param string $value
         * @param string $to Encoding to convert to, e.g. 'UTF-8'
         * @param string $from Encoding to convert from, e.g. 'UTF-16LE'
         *
         * @return string
         */
        public static function convertEncoding($value, $to, $from)
        {
        }
        /**
         * Get character count.
         *
         * @param string $value
         * @param string $enc Encoding
         *
         * @return int Character count
         */
        public static function countCharacters($value, $enc = 'UTF-8')
        {
        }
        /**
         * Get a substring of a UTF-8 encoded string.
         *
         * @param string $pValue UTF-8 encoded string
         * @param int $pStart Start offset
         * @param int $pLength Maximum number of characters in substring
         *
         * @return string
         */
        public static function substring($pValue, $pStart, $pLength = 0)
        {
        }
        /**
         * Convert a UTF-8 encoded string to upper case.
         *
         * @param string $pValue UTF-8 encoded string
         *
         * @return string
         */
        public static function strToUpper($pValue)
        {
        }
        /**
         * Convert a UTF-8 encoded string to lower case.
         *
         * @param string $pValue UTF-8 encoded string
         *
         * @return string
         */
        public static function strToLower($pValue)
        {
        }
        /**
         * Convert a UTF-8 encoded string to title/proper case
         * (uppercase every first character in each word, lower case all other characters).
         *
         * @param string $pValue UTF-8 encoded string
         *
         * @return string
         */
        public static function strToTitle($pValue)
        {
        }
        public static function mbIsUpper($char)
        {
        }
        public static function mbStrSplit($string)
        {
        }
        /**
         * Reverse the case of a string, so that all uppercase characters become lowercase
         * and all lowercase characters become uppercase.
         *
         * @param string $pValue UTF-8 encoded string
         *
         * @return string
         */
        public static function strCaseReverse($pValue)
        {
        }
        /**
         * Identify whether a string contains a fractional numeric value,
         * and convert it to a numeric if it is.
         *
         * @param string &$operand string value to test
         *
         * @return bool
         */
        public static function convertToNumberIfFraction(&$operand)
        {
        }
        //    function convertToNumberIfFraction()
        /**
         * Get the decimal separator. If it has not yet been set explicitly, try to obtain number
         * formatting information from locale.
         *
         * @return string
         */
        public static function getDecimalSeparator()
        {
        }
        /**
         * Set the decimal separator. Only used by NumberFormat::toFormattedString()
         * to format output by \PhpOffice\PhpSpreadsheet\Writer\Html and \PhpOffice\PhpSpreadsheet\Writer\Pdf.
         *
         * @param string $pValue Character for decimal separator
         */
        public static function setDecimalSeparator($pValue) : void
        {
        }
        /**
         * Get the thousands separator. If it has not yet been set explicitly, try to obtain number
         * formatting information from locale.
         *
         * @return string
         */
        public static function getThousandsSeparator()
        {
        }
        /**
         * Set the thousands separator. Only used by NumberFormat::toFormattedString()
         * to format output by \PhpOffice\PhpSpreadsheet\Writer\Html and \PhpOffice\PhpSpreadsheet\Writer\Pdf.
         *
         * @param string $pValue Character for thousands separator
         */
        public static function setThousandsSeparator($pValue) : void
        {
        }
        /**
         *    Get the currency code. If it has not yet been set explicitly, try to obtain the
         *        symbol information from locale.
         *
         * @return string
         */
        public static function getCurrencyCode()
        {
        }
        /**
         * Set the currency code. Only used by NumberFormat::toFormattedString()
         *        to format output by \PhpOffice\PhpSpreadsheet\Writer\Html and \PhpOffice\PhpSpreadsheet\Writer\Pdf.
         *
         * @param string $pValue Character for currency code
         */
        public static function setCurrencyCode($pValue) : void
        {
        }
        /**
         * Convert SYLK encoded string to UTF-8.
         *
         * @param string $pValue
         *
         * @return string UTF-8 encoded string
         */
        public static function SYLKtoUTF8($pValue)
        {
        }
        /**
         * Retrieve any leading numeric part of a string, or return the full string if no leading numeric
         * (handles basic integer or float, but not exponent or non decimal).
         *
         * @param string $value
         *
         * @return mixed string or only the leading numeric part of the string
         */
        public static function testStringAsNumeric($value)
        {
        }
    }
    class OLERead
    {
        private $data = '';
        // Size of a sector = 512 bytes
        const BIG_BLOCK_SIZE = 0x200;
        // Size of a short sector = 64 bytes
        const SMALL_BLOCK_SIZE = 0x40;
        // Size of a directory entry always = 128 bytes
        const PROPERTY_STORAGE_BLOCK_SIZE = 0x80;
        // Minimum size of a standard stream = 4096 bytes, streams smaller than this are stored as short streams
        const SMALL_BLOCK_THRESHOLD = 0x1000;
        // header offsets
        const NUM_BIG_BLOCK_DEPOT_BLOCKS_POS = 0x2c;
        const ROOT_START_BLOCK_POS = 0x30;
        const SMALL_BLOCK_DEPOT_BLOCK_POS = 0x3c;
        const EXTENSION_BLOCK_POS = 0x44;
        const NUM_EXTENSION_BLOCK_POS = 0x48;
        const BIG_BLOCK_DEPOT_BLOCKS_POS = 0x4c;
        // property storage offsets (directory offsets)
        const SIZE_OF_NAME_POS = 0x40;
        const TYPE_POS = 0x42;
        const START_BLOCK_POS = 0x74;
        const SIZE_POS = 0x78;
        public $wrkbook;
        public $summaryInformation;
        public $documentSummaryInformation;
        /**
         * @var int
         */
        private $numBigBlockDepotBlocks;
        /**
         * @var int
         */
        private $rootStartBlock;
        /**
         * @var int
         */
        private $sbdStartBlock;
        /**
         * @var int
         */
        private $extensionBlock;
        /**
         * @var int
         */
        private $numExtensionBlocks;
        /**
         * @var string
         */
        private $bigBlockChain;
        /**
         * @var string
         */
        private $smallBlockChain;
        /**
         * @var string
         */
        private $entry;
        /**
         * @var int
         */
        private $rootentry;
        /**
         * @var array
         */
        private $props = [];
        /**
         * Read the file.
         *
         * @param $pFilename string Filename
         */
        public function read($pFilename) : void
        {
        }
        /**
         * Extract binary stream data.
         *
         * @param int $stream
         *
         * @return string
         */
        public function getStream($stream)
        {
        }
        /**
         * Read a standard stream (by joining sectors using information from SAT).
         *
         * @param int $bl Sector ID where the stream starts
         *
         * @return string Data for standard stream
         */
        private function _readData($bl)
        {
        }
        /**
         * Read entries in the directory stream.
         */
        private function readPropertySets() : void
        {
        }
        /**
         * Read 4 bytes of data at specified position.
         *
         * @param string $data
         * @param int $pos
         *
         * @return int
         */
        private static function getInt4d($data, $pos)
        {
        }
    }
    class PasswordHasher
    {
        /**
         * Get algorithm name for PHP.
         */
        private static function getAlgorithm(string $algorithmName) : string
        {
        }
        /**
         * Create a password hash from a given string.
         *
         * This method is based on the algorithm provided by
         * Daniel Rentz of OpenOffice and the PEAR package
         * Spreadsheet_Excel_Writer by Xavier Noguer <xnoguer@rezebra.com>.
         *
         * @param string $pPassword Password to hash
         */
        private static function defaultHashPassword(string $pPassword) : string
        {
        }
        /**
         * Create a password hash from a given string by a specific algorithm.
         *
         * 2.4.2.4 ISO Write Protection Method
         *
         * @see https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-offcrypto/1357ea58-646e-4483-92ef-95d718079d6f
         *
         * @param string $password Password to hash
         * @param string $algorithm Hash algorithm used to compute the password hash value
         * @param string $salt Pseudorandom string
         * @param int $spinCount Number of times to iterate on a hash of a password
         *
         * @return string Hashed password
         */
        public static function hashPassword(string $password, string $algorithm = '', string $salt = '', int $spinCount = 10000) : string
        {
        }
    }
}
namespace {
    abstract class FilesystemRegexFilter extends \RecursiveRegexIterator
    {
        protected $regex;
        public function __construct(\RecursiveIterator $it, $regex)
        {
        }
    }
    class FilenameFilter extends \FilesystemRegexFilter
    {
        // Filter files against the regex
        public function accept()
        {
        }
    }
}
namespace Complex {
    /**
     * Complex Number object.
     *
     * @package Complex
     *
     * @method float abs()
     * @method Complex acos()
     * @method Complex acosh()
     * @method Complex acot()
     * @method Complex acoth()
     * @method Complex acsc()
     * @method Complex acsch()
     * @method float argument()
     * @method Complex asec()
     * @method Complex asech()
     * @method Complex asin()
     * @method Complex asinh()
     * @method Complex atan()
     * @method Complex atanh()
     * @method Complex conjugate()
     * @method Complex cos()
     * @method Complex cosh()
     * @method Complex cot()
     * @method Complex coth()
     * @method Complex csc()
     * @method Complex csch()
     * @method Complex exp()
     * @method Complex inverse()
     * @method Complex ln()
     * @method Complex log2()
     * @method Complex log10()
     * @method Complex negative()
     * @method Complex pow(int|float $power)
     * @method float rho()
     * @method Complex sec()
     * @method Complex sech()
     * @method Complex sin()
     * @method Complex sinh()
     * @method Complex sqrt()
     * @method Complex tan()
     * @method Complex tanh()
     * @method float theta()
     * @method Complex add(...$complexValues)
     * @method Complex subtract(...$complexValues)
     * @method Complex multiply(...$complexValues)
     * @method Complex divideby(...$complexValues)
     * @method Complex divideinto(...$complexValues)
     */
    class Complex
    {
        /**
         * @constant    Euler's Number.
         */
        const EULER = 2.718281828459045;
        /**
         * @constant    Regexp to split an input string into real and imaginary components and suffix
         */
        const NUMBER_SPLIT_REGEXP = '` ^
            (                                   # Real part
                [-+]?(\\d+\\.?\\d*|\\d*\\.?\\d+)          # Real value (integer or float)
                ([Ee][-+]?[0-2]?\\d{1,3})?           # Optional real exponent for scientific format
            )
            (                                   # Imaginary part
                [-+]?(\\d+\\.?\\d*|\\d*\\.?\\d+)          # Imaginary value (integer or float)
                ([Ee][-+]?[0-2]?\\d{1,3})?           # Optional imaginary exponent for scientific format
            )?
            (                                   # Imaginary part is optional
                ([-+]?)                             # Imaginary (implicit 1 or -1) only
                ([ij]?)                             # Imaginary i or j - depending on whether mathematical or engineering
            )
        $`uix';
        /**
         * @var    float    $realPart    The value of of this complex number on the real plane.
         */
        protected $realPart = 0.0;
        /**
         * @var    float    $imaginaryPart    The value of of this complex number on the imaginary plane.
         */
        protected $imaginaryPart = 0.0;
        /**
         * @var    string    $suffix    The suffix for this complex number (i or j).
         */
        protected $suffix;
        /**
         * Validates whether the argument is a valid complex number, converting scalar or array values if possible
         *
         * @param     mixed    $complexNumber   The value to parse
         * @return    array
         * @throws    Exception    If the argument isn't a Complex number or cannot be converted to one
         */
        private static function parseComplex($complexNumber)
        {
        }
        public function __construct($realPart = 0.0, $imaginaryPart = null, $suffix = 'i')
        {
        }
        /**
         * Gets the real part of this complex number
         *
         * @return Float
         */
        public function getReal()
        {
        }
        /**
         * Gets the imaginary part of this complex number
         *
         * @return Float
         */
        public function getImaginary()
        {
        }
        /**
         * Gets the suffix of this complex number
         *
         * @return String
         */
        public function getSuffix()
        {
        }
        /**
         * Returns true if this is a real value, false if a complex value
         *
         * @return Bool
         */
        public function isReal()
        {
        }
        /**
         * Returns true if this is a complex value, false if a real value
         *
         * @return Bool
         */
        public function isComplex()
        {
        }
        public function format()
        {
        }
        public function __toString()
        {
        }
        /**
         * Validates whether the argument is a valid complex number, converting scalar or array values if possible
         *
         * @param     mixed    $complex   The value to validate
         * @return    Complex
         * @throws    Exception    If the argument isn't a Complex number or cannot be converted to one
         */
        public static function validateComplexArgument($complex)
        {
        }
        /**
         * Returns the reverse of this complex number
         *
         * @return    Complex
         */
        public function reverse()
        {
        }
        public function invertImaginary()
        {
        }
        public function invertReal()
        {
        }
        protected static $functions = ['abs', 'acos', 'acosh', 'acot', 'acoth', 'acsc', 'acsch', 'argument', 'asec', 'asech', 'asin', 'asinh', 'atan', 'atanh', 'conjugate', 'cos', 'cosh', 'cot', 'coth', 'csc', 'csch', 'exp', 'inverse', 'ln', 'log2', 'log10', 'negative', 'pow', 'rho', 'sec', 'sech', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'theta'];
        protected static $operations = ['add', 'subtract', 'multiply', 'divideby', 'divideinto'];
        /**
         * Returns the result of the function call or operation
         *
         * @return    Complex|float
         * @throws    Exception|\InvalidArgumentException
         */
        public function __call($functionName, $arguments)
        {
        }
    }
    class Exception extends \Exception
    {
    }
    /**
     *
     * Autoloader for Complex classes
     *
     * @package Complex
     * @copyright  Copyright (c) 2014 Mark Baker (https://github.com/MarkBaker/PHPComplex)
     * @license    https://opensource.org/licenses/MIT          MIT
     */
    class Autoloader
    {
        /**
         * Register the Autoloader with SPL
         *
         */
        public static function Register()
        {
        }
        /**
         * Autoload a class identified by name
         *
         * @param    string    $pClassName    Name of the object to load
         */
        public static function Load($pClassName)
        {
        }
    }
}
namespace Matrix {
    class Exception extends \Exception
    {
    }
    /**
     * Matrix object.
     *
     * @package Matrix
     *
     * @property-read int $rows The number of rows in the matrix
     * @property-read int $columns The number of columns in the matrix
     * @method Matrix antidiagonal()
     * @method Matrix adjoint()
     * @method Matrix cofactors()
     * @method float determinant()
     * @method Matrix diagonal()
     * @method Matrix identity()
     * @method Matrix inverse()
     * @method Matrix pseudoInverse()
     * @method Matrix minors()
     * @method float trace()
     * @method Matrix transpose()
     * @method Matrix add(...$matrices)
     * @method Matrix subtract(...$matrices)
     * @method Matrix multiply(...$matrices)
     * @method Matrix divideby(...$matrices)
     * @method Matrix divideinto(...$matrices)
     */
    class Matrix
    {
        protected $rows;
        protected $columns;
        protected $grid = [];
        /*
         * Create a new Matrix object from an array of values
         *
         * @param array $grid
         */
        public final function __construct(array $grid)
        {
        }
        /*
         * Create a new Matrix object from an array of values
         *
         * @param array $grid
         */
        protected function buildFromArray(array $grid)
        {
        }
        /**
         * Validate that a row number is a positive integer
         *
         * @param int $row
         * @return int
         * @throws Exception
         */
        public static function validateRow($row)
        {
        }
        /**
         * Validate that a column number is a positive integer
         *
         * @param int $column
         * @return int
         * @throws Exception
         */
        public static function validateColumn($column)
        {
        }
        /**
         * Validate that a row number falls within the set of rows for this matrix
         *
         * @param int $row
         * @return int
         * @throws Exception
         */
        protected function validateRowInRange($row)
        {
        }
        /**
         * Validate that a column number falls within the set of columns for this matrix
         *
         * @param int $column
         * @return int
         * @throws Exception
         */
        protected function validateColumnInRange($column)
        {
        }
        /**
         * Return a new matrix as a subset of rows from this matrix, starting at row number $row, and $rowCount rows
         * A $rowCount value of 0 will return all rows of the matrix from $row
         * A negative $rowCount value will return rows until that many rows from the end of the matrix
         *
         * Note that row numbers start from 1, not from 0
         *
         * @param int $row
         * @param int $rowCount
         * @return static
         * @throws Exception
         */
        public function getRows($row, $rowCount = 1)
        {
        }
        /**
         * Return a new matrix as a subset of columns from this matrix, starting at column number $column, and $columnCount columns
         * A $columnCount value of 0 will return all columns of the matrix from $column
         * A negative $columnCount value will return columns until that many columns from the end of the matrix
         *
         * Note that column numbers start from 1, not from 0
         *
         * @param int $column
         * @param int $columnCount
         * @return Matrix
         * @throws Exception
         */
        public function getColumns($column, $columnCount = 1)
        {
        }
        /**
         * Return a new matrix as a subset of rows from this matrix, dropping rows starting at row number $row,
         *     and $rowCount rows
         * A negative $rowCount value will drop rows until that many rows from the end of the matrix
         * A $rowCount value of 0 will remove all rows of the matrix from $row
         *
         * Note that row numbers start from 1, not from 0
         *
         * @param int $row
         * @param int $rowCount
         * @return static
         * @throws Exception
         */
        public function dropRows($row, $rowCount = 1)
        {
        }
        /**
         * Return a new matrix as a subset of columns from this matrix, dropping columns starting at column number $column,
         *     and $columnCount columns
         * A negative $columnCount value will drop columns until that many columns from the end of the matrix
         * A $columnCount value of 0 will remove all columns of the matrix from $column
         *
         * Note that column numbers start from 1, not from 0
         *
         * @param int $column
         * @param int $columnCount
         * @return static
         * @throws Exception
         */
        public function dropColumns($column, $columnCount = 1)
        {
        }
        /**
         * Return a value from this matrix, from the "cell" identified by the row and column numbers
         * Note that row and column numbers start from 1, not from 0
         *
         * @param int $row
         * @param int $column
         * @return mixed
         * @throws Exception
         */
        public function getValue($row, $column)
        {
        }
        /**
         * Returns a Generator that will yield each row of the matrix in turn as a vector matrix
         *     or the value of each cell if the matrix is a vector
         *
         * @return \Generator|Matrix[]|mixed[]
         */
        public function rows()
        {
        }
        /**
         * Returns a Generator that will yield each column of the matrix in turn as a vector matrix
         *     or the value of each cell if the matrix is a vector
         *
         * @return \Generator|Matrix[]|mixed[]
         */
        public function columns()
        {
        }
        /**
         * Identify if the row and column dimensions of this matrix are equal,
         *     i.e. if it is a "square" matrix
         *
         * @return bool
         */
        public function isSquare()
        {
        }
        /**
         * Identify if this matrix is a vector
         *     i.e. if it comprises only a single row or a single column
         *
         * @return bool
         */
        public function isVector()
        {
        }
        /**
         * Return the matrix as a 2-dimensional array
         *
         * @return array
         */
        public function toArray()
        {
        }
        protected static $getters = ['rows', 'columns'];
        /**
         * Access specific properties as read-only (no setters)
         *
         * @param string $propertyName
         * @return mixed
         * @throws Exception
         */
        public function __get($propertyName)
        {
        }
        protected static $functions = ['antidiagonal', 'adjoint', 'cofactors', 'determinant', 'diagonal', 'identity', 'inverse', 'minors', 'trace', 'transpose'];
        protected static $operations = ['add', 'subtract', 'multiply', 'divideby', 'divideinto', 'directsum'];
        /**
         * Returns the result of the function call or operation
         *
         * @param string $functionName
         * @param mixed[] $arguments
         * @return Matrix|float
         * @throws Exception
         */
        public function __call($functionName, $arguments)
        {
        }
    }
    /**
     * Matrix Builder class.
     *
     * @package Matrix
     */
    class Builder
    {
        /**
         * Create a new matrix of specified dimensions, and filled with a specified value
         * If the column argument isn't provided, then a square matrix will be created
         *
         * @param mixed $value
         * @param int $rows
         * @param int|null $columns
         * @return Matrix
         * @throws Exception
         */
        public static function createFilledMatrix($value, $rows, $columns = null)
        {
        }
        /**
         * Create a new identity matrix of specified dimensions
         * This will always be a square matrix, with the number of rows and columns matching the provided dimension
         *
         * @param int $dimensions
         * @return Matrix
         * @throws Exception
         */
        public static function createIdentityMatrix($dimensions)
        {
        }
    }
    class Functions
    {
        /**
         * Calculate the adjoint of the matrix
         *
         * @param Matrix $matrix The matrix whose adjoint we wish to calculate
         * @return Matrix
         *
         * @throws Exception
         */
        private static function getAdjoint(\Matrix\Matrix $matrix)
        {
        }
        /**
         * Return the adjoint of this matrix
         * The adjugate, classical adjoint, or adjunct of a square matrix is the transpose of its cofactor matrix.
         * The adjugate has sometimes been called the "adjoint", but today the "adjoint" of a matrix normally refers
         *     to its corresponding adjoint operator, which is its conjugate transpose.
         *
         * @param Matrix $matrix The matrix whose adjoint we wish to calculate
         * @return Matrix
         * @throws Exception
         **/
        public static function adjoint(\Matrix\Matrix $matrix)
        {
        }
        /**
         * Calculate the cofactors of the matrix
         *
         * @param Matrix $matrix The matrix whose cofactors we wish to calculate
         * @return Matrix
         *
         * @throws Exception
         */
        private static function getCofactors(\Matrix\Matrix $matrix)
        {
        }
        /**
         * Return the cofactors of this matrix
         *
         * @param Matrix $matrix The matrix whose cofactors we wish to calculate
         * @return Matrix
         *
         * @throws Exception
         */
        public static function cofactors(\Matrix\Matrix $matrix)
        {
        }
        /**
         * @param Matrix $matrix
         * @param int $row
         * @param int $column
         * @return float
         * @throws Exception
         */
        private static function getDeterminantSegment(\Matrix\Matrix $matrix, $row, $column)
        {
        }
        /**
         * Calculate the determinant of the matrix
         *
         * @param Matrix $matrix The matrix whose determinant we wish to calculate
         * @return float
         *
         * @throws Exception
         */
        private static function getDeterminant(\Matrix\Matrix $matrix)
        {
        }
        /**
         * Return the determinant of this matrix
         *
         * @param Matrix $matrix The matrix whose determinant we wish to calculate
         * @return float
         * @throws Exception
         **/
        public static function determinant(\Matrix\Matrix $matrix)
        {
        }
        /**
         * Return the diagonal of this matrix
         *
         * @param Matrix $matrix The matrix whose diagonal we wish to calculate
         * @return Matrix
         * @throws Exception
         **/
        public static function diagonal(\Matrix\Matrix $matrix)
        {
        }
        /**
         * Return the antidiagonal of this matrix
         *
         * @param Matrix $matrix The matrix whose antidiagonal we wish to calculate
         * @return Matrix
         * @throws Exception
         **/
        public static function antidiagonal(\Matrix\Matrix $matrix)
        {
        }
        /**
         * Return the identity matrix
         * The identity matrix, or sometimes ambiguously called a unit matrix, of size n is the n  n square matrix
         *   with ones on the main diagonal and zeros elsewhere
         *
         * @param Matrix $matrix The matrix whose identity we wish to calculate
         * @return Matrix
         * @throws Exception
         **/
        public static function identity(\Matrix\Matrix $matrix)
        {
        }
        /**
         * Return the inverse of this matrix
         *
         * @param Matrix $matrix The matrix whose inverse we wish to calculate
         * @return Matrix
         * @throws Exception
         **/
        public static function inverse(\Matrix\Matrix $matrix)
        {
        }
        /**
         * Calculate the minors of the matrix
         *
         * @param Matrix $matrix The matrix whose minors we wish to calculate
         * @return array[]
         *
         * @throws Exception
         */
        protected static function getMinors(\Matrix\Matrix $matrix)
        {
        }
        /**
         * Return the minors of the matrix
         * The minor of a matrix A is the determinant of some smaller square matrix, cut down from A by removing one or
         *     more of its rows or columns.
         * Minors obtained by removing just one row and one column from square matrices (first minors) are required for
         *     calculating matrix cofactors, which in turn are useful for computing both the determinant and inverse of
         *     square matrices.
         *
         * @param Matrix $matrix The matrix whose minors we wish to calculate
         * @return Matrix
         * @throws Exception
         **/
        public static function minors(\Matrix\Matrix $matrix)
        {
        }
        /**
         * Return the trace of this matrix
         * The trace is defined as the sum of the elements on the main diagonal (the diagonal from the upper left to the lower right)
         *     of the matrix
         *
         * @param Matrix $matrix The matrix whose trace we wish to calculate
         * @return float
         * @throws Exception
         **/
        public static function trace(\Matrix\Matrix $matrix)
        {
        }
        /**
         * Return the transpose of this matrix
         *
         * @param Matrix $matrix The matrix whose transpose we wish to calculate
         * @return Matrix
         **/
        public static function transpose(\Matrix\Matrix $matrix)
        {
        }
    }
}
namespace Matrix\Operators {
    abstract class Operator
    {
        /**
         * Stored internally as a 2-dimension array of values
         *
         * @property mixed[][] $matrix
         **/
        protected $matrix;
        /**
         * Number of rows in the matrix
         *
         * @property integer $rows
         **/
        protected $rows;
        /**
         * Number of columns in the matrix
         *
         * @property integer $columns
         **/
        protected $columns;
        /**
         * Create an new handler object for the operation
         *
         * @param Matrix $matrix The base Matrix object on which the operation will be performed
         */
        public function __construct(\Matrix\Matrix $matrix)
        {
        }
        /**
         * Compare the dimensions of the matrices being operated on to see if they are valid for addition/subtraction
         *
         * @param Matrix $matrix The second Matrix object on which the operation will be performed
         * @throws Exception
         */
        protected function validateMatchingDimensions(\Matrix\Matrix $matrix)
        {
        }
        /**
         * Compare the dimensions of the matrices being operated on to see if they are valid for multiplication/division
         *
         * @param Matrix $matrix The second Matrix object on which the operation will be performed
         * @throws Exception
         */
        protected function validateReflectingDimensions(\Matrix\Matrix $matrix)
        {
        }
        /**
         * Return the result of the operation
         *
         * @return Matrix
         */
        public function result()
        {
        }
    }
    class DirectSum extends \Matrix\Operators\Operator
    {
        /**
         * Execute the addition
         *
         * @param mixed $value The matrix or numeric value to add to the current base value
         * @return $this The operation object, allowing multiple additions to be chained
         * @throws Exception If the provided argument is not appropriate for the operation
         */
        public function execute($value)
        {
        }
        /**
         * Execute the direct sum for a matrix
         *
         * @param Matrix $value The numeric value to concatenate/direct sum with the current base value
         * @return $this The operation object, allowing multiple additions to be chained
         **/
        private function directSumMatrix($value)
        {
        }
    }
    class Multiplication extends \Matrix\Operators\Operator
    {
        /**
         * Execute the multiplication
         *
         * @param mixed $value The matrix or numeric value to multiply the current base value by
         * @throws Exception If the provided argument is not appropriate for the operation
         * @return $this The operation object, allowing multiple multiplications to be chained
         **/
        public function execute($value)
        {
        }
        /**
         * Execute the multiplication for a scalar
         *
         * @param mixed $value The numeric value to multiply with the current base value
         * @return $this The operation object, allowing multiple mutiplications to be chained
         **/
        protected function multiplyScalar($value)
        {
        }
        /**
         * Execute the multiplication for a matrix
         *
         * @param Matrix $value The numeric value to multiply with the current base value
         * @return $this The operation object, allowing multiple mutiplications to be chained
         * @throws Exception If the provided argument is not appropriate for the operation
         **/
        protected function multiplyMatrix(\Matrix\Matrix $value)
        {
        }
    }
    class Division extends \Matrix\Operators\Multiplication
    {
        /**
         * Execute the division
         *
         * @param mixed $value The matrix or numeric value to divide the current base value by
         * @throws Exception If the provided argument is not appropriate for the operation
         * @return $this The operation object, allowing multiple divisions to be chained
         **/
        public function execute($value)
        {
        }
    }
    class Subtraction extends \Matrix\Operators\Operator
    {
        /**
         * Execute the subtraction
         *
         * @param mixed $value The matrix or numeric value to subtract from the current base value
         * @throws Exception If the provided argument is not appropriate for the operation
         * @return $this The operation object, allowing multiple subtractions to be chained
         **/
        public function execute($value)
        {
        }
        /**
         * Execute the subtraction for a scalar
         *
         * @param mixed $value The numeric value to subtracted from the current base value
         * @return $this The operation object, allowing multiple additions to be chained
         **/
        protected function subtractScalar($value)
        {
        }
        /**
         * Execute the subtraction for a matrix
         *
         * @param Matrix $value The numeric value to subtract from the current base value
         * @return $this The operation object, allowing multiple subtractions to be chained
         * @throws Exception If the provided argument is not appropriate for the operation
         **/
        protected function subtractMatrix(\Matrix\Matrix $value)
        {
        }
    }
    class Addition extends \Matrix\Operators\Operator
    {
        /**
         * Execute the addition
         *
         * @param mixed $value The matrix or numeric value to add to the current base value
         * @throws Exception If the provided argument is not appropriate for the operation
         * @return $this The operation object, allowing multiple additions to be chained
         **/
        public function execute($value)
        {
        }
        /**
         * Execute the addition for a scalar
         *
         * @param mixed $value The numeric value to add to the current base value
         * @return $this The operation object, allowing multiple additions to be chained
         **/
        protected function addScalar($value)
        {
        }
        /**
         * Execute the addition for a matrix
         *
         * @param Matrix $value The numeric value to add to the current base value
         * @return $this The operation object, allowing multiple additions to be chained
         * @throws Exception If the provided argument is not appropriate for the operation
         **/
        protected function addMatrix(\Matrix\Matrix $value)
        {
        }
    }
}
namespace Matrix {
    /**
     *
     * Autoloader for Matrix classes
     *
     * @package Matrix
     * @copyright  Copyright (c) 2014 Mark Baker (https://github.com/MarkBaker/PHPMatrix)
     * @license    https://opensource.org/licenses/MIT          MIT
     */
    class Autoloader
    {
        /**
         * Register the Autoloader with SPL
         *
         */
        public static function Register()
        {
        }
        /**
         * Autoload a class identified by name
         *
         * @param    string    $pClassName    Name of the object to load
         */
        public static function Load($pClassName)
        {
        }
    }
}
namespace BigintTest {
    class BigintTest extends \PHPUnit\Framework\TestCase
    {
        public function testConstruct() : void
        {
        }
        public function testConstructLarge() : void
        {
        }
        public function testAddSmallValue() : void
        {
        }
        public function testAddWithOverflowAtLowestByte() : void
        {
        }
        public function testAddWithOverflowAtInteger32() : void
        {
        }
        public function testAddWithOverflowAtInteger64() : void
        {
        }
    }
}
namespace ZipStreamTest {
    /**
     * Test Class for the Main ZipStream CLass
     */
    class ZipStreamTest extends \PHPUnit\Framework\TestCase
    {
        const OSX_ARCHIVE_UTILITY = '/System/Library/CoreServices/Applications/Archive Utility.app/Contents/MacOS/Archive Utility';
        public function testFileNotFoundException() : void
        {
        }
        public function testFileNotReadableException() : void
        {
        }
        public function testDostime() : void
        {
        }
        public function testAddFile() : void
        {
        }
        /**
         * @return array
         */
        protected function getTmpFileStream() : array
        {
        }
        /**
         * @param string $tmp
         * @return string
         */
        protected function validateAndExtractZip($tmp) : string
        {
        }
        protected function getTmpDir() : string
        {
        }
        /**
         * @param string $path
         * @return string[]
         */
        protected function getRecursiveFileList(string $path) : array
        {
        }
        public function testAddFileUtf8NameComment() : void
        {
        }
        public function testAddFileUtf8NameNonUtfComment() : void
        {
        }
        public function testAddFileNonUtf8NameUtfComment() : void
        {
        }
        public function testAddFileWithStorageMethod() : void
        {
        }
        public function testDecompressFileWithMacUnarchiver() : void
        {
        }
        public function testAddFileFromPath() : void
        {
        }
        public function testAddFileFromPathWithStorageMethod() : void
        {
        }
        public function testAddLargeFileFromPath() : void
        {
        }
        protected function addLargeFileFileFromPath($method, $zeroHeader, $zip64) : void
        {
        }
        public function testAddFileFromStream() : void
        {
        }
        public function testAddFileFromStreamWithStorageMethod() : void
        {
        }
        public function testAddFileFromPsr7Stream() : void
        {
        }
        public function testAddFileFromPsr7StreamWithFileSizeSet() : void
        {
        }
        public function testCreateArchiveWithFlushOptionSet() : void
        {
        }
        public function testCreateArchiveWithOutputBufferingOffAndFlushOptionSet() : void
        {
        }
    }
}
namespace BugHonorFileTimeTest {
    /**
     * Asserts that specified last-modified timestamps are not overwritten when a
     * file is added
     */
    class BugHonorFileTimeTest extends \PHPUnit\Framework\TestCase
    {
        public function testHonorsFileTime() : void
        {
        }
    }
}
namespace ZipStream {
    class Bigint
    {
        /**
         * @var int[]
         */
        private $bytes = [0, 0, 0, 0, 0, 0, 0, 0];
        /**
         * Initialize the bytes array
         *
         * @param int $value
         */
        public function __construct(int $value = 0)
        {
        }
        /**
         * Fill the bytes field with int
         *
         * @param int $value
         * @param int $start
         * @param int $count
         * @return void
         */
        protected function fillBytes(int $value, int $start, int $count) : void
        {
        }
        /**
         * Get an instance
         *
         * @param int $value
         * @return Bigint
         */
        public static function init(int $value = 0) : self
        {
        }
        /**
         * Fill bytes from low to high
         *
         * @param int $low
         * @param int $high
         * @return Bigint
         */
        public static function fromLowHigh(int $low, int $high) : self
        {
        }
        /**
         * Get high 32
         *
         * @return int
         */
        public function getHigh32() : int
        {
        }
        /**
         * Get value from bytes array
         *
         * @param int $end
         * @param int $length
         * @return int
         */
        public function getValue(int $end = 0, int $length = 8) : int
        {
        }
        /**
         * Get low FF
         *
         * @param bool $force
         * @return float
         */
        public function getLowFF(bool $force = false) : float
        {
        }
        /**
         * Check if is over 32
         *
         * @param bool $force
         * @return bool
         */
        public function isOver32(bool $force = false) : bool
        {
        }
        /**
         * Get low 32
         *
         * @return int
         */
        public function getLow32() : int
        {
        }
        /**
         * Get hexadecimal
         *
         * @return string
         */
        public function getHex64() : string
        {
        }
        /**
         * Add
         *
         * @param Bigint $other
         * @return Bigint
         */
        public function add(\ZipStream\Bigint $other) : \ZipStream\Bigint
        {
        }
    }
    /**
     * This class is only for inheriting
     */
    abstract class Exception extends \Exception
    {
    }
    /**
     * Describes a data stream.
     *
     * Typically, an instance will wrap a PHP stream; this interface provides
     * a wrapper around the most common operations, including serialization of
     * the entire stream to a string.
     */
    class Stream implements \Psr\Http\Message\StreamInterface
    {
        protected $stream;
        public function __construct($stream)
        {
        }
        /**
         * Closes the stream and any underlying resources.
         *
         * @return void
         */
        public function close() : void
        {
        }
        /**
         * Separates any underlying resources from the stream.
         *
         * After the stream has been detached, the stream is in an unusable state.
         *
         * @return resource|null Underlying PHP stream, if any
         */
        public function detach()
        {
        }
        /**
         * Reads all data from the stream into a string, from the beginning to end.
         *
         * This method MUST attempt to seek to the beginning of the stream before
         * reading data and read the stream until the end is reached.
         *
         * Warning: This could attempt to load a large amount of data into memory.
         *
         * This method MUST NOT raise an exception in order to conform with PHP's
         * string casting operations.
         *
         * @see http://php.net/manual/en/language.oop5.magic.php#object.tostring
         * @return string
         */
        public function __toString() : string
        {
        }
        /**
         * Seek to a position in the stream.
         *
         * @link http://www.php.net/manual/en/function.fseek.php
         * @param int $offset Stream offset
         * @param int $whence Specifies how the cursor position will be calculated
         *     based on the seek offset. Valid values are identical to the built-in
         *     PHP $whence values for `fseek()`.  SEEK_SET: Set position equal to
         *     offset bytes SEEK_CUR: Set position to current location plus offset
         *     SEEK_END: Set position to end-of-stream plus offset.
         * @throws \RuntimeException on failure.
         */
        public function seek($offset, $whence = SEEK_SET) : void
        {
        }
        /**
         * Returns whether or not the stream is seekable.
         *
         * @return bool
         */
        public function isSeekable() : bool
        {
        }
        /**
         * Get stream metadata as an associative array or retrieve a specific key.
         *
         * The keys returned are identical to the keys returned from PHP's
         * stream_get_meta_data() function.
         *
         * @link http://php.net/manual/en/function.stream-get-meta-data.php
         * @param string $key Specific metadata to retrieve.
         * @return array|mixed|null Returns an associative array if no key is
         *     provided. Returns a specific key value if a key is provided and the
         *     value is found, or null if the key is not found.
         */
        public function getMetadata($key = null)
        {
        }
        /**
         * Get the size of the stream if known.
         *
         * @return int|null Returns the size in bytes if known, or null if unknown.
         */
        public function getSize() : ?int
        {
        }
        /**
         * Returns the current position of the file read/write pointer
         *
         * @return int Position of the file pointer
         * @throws \RuntimeException on error.
         */
        public function tell() : int
        {
        }
        /**
         * Returns true if the stream is at the end of the stream.
         *
         * @return bool
         */
        public function eof() : bool
        {
        }
        /**
         * Seek to the beginning of the stream.
         *
         * If the stream is not seekable, this method will raise an exception;
         * otherwise, it will perform a seek(0).
         *
         * @see seek()
         * @link http://www.php.net/manual/en/function.fseek.php
         * @throws \RuntimeException on failure.
         */
        public function rewind() : void
        {
        }
        /**
         * Write data to the stream.
         *
         * @param string $string The string that is to be written.
         * @return int Returns the number of bytes written to the stream.
         * @throws \RuntimeException on failure.
         */
        public function write($string) : int
        {
        }
        /**
         * Returns whether or not the stream is writable.
         *
         * @return bool
         */
        public function isWritable() : bool
        {
        }
        /**
         * Read data from the stream.
         *
         * @param int $length Read up to $length bytes from the object and return
         *     them. Fewer than $length bytes may be returned if underlying stream
         *     call returns fewer bytes.
         * @return string Returns the data read from the stream, or an empty string
         *     if no bytes are available.
         * @throws \RuntimeException if an error occurs.
         */
        public function read($length) : string
        {
        }
        /**
         * Returns whether or not the stream is readable.
         *
         * @return bool
         */
        public function isReadable() : bool
        {
        }
        /**
         * Returns the remaining contents in a string
         *
         * @return string
         * @throws \RuntimeException if unable to read or an error occurs while
         *     reading.
         */
        public function getContents() : string
        {
        }
    }
    class DeflateStream extends \ZipStream\Stream
    {
        protected $filter;
        /**
         * @var Option\File
         */
        protected $options;
        /**
         * Rewind stream
         *
         * @return void
         */
        public function rewind() : void
        {
        }
        /**
         * Remove the deflate filter
         *
         * @return void
         */
        public function removeDeflateFilter() : void
        {
        }
        /**
         * Add a deflate filter
         *
         * @param Option\File $options
         * @return void
         */
        public function addDeflateFilter(\ZipStream\Option\File $options) : void
        {
        }
    }
    class File
    {
        const HASH_ALGORITHM = 'crc32b';
        const BIT_ZERO_HEADER = 0x8;
        const BIT_EFS_UTF8 = 0x800;
        const COMPUTE = 1;
        const SEND = 2;
        private const CHUNKED_READ_BLOCK_SIZE = 1048576;
        /**
         * @var string
         */
        public $name;
        /**
         * @var FileOptions
         */
        public $opt;
        /**
         * @var Bigint
         */
        public $len;
        /**
         * @var Bigint
         */
        public $zlen;
        /** @var  int */
        public $crc;
        /**
         * @var Bigint
         */
        public $hlen;
        /**
         * @var Bigint
         */
        public $ofs;
        /**
         * @var int
         */
        public $bits;
        /**
         * @var Version
         */
        public $version;
        /**
         * @var ZipStream
         */
        public $zip;
        /**
         * @var resource
         */
        private $deflate;
        /**
         * @var resource
         */
        private $hash;
        /**
         * @var Method
         */
        private $method;
        /**
         * @var Bigint
         */
        private $totalLength;
        public function __construct(\ZipStream\ZipStream $zip, string $name, ?\ZipStream\Option\File $opt = null)
        {
        }
        public function processPath(string $path) : void
        {
        }
        public function processData(string $data) : void
        {
        }
        /**
         * Create and send zip header for this file.
         *
         * @return void
         * @throws \ZipStream\Exception\EncodingException
         */
        public function addFileHeader() : void
        {
        }
        /**
         * Strip characters that are not legal in Windows filenames
         * to prevent compatibility issues
         *
         * @param string $filename Unprocessed filename
         * @return string
         */
        public static function filterFilename(string $filename) : string
        {
        }
        /**
         * Convert a UNIX timestamp to a DOS timestamp.
         *
         * @param int $when
         * @return int DOS Timestamp
         */
        protected static final function dosTime(int $when) : int
        {
        }
        protected function buildZip64ExtraBlock(bool $force = false) : string
        {
        }
        /**
         * Create and send data descriptor footer for this file.
         *
         * @return void
         */
        public function addFileFooter() : void
        {
        }
        public function processStream(\Psr\Http\Message\StreamInterface $stream) : void
        {
        }
        protected function processStreamWithZeroHeader(\Psr\Http\Message\StreamInterface $stream) : void
        {
        }
        protected function readStream(\Psr\Http\Message\StreamInterface $stream, ?int $options = null) : void
        {
        }
        protected function deflateInit() : void
        {
        }
        protected function deflateData(\Psr\Http\Message\StreamInterface $stream, string &$data, ?int $options = null) : void
        {
        }
        protected function deflateFinish(?int $options = null) : void
        {
        }
        protected function processStreamWithComputedHeader(\Psr\Http\Message\StreamInterface $stream) : void
        {
        }
        /**
         * Send CDR record for specified file.
         *
         * @return string
         */
        public function getCdrFile() : string
        {
        }
        /**
         * @return Bigint
         */
        public function getTotalLength() : \ZipStream\Bigint
        {
        }
    }
}
namespace ZipStream\Exception {
    /**
     * This Exception gets invoked if `fread` fails on a stream.
     */
    class StreamNotReadableException extends \ZipStream\Exception
    {
        /**
         * Constructor of the Exception
         *
         * @param string $fileName - The name of the file which the stream belongs to.
         */
        public function __construct(string $fileName)
        {
        }
    }
    /**
     * This Exception gets invoked if options are incompatible
     */
    class IncompatibleOptionsException extends \ZipStream\Exception
    {
    }
    /**
     * This Exception gets invoked if a file wasn't found
     */
    class FileNotFoundException extends \ZipStream\Exception
    {
        /**
         * Constructor of the Exception
         *
         * @param String $path - The path which wasn't found
         */
        public function __construct(string $path)
        {
        }
    }
    /**
     * This Exception gets invoked if a counter value exceeds storage size
     */
    class OverflowException extends \ZipStream\Exception
    {
        public function __construct()
        {
        }
    }
    /**
     * This Exception gets invoked if file or comment encoding is incorrect
     */
    class EncodingException extends \ZipStream\Exception
    {
    }
    /**
     * This Exception gets invoked if a file wasn't found
     */
    class FileNotReadableException extends \ZipStream\Exception
    {
        /**
         * Constructor of the Exception
         *
         * @param String $path - The path which wasn't found
         */
        public function __construct(string $path)
        {
        }
    }
}
namespace ZipStream {
    /**
     * ZipStream
     *
     * Streamed, dynamically generated zip archives.
     *
     * Usage:
     *
     * Streaming zip archives is a simple, three-step process:
     *
     * 1.  Create the zip stream:
     *
     *     $zip = new ZipStream('example.zip');
     *
     * 2.  Add one or more files to the archive:
     *
     *      * add first file
     *     $data = file_get_contents('some_file.gif');
     *     $zip->addFile('some_file.gif', $data);
     *
     *      * add second file
     *     $data = file_get_contents('some_file.gif');
     *     $zip->addFile('another_file.png', $data);
     *
     * 3.  Finish the zip stream:
     *
     *     $zip->finish();
     *
     * You can also add an archive comment, add comments to individual files,
     * and adjust the timestamp of files. See the API documentation for each
     * method below for additional information.
     *
     * Example:
     *
     *   // create a new zip stream object
     *   $zip = new ZipStream('some_files.zip');
     *
     *   // list of local files
     *   $files = array('foo.txt', 'bar.jpg');
     *
     *   // read and add each file to the archive
     *   foreach ($files as $path)
     *     $zip->addFile($path, file_get_contents($path));
     *
     *   // write archive footer to stream
     *   $zip->finish();
     */
    class ZipStream
    {
        /**
         * This number corresponds to the ZIP version/OS used (2 bytes)
         * From: https://www.iana.org/assignments/media-types/application/zip
         * The upper byte (leftmost one) indicates the host system (OS) for the
         * file.  Software can use this information to determine
         * the line record format for text files etc.  The current
         * mappings are:
         *
         * 0 - MS-DOS and OS/2 (F.A.T. file systems)
         * 1 - Amiga                     2 - VAX/VMS
         * 3 - *nix                      4 - VM/CMS
         * 5 - Atari ST                  6 - OS/2 H.P.F.S.
         * 7 - Macintosh                 8 - Z-System
         * 9 - CP/M                      10 thru 255 - unused
         *
         * The lower byte (rightmost one) indicates the version number of the
         * software used to encode the file.  The value/10
         * indicates the major version number, and the value
         * mod 10 is the minor version number.
         * Here we are using 6 for the OS, indicating OS/2 H.P.F.S.
         * to prevent file permissions issues upon extract (see #84)
         * 0x603 is 00000110 00000011 in binary, so 6 and 3
         */
        const ZIP_VERSION_MADE_BY = 0x603;
        /**
         * The following signatures end with 0x4b50, which in ASCII isPK,
         * the initials of the inventor Phil Katz.
         * See https://en.wikipedia.org/wiki/Zip_(file_format)#File_headers
         */
        const FILE_HEADER_SIGNATURE = 0x4034b50;
        const CDR_FILE_SIGNATURE = 0x2014b50;
        const CDR_EOF_SIGNATURE = 0x6054b50;
        const DATA_DESCRIPTOR_SIGNATURE = 0x8074b50;
        const ZIP64_CDR_EOF_SIGNATURE = 0x6064b50;
        const ZIP64_CDR_LOCATOR_SIGNATURE = 0x7064b50;
        /**
         * Global Options
         *
         * @var ArchiveOptions
         */
        public $opt;
        /**
         * @var array
         */
        public $files = [];
        /**
         * @var Bigint
         */
        public $cdr_ofs;
        /**
         * @var Bigint
         */
        public $ofs;
        /**
         * @var bool
         */
        protected $need_headers;
        /**
         * @var null|String
         */
        protected $output_name;
        /**
         * Create a new ZipStream object.
         *
         * Parameters:
         *
         * @param String $name - Name of output file (optional).
         * @param ArchiveOptions $opt - Archive Options
         *
         * Large File Support:
         *
         * By default, the method addFileFromPath() will send send files
         * larger than 20 megabytes along raw rather than attempting to
         * compress them.  You can change both the maximum size and the
         * compression behavior using the largeFile* options above, with the
         * following caveats:
         *
         * * For "small" files (e.g. files smaller than largeFileSize), the
         *   memory use can be up to twice that of the actual file.  In other
         *   words, adding a 10 megabyte file to the archive could potentially
         *   occupy 20 megabytes of memory.
         *
         * * Enabling compression on large files (e.g. files larger than
         *   large_file_size) is extremely slow, because ZipStream has to pass
         *   over the large file once to calculate header information, and then
         *   again to compress and send the actual data.
         *
         * Examples:
         *
         *   // create a new zip file named 'foo.zip'
         *   $zip = new ZipStream('foo.zip');
         *
         *   // create a new zip file named 'bar.zip' with a comment
         *   $opt->setComment = 'this is a comment for the zip file.';
         *   $zip = new ZipStream('bar.zip', $opt);
         *
         * Notes:
         *
         * In order to let this library send HTTP headers, a filename must be given
         * _and_ the option `sendHttpHeaders` must be `true`. This behavior is to
         * allow software to send its own headers (including the filename), and
         * still use this library.
         */
        public function __construct(?string $name = null, ?\ZipStream\Option\Archive $opt = null)
        {
        }
        /**
         * addFile
         *
         * Add a file to the archive.
         *
         * @param String $name - path of file in archive (including directory).
         * @param String $data - contents of file
         * @param FileOptions $options
         *
         * File Options:
         *  time     - Last-modified timestamp (seconds since the epoch) of
         *             this file.  Defaults to the current time.
         *  comment  - Comment related to this file.
         *  method   - Storage method for file ("store" or "deflate")
         *
         * Examples:
         *
         *   // add a file named 'foo.txt'
         *   $data = file_get_contents('foo.txt');
         *   $zip->addFile('foo.txt', $data);
         *
         *   // add a file named 'bar.jpg' with a comment and a last-modified
         *   // time of two hours ago
         *   $data = file_get_contents('bar.jpg');
         *   $opt->setTime = time() - 2 * 3600;
         *   $opt->setComment = 'this is a comment about bar.jpg';
         *   $zip->addFile('bar.jpg', $data, $opt);
         */
        public function addFile(string $name, string $data, ?\ZipStream\Option\File $options = null) : void
        {
        }
        /**
         * addFileFromPath
         *
         * Add a file at path to the archive.
         *
         * Note that large files may be compressed differently than smaller
         * files; see the "Large File Support" section above for more
         * information.
         *
         * @param String $name - name of file in archive (including directory path).
         * @param String $path - path to file on disk (note: paths should be encoded using
         *          UNIX-style forward slashes -- e.g '/path/to/some/file').
         * @param FileOptions $options
         *
         * File Options:
         *  time     - Last-modified timestamp (seconds since the epoch) of
         *             this file.  Defaults to the current time.
         *  comment  - Comment related to this file.
         *  method   - Storage method for file ("store" or "deflate")
         *
         * Examples:
         *
         *   // add a file named 'foo.txt' from the local file '/tmp/foo.txt'
         *   $zip->addFileFromPath('foo.txt', '/tmp/foo.txt');
         *
         *   // add a file named 'bigfile.rar' from the local file
         *   // '/usr/share/bigfile.rar' with a comment and a last-modified
         *   // time of two hours ago
         *   $path = '/usr/share/bigfile.rar';
         *   $opt->setTime = time() - 2 * 3600;
         *   $opt->setComment = 'this is a comment about bar.jpg';
         *   $zip->addFileFromPath('bigfile.rar', $path, $opt);
         *
         * @return void
         * @throws \ZipStream\Exception\FileNotFoundException
         * @throws \ZipStream\Exception\FileNotReadableException
         */
        public function addFileFromPath(string $name, string $path, ?\ZipStream\Option\File $options = null) : void
        {
        }
        /**
         * addFileFromStream
         *
         * Add an open stream to the archive.
         *
         * @param String $name - path of file in archive (including directory).
         * @param resource $stream - contents of file as a stream resource
         * @param FileOptions $options
         *
         * File Options:
         *  time     - Last-modified timestamp (seconds since the epoch) of
         *             this file.  Defaults to the current time.
         *  comment  - Comment related to this file.
         *
         * Examples:
         *
         *   // create a temporary file stream and write text to it
         *   $fp = tmpfile();
         *   fwrite($fp, 'The quick brown fox jumped over the lazy dog.');
         *
         *   // add a file named 'streamfile.txt' from the content of the stream
         *   $x->addFileFromStream('streamfile.txt', $fp);
         *
         * @return void
         */
        public function addFileFromStream(string $name, $stream, ?\ZipStream\Option\File $options = null) : void
        {
        }
        /**
         * addFileFromPsr7Stream
         *
         * Add an open stream to the archive.
         *
         * @param String $name - path of file in archive (including directory).
         * @param StreamInterface $stream - contents of file as a stream resource
         * @param FileOptions $options
         *
         * File Options:
         *  time     - Last-modified timestamp (seconds since the epoch) of
         *             this file.  Defaults to the current time.
         *  comment  - Comment related to this file.
         *
         * Examples:
         *
         *   // create a temporary file stream and write text to it
         *   $fp = tmpfile();
         *   fwrite($fp, 'The quick brown fox jumped over the lazy dog.');
         *
         *   // add a file named 'streamfile.txt' from the content of the stream
         *   $x->addFileFromPsr7Stream('streamfile.txt', $fp);
         *
         * @return void
         */
        public function addFileFromPsr7Stream(string $name, \Psr\Http\Message\StreamInterface $stream, ?\ZipStream\Option\File $options = null) : void
        {
        }
        /**
         * finish
         *
         * Write zip footer to stream.
         *
         *  Example:
         *
         *   // add a list of files to the archive
         *   $files = array('foo.txt', 'bar.jpg');
         *   foreach ($files as $path)
         *     $zip->addFile($path, file_get_contents($path));
         *
         *   // write footer to stream
         *   $zip->finish();
         * @return void
         *
         * @throws OverflowException
         */
        public function finish() : void
        {
        }
        /**
         * Send ZIP64 CDR EOF (Central Directory Record End-of-File) record.
         *
         * @return void
         */
        protected function addCdr64Eof() : void
        {
        }
        /**
         * Create a format string and argument list for pack(), then call
         * pack() and return the result.
         *
         * @param array $fields
         * @return string
         */
        public static function packFields(array $fields) : string
        {
        }
        /**
         * Send string, sending HTTP headers if necessary.
         * Flush output after write if configure option is set.
         *
         * @param String $str
         * @return void
         */
        public function send(string $str) : void
        {
        }
        /**
         * Send HTTP headers for this stream.
         *
         * @return void
         */
        protected function sendHttpHeaders() : void
        {
        }
        /**
         * Send ZIP64 CDR Locator (Central Directory Record Locator) record.
         *
         * @return void
         */
        protected function addCdr64Locator() : void
        {
        }
        /**
         * Send CDR EOF (Central Directory Record End-of-File) record.
         *
         * @return void
         */
        protected function addCdrEof() : void
        {
        }
        /**
         * Clear all internal variables. Note that the stream object is not
         * usable after this.
         *
         * @return void
         */
        protected function clear() : void
        {
        }
        /**
         * Is this file larger than large_file_size?
         *
         * @param string $path
         * @return bool
         */
        public function isLargeFile(string $path) : bool
        {
        }
        /**
         * Save file attributes for trailing CDR record.
         *
         * @param File $file
         * @return void
         */
        public function addToCdr(\ZipStream\File $file) : void
        {
        }
    }
}
namespace MyCLabs\Enum {
    /**
     * Base Enum class
     *
     * Create an enum by implementing this class and adding class constants.
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     * @author Daniel Costa <danielcosta@gmail.com>
     * @author Mirosaw Filip <mirfilip@gmail.com>
     *
     * @psalm-template T
     * @psalm-immutable
     */
    abstract class Enum implements \JsonSerializable
    {
        /**
         * Enum value
         *
         * @var mixed
         * @psalm-var T
         */
        protected $value;
        /**
         * Store existing constants in a static cache per object.
         *
         *
         * @var array
         * @psalm-var array<class-string, array<string, mixed>>
         */
        protected static $cache = [];
        /**
         * Creates a new value of some type
         *
         * @psalm-pure
         * @param mixed $value
         *
         * @psalm-param static<T>|T $value
         * @throws \UnexpectedValueException if incompatible type is given.
         */
        public function __construct($value)
        {
        }
        /**
         * @psalm-pure
         * @return mixed
         * @psalm-return T
         */
        public function getValue()
        {
        }
        /**
         * Returns the enum key (i.e. the constant name).
         *
         * @psalm-pure
         * @return mixed
         */
        public function getKey()
        {
        }
        /**
         * @psalm-pure
         * @psalm-suppress InvalidCast
         * @return string
         */
        public function __toString()
        {
        }
        /**
         * Determines if Enum should be considered equal with the variable passed as a parameter.
         * Returns false if an argument is an object of different class or not an object.
         *
         * This method is final, for more information read https://github.com/myclabs/php-enum/issues/4
         *
         * @psalm-pure
         * @psalm-param mixed $variable
         * @return bool
         */
        public final function equals($variable = null) : bool
        {
        }
        /**
         * Returns the names (keys) of all constants in the Enum class
         *
         * @psalm-pure
         * @psalm-return list<string>
         * @return array
         */
        public static function keys()
        {
        }
        /**
         * Returns instances of the Enum class of all Enum constants
         *
         * @psalm-pure
         * @psalm-return array<string, static>
         * @return static[] Constant name in key, Enum instance in value
         */
        public static function values()
        {
        }
        /**
         * Returns all possible values as an array
         *
         * @psalm-pure
         * @psalm-suppress ImpureStaticProperty
         *
         * @psalm-return array<string, mixed>
         * @return array Constant name in key, constant value in value
         */
        public static function toArray()
        {
        }
        /**
         * Check if is valid enum value
         *
         * @param $value
         * @psalm-param mixed $value
         * @psalm-pure
         * @return bool
         */
        public static function isValid($value)
        {
        }
        /**
         * Check if is valid enum key
         *
         * @param $key
         * @psalm-param string $key
         * @psalm-pure
         * @return bool
         */
        public static function isValidKey($key)
        {
        }
        /**
         * Return key for value
         *
         * @param $value
         *
         * @psalm-param mixed $value
         * @psalm-pure
         * @return mixed
         */
        public static function search($value)
        {
        }
        /**
         * Returns a value when called statically like so: MyEnum::SOME_VALUE() given SOME_VALUE is a class constant
         *
         * @param string $name
         * @param array  $arguments
         *
         * @return static
         * @psalm-pure
         * @throws \BadMethodCallException
         */
        public static function __callStatic($name, $arguments)
        {
        }
        /**
         * Specify data which should be serialized to JSON. This method returns data that can be serialized by json_encode()
         * natively.
         *
         * @return mixed
         * @link http://php.net/manual/en/jsonserializable.jsonserialize.php
         * @psalm-pure
         */
        public function jsonSerialize()
        {
        }
    }
}
namespace ZipStream\Option {
    /**
     * Class Version
     * @package ZipStream\Option
     *
     * @method static STORE(): Version
     * @method static DEFLATE(): Version
     * @method static ZIP64(): Version
     * @psalm-immutable
     */
    class Version extends \MyCLabs\Enum\Enum
    {
        const STORE = 0xa;
        // 1.00
        const DEFLATE = 0x14;
        // 2.00
        const ZIP64 = 0x2d;
        // 4.50
    }
    final class Archive
    {
        const DEFAULT_DEFLATE_LEVEL = 6;
        /**
         * @var string
         */
        private $comment = '';
        /**
         * Size, in bytes, of the largest file to try
         * and load into memory (used by
         * addFileFromPath()).  Large files may also
         * be compressed differently; see the
         * 'largeFileMethod' option. Default is ~20 Mb.
         *
         * @var int
         */
        private $largeFileSize = 20 * 1024 * 1024;
        /**
         * How to handle large files.  Legal values are
         * Method::STORE() (the default), or
         * Method::DEFLATE(). STORE sends the file
         * raw and is significantly
         * faster, while DEFLATE compresses the file
         * and is much, much slower. Note that DEFLATE
         * must compress the file twice and is extremely slow.
         *
         * @var Method
         */
        private $largeFileMethod;
        /**
         * Boolean indicating whether or not to send
         * the HTTP headers for this file.
         *
         * @var bool
         */
        private $sendHttpHeaders = false;
        /**
         * The method called to send headers
         *
         * @var Callable
         */
        private $httpHeaderCallback = 'header';
        /**
         * Enable Zip64 extension, supporting very large
         * archives (any size > 4 GB or file count > 64k)
         *
         * @var bool
         */
        private $enableZip64 = true;
        /**
         * Enable streaming files with single read where
         * general purpose bit 3 indicates local file header
         * contain zero values in crc and size fields,
         * these appear only after file contents
         * in data descriptor block.
         *
         * @var bool
         */
        private $zeroHeader = false;
        /**
         * Enable reading file stat for determining file size.
         * When a 32-bit system reads file size that is
         * over 2 GB, invalid value appears in file size
         * due to integer overflow. Should be disabled on
         * 32-bit systems with method addFileFromPath
         * if any file may exceed 2 GB. In this case file
         * will be read in blocks and correct size will be
         * determined from content.
         *
         * @var bool
         */
        private $statFiles = true;
        /**
         * Enable flush after every write to output stream.
         * @var bool
         */
        private $flushOutput = false;
        /**
         * HTTP Content-Disposition.  Defaults to
         * 'attachment', where
         * FILENAME is the specified filename.
         *
         * Note that this does nothing if you are
         * not sending HTTP headers.
         *
         * @var string
         */
        private $contentDisposition = 'attachment';
        /**
         * Note that this does nothing if you are
         * not sending HTTP headers.
         *
         * @var string
         */
        private $contentType = 'application/x-zip';
        /**
         * @var int
         */
        private $deflateLevel = 6;
        /**
         * @var resource
         */
        private $outputStream;
        /**
         * Options constructor.
         */
        public function __construct()
        {
        }
        public function getComment() : string
        {
        }
        public function setComment(string $comment) : void
        {
        }
        public function getLargeFileSize() : int
        {
        }
        public function setLargeFileSize(int $largeFileSize) : void
        {
        }
        public function getLargeFileMethod() : \ZipStream\Option\Method
        {
        }
        public function setLargeFileMethod(\ZipStream\Option\Method $largeFileMethod) : void
        {
        }
        public function isSendHttpHeaders() : bool
        {
        }
        public function setSendHttpHeaders(bool $sendHttpHeaders) : void
        {
        }
        public function getHttpHeaderCallback() : callable
        {
        }
        public function setHttpHeaderCallback(callable $httpHeaderCallback) : void
        {
        }
        public function isEnableZip64() : bool
        {
        }
        public function setEnableZip64(bool $enableZip64) : void
        {
        }
        public function isZeroHeader() : bool
        {
        }
        public function setZeroHeader(bool $zeroHeader) : void
        {
        }
        public function isFlushOutput() : bool
        {
        }
        public function setFlushOutput(bool $flushOutput) : void
        {
        }
        public function isStatFiles() : bool
        {
        }
        public function setStatFiles(bool $statFiles) : void
        {
        }
        public function getContentDisposition() : string
        {
        }
        public function setContentDisposition(string $contentDisposition) : void
        {
        }
        public function getContentType() : string
        {
        }
        public function setContentType(string $contentType) : void
        {
        }
        /**
         * @return resource
         */
        public function getOutputStream()
        {
        }
        /**
         * @param resource $outputStream
         */
        public function setOutputStream($outputStream) : void
        {
        }
        /**
         * @return int
         */
        public function getDeflateLevel() : int
        {
        }
        /**
         * @param int $deflateLevel
         */
        public function setDeflateLevel(int $deflateLevel) : void
        {
        }
    }
    /**
     * Methods enum
     *
     * @method static STORE(): Method
     * @method static DEFLATE(): Method
     * @psalm-immutable
     */
    class Method extends \MyCLabs\Enum\Enum
    {
        const STORE = 0x0;
        const DEFLATE = 0x8;
    }
    final class File
    {
        /**
         * @var string
         */
        private $comment = '';
        /**
         * @var Method
         */
        private $method;
        /**
         * @var int
         */
        private $deflateLevel;
        /**
         * @var DateTime
         */
        private $time;
        /**
         * @var int
         */
        private $size = 0;
        public function defaultTo(\ZipStream\Option\Archive $archiveOptions) : void
        {
        }
        /**
         * @return string
         */
        public function getComment() : string
        {
        }
        /**
         * @param string $comment
         */
        public function setComment(string $comment) : void
        {
        }
        /**
         * @return Method
         */
        public function getMethod() : \ZipStream\Option\Method
        {
        }
        /**
         * @param Method $method
         */
        public function setMethod(\ZipStream\Option\Method $method) : void
        {
        }
        /**
         * @return int
         */
        public function getDeflateLevel() : int
        {
        }
        /**
         * @param int $deflateLevel
         */
        public function setDeflateLevel(int $deflateLevel) : void
        {
        }
        /**
         * @return DateTime
         */
        public function getTime() : \DateTime
        {
        }
        /**
         * @param DateTime $time
         */
        public function setTime(\DateTime $time) : void
        {
        }
        /**
         * @return int
         */
        public function getSize() : int
        {
        }
        /**
         * @param int $size
         */
        public function setSize(int $size) : void
        {
        }
    }
}
namespace MyCLabs\Enum\PHPUnit {
    /**
     * Use this Comparator to get nice output when using PHPUnit assertEquals() with Enums.
     *
     * Add this to your PHPUnit bootstrap PHP file:
     *
     * \SebastianBergmann\Comparator\Factory::getInstance()->register(new \MyCLabs\Enum\PHPUnit\Comparator());
     */
    final class Comparator extends \SebastianBergmann\Comparator\Comparator
    {
        public function accepts($expected, $actual)
        {
        }
        /**
         * @param Enum $expected
         * @param Enum|null $actual
         *
         * @return void
         */
        public function assertEquals($expected, $actual, $delta = 0.0, $canonicalize = false, $ignoreCase = false)
        {
        }
        private function formatEnum(\MyCLabs\Enum\Enum $enum = null)
        {
        }
    }
}
/**
 *
 * Function code for the complex csch() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the hyperbolic cosecant of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The hyperbolic cosecant of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     * @throws    \InvalidArgumentException    If function would result in a division by zero
     */
    function csch($complex)
    {
    }
}
/**
 *
 * Function code for the complex coth() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the hyperbolic cotangent of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The hyperbolic cotangent of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     * @throws    \InvalidArgumentException    If function would result in a division by zero
     */
    function coth($complex)
    {
    }
}
/**
 *
 * Function code for the complex tan() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the tangent of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The tangent of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     * @throws    \InvalidArgumentException    If function would result in a division by zero
     */
    function tan($complex)
    {
    }
}
/**
 *
 * Function code for the complex ln() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the natural logarithm of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The natural logarithm of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     * @throws    \InvalidArgumentException  If the real and the imaginary parts are both zero
     */
    function ln($complex)
    {
    }
}
/**
 *
 * Function code for the complex asec() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the inverse secant of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The inverse secant of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     * @throws    \InvalidArgumentException    If function would result in a division by zero
     */
    function asec($complex)
    {
    }
}
/**
 *
 * Function code for the complex negative() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the negative of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    float            The negative value of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     *
     * @see    rho
     *
     */
    function negative($complex)
    {
    }
}
/**
 *
 * Function code for the complex argument() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the argument of a complex number.
     * Also known as the theta of the complex number, i.e. the angle in radians
     *   from the real axis to the representation of the number in polar coordinates.
     *
     * This function is a synonym for theta()
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    float            The argument (or theta) value of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     *
     * @see    theta
     */
    function argument($complex)
    {
    }
}
/**
 *
 * Function code for the complex sinh() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the hyperbolic sine of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The hyperbolic sine of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     */
    function sinh($complex)
    {
    }
}
/**
 *
 * Function code for the complex acoth() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the inverse hyperbolic cotangent of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The inverse hyperbolic cotangent of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     * @throws    \InvalidArgumentException    If function would result in a division by zero
     */
    function acoth($complex)
    {
    }
}
/**
 *
 * Function code for the complex acot() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the inverse cotangent of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The inverse cotangent of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     * @throws    \InvalidArgumentException    If function would result in a division by zero
     */
    function acot($complex)
    {
    }
}
/**
 *
 * Function code for the complex theta() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the theta of a complex number.
     *   This is the angle in radians from the real axis to the representation of the number in polar coordinates.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    float            The theta value of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     */
    function theta($complex)
    {
    }
}
/**
 *
 * Function code for the complex atan() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    //include_once 'Math/Complex.php';
    //include_once 'Math/ComplexOp.php';
    /**
     * Returns the inverse tangent of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The inverse tangent of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     * @throws    \InvalidArgumentException    If function would result in a division by zero
     */
    function atan($complex)
    {
    }
}
/**
 *
 * Function code for the complex csc() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the cosecant of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The cosecant of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     * @throws    \InvalidArgumentException    If function would result in a division by zero
     */
    function csc($complex)
    {
    }
}
/**
 *
 * Function code for the complex exp() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the exponential of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The exponential of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     */
    function exp($complex)
    {
    }
}
/**
 *
 * Function code for the complex acos() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the inverse cosine of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The inverse cosine of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     */
    function acos($complex)
    {
    }
}
/**
 *
 * Function code for the complex acosh() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the inverse hyperbolic cosine of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The inverse hyperbolic cosine of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     */
    function acosh($complex)
    {
    }
}
/**
 *
 * Function code for the complex tanh() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the hyperbolic tangent of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The hyperbolic tangent of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     * @throws    \InvalidArgumentException    If function would result in a division by zero
     */
    function tanh($complex)
    {
    }
}
/**
 *
 * Function code for the complex pow() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns a complex number raised to a power.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @param     float|integer    $power      The power to raise this value to
     * @return    Complex          The complex argument raised to the real power.
     * @throws    Exception        If the power argument isn't a valid real
     */
    function pow($complex, $power)
    {
    }
}
/**
 *
 * Function code for the complex conjugate() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the complex conjugate of a complex number
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The conjugate of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     */
    function conjugate($complex)
    {
    }
}
/**
 *
 * Function code for the complex cosh() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the hyperbolic cosine of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The hyperbolic cosine of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     */
    function cosh($complex)
    {
    }
}
/**
 *
 * Function code for the complex log2() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the base-2 logarithm of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The base-2 logarithm of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     * @throws    \InvalidArgumentException  If the real and the imaginary parts are both zero
     */
    function log2($complex)
    {
    }
}
/**
 *
 * Function code for the complex acsch() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the inverse hyperbolic cosecant of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The inverse hyperbolic cosecant of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     * @throws    \InvalidArgumentException    If function would result in a division by zero
     */
    function acsch($complex)
    {
    }
}
/**
 *
 * Function code for the complex inverse() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the inverse of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The inverse of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     * @throws    \InvalidArgumentException    If function would result in a division by zero
     */
    function inverse($complex)
    {
    }
}
/**
 *
 * Function code for the complex asech() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the inverse hyperbolic secant of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The inverse hyperbolic secant of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     * @throws    \InvalidArgumentException    If function would result in a division by zero
     */
    function asech($complex)
    {
    }
}
/**
 *
 * Function code for the complex rho() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the rho of a complex number.
     * This is the distance/radius from the centrepoint to the representation of the number in polar coordinates.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    float            The rho value of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     */
    function rho($complex)
    {
    }
}
/**
 *
 * Function code for the complex cot() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the cotangent of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The cotangent of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     * @throws    \InvalidArgumentException    If function would result in a division by zero
     */
    function cot($complex)
    {
    }
}
/**
 *
 * Function code for the complex asin() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the inverse sine of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The inverse sine of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     */
    function asin($complex)
    {
    }
}
/**
 *
 * Function code for the complex asinh() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the inverse hyperbolic sine of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The inverse hyperbolic sine of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     */
    function asinh($complex)
    {
    }
}
/**
 *
 * Function code for the complex log10() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the common logarithm (base 10) of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The common logarithm (base 10) of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     * @throws    \InvalidArgumentException  If the real and the imaginary parts are both zero
     */
    function log10($complex)
    {
    }
}
/**
 *
 * Function code for the complex acsc() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the inverse cosecant of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The inverse cosecant of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     * @throws    \InvalidArgumentException    If function would result in a division by zero
     */
    function acsc($complex)
    {
    }
}
/**
 *
 * Function code for the complex sech() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the hyperbolic secant of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The hyperbolic secant of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     * @throws    \InvalidArgumentException    If function would result in a division by zero
     */
    function sech($complex)
    {
    }
}
/**
 *
 * Function code for the complex sin() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the sine of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The sine of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     */
    function sin($complex)
    {
    }
}
/**
 *
 * Function code for the complex cos() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the cosine of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The cosine of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     */
    function cos($complex)
    {
    }
}
/**
 *
 * Function code for the complex sqrt() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the square root of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The Square root of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     */
    function sqrt($complex)
    {
    }
}
/**
 *
 * Function code for the complex abs() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the absolute value (modulus) of a complex number.
     * Also known as the rho of the complex number, i.e. the distance/radius
     *   from the centrepoint to the representation of the number in polar coordinates.
     *
     * This function is a synonym for rho()
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    float            The absolute (or rho) value of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     *
     * @see    rho
     *
     */
    function abs($complex)
    {
    }
}
/**
 *
 * Function code for the complex atanh() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the inverse hyperbolic tangent of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The inverse hyperbolic tangent of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     */
    function atanh($complex)
    {
    }
}
/**
 *
 * Function code for the complex sec() function
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Returns the secant of a complex number.
     *
     * @param     Complex|mixed    $complex    Complex number or a numeric value.
     * @return    Complex          The secant of the complex argument.
     * @throws    Exception        If argument isn't a valid real or complex number.
     * @throws    \InvalidArgumentException    If function would result in a division by zero
     */
    function sec($complex)
    {
    }
}
/**
 *
 * Function code for the complex multiplication operation
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Multiplies two or more complex numbers
     *
     * @param     array of string|integer|float|Complex    $complexValues   The numbers to multiply
     * @return    Complex
     */
    function multiply(...$complexValues)
    {
    }
}
/**
 *
 * Function code for the complex subtraction operation
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Subtracts two or more complex numbers
     *
     * @param     array of string|integer|float|Complex    $complexValues   The numbers to subtract
     * @return    Complex
     */
    function subtract(...$complexValues)
    {
    }
}
/**
 *
 * Function code for the complex addition operation
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Adds two or more complex numbers
     *
     * @param     array of string|integer|float|Complex    $complexValues   The numbers to add
     * @return    Complex
     */
    function add(...$complexValues)
    {
    }
}
/**
 *
 * Function code for the complex division operation
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Divides two or more complex numbers
     *
     * @param     array of string|integer|float|Complex    $complexValues   The numbers to divide
     * @return    Complex
     */
    function divideinto(...$complexValues)
    {
    }
}
/**
 *
 * Function code for the complex division operation
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Complex {
    /**
     * Divides two or more complex numbers
     *
     * @param     array of string|integer|float|Complex    $complexValues   The numbers to divide
     * @return    Complex
     */
    function divideby(...$complexValues)
    {
    }
}
/**
 *
 * Function code for the matrix adjoint() function
 *
 * @copyright  Copyright (c) 2018 Mark Baker (https://github.com/MarkBaker/PHPMatrix)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Matrix {
    /**
     * Returns the adjoint of a matrix or an array.
     *
     * @param Matrix|array $matrix Matrix or an array to treat as a matrix.
     * @return Matrix The new matrix
     * @throws Exception If argument isn't a valid matrix or array.
     */
    function adjoint($matrix)
    {
    }
}
/**
 *
 * Function code for the matrix antidiagonal() function
 *
 * @copyright  Copyright (c) 2018 Mark Baker (https://github.com/MarkBaker/PHPMatrix)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Matrix {
    /**
     * Returns the antidiagonal of a matrix or an array.
     *
     * @param     Matrix|array     $matrix    Matrix or an array to treat as a matrix.
     * @return    Matrix           The new matrix
     * @throws    Exception        If argument isn't a valid matrix or array.
     */
    function antidiagonal($matrix)
    {
    }
}
/**
 *
 * Function code for the matrix minors() function
 *
 * @copyright  Copyright (c) 2018 Mark Baker (https://github.com/MarkBaker/PHPMatrix)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Matrix {
    /**
     * Returns the minors of a matrix or an array.
     *
     * @param Matrix|array $matrix Matrix or an array to treat as a matrix.
     * @return Matrix The new matrix
     * @throws Exception If argument isn't a valid matrix or array.
     */
    function minors($matrix)
    {
    }
}
/**
 *
 * Function code for the matrix cofactors() function
 *
 * @copyright  Copyright (c) 2018 Mark Baker (https://github.com/MarkBaker/PHPMatrix)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Matrix {
    /**
     * Returns the cofactors of a matrix or an array.
     *
     * @param Matrix|array $matrix Matrix or an array to treat as a matrix.
     * @return Matrix The new matrix
     * @throws Exception If argument isn't a valid matrix or array.
     */
    function cofactors($matrix)
    {
    }
}
/**
 *
 * Function code for the matrix transpose() function
 *
 * @copyright  Copyright (c) 2018 Mark Baker (https://github.com/MarkBaker/PHPMatrix)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Matrix {
    /**
     * Returns the transpose of a matrix or an array.
     *
     * @param Matrix|array $matrix Matrix or an array to treat as a matrix.
     * @return Matrix The transposed matrix
     * @throws Exception If argument isn't a valid matrix or array.
     */
    function transpose($matrix)
    {
    }
}
/**
 *
 * Function code for the matrix inverse() function
 *
 * @copyright  Copyright (c) 2018 Mark Baker (https://github.com/MarkBaker/PHPMatrix)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Matrix {
    /**
     * Returns the inverse of a matrix or an array.
     *
     * @param Matrix|array $matrix Matrix or an array to treat as a matrix.
     * @return Matrix The new matrix
     * @throws Exception If argument isn't a valid matrix or array.
     */
    function inverse($matrix)
    {
    }
}
/**
 *
 * Function code for the matrix determinant() function
 *
 * @copyright  Copyright (c) 2018 Mark Baker (https://github.com/MarkBaker/PHPMatrix)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Matrix {
    /**
     * Returns the determinant of a matrix or an array.
     *
     * @param Matrix|array $matrix Matrix or an array to treat as a matrix.
     * @return float Matrix determinant
     * @throws Exception If argument isn't a valid matrix or array.
     */
    function determinant($matrix)
    {
    }
}
/**
 *
 * Function code for the matrix diagonal() function
 *
 * @copyright  Copyright (c) 2018 Mark Baker (https://github.com/MarkBaker/PHPMatrix)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Matrix {
    /**
     * Returns the diagonal of a matrix or an array.
     *
     * @param Matrix|array $matrix Matrix or an array to treat as a matrix.
     * @return Matrix The new matrix
     * @throws Exception If argument isn't a valid matrix or array.
     */
    function diagonal($matrix)
    {
    }
}
/**
 *
 * Function code for the matrix trace() function
 *
 * @copyright  Copyright (c) 2018 Mark Baker (https://github.com/MarkBaker/PHPMatrix)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Matrix {
    /**
     * Returns the trace of a matrix or an array.
     *
     * @param Matrix|array $matrix Matrix or an array to treat as a matrix.
     * @return float The trace of the matrix
     * @throws Exception If argument isn't a valid matrix or array.
     */
    function trace($matrix)
    {
    }
}
/**
 *
 * Function code for the matrix identity() function
 *
 * @copyright  Copyright (c) 2018 Mark Baker (https://github.com/MarkBaker/PHPMatrix)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Matrix {
    /**
     * Returns the identity of a matrix or an array.
     *
     * @param Matrix|array $matrix Matrix or an array to treat as a matrix.
     * @return Matrix The identity matrix
     * @throws Exception If argument isn't a valid matrix or array.
     */
    function identity($matrix)
    {
    }
}
/**
 *
 * Function code for the matrix multiplication operation
 *
 * @copyright  Copyright (c) 2018 Mark Baker (https://github.com/MarkBaker/PHPMatrix)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Matrix {
    /**
     * Multiplies two or more matrices
     *
     * @param array<int, mixed> $matrixValues The matrices to multiply
     * @return Matrix
     * @throws Exception
     */
    function multiply(...$matrixValues)
    {
    }
}
/**
 *
 * Function code for the matrix subtraction operation
 *
 * @copyright  Copyright (c) 2018 Mark Baker (https://github.com/MarkBaker/PHPMatrix)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Matrix {
    /**
     * Subtracts two or more matrices
     *
     * @param array<int, mixed> $matrixValues The matrices to subtract
     * @return Matrix
     * @throws Exception
     */
    function subtract(...$matrixValues)
    {
    }
}
/**
 *
 * Function code for the matrix addition operation
 *
 * @copyright  Copyright (c) 2018 Mark Baker (https://github.com/MarkBaker/PHPMatrix)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Matrix {
    /**
     * Adds two or more matrices
     *
     * @param array<int, mixed> $matrixValues The matrices to add
     * @return Matrix
     * @throws Exception
     */
    function add(...$matrixValues)
    {
    }
}
/**
 *
 * Function code for the matrix division operation
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPMatrix)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Matrix {
    /**
     * Divides two or more matrix numbers
     *
     * @param array<int, mixed> $matrixValues The numbers to divide
     * @return Matrix
     * @throws Exception
     */
    function divideinto(...$matrixValues)
    {
    }
}
/**
 *
 * Function code for the matrix direct sum operation
 *
 * @copyright  Copyright (c) 2018 Mark Baker (https://github.com/MarkBaker/PHPMatrix)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Matrix {
    /**
     * Adds two or more matrices
     *
     * @param array<int, mixed> $matrixValues The matrices to add
     * @return Matrix
     * @throws Exception
     */
    function directsum(...$matrixValues)
    {
    }
}
/**
 *
 * Function code for the matrix division operation
 *
 * @copyright  Copyright (c) 2013-2018 Mark Baker (https://github.com/MarkBaker/PHPComplex)
 * @license    https://opensource.org/licenses/MIT    MIT
 */
namespace Matrix {
    /**
     * Divides two or more matrix numbers
     *
     * @param array<int, mixed> $matrixValues The matrices to divide
     * @return Matrix
     * @throws Exception
     */
    function divideby(...$matrixValues)
    {
    }
}
namespace {
    function woo_ce_coupon_scheduled_export_save($post_ID = 0)
    {
    }
    function woo_ce_coupon_dataset_args($args, $export_type = '')
    {
    }
    function woo_ce_cron_coupon_dataset_args($args, $export_type = '', $is_scheduled = 0)
    {
    }
    // Returns a list of Coupon export columns
    function woo_ce_get_coupon_fields($format = 'full', $post_ID = 0)
    {
    }
    // Check if we should override field labels from the Field Editor
    function woo_ce_override_coupon_field_labels($fields = array())
    {
    }
    // Returns the export column header label based on an export column slug
    function woo_ce_get_coupon_field($name = \null, $format = 'name')
    {
    }
    // Returns a list of Coupon IDs
    function woo_ce_get_coupons($args = array())
    {
    }
    function woo_ce_get_coupon_data($coupon_id = 0, $args = array())
    {
    }
    function woo_ce_export_dataset_override_coupon($output = \null, $export_type = \null)
    {
    }
    function woo_ce_export_dataset_multisite_override_coupon($output = \null, $export_type = \null)
    {
    }
    function woo_ce_get_coupon_usage_cost($coupon_code = '')
    {
    }
    function woo_ce_get_coupon_code_usage($coupon_code = '')
    {
    }
    function woo_ce_get_coupon_discount_types()
    {
    }
    // Format the discount type, defaults to Cart Discount
    function woo_ce_format_discount_type($discount_type = '')
    {
    }
    // Format the raw memory data provided by PHP
    function woo_ce_display_memory($memory = 0)
    {
    }
    // Format the raw timestamps to something more friendly
    function woo_ce_display_time_elapsed($from, $to)
    {
    }
    // Takes an array and formats it for the export
    function woo_ce_escape_csv_array($array = array(), $child = \false, $escape = \true)
    {
    }
    // Escape all cells in 'Excel' CSV escape formatting of a CSV file, also converts HTML entities to plain-text
    function woo_ce_escape_csv_value($string = '', $delimiter = ',', $format = 'all')
    {
    }
    function woo_ce_wp_specialchars_decode($string = '', $quote_style = 'ENT_QUOTES', $type = 'string')
    {
    }
    function woo_ce_detect_value_string($string = \false, $format = 'boolean')
    {
    }
    function woo_ce_filter_attribute_escape($safe_text = '', $text = '')
    {
    }
    function woo_ce_filter_sanitize_key($key)
    {
    }
    // Return the element count of an object
    function woo_ce_count_object($object = 0, $exclude_post_types = array())
    {
    }
    function woo_ce_format_custom_meta($custom_meta = \false)
    {
    }
    // Takes an array or comma separated string and returns an export formatted string
    function woo_ce_convert_product_ids($product_ids = \null)
    {
    }
    // Format the raw post_status
    function woo_ce_format_post_status($post_status = '')
    {
    }
    // Format the raw comment_status
    function woo_ce_format_comment_status($comment_status)
    {
    }
    function woo_ce_format_switch($input = '', $output_format = 'answer')
    {
    }
    function woo_ce_format_product_filters($product_filters = array())
    {
    }
    function woo_ce_format_user_role_filters($user_role_filters = array())
    {
    }
    function woo_ce_format_price($price = '', $currency = '')
    {
    }
    function woo_ce_filter_wc_price($return, $price)
    {
    }
    function woo_ce_formatted_woocommerce_price($return, $price, $num_decimals, $decimal_sep, $thousands_sep)
    {
    }
    // Strip the currency symbol from the price
    function woo_ce_woocommerce_currency_symbol($currency_symbol, $currency)
    {
    }
    function woo_ce_format_date($date = '', $format = '')
    {
    }
    // Take our pretty slashed date format and make it play nice with strtotime() and date()
    function woo_ce_format_order_date($date = '', $format = 'export')
    {
    }
    function woo_ce_validate_order_date($date, $format = 'd/m/Y')
    {
    }
    function woo_ce_format_archive_date($post_ID = 0, $time = \false)
    {
    }
    function woo_ce_format_ip_address($ip = '')
    {
    }
    function woo_ce_format_export_method($export_method = '')
    {
    }
    function woo_ce_format_archive_method($export_method = '')
    {
    }
    function woo_ce_format_product_category_label($product_category = '', $parent_category = '')
    {
    }
    function woo_ce_clean_export_label($label = '')
    {
    }
    function woo_ce_expand_state_name($country_prefix = '', $state_prefix = '')
    {
    }
    function woo_ce_expand_country_name($country_prefix = '')
    {
    }
    function woo_ce_allowed_countries()
    {
    }
    function woo_ce_format_description_excerpt($string = '')
    {
    }
    function woo_ce_format_ftp_host($host = '')
    {
    }
    function woo_ce_format_email_contents_allowed_html()
    {
    }
    function woo_ce_format_email_contents_allowed_protocols()
    {
    }
    function woo_ce_format_post_title($title = '')
    {
    }
    function woo_ce_format_wpseo_noindex($noindex = '')
    {
    }
    function woo_ce_format_wpseo_sitemap_include($sitemap_include = '')
    {
    }
    function woo_ce_format_wpseo_follow($follow = '')
    {
    }
    function woo_ce_shipping_class_scheduled_export_save($post_ID = 0)
    {
    }
    function woo_ce_shipping_class_dataset_args($args, $export_type = '')
    {
    }
    // Returns a list of Shipping Class export columns
    function woo_ce_get_shipping_class_fields($format = 'full', $post_ID = 0)
    {
    }
    // Check if we should override field labels from the Field Editor
    function woo_ce_override_shipping_class_field_labels($fields = array())
    {
    }
    // Returns the export column header label based on an export column slug
    function woo_ce_get_shipping_class_field($name = \null, $format = 'name')
    {
    }
    // Returns a list of WooCommerce Shipping Classes to export process
    function woo_ce_get_shipping_classes($args = array())
    {
    }
    function woo_ce_export_dataset_override_shipping_class($output = \null, $export_type = \null)
    {
    }
    function woo_ce_export_dataset_multisite_override_shipping_class($output = \null, $export_type = \null)
    {
    }
    function woo_ce_brand_scheduled_export_save($post_ID = 0)
    {
    }
    function woo_ce_brand_dataset_args($args, $export_type = '')
    {
    }
    // Returns a list of Brand export columns
    function woo_ce_get_brand_fields($format = 'full', $post_ID = 0)
    {
    }
    // Check if we should override field labels from the Field Editor
    function woo_ce_override_brand_field_labels($fields = array())
    {
    }
    // Returns the export column header label based on an export column slug
    function woo_ce_get_brand_field($name = \null, $format = 'name')
    {
    }
    // Returns a list of WooCommerce Product Brands to export process
    function woo_ce_get_product_brands($args = array())
    {
    }
    function woo_ce_export_dataset_override_brand($output = \null, $export_type = \null)
    {
    }
    function woo_ce_export_dataset_multisite_override_brand($output = \null, $export_type = \null)
    {
    }
    // Return whether the Brands Term Taxonomy is in use
    function woo_ce_detect_product_brands()
    {
    }
    function woo_ce_product_fields_gm_rss($fields = array())
    {
    }
    function woo_cd_load_phpexcel_sed_csv_writer()
    {
    }
    function woo_ce_export_template_banner($post)
    {
    }
    function woo_ce_export_template_options_meta_box()
    {
    }
    function woo_ce_export_template_general_export_type($post_ID = 0)
    {
    }
    function woo_ce_export_template_save($post_ID = 0)
    {
    }
    function woo_ce_admin_export_template_footer_javascript()
    {
    }
    // Adds custom Shipping Class columns to the Shipping Class fields list
    function woo_ce_extend_shipping_class_fields($fields = array())
    {
    }
    function woo_ce_extend_shipping_class_item($shipping_classes)
    {
    }
    // Adds custom Brand columns to the Brand fields list
    function woo_ce_extend_brand_fields($fields = array())
    {
    }
    function woo_ce_extend_brand_item($brand)
    {
    }
    function woo_ce_extend_brand_term_taxonomy($term_taxonomy = '')
    {
    }
    function woo_ce_tag_scheduled_export_save($post_ID = 0)
    {
    }
    function woo_ce_tag_dataset_args($args, $export_type = '')
    {
    }
    // Returns a list of Product Tag export columns
    function woo_ce_get_tag_fields($format = 'full', $post_ID = 0)
    {
    }
    // Check if we should override field labels from the Field Editor
    function woo_ce_override_tag_field_labels($fields = array())
    {
    }
    // Returns the export column header label based on an export column slug
    function woo_ce_get_tag_field($name = \null, $format = 'name')
    {
    }
    // Returns a list of WooCommerce Product Tags to export process
    function woo_ce_get_product_tags($args = array())
    {
    }
    function woo_ce_export_dataset_override_tag($output = \null, $export_type = \null)
    {
    }
    function woo_ce_export_dataset_multisite_override_tag($output = \null, $export_type = \null)
    {
    }
    function woo_ce_get_export_type_attribute_count()
    {
    }
    // Returns a list of Attribute export columns
    function woo_ce_get_attribute_fields($format = 'full', $post_ID = 0)
    {
    }
    // Check if we should override field labels from the Field Editor
    function woo_ce_override_attribute_field_labels($fields = array())
    {
    }
    // Returns the export column header label based on an export column slug
    function woo_ce_get_attribute_field($name = \null, $format = 'name')
    {
    }
    // Returns a list of WooCommerce Product Attributes to export process
    function woo_ce_get_attributes($args = array())
    {
    }
    function woo_ce_get_attribute_terms($attribute_slug = '')
    {
    }
    function woo_ce_export_dataset_override_attribute($output = \null, $export_type = \null)
    {
    }
    function woo_ce_export_dataset_multisite_override_attribute($output = \null, $export_type = \null)
    {
    }
    function woo_ce_format_attribute_type_label($attribute_type = '')
    {
    }
    function woo_ce_format_attribute_sorting_label($attribute_sorting = 'menu_order')
    {
    }
    function woo_ce_customer_dataset_args($args, $export_type = '')
    {
    }
    // Returns a list of Customer export columns
    function woo_ce_get_customer_fields($format = 'full', $post_ID = 0)
    {
    }
    // Check if we should override field labels from the Field Editor
    function woo_ce_override_customer_field_labels($fields = array())
    {
    }
    // Returns the export column header label based on an export column slug
    function woo_ce_get_customer_field($name = \null, $format = 'name')
    {
    }
    function woo_ce_export_dataset_override_customer($output = \null, $export_type = \null)
    {
    }
    function woo_ce_export_dataset_multisite_override_customer($output = \null, $export_type = \null)
    {
    }
    function woo_ce_get_customers_list()
    {
    }
    function woo_ce_is_duplicate_customer($customers = array(), $order = array())
    {
    }
    /* Start of: WordPress Administration */
    // Quick Export
    function woo_ce_orders_filter_by_order_meta()
    {
    }
    // Scheduled Exports
    function woo_ce_extend_order_scheduled_export_save($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_order_filter_by_order_meta($post_ID = 0)
    {
    }
    // Adds custom Order columns to the Order fields list
    function woo_ce_extend_order_fields($fields = array())
    {
    }
    // Adds custom Order Item columns to the Order Items fields list
    function woo_ce_extend_order_items_fields($fields = array())
    {
    }
    // Populate Order details for export of 3rd party Plugins
    function woo_ce_order_extend($order, $order_id)
    {
    }
    function woo_ce_extend_order_dataset_args($args, $export_type = '')
    {
    }
    function woo_ce_extend_cron_order_dataset_args($args, $export_type = '', $is_scheduled = 0)
    {
    }
    function woo_ce_extend_get_orders_by_coupon($order_items)
    {
    }
    function woo_ce_extend_get_orders_args($args)
    {
    }
    // Gravity Forms - http://woothemes.com/woocommerce
    function woo_ce_get_gravity_forms_products()
    {
    }
    // Gravity Forms - http://woothemes.com/woocommerce
    function woo_ce_get_gravity_forms_fields()
    {
    }
    // WooCommerce TM Extra Product Options - http://codecanyon.net/item/woocommerce-extra-product-options/7908619
    function woo_ce_get_extra_product_option_fields($order_item = 0)
    {
    }
    // WooCommerce TM Extra Product Options - http://codecanyon.net/item/woocommerce-extra-product-options/7908619
    function woo_ce_get_extra_product_option_value($order_item = 0, $tm_field = array())
    {
    }
    function woo_ce_get_nm_personalized_product_fields()
    {
    }
    // WooCommerce Custom Fields - http://www.rightpress.net/woocommerce-custom-fields
    function woo_ce_get_wccf_product_fields()
    {
    }
    // WooCommerce Custom Fields - http://www.rightpress.net/woocommerce-custom-fields
    function woo_ce_get_wccf_order_fields()
    {
    }
    // WooCommerce Custom Fields - http://www.rightpress.net/woocommerce-custom-fields
    function woo_ce_get_wccf_checkout_fields()
    {
    }
    // WooCommerce Appointments - http://www.bizzthemes.com/plugins/woocommerce-appointments/
    function woo_ce_get_appointment_by_order_item($order_item_id = 0, $order_id = 0)
    {
    }
    // WooCommerce Product Custom Options Lite - https://wordpress.org/plugins/woocommerce-custom-options-lite/
    function woo_ce_get_product_custom_options()
    {
    }
    // WooCommerce Bookings - http://www.woothemes.com/products/woocommerce-bookings/
    function woo_ce_get_order_assoc_booking_id($order_id = \false, $order_item_id = \false)
    {
    }
    // Tickera - https://tickera.com/
    // FooEvents for WooCommerce - https://www.fooevents.com/
    function woo_ce_get_order_assoc_ticket_ids($order_id)
    {
    }
    // Tickera - https://tickera.com/
    function woo_ce_get_tickera_custom_fields()
    {
    }
    // WooCommerce Germanized - http://www.wpovernight.com
    function woo_ce_get_order_invoice_status($invoice_id = 0)
    {
    }
    function woo_ce_extend_get_order_items($order_items, $order_id = 0)
    {
    }
    function woo_ce_extend_get_order_items_pre($order_items, $order_id)
    {
    }
    function woo_ce_extend_orders_output($output = \null, $orders = \false)
    {
    }
    function woo_ce_extend_order_item_custom_meta($order_item, $meta_key = '', $meta_value = '')
    {
    }
    function woo_ce_extend_order_item($order_item = array(), $order_id = 0)
    {
    }
    // Add additional shipping methods to the Filter Orders by Shipping Methods list
    function woo_ce_extend_get_order_shipping_methods($output)
    {
    }
    // WooCommerce P.IVA e Codice Fiscale per Italia - https://wordpress.org/plugins/woo-piva-codice-fiscale-e-fattura-pdf-per-italia/
    function woo_ce_format_invoice_type($invoice_type = '')
    {
    }
    // Adds custom Tag columns to the Tag fields list
    function woo_ce_extend_tag_fields($fields = array())
    {
    }
    function woo_ce_extend_tag_item($tag)
    {
    }
    function woo_ce_get_booking_count()
    {
    }
    function woo_ce_booking_dataset_args($args, $export_type = '')
    {
    }
    function woo_ce_cron_booking_dataset_args($args, $export_type = '', $is_scheduled = 0)
    {
    }
    // Returns a list of Booking export columns
    function woo_ce_get_booking_fields($format = 'full', $post_ID = 0)
    {
    }
    // Check if we should override field labels from the Field Editor
    function woo_ce_override_booking_field_labels($fields = array())
    {
    }
    // Returns the export column header label based on an export column slug
    function woo_ce_get_booking_field($name = \null, $format = 'name')
    {
    }
    // Returns a list of WooCommerce Booking IDs to export process
    function woo_ce_get_bookings($args = array())
    {
    }
    function woo_ce_export_dataset_override_booking($output = \null, $export_type = \null)
    {
    }
    function woo_ce_export_dataset_multisite_override_booking($output = \null, $export_type = \null)
    {
    }
    function woo_ce_get_booking_data($booking_id = 0, $args = array(), $fields = array())
    {
    }
    function woo_ce_extend_booking_format_post_status($output, $post_status)
    {
    }
    function woo_ce_export_settings_quicklinks()
    {
    }
    function woo_ce_export_settings_multisite()
    {
    }
    // add_action( 'woo_ce_export_settings_general', 'woo_ce_export_settings_multisite', 11 );
    function woo_ce_export_settings_general()
    {
    }
    function woo_ce_export_settings_general_advanced_settings_extend()
    {
    }
    function woo_ce_export_settings_csv()
    {
    }
    // Returns the HTML template for the CRON, scheduled exports, Secret Export Key and Export Trigger options for the Settings screen
    function woo_ce_export_settings_extend()
    {
    }
    function woo_ce_export_settings_save()
    {
    }
    // De-activate Store Exporter to limit conflicts
    function woo_cd_deactivate_ce()
    {
    }
    function woo_cd_install()
    {
    }
    // Trigger the creation of Admin options for this Plugin
    function woo_cd_create_options()
    {
    }
    function woo_cd_create_secure_archives_dir()
    {
    }
    // Detect Store Exporter and other platform versions
    function woo_cd_detect_ce()
    {
    }
    function woo_cd_uninstall()
    {
    }
    function woo_ce_archives_add_options()
    {
    }
    function woo_ce_set_archives_screen_option($status, $option, $value)
    {
    }
    function woo_ce_get_subscription_count()
    {
    }
    function woo_ce_subscription_scheduled_export_save($post_ID = 0)
    {
    }
    function woo_ce_subscription_dataset_args($args, $export_type = '')
    {
    }
    function woo_ce_cron_subscription_dataset_args($args, $export_type = '', $is_scheduled = 0)
    {
    }
    // Returns a list of Subscription export columns
    function woo_ce_get_subscription_fields($format = 'full', $post_ID = 0)
    {
    }
    // Check if we should override field labels from the Field Editor
    function woo_ce_override_subscription_field_labels($fields = array())
    {
    }
    // Returns the export column header label based on an export column slug
    function woo_ce_get_subscription_field($name = \null, $format = 'name')
    {
    }
    // Returns a list of Subscription IDs
    function woo_ce_get_subscriptions($args = array())
    {
    }
    function woo_ce_woocommerce_get_subscriptions_query_args($args)
    {
    }
    // Override wcs_get_subscriptions() to only return the Subscription Post ID
    function woo_ce_woocommerce_got_subscriptions($subscriptions)
    {
    }
    function woo_ce_export_dataset_override_subscription($output = \null, $export_type = \null)
    {
    }
    function woo_ce_export_dataset_multisite_override_subscription($output = \null, $export_type = \null)
    {
    }
    function woo_ce_get_subscription_data($subscription_id, $args = array(), $fields = array())
    {
    }
    function woo_ce_get_subscription_statuses()
    {
    }
    function woo_ce_get_wc_subscriptions_version()
    {
    }
    function woo_ce_get_subscription_order_item($order_id = 0, $product_id = 0)
    {
    }
    function woo_ce_get_subscription_product($order = \false, $order_item = \false)
    {
    }
    function woo_ce_format_subscription_date($end_date = '')
    {
    }
    function woo_ce_get_subscription_products()
    {
    }
    function woo_ce_format_subscription_status($subscription_status = '')
    {
    }
    function woo_ce_format_product_subscription_period_interval($interval)
    {
    }
    function woo_ce_format_product_subscripion_length($length, $period = '')
    {
    }
    function woo_ce_format_product_subscription_limit($limit)
    {
    }
    // Quick Export
    // HTML template for Filter Coupons by Discount Type on Store Exporter screen
    function woo_ce_coupons_filter_by_discount_type()
    {
    }
    // HTML template for Coupon Sorting widget on Store Exporter screen
    function woo_ce_coupon_sorting()
    {
    }
    // Scheduled Exports
    function woo_ce_scheduled_export_filters_coupon($post_ID = 0)
    {
    }
    // HTML template for Coupon Sorting filter on Edit Scheduled Export screen
    function woo_ce_scheduled_export_coupon_filter_orderby($post_ID)
    {
    }
    // HTML template for Filter Coupons by Discount Type widget on Scheduled Export screen
    function woo_ce_scheduled_export_coupon_filter_by_discount_type($post_ID)
    {
    }
    // Export templates
    function woo_ce_export_template_fields_coupon($post_ID = 0)
    {
    }
    // Scheduled Exports
    function woo_ce_scheduled_export_filters_shipping_class($post_ID = 0)
    {
    }
    // HTML template for Shipping Class Sorting filter on Edit Scheduled Export screen
    function woo_ce_scheduled_export_shipping_class_filter_orderby($post_ID)
    {
    }
    // Quick Export
    // HTML template for Shipping Class Sorting widget on Store Exporter screen
    function woo_ce_shipping_class_sorting()
    {
    }
    // Export templates
    function woo_ce_export_template_fields_shipping_class($post_ID = 0)
    {
    }
    // Quick Export
    // HTML template for Coupon Sorting widget on Store Exporter screen
    function woo_ce_brand_sorting()
    {
    }
    // HTML template for Custom Brands widget on Store Exporter screen
    function woo_ce_brands_custom_fields()
    {
    }
    // Scheduled Exports
    function woo_ce_scheduled_export_filters_brand($post_ID = 0)
    {
    }
    // HTML template for Brand Sorting filter on Edit Scheduled Export screen
    function woo_ce_scheduled_export_brand_filter_orderby($post_ID)
    {
    }
    // Export templates
    function woo_ce_export_template_fields_brand($post_ID = 0)
    {
    }
    function woo_ce_export_options_export_format()
    {
    }
    function woo_ce_export_options_export_template()
    {
    }
    function woo_ce_export_options_troubleshooting()
    {
    }
    function woo_ce_export_options_limit_volume()
    {
    }
    function woo_ce_export_options_volume_offset()
    {
    }
    // Quick Export
    // HTML template for Filter Tags by Language widget on Store Exporter screen
    function woo_ce_tags_filter_by_language()
    {
    }
    // HTML template for Tag Sorting widget on Store Exporter screen
    function woo_ce_tag_sorting()
    {
    }
    // HTML template for Custom Tags widget on Store Exporter screen
    function woo_ce_tags_custom_fields()
    {
    }
    // Scheduled Exports
    function woo_ce_scheduled_export_filters_tag($post_ID = 0)
    {
    }
    // HTML template for Tag Sorting filter on Edit Scheduled Export screen
    function woo_ce_scheduled_export_tag_filter_orderby($post_ID)
    {
    }
    // Export templates
    function woo_ce_export_template_fields_tag($post_ID = 0)
    {
    }
    // @mod - We'll do this once 2.4+ goes out
    function woo_ce_ajax_dismiss_pointer()
    {
    }
    // add_action( 'wp_ajax_woo_ce_dismiss_pointer', 'woo_ce_ajax_dismiss_pointer' );
    // @mod - We'll do this once 2.4+ goes out
    function woo_ce_admin_register_pointer_testing($pointers = array())
    {
    }
    // Quick Export
    // HTML template for Filter Customers by Order Status widget on Store Exporter screen
    function woo_ce_customers_filter_by_status()
    {
    }
    // HTML template for Filter Customers by User Role widget on Store Exporter screen
    function woo_ce_customers_filter_by_user_role()
    {
    }
    // HTML template for Customer Sorting widget on Store Exporter screen
    function woo_ce_customer_sorting()
    {
    }
    // HTML template for jump link to Custom Customer Fields within Order Options on Store Exporter screen
    function woo_ce_customers_custom_fields_link()
    {
    }
    // HTML template for Custom Customers widget on Store Exporter screen
    function woo_ce_customers_custom_fields()
    {
    }
    // Scheduled Exports
    // Export templates
    function woo_ce_export_template_fields_customer($post_ID = 0)
    {
    }
    // Quick Export
    // HTML template for Filter Orders by Brand widget on Store Exporter screen
    function woo_ce_orders_filter_by_product_brand()
    {
    }
    // HTML template for Filter Orders by Product Vendor widget on Store Exporter screen
    function woo_ce_orders_filter_by_product_vendor()
    {
    }
    // HTML template for Filter Orders by Delivery Date widget on Store Exporter screen
    function woo_ce_orders_filter_by_delivery_date()
    {
    }
    // HTML template for Filter Orders by Booking Date widget on Store Exporter screen
    function woo_ce_orders_filter_by_booking_date()
    {
    }
    // HTML template for Filter Orders by Booking Start Date widget on Store Exporter screen
    function woo_ce_orders_filter_by_booking_start_date()
    {
    }
    function woo_ce_orders_filter_by_voucher_redeemed()
    {
    }
    function woo_ce_orders_filter_by_order_type()
    {
    }
    function woo_ce_extend_order_sorting($orderby = \false)
    {
    }
    function woo_ce_orders_custom_fields_extra_product_options()
    {
    }
    function woo_ce_orders_custom_fields_product_addons()
    {
    }
    // Scheduled Exports
    function woo_ce_scheduled_export_order_filter_by_product_brand($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_order_filter_by_order_type($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_order_filter_by_booking_start_date($post_ID = 0)
    {
    }
    // HTML template for Filter Orders by Delivery Date widget on Store Exporter screen
    function woo_ce_scheduled_export_order_filter_by_delivery_date($post_ID = 0)
    {
    }
    // Quick Export
    // HTML template for Booking Sorting widget on Store Exporter screen
    function woo_ce_booking_sorting()
    {
    }
    // Export templates
    function woo_ce_export_template_fields_booking($post_ID = 0)
    {
    }
    // Add Export to... to Booking screen
    function woo_ce_extend_woocommerce_admin_booking_actions($actions, $booking)
    {
    }
    // Quick Export
    // HTML template for Filter Subscriptionss by Subscription Date widget on Store Exporter screen
    function woo_ce_subscriptions_filter_by_date()
    {
    }
    // HTML template for Filter Subscriptions by Subscription Status widget on Store Exporter screen
    function woo_ce_subscriptions_filter_by_subscription_status()
    {
    }
    // HTML template for Filter Subscriptions by Subscription Product widget on Store Exporter screen
    function woo_ce_subscriptions_filter_by_subscription_product()
    {
    }
    // HTML template for Filter Subscriptions by Customer widget on Store Exporter screen
    function woo_ce_subscriptions_filter_by_customer()
    {
    }
    // HTML template for Filter Subscriptions by Source widget on Store Exporter screen
    function woo_ce_subscriptions_filter_by_source()
    {
    }
    // HTML template for Subscription Sorting widget on Store Exporter screen
    function woo_ce_subscription_sorting()
    {
    }
    // HTML template for Subscription Items Formatting on Store Exporter screen
    function woo_ce_subscriptions_items_formatting()
    {
    }
    // HTML template for jump link to Custom Subscription Fields within Subscription Options on Store Exporter screen
    function woo_ce_subscriptions_custom_fields_link()
    {
    }
    // HTML template for Custom Subscriptions widget on Store Exporter screen
    function woo_ce_subscriptions_custom_fields()
    {
    }
    // Scheduled Exports
    function woo_ce_scheduled_export_filters_subscription($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_subscription_filter_by_subscription_date($post_ID = 0)
    {
    }
    // HTML template for Subscription Status filter on Edit Scheduled Export screen
    function woo_ce_scheduled_export_subscription_filter_by_subscription_status($post_ID)
    {
    }
    // HTML template for Subscription Sorting filter on Edit Scheduled Export screen
    function woo_ce_scheduled_export_subscription_filter_orderby($post_ID)
    {
    }
    function woo_ce_scheduled_export_subscription_filter_by_subscription_product($post_ID)
    {
    }
    function woo_ce_scheduled_export_subscription_items_formatting($post_ID = 0)
    {
    }
    // Export templates
    function woo_ce_export_template_fields_subscription($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_banner($post)
    {
    }
    function woo_ce_scheduled_export_filters_meta_box()
    {
    }
    function woo_ce_extend_scheduled_export_options($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_general_export_type($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_general_export_format($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_general_export_method($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_general_export_fields($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_general_excel_formulas($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_general_header_formatting($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_general_grouped_product_formatting($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_general_order($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_general_volume_limit_offset($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_general_product_image_formatting($post_ID = 0)
    {
    }
    // Save to WordPress Media
    function woo_ce_scheduled_export_method_archive($post_ID = 0)
    {
    }
    // Save to this server
    function woo_ce_scheduled_export_method_save($post_ID = 0)
    {
    }
    // Send as e-mail
    function woo_ce_scheduled_export_method_email($post_ID = 0)
    {
    }
    // Post to remote URL
    function woo_ce_scheduled_export_method_post($post_ID = 0)
    {
    }
    // Upload to remote FTP/SFTP
    function woo_ce_scheduled_export_method_ftp($post_ID = 0)
    {
    }
    // Save to Google Sheets
    function woo_ce_scheduled_export_method_google_sheets($post_ID = 0)
    {
    }
    // Save to Google Sheets (legacy)
    function woo_ce_scheduled_export_method_google_sheets_legacy($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_frequency_schedule($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_frequency_days($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_frequency_commence($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_details_meta_box()
    {
    }
    function woo_ce_scheduled_export_history_meta_box()
    {
    }
    function woo_ce_scheduled_export_execute_meta_box()
    {
    }
    function woo_ce_admin_scheduled_export_footer_javascript()
    {
    }
    function woo_ce_scheduled_export_update($post_ID = '', $post = array())
    {
    }
    function woo_ce_scheduled_export_save($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_delete($post_ID = \false)
    {
    }
    function woo_ce_extend_scheduled_export_save($post_ID = 0)
    {
    }
    function woo_ce_admin_scheduled_exports_recent_scheduled_exports()
    {
    }
    function woo_ce_admin_scheduled_export_widget()
    {
    }
    function woo_ce_admin_recent_scheduled_export_widget()
    {
    }
    function woo_ce_admin_scheduled_export_widget_configure()
    {
    }
    function woo_ce_admin_recent_scheduled_export_widget_configure()
    {
    }
    // Quick Export
    // HTML template for Filter Products by Product Category widget on Store Exporter screen
    function woo_ce_products_filter_by_product_category()
    {
    }
    // HTML template for Filter Products by Product Tag widget on Store Exporter screen
    function woo_ce_products_filter_by_product_tag()
    {
    }
    // HTML template for Filter Products by Product Status widget on Store Exporter screen
    function woo_ce_products_filter_by_product_status()
    {
    }
    // HTML template for Filter Products by Product Type widget on Store Exporter screen
    function woo_ce_products_filter_by_product_type()
    {
    }
    // HTML template for Filter Products by Product widget on Store Exporter screen
    function woo_ce_products_filter_by_sku()
    {
    }
    // HTML template for Filter Products by User Role widget on Store Exporter screen
    function woo_ce_products_filter_by_user_role()
    {
    }
    // HTML template for Filter Products by Stock Status widget on Store Exporter screen
    function woo_ce_products_filter_by_stock_status()
    {
    }
    // HTML template for Filter Products by Stock Quantity widget on Store Exporter screen
    function woo_ce_products_filter_by_stock_quantity()
    {
    }
    // HTML template for Filter Products by Featured widget on Store Exporter screen
    function woo_ce_products_filter_by_featured()
    {
    }
    // HTML template for Filter Products by Shipping Classes widget on Store Exporter screen
    function woo_ce_products_filter_by_shipping_class()
    {
    }
    // HTML template for Filter Products by Featured Image widget on Store Exporter screen
    function woo_ce_products_filter_by_featured_image()
    {
    }
    // HTML template for Filter Products by Product Gallery widget on Store Exporter screen
    function woo_ce_products_filter_by_product_gallery()
    {
    }
    // HTML template for Filter Products by Date Modified widget on Store Exporter screen
    function woo_ce_products_filter_by_date_modified()
    {
    }
    // HTML template for Filter Products by Date Published widget on Store Exporter screen
    function woo_ce_products_filter_by_date_published()
    {
    }
    function woo_ce_products_filter_by_product_meta()
    {
    }
    // HTML template for jump link to Custom Product Fields within Product Options on Store Exporter screen
    function woo_ce_products_custom_fields_link()
    {
    }
    // HTML template for Product Sorting widget on Store Exporter screen
    function woo_ce_product_sorting()
    {
    }
    // HTML template for Product Sorting widget on Store Exporter screen
    function woo_ce_product_multi_level_sorting($post_ID = 0)
    {
    }
    // HTML template for Grouped Products formatting on Store Exporter screen
    function woo_ce_products_grouped_formatting()
    {
    }
    // HTML template for Up-sells formatting on Store Exporter screen
    function woo_ce_products_upsell_formatting()
    {
    }
    // HTML template for Cross-sells formatting on Store Exporter screen
    function woo_ce_products_crosssell_formatting()
    {
    }
    // HTML template for Variation formatting on Store Exporter screen
    function woo_ce_products_variation_formatting()
    {
    }
    function woo_ce_products_description_excerpt_formatting()
    {
    }
    // HTML template for Custom Products widget on Store Exporter screen
    function woo_ce_products_custom_fields()
    {
    }
    function woo_ce_export_options_featured_image_formatting()
    {
    }
    function woo_ce_export_options_product_gallery_formatting()
    {
    }
    // Scheduled Exports
    function woo_ce_scheduled_export_filters_product($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_product_filter_by_product_category($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_product_filter_by_product_tag($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_product_filter_by_product_status($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_product_filter_by_product_type($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_product_filter_by_product($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_product_filter_by_user_role($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_product_filter_by_shipping_class($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_product_filter_by_date_modified($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_product_filter_by_date_published($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_product_filter_by_stock_status($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_product_filter_by_stock_quantity($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_product_filter_by_featured($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_product_filter_by_product_meta($post_ID = 0)
    {
    }
    // HTML template for Product Sorting filter on Edit Scheduled Export screen
    function woo_ce_scheduled_export_product_filter_orderby($post_ID)
    {
    }
    // HTML template for Product Multi Level Sorting filter on Edit Scheduled Export screen
    function woo_ce_scheduled_export_product_multi_level_sorting($post_ID)
    {
    }
    // Export templates
    function woo_ce_export_template_fields_product($post_ID = 0)
    {
    }
    // Quick Export
    // HTML template for Category Sorting widget on Store Exporter screen
    function woo_ce_category_sorting()
    {
    }
    // HTML template for Custom Categories widget on Store Exporter screen
    function woo_ce_categories_custom_fields()
    {
    }
    // Scheduled Export
    function woo_ce_scheduled_export_filters_category($post_ID = 0)
    {
    }
    // HTML template for Category Sorting filter on Edit Scheduled Export screen
    function woo_ce_scheduled_export_category_filter_orderby($post_ID)
    {
    }
    // Export templates
    function woo_ce_export_template_fields_category($post_ID = 0)
    {
    }
    // Quick Export
    // HTML template for Review Sorting widget on Store Exporter screen
    function woo_ce_review_sorting()
    {
    }
    // Scheduled Exports
    function woo_ce_scheduled_export_filters_review($post_ID = 0)
    {
    }
    // HTML template for Review Sorting filter on Edit Scheduled Export screen
    function woo_ce_scheduled_export_review_filter_orderby($post_ID)
    {
    }
    function woo_ce_scheduled_export_review_filter_by_review_date($post_ID)
    {
    }
    // Export templates
    function woo_ce_export_template_fields_review($post_ID = 0)
    {
    }
    // Quick Export
    // Scheduled Exports
    // Export templates
    function woo_ce_export_template_fields_ticket($post_ID = 0)
    {
    }
    // Quick Export
    // HTML template for Filter Orders by Order Date widget on Store Exporter screen
    function woo_ce_orders_filter_by_date()
    {
    }
    // HTML template for Filter Orders by Order Modified Date widget on Store Exporter screen
    function woo_ce_orders_filter_by_modified_date()
    {
    }
    // HTML template for Filter Orders by Order Status widget on Store Exporter screen
    function woo_ce_orders_filter_by_status()
    {
    }
    // HTML template for Filter Orders by Customer widget on Store Exporter screen
    function woo_ce_orders_filter_by_customer()
    {
    }
    // HTML template for Filter Orders by Billing Country widget on Store Exporter screen
    function woo_ce_orders_filter_by_billing_country()
    {
    }
    // HTML template for Filter Orders by Shipping Country widget on Store Exporter screen
    function woo_ce_orders_filter_by_shipping_country()
    {
    }
    // HTML template for Filter Orders by User Role widget on Store Exporter screen
    function woo_ce_orders_filter_by_user_role()
    {
    }
    // HTML template for Filter Orders by Coupon Code widget on Store Exporter screen
    function woo_ce_orders_filter_by_coupon()
    {
    }
    // HTML template for Filter Orders by Order ID widget on Store Exporter screen
    function woo_ce_orders_filter_by_order_id()
    {
    }
    // HTML template for Filter Orders by Payment Gateway widget on Store Exporter screen
    function woo_ce_orders_filter_by_payment_gateway()
    {
    }
    // HTML template for Filter Orders by Shipping Gateway widget on Store Exporter screen
    function woo_ce_orders_filter_by_shipping_method()
    {
    }
    // HTML template for Digital Products on Store Exporter screen
    function woo_ce_orders_filter_by_digital_products()
    {
    }
    // HTML template for Filter Orders by Product widget on Store Exporter screen
    function woo_ce_orders_filter_by_product()
    {
    }
    // HTML template for Filter Orders by Product Category widget on Store Exporter screen
    function woo_ce_orders_filter_by_product_category()
    {
    }
    // HTML template for Filter Orders by Product Tag widget on Store Exporter screen
    function woo_ce_orders_filter_by_product_tag()
    {
    }
    // HTML template for Order Sorting widget on Store Exporter screen
    function woo_ce_order_sorting()
    {
    }
    // HTML template for jump link to Custom Order Fields within Order Options on Store Exporter screen
    function woo_ce_orders_custom_fields_link()
    {
    }
    // HTML template for Order Items Formatting on Store Exporter screen
    function woo_ce_orders_items_formatting()
    {
    }
    // HTML template for Max Order Items widget on Store Exporter screen
    function woo_ce_orders_max_order_items()
    {
    }
    // HTML template for Order Items Types on Store Exporter screen
    function woo_ce_orders_items_types()
    {
    }
    // HTML template for Add note for exported Order flag widget on Store Exporter screen
    function woo_ce_orders_flag_notes()
    {
    }
    // HTML template for Custom Orders widget on Store Exporter screen
    function woo_ce_orders_custom_fields()
    {
    }
    // Scheduled Exports
    function woo_ce_scheduled_export_filters_order($post_ID = 0)
    {
    }
    // HTML template for Order Sorting filter on Edit Scheduled Export screen
    function woo_ce_scheduled_export_order_filter_orderby($post_ID)
    {
    }
    function woo_ce_scheduled_export_order_filter_by_product($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_order_filter_by_product_category($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_order_filter_by_product_tag($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_order_filter_by_customer($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_order_filter_by_order_status($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_order_filter_by_billing_country($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_order_filter_by_shipping_country($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_order_filter_by_order_date($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_order_filter_by_order_modified_date($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_order_filter_by_user_role($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_order_filter_by_coupon($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_order_filter_by_payment_gateway($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_order_filter_by_shipping_method($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_order_items_formatting($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_order_max_order_items($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_order_export_order_notes($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_order_filter_by_digital_products($post_ID = 0)
    {
    }
    // HTML template for Order Item Types filter on Edit Scheduled Export screen
    function woo_ce_scheduled_export_order_order_item_types($post_ID)
    {
    }
    // Export templates
    function woo_ce_export_template_fields_order($post_ID = 0)
    {
    }
    // Quick Export
    // HTML template for Filter Commissions by Commission Date widget on Store Exporter screen
    function woo_ce_commissions_filter_by_date()
    {
    }
    // HTML template for Commission Sorting widget on Store Exporter screen
    function woo_ce_commission_sorting()
    {
    }
    // HTML template for Filter Commissions by Product Vendor widget on Store Exporter screen
    function woo_ce_commissions_filter_by_product_vendor()
    {
    }
    // HTML template for Filter Commissions by Commission Status widget on Store Exporter screen
    function woo_ce_commissions_filter_by_commission_status()
    {
    }
    // Scheduled Export
    function woo_ce_scheduled_export_filters_commission($post_ID = 0)
    {
    }
    // HTML template for Commission Sorting filter on Edit Scheduled Export screen
    function woo_ce_scheduled_export_commission_filter_orderby($post_ID)
    {
    }
    // Export templates
    function woo_ce_export_template_fields_commission($post_ID = 0)
    {
    }
    // Quick Export
    // HTML template for Filter Users by User Role widget on Store Exporter screen
    function woo_ce_users_filter_by_user_role()
    {
    }
    // HTML template for Filter Users by Date Registered widget on Store Exporter screen
    function woo_ce_users_filter_by_date_registered()
    {
    }
    // HTML template for Filter Orders by Users Date Last Updated widget on Store Exporter screen
    function woo_ce_users_filter_by_date_last_updated()
    {
    }
    // HTML template for jump link to Store Exporter screen
    function woo_ce_users_custom_fields_link()
    {
    }
    // HTML template for User Sorting widget on Store Exporter screen
    function woo_ce_user_sorting()
    {
    }
    // HTML template for Custom Users widget on Store Exporter screen
    function woo_ce_users_custom_fields()
    {
    }
    // Scheduled Exports
    function woo_ce_scheduled_export_filters_user($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_user_filter_by_date_registered($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_user_filter_by_date_last_updated($post_ID = 0)
    {
    }
    // HTML template for User Sorting filter on Edit Scheduled Export screen
    function woo_ce_scheduled_export_user_filter_orderby($post_ID)
    {
    }
    // Export templates
    function woo_ce_export_template_fields_user($post_ID = 0)
    {
    }
    // Quick Export
    // HTML template for Filter Products by Brand widget on Store Exporter screen
    function woo_ce_products_filter_by_product_brand()
    {
    }
    // HTML template for Filter Products by Product Vendor widget on Store Exporter screen
    function woo_ce_products_filter_by_product_vendor()
    {
    }
    // HTML template for Filter Products by Language widget on Store Exporter screen
    function woo_ce_products_filter_by_language()
    {
    }
    // Scheduled Export
    function woo_ce_scheduled_export_product_filter_by_product_brand($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_product_filter_by_language($post_ID = 0)
    {
    }
    function woo_ce_scheduled_export_product_filter_by_product_vendor($post_ID = 0)
    {
    }
    /* Start of: WordPress Administration */
    // HTML template for Filter Users by User Membership widget on Store Exporter screen
    function woo_ce_users_filter_by_user_membership()
    {
    }
    function woo_ce_extend_user_dataset_args($args, $export_type = '')
    {
    }
    function woo_ce_extend_get_users_args($args, $export_args)
    {
    }
    // Adds custom User columns to the User fields list
    function woo_ce_extend_user_fields($fields = array())
    {
    }
    function woo_ce_user_extend($user)
    {
    }
    // Return a list of WooCommerce Membership PLans
    function woo_ce_get_membership_plans()
    {
    }
    // Return a list of WooCommerce Membership Plans linked to a specific User
    function woo_ce_get_user_assoc_user_memberships($user_id = 0)
    {
    }
    // Return a list of Users linked to the specific WooCommerce Membership Plans
    function woo_ce_get_user_membership_assoc_users($user_memberships = '')
    {
    }
    function woo_ce_format_user_membership_status($post_status = '')
    {
    }
    function woo_ce_get_wccf_user_fields()
    {
    }
    // Adds custom Review columns to the Review fields list
    function woo_ce_extend_review_fields($fields = array())
    {
    }
    function woo_ce_extend_review_item($review)
    {
    }
    function woo_vl_dashboard_setup()
    {
    }
    function woo_vl_news_widget()
    {
    }
    function woo_vm_dashboard_setup()
    {
    }
    function woo_vm_status_widget()
    {
    }
    function woo_vm_status_widget_configure()
    {
    }
    // Here we inform WordPress CRON of future scheduled exports
    function woo_ce_cron_activation($force_reload = \false, $post_ID = 0)
    {
    }
    // Here is our list of WordPress CRON schedule frequencies
    function woo_ce_cron_schedules($schedules = array())
    {
    }
    // Runs as part of Scheduled Export tasks
    function woo_ce_auto_export($args = array())
    {
    }
    function woo_ce_cron_export($gui = '', $type = '', $assoc_args = array())
    {
    }
    // Sets the e-mail header to HTML
    function woo_ce_set_html_content_type()
    {
    }
    function woo_ce_check_cron_export_arguments($args)
    {
    }
    function woo_ce_cron_export_fields($export_type = '', $is_scheduled = 0, $scheduled_export = 0)
    {
    }
    function woo_ce_cron_email_subject($type = '', $filename = '')
    {
    }
    function woo_ce_cron_email_heading($type = '', $filename = '')
    {
    }
    function woo_ce_cron_email_contents($type = '', $filename = '')
    {
    }
    function woo_ce_trigger_new_order_export($order_id = 0)
    {
    }
    function woo_ce_is_xml_cdata($string = '', $export_type = '', $field = '')
    {
    }
    function woo_ce_sanitize_xml_string($string = '')
    {
    }
    // Function to generate a valid XML file
    function woo_ce_format_xml($xml = \null)
    {
    }
    function woo_ce_extend_order_items_individual($order, $order_item)
    {
    }
    // Order items formatting: Combined
    function woo_ce_extend_order_items_combined($order)
    {
    }
    function woo_ce_product_scheduled_export_save($post_ID = 0)
    {
    }
    function woo_ce_product_dataset_args($args, $export_type = '')
    {
    }
    function woo_ce_cron_product_dataset_args($args, $export_type = '', $is_scheduled = 0)
    {
    }
    // Returns a list of Product export columns
    function woo_ce_get_product_fields($format = 'full', $post_ID = 0)
    {
    }
    // Check if we should override field labels from the Field Editor
    function woo_ce_override_product_field_labels($fields = array())
    {
    }
    // Returns the export column header label based on an export column slug
    function woo_ce_get_product_field($name = \null, $format = 'name')
    {
    }
    // Returns a list of WooCommerce Products
    function woo_ce_get_products($args = array())
    {
    }
    function woo_ce_get_product_data($product_id = 0, $args = array(), $fields = array())
    {
    }
    function woo_ce_wp_query_product_where_override_language($where)
    {
    }
    function woo_ce_export_dataset_override_product($output = \null, $export_type = \null)
    {
    }
    function woo_ce_export_dataset_multisite_override_product($output = \null, $export_type = \null)
    {
    }
    // Filters the get_the_title() function and adds friendly Variation information
    function woo_ce_get_product_title($title = '', $post_ID = '')
    {
    }
    // Filters the get_the_title() function and adds friendly Variation information suffixed with SKU
    function woo_ce_get_product_title_sku($title = '', $post_ID = '')
    {
    }
    // Returns date of first Product Date Modified, any status
    function woo_ce_get_product_first_date($date_format = 'd/m/Y')
    {
    }
    // Returns Product Categories or optionally other hierarchical Term Taxonomies associated to a specific Product
    function woo_ce_get_product_assoc_categories($product_id = 0, $parent_id = 0, $term_taxonomy = 'product_cat', $format = 'default')
    {
    }
    // Returns Product Tags or optionally other single level Term Taxonomies associated to a specific Product
    function woo_ce_get_product_assoc_tags($product_id = 0, $term_taxonomy = 'product_tag', $format = 'default')
    {
    }
    // Returns the Featured Image associated to a specific Product
    function woo_ce_get_product_assoc_featured_image($product_id = 0, $parent_id = 0, $image_format = 'full')
    {
    }
    // Returns the Product Galleries associated to a specific Product
    function woo_ce_get_product_assoc_product_gallery($product_id = 0, $image_format = 'full')
    {
    }
    // Returns the Product Type of a specific Product
    function woo_ce_get_product_assoc_type($product_id = 0)
    {
    }
    // Returns the Shipping Class of a specific Product
    function woo_ce_get_product_assoc_shipping_class($product_id = 0)
    {
    }
    // Returns the Grouped Products associated to a specific Grouped Product
    function woo_ce_get_product_assoc_grouped_products($product_id = 0)
    {
    }
    // Returns the Up-Sell associated to a specific Product
    function woo_ce_get_product_assoc_upsell_ids($product_id = 0)
    {
    }
    // Returns the Cross-Sell associated to a specific Product
    function woo_ce_get_product_assoc_crosssell_ids($product_id = 0)
    {
    }
    // Returns Product Attributes associated to a specific Product
    function woo_ce_get_product_assoc_attributes($product_id = 0, $args = array())
    {
    }
    // Returns the Variation quantities linked to Attributes of a given Variable Product
    function woo_ce_get_product_assoc_attribute_quantities($product_id = 0, $args = array())
    {
    }
    // Returns the Attribute Name when passed a Attribute Slug
    function woo_ce_get_product_attribute_name_by_slug($slug = '', $term_taxonomy = '')
    {
    }
    // Returns File Downloads associated to a specific Product
    function woo_ce_get_product_assoc_download_files($product_id = 0, $type = 'url')
    {
    }
    function woo_ce_get_product_assoc_order_ids($products = array())
    {
    }
    function woo_ce_format_product_visibility($product_id = 0, $visibility = '')
    {
    }
    function woo_ce_format_product_allow_backorders($allow_backorders = '')
    {
    }
    function woo_ce_format_product_download_type($download_type = '')
    {
    }
    function woo_ce_format_product_stock_status($stock_status = '', $stock = '')
    {
    }
    function woo_ce_format_product_tax_status($tax_status = \null)
    {
    }
    function woo_ce_format_product_tax_class($tax_class = '')
    {
    }
    function woo_ce_format_product_type($type_id = '')
    {
    }
    // Returns a list of WooCommerce Product Types to export process
    function woo_ce_get_product_types()
    {
    }
    function woo_ce_get_product_type_count($post_type = 'product', $args = array())
    {
    }
    // Returns a list of WooCommerce Product Attributes to export process
    function woo_ce_get_product_attributes($slice = '')
    {
    }
    function woo_ce_get_product_assoc_brands($product_id = 0, $parent_id = 0)
    {
    }
    function woo_ce_get_product_assoc_per_product_shipping_rules($product_id)
    {
    }
    function woo_ce_format_product_sale_price_dates($sale_date = '')
    {
    }
    function woo_ce_unique_product_gallery_fields($fields = array())
    {
    }
    function woo_ce_unique_product_gallery_columns($columns = array(), $fields = array())
    {
    }
    function woo_ce_category_scheduled_export_save($post_ID = 0)
    {
    }
    function woo_ce_category_dataset_args($args, $export_type = '')
    {
    }
    // Returns a list of Category export columns
    function woo_ce_get_category_fields($format = 'full', $post_ID = 0)
    {
    }
    // Check if we should override field labels from the Field Editor
    function woo_ce_override_category_field_labels($fields = array())
    {
    }
    // Returns the export column header label based on an export column slug
    function woo_ce_get_category_field($name = \null, $format = 'name')
    {
    }
    // Returns a list of WooCommerce Product Categories to export process
    function woo_ce_get_product_categories($args = array())
    {
    }
    function woo_ce_get_category_data($term_id = 0)
    {
    }
    function woo_ce_export_dataset_override_category($output = \null, $export_type = \null)
    {
    }
    function woo_ce_export_dataset_multisite_override_category($output = \null, $export_type = \null)
    {
    }
    function woo_ce_get_category_thumbnail_url($category_id = 0, $size = 'full')
    {
    }
    function woo_ce_get_category_thumbnail_path($category_id = 0, $thumbnail_size = 'full')
    {
    }
    function woo_ce_format_category_display_type($display_type = '')
    {
    }
    // Adds custom Customer columns to the Customer fields list
    function woo_ce_extend_customer_fields($fields = array())
    {
    }
    function woo_ce_review_scheduled_export_save($post_ID = 0)
    {
    }
    function woo_ce_review_dataset_args($args, $export_type = '')
    {
    }
    function woo_ce_cron_review_dataset_args($args, $export_type = '', $is_scheduled = 0)
    {
    }
    // Returns a list of Review export columns
    function woo_ce_get_review_fields($format = 'full', $post_ID = 0)
    {
    }
    // Check if we should override field labels from the Field Editor
    function woo_ce_override_review_field_labels($fields = array())
    {
    }
    // Returns the export column header label based on an export column slug
    function woo_ce_get_review_field($name = \null, $format = 'name')
    {
    }
    // Returns a list of WooCommerce Review IDs to export process
    function woo_ce_get_reviews($args = array())
    {
    }
    function woo_ce_get_review_data($review_id = 0, $args = array(), $fields = array())
    {
    }
    function woo_ce_export_dataset_override_review($output = \null, $export_type = \null)
    {
    }
    function woo_ce_export_dataset_multisite_override_review($output = \null, $export_type = \null)
    {
    }
    // Return whether the Ticket Post Type is in use
    function woo_ce_detect_tickets()
    {
    }
    // Returns a list of Ticket export columns
    function woo_ce_get_ticket_fields($format = 'full', $post_ID = 0)
    {
    }
    // Check if we should override field labels from the Field Editor
    function woo_ce_override_ticket_field_labels($fields = array())
    {
    }
    // Returns the export column header label based on an export column slug
    function woo_ce_get_ticket_field($name = \null, $format = 'name')
    {
    }
    // Returns a list of WooCommerce Ticket IDs to export process
    function woo_ce_get_tickets($args = array())
    {
    }
    function woo_ce_export_dataset_override_ticket($output = \null, $export_type = \null)
    {
    }
    function woo_ce_export_dataset_multisite_override_ticket($output = \null, $export_type = \null)
    {
    }
    function woo_ce_get_ticket_data($ticket_id = 0, $args = array(), $fields = array())
    {
    }
    function woo_ce_order_scheduled_export_save($post_ID = 0)
    {
    }
    function woo_ce_order_dataset_args($args, $export_type = '')
    {
    }
    function woo_ce_cron_order_dataset_args($args, $export_type = '', $is_scheduled = 0)
    {
    }
    // Returns a list of Order export columns
    function woo_ce_get_order_fields($format = 'full', $post_ID = 0)
    {
    }
    // Check if we should override field labels from the Field Editor
    function woo_ce_override_order_field_labels($fields = array())
    {
    }
    // Returns the export column header label based on an export column slug
    function woo_ce_get_order_field($name = \null, $format = 'name', $order_items = \false)
    {
    }
    // Returns an array of export column header labels based on an export column slug
    function woo_ce_get_order_field_array($export_fields = \null, $format = 'name')
    {
    }
    // Returns a list of Order IDs
    function woo_ce_get_orders($export_type = 'order', $args = array())
    {
    }
    function woo_ce_wp_query_order_where_override($where)
    {
    }
    // Returns WooCommerce Order data associated to a specific Order
    function woo_ce_get_order_wc_data($order_id = 0)
    {
    }
    function woo_ce_get_order_data($order_id = 0, $export_type = 'order', $args = array(), $fields = array())
    {
    }
    function woo_ce_export_dataset_override_order($output = \null, $export_type = \null)
    {
    }
    function woo_ce_export_dataset_multisite_override_order($output = \null, $export_type = \null)
    {
    }
    // Returns a list of WooCommerce Tax Rates based on existing Orders
    function woo_ce_get_order_tax_rates($order_id = 0)
    {
    }
    // Get the Order Item ID and tax rate ID of tax Order Items
    function woo_ce_get_order_assoc_tax_rates($order_id = 0)
    {
    }
    // Get the Tax Rate assigned to a given tax rate ID
    function woo_ce_get_order_tax_percentage($tax_rate_id = 0)
    {
    }
    // Return the total tax applied to a specific Tax Rate for a given Order
    function woo_ce_get_order_assoc_tax_rate_total($order_id = 0, $tax_rate = 0)
    {
    }
    // Get the Order Item ID of refunded Order Items
    function woo_ce_get_order_line_item_assoc_refunds($line_item_id = 0)
    {
    }
    // Return the PHP date format for the requested Order Date filter
    function woo_ce_get_order_date_filter($filter = '', $format = '', $date_format = 'd-m-Y')
    {
    }
    // Returns date of first Order received, any status
    function woo_ce_get_order_first_date($date_format = 'd/m/Y')
    {
    }
    // Returns a list of WooCommerce Order statuses
    function woo_ce_get_order_statuses()
    {
    }
    // Returns the Shipping Method ID associated to a specific Order
    function woo_ce_get_order_assoc_shipping_method_meta($order_id = 0, &$order = \null, $meta = 'method_id')
    {
    }
    // Returns Download keys associated to a specified Order
    function woo_ce_get_order_assoc_downloads($order_id = 0)
    {
    }
    // Returns Order Notes associated to a specific Order
    function woo_ce_get_order_assoc_notes($order_id = 0, $note_type = 'order_note')
    {
    }
    function woo_ce_get_order_assoc_refund_date($order_id = 0)
    {
    }
    // Returns the Coupon Code associated to a specific Order
    function woo_ce_get_order_assoc_coupon($order_id = 0, &$order = \null)
    {
    }
    // Returns a list of Order ID's where a Coupon is associated
    function woo_ce_get_orders_by_coupon($post_name = '')
    {
    }
    function woo_ce_max_order_items($orders = array())
    {
    }
    // Returns a list of Order Item ID's with the order_item_type of 'line item' for a specified Order
    function woo_ce_get_order_item_ids($order_id = 0)
    {
    }
    // Returns a list of Order Items for a specified Order
    function woo_ce_get_order_items($order_id = 0, $order_items_types = array())
    {
    }
    // Returns refund data as a order line item
    function woo_ce_get_refund_order_item_data($order_items, $order_id)
    {
    }
    function woo_ce_get_refund_order_data($order_items, $order)
    {
    }
    // Returns a list of WooCommerce Order Item Types
    function woo_ce_get_order_items_types()
    {
    }
    // Return the Order Status for a specified Order
    function woo_ce_get_order_status($order_id = 0)
    {
    }
    function woo_ce_get_order_payment_gateways()
    {
    }
    function woo_ce_format_order_payment_gateway($payment_id = '')
    {
    }
    function woo_ce_get_order_payment_gateway_usage($payment_id = '')
    {
    }
    function woo_ce_get_order_shipping_methods()
    {
    }
    function woo_ce_format_order_shipping_method($shipping_id = '')
    {
    }
    function woo_ce_format_order_item_type($line_type = '')
    {
    }
    function woo_ce_format_order_item_tax_class($tax_class = '')
    {
    }
    function woo_ce_format_order_status($status_id = '')
    {
    }
    /**
     * Helper function to get meta for an Order.
     *
     * @param \WC_Order $order the order object
     * @param string $meta_key the meta key
     * @param bool $single whether to get the meta as a single item. Defaults to `true`
     * @param string $context if 'view' then the value will be filtered
     * @return mixed the order property
     */
    function woo_ce_get_order_meta($order, $meta_key = '', $single = \true, $context = 'edit')
    {
    }
    // Adds custom Coupon columns to the Coupon fields list
    function woo_ce_extend_coupon_fields($fields = array())
    {
    }
    function woo_ce_extend_coupon_item($coupon, $coupon_id = 0)
    {
    }
    // Only load these resources if we are running an export, can be limited to a single export type
    function woo_ce_load_export_types($export_type = \false)
    {
    }
    function woo_ce_export_init()
    {
    }
    // Displays a HTML notice when a WordPress or Store Exporter error is encountered
    function woo_ce_admin_fail_notices()
    {
    }
    // Saves the state of Export fields for next export
    function woo_ce_save_fields($export_type = '', $fields = array(), $sorting = array())
    {
    }
    // Returns number of an Export type prior to export, used on Store Exporter screen
    function woo_ce_get_export_type_count($export_type = '', $args = array())
    {
    }
    // In-line display of export file and export details when viewed via WordPress Media screen
    function woo_ce_read_export_file($post = \false)
    {
    }
    // Returns a list of archived exports
    function woo_ce_get_archive_files()
    {
    }
    function woo_ce_nuke_archive_files()
    {
    }
    // Reset WP-CRON
    function woo_ce_nuke_cron()
    {
    }
    // Delete all Scheduled Exports
    function woo_ce_nuke_scheduled_exports()
    {
    }
    // Delete all WordPress Options generated by Store Exporter
    function woo_ce_nuke_options()
    {
    }
    // Reset all dismissed notices within Store Exporter
    function woo_ce_nuke_dismissed_notices()
    {
    }
    // Returns a list of Attachments which are exposed to the public
    function woo_ce_get_unprotected_archives($postarr = array())
    {
    }
    function woo_ce_update_archives_privacy()
    {
    }
    // Returns an archived export with additional details
    function woo_ce_get_archive_file($file = '')
    {
    }
    // HTML template for displaying the current export type filter on the Archives screen
    function woo_ce_archives_quicklink_current($current = '')
    {
    }
    // HTML template for displaying the number of each export type filter on the Archives screen
    function woo_ce_archives_quicklink_count($type = '')
    {
    }
    function woo_ce_export_fields_summary_text($type = '')
    {
    }
    function woo_ce_raise_export_memory_limit()
    {
    }
    // Export process for CSV file
    function woo_ce_export_dataset($export_type = \null, &$output = \null)
    {
    }
    function woo_ce_fatal_error()
    {
    }
    // List of Export types used on Store Exporter screen
    function woo_ce_get_export_types($plural = \true, $default = \false)
    {
    }
    // Returns label of Export type slug used on Store Exporter screen
    function woo_ce_export_type_label($export_type = '', $echo = \false, $plural = \true)
    {
    }
    function woo_ce_get_export_type_label($export_type = '', $plural = \true)
    {
    }
    function woo_ce_generate_file_headers($post_mime_type = 'text/csv')
    {
    }
    // Function to generate filename of export file based on the Export type
    function woo_ce_generate_filename($export_type = '', $override = '')
    {
    }
    // Returns the Post object of the export file saved as an attachment to the WordPress Media library
    function woo_ce_save_file_attachment($filename = '', $post_mime_type = 'text/csv')
    {
    }
    // Updates the GUID of the export file attachment to match the correct file URL
    function woo_ce_save_file_guid($post_ID, $export_type, $upload_url = '')
    {
    }
    // Save critical export details against the archived export
    function woo_ce_save_file_details($post_ID)
    {
    }
    // Update detail of existing archived export
    function woo_ce_update_file_detail($post_ID, $detail, $value)
    {
    }
    // Returns a list of allowed Export type statuses, can be overridden on a per-Export type basis
    function woo_ce_post_statuses($extra_status = array(), $override = \false)
    {
    }
    function woo_ce_get_export_formats()
    {
    }
    function woo_ce_get_export_format_label($export_format = '')
    {
    }
    function woo_ce_get_mime_types()
    {
    }
    function woo_ce_get_mime_type_extension($mime_type, $search_by = 'extension')
    {
    }
    function woo_ce_add_missing_mime_type($mime_types = array())
    {
    }
    function woo_ce_sort_fields($key)
    {
    }
    function woo_ce_register_scheduled_export_cpt()
    {
    }
    function woo_ce_get_scheduled_exports($args = array())
    {
    }
    function woo_ce_get_next_scheduled_export($scheduled_export = 0, $format = 'human')
    {
    }
    function woo_ce_add_recent_scheduled_export($scheduled_export = 0, $gui = '', $post_ID = 0, $error = '')
    {
    }
    // Convert the legacy scheduled export WordPress Options to CPT
    function woo_ce_legacy_scheduled_export()
    {
    }
    function woo_ce_register_export_template_cpt()
    {
    }
    // Add Store Export to filter types on the WordPress Media screen
    function woo_ce_add_post_mime_type($post_mime_types = array())
    {
    }
    function woo_ce_current_memory_usage()
    {
    }
    function woo_ce_get_start_of_week_day()
    {
    }
    // Provided by Pippin Williamson, mentioned on WP Beginner (http://www.wpbeginner.com/wp-tutorials/how-to-display-a-users-ip-address-in-wordpress/)
    function woo_ce_get_visitor_ip_address()
    {
    }
    function woo_ce_get_line_ending()
    {
    }
    // A list of allowed Image Embed fields
    function woo_ce_get_image_embed_allowed_fields()
    {
    }
    function woo_ce_wpml_get_language_name($language_code = '')
    {
    }
    // Return whether WPML exists
    function woo_ce_detect_wpml()
    {
    }
    // List of WordPress Plugins that Store Exporter integrates with
    function woo_ce_modules_list($module_status = \false)
    {
    }
    // Returns whether a supported export Plugin is activated
    function woo_ce_detect_export_plugin($plugin_name = '')
    {
    }
    function woo_ce_refresh_active_export_plugins()
    {
    }
    // Return a list of Export Template ID's
    function woo_ce_get_export_templates($args = array())
    {
    }
    function woo_ce_error_log($message = '', $level = \false)
    {
    }
    function woo_ce_error_get_last_message()
    {
    }
    function woo_ce_is_scheduled_export($post_ID = \false)
    {
    }
    function woo_ce_is_export_template($post_ID = \false)
    {
    }
    function woo_ce_get_option($option = \null, $default = \false, $allow_empty = \false)
    {
    }
    function woo_ce_update_option($option = \null, $value = \null)
    {
    }
    function woo_ce_multi_level_sorting($output, $export)
    {
    }
    // Display admin notice on screen load
    function woo_cd_admin_notice($message = '', $priority = 'updated', $screen = '')
    {
    }
    // HTML template for admin notice
    function woo_cd_admin_notice_html($message = '', $priority = 'updated', $screen = '', $id = '')
    {
    }
    // Grabs the WordPress transient that holds the admin notice and prints it
    function woo_cd_admin_notice_print()
    {
    }
    // HTML template header on Store Exporter screen
    function woo_cd_template_header($title = '', $icon = 'woocommerce')
    {
    }
    // HTML template footer on Store Exporter screen
    function woo_cd_template_footer()
    {
    }
    function woo_cd_template_header_title()
    {
    }
    function woo_ce_quick_export_in_process()
    {
    }
    function woo_ce_ajax_load_export_template()
    {
    }
    function woo_ce_ajax_override_scheduled_export()
    {
    }
    // Add Export, Docs and Support links to the Plugins screen
    function woo_cd_add_settings_link($links, $file)
    {
    }
    function woo_ce_admin_custom_fields_save()
    {
    }
    function woo_ce_admin_order_column_headers($columns)
    {
    }
    function woo_ce_admin_order_column_content($column)
    {
    }
    // Display bulk export actions on the Products and Orders screen
    function woo_ce_admin_export_bulk_actions()
    {
    }
    // Process the bulk export actions on the Orders and Products screen
    function woo_ce_admin_export_process_bulk_action()
    {
    }
    // Add Download as... buttons to Actions column on Orders screen
    function woo_ce_admin_order_actions($actions = array(), $order = \false)
    {
    }
    // Generate exports for Download as... button clicks
    function woo_ce_ajax_export_order()
    {
    }
    function woo_ce_admin_order_single_export_csv($order = \false)
    {
    }
    function woo_ce_admin_order_single_export_tsv($order = \false)
    {
    }
    function woo_ce_admin_order_single_export_xls($order = \false)
    {
    }
    function woo_ce_admin_order_single_export_xlsx($order = \false)
    {
    }
    function woo_ce_admin_order_single_export_xml($order = \false)
    {
    }
    function woo_ce_admin_order_single_export_unflag($order = \false)
    {
    }
    function woo_ce_admin_order_single_actions($actions)
    {
    }
    // Add Store Export page to WooCommerce screen IDs
    function woo_ce_wc_screen_ids($screen_ids = array())
    {
    }
    // Add Store Export to WordPress Administration menu
    function woo_ce_admin_menu()
    {
    }
    function woo_ce_admin_enqueue_scripts($hook = '')
    {
    }
    // Load CSS and jQuery scripts for Store Exporter Deluxe screen
    function woo_ce_enqueue_scripts()
    {
    }
    function woo_ce_admin_export_bar_menu($admin_bar)
    {
    }
    function woo_ce_admin_current_screen()
    {
    }
    function woo_ce_extend_woo_st_product_data_actions($post_id, $meta_key = '')
    {
    }
    function woo_ce_extend_woo_st_category_data_actions($term_id, $meta_key = '')
    {
    }
    function woo_ce_extend_woo_st_tag_data_actions($term_id, $meta_key = '')
    {
    }
    function woo_ce_extend_woo_st_brand_data_actions($term_id, $meta_key = '')
    {
    }
    function woo_ce_extend_woo_st_order_data_actions($post_id, $meta_key = '')
    {
    }
    function woo_ce_extend_woo_st_order_item_data_actions($post_id, $meta_key = '')
    {
    }
    function woo_ce_extend_woo_st_coupon_data_actions($post_id, $meta_key = '')
    {
    }
    function woo_ce_extend_woo_st_user_data_actions($user_id, $meta_key = '')
    {
    }
    function woo_ce_extend_woocommerce_system_status_report()
    {
    }
    // Pre-WooCommerce 2.5 compatibility
    function woo_ce_wc_help_tip($tip, $allow_html = \false)
    {
    }
    function woo_ce_admin_plugin_row()
    {
    }
    function woo_ce_admin_override_scheduled_export_notice()
    {
    }
    // HTML active class for the currently selected tab on the Store Exporter screen
    function woo_cd_admin_active_tab($tab_name = \null, $tab = \null)
    {
    }
    // HTML template for each tab on the Store Exporter screen
    function woo_cd_tab_template($tab = '')
    {
    }
    function woo_ce_export_export_types()
    {
    }
    function woo_ce_export_export_options()
    {
    }
    // This function is run on all screens where the DatePicker object within Store Exporter Deluxe is used
    function woo_ce_admin_footer_javascript()
    {
    }
    // This function only runs on the Quick Export screen
    function woo_ce_admin_export_footer_javascript()
    {
    }
    // Display the memory usage in the screen footer
    function woo_ce_admin_footer_text($footer_text = '')
    {
    }
    function woo_ce_modules_status_class($status = 'inactive')
    {
    }
    function woo_ce_modules_status_label($status = 'inactive')
    {
    }
    function woo_ce_is_network_admin()
    {
    }
    function woo_ce_admin_dashboard_setup()
    {
    }
    // Order items formatting: Individual
    function woo_ce_order_items_individual($order, $order_item)
    {
    }
    // Order items formatting: Unique
    function woo_ce_extend_order_items_unique($order, $i = 0, $order_item = array())
    {
    }
    function woo_ce_extend_order_items_unique_fields_exclusion($excluded_fields = array(), $fields = '')
    {
    }
    // This prepares the Order columns for the 'unique' Order Item formatting selection
    function woo_ce_unique_order_item_fields_on($fields = array(), $i = 0)
    {
    }
    function woo_ce_extend_order_items_unique_columns($fields = array(), $i = 0, $original_columns = array())
    {
    }
    function woo_ce_commission_scheduled_export_save($post_ID = 0)
    {
    }
    // Returns date of first Commission received, any status
    function woo_ce_get_commission_first_date($date_format = 'd/m/Y')
    {
    }
    // HTML template for displaying the number of each export type filter on the Archives screen
    function woo_ce_commissions_stock_status_count($type = '')
    {
    }
    function woo_ce_commission_dataset_args($args, $export_type = '')
    {
    }
    function woo_ce_cron_commission_dataset_args($args, $export_type = '', $is_scheduled = 0)
    {
    }
    function woo_ce_get_commission_fields($format = 'full', $post_ID = 0)
    {
    }
    // Check if we should override field labels from the Field Editor
    function woo_ce_override_commission_field_labels($fields = array())
    {
    }
    // Returns the export column header label based on an export column slug
    function woo_ce_get_commission_field($name = \null, $format = 'name')
    {
    }
    // Returns a list of Commission Post IDs
    function woo_ce_get_commissions($args = array())
    {
    }
    function woo_ce_export_dataset_override_commission($output = \null, $export_type = \null)
    {
    }
    function woo_ce_export_dataset_multisite_override_commission($output = \null, $export_type = \null)
    {
    }
    function woo_ce_get_commission_data($commission_id = 0, $args = array())
    {
    }
    function woo_ce_extend_commission_fields($fields = array())
    {
    }
    function woo_ce_format_commission_paid_status($paid_status = '')
    {
    }
    function woo_ce_user_scheduled_export_save($post_ID = 0)
    {
    }
    function woo_ce_user_dataset_args($args, $export_type = '')
    {
    }
    function woo_ce_cron_user_dataset_args($args, $export_type = '', $is_scheduled = 0)
    {
    }
    // Returns a list of User export columns
    function woo_ce_get_user_fields($format = 'full', $post_ID = 0)
    {
    }
    // Check if we should override field labels from the Field Editor
    function woo_ce_override_user_field_labels($fields = array())
    {
    }
    // Returns the export column header label based on an export column slug
    function woo_ce_get_user_field($name = \null, $format = 'name')
    {
    }
    // Returns a list of User IDs
    function woo_ce_get_users($export_args = array())
    {
    }
    function woo_ce_get_user_data($user_id = 0, $args = array())
    {
    }
    function woo_ce_export_dataset_override_user($output = \null, $export_type = \null)
    {
    }
    function woo_ce_export_dataset_multisite_override_user($output = \null, $export_type = \null)
    {
    }
    // Returns a list of WordPress User Roles
    function woo_ce_get_user_roles()
    {
    }
    // Returns the Username of a User
    function woo_ce_get_username($user_id = 0)
    {
    }
    // Returns the User Role of a User
    function woo_ce_get_user_role($user_id = 0)
    {
    }
    function woo_ce_format_user_role_label($user_role = '')
    {
    }
    // Returns date of first User registered, any status
    function woo_ce_get_user_first_date($date_format = 'd/m/Y')
    {
    }
    /* Start of: WordPress Administration */
    // HTML template for Filter Categories by Language widget on Store Exporter screen
    function woo_ce_categories_filter_by_language()
    {
    }
    function woo_ce_extend_cron_category_dataset_args($args, $export_type = '', $is_scheduled = 0)
    {
    }
    // Adds custom Category columns to the Category fields list
    function woo_ce_extend_category_fields($fields = array())
    {
    }
    // Turns out we didn't need this after all...
    function woo_ce_extend_get_product_categories_args($args)
    {
    }
    // add_filter( 'woo_ce_get_product_categories_args', 'woo_ce_extend_get_product_categories_args' );
    function woo_ce_extend_category_item($category)
    {
    }
    // Adds custom Ticket columns to the Ticket fields list
    function woo_ce_extend_ticket_fields($fields = array())
    {
    }
    function woo_ce_extend_ticket_item($ticket)
    {
    }
    function woo_ce_extend_ticket_post_type($post_type = '')
    {
    }
    /* Start of: WordPress Administration */
    // Quick Export
    // Scheduled Exports
    function woo_ce_products_filter_post_stati($product_stati = '')
    {
    }
    function woo_ce_products_custom_fields_tab_manager()
    {
    }
    function woo_ce_products_custom_fields_wootabs()
    {
    }
    // Product Add-ons - http://www.woothemes.com/
    function woo_ce_products_custom_fields_product_addons()
    {
    }
    function woo_ce_extend_product_fields($fields = array())
    {
    }
    function woo_ce_extend_product_item($product, $product_id, $_product = \false)
    {
    }
    // WooCommerce All Discounts Lite - https://wordpress.org/plugins/woo-advanced-discounts/
    function woo_ce_format_qbp_discount_type($discount_type = '')
    {
    }
    // WP-Lister Pro for Amazon - https://www.wplab.com/plugins/wp-lister-for-amazon/
    function woo_ce_format_wpla_id_type($id_type = '')
    {
    }
    // WP-Lister Pro for Amazon - https://www.wplab.com/plugins/wp-lister-for-amazon/
    function woo_ce_format_wpla_condition_type($condition_type = '')
    {
    }
    // WooCommerce Pre-Orders - http://www.woothemes.com/products/woocommerce-pre-orders/
    function woo_ce_format_pre_orders_charge($charge = '')
    {
    }
    // WooCommerce Measurement Price Calculator - http://www.woocommerce.com/products/measurement-price-calculator/
    function woo_ce_format_measurement_type_label($measurement_type = '')
    {
    }
    // WooCommerce Measurement Price Calculator - http://www.woocommerce.com/products/measurement-price-calculator/
    function woo_ce_format_measurement_input_type($input_type = '')
    {
    }
    function woo_ce_extend_product_dataset_args($args, $export_type = '')
    {
    }
    function woo_ce_extend_get_products_args($args)
    {
    }
    function woo_ce_extend_cron_product_dataset_args($args, $export_type = '', $is_scheduled = 0)
    {
    }
    // Return a list of custom Term Taxonomies linked to Products
    function woo_ce_get_product_custom_term_taxonomies()
    {
    }
    // Returns list of Product Add-on columns
    function woo_ce_get_product_addons()
    {
    }
    // WooCommerce Tab Manager - https://woocommerce.com/products/woocommerce-tab-manager/
    function woo_ce_get_product_tabs()
    {
    }
    // WooCommerce Custom Fields - http://www.rightpress.net/woocommerce-custom-fields
    function woo_ce_get_wccf_product_properties()
    {
    }
    // WC Fields Factory - https://wordpress.org/plugins/wc-fields-factory/
    function woo_ce_get_wcff_admin_fields()
    {
    }
    // WC Fields Factory - https://wordpress.org/plugins/wc-fields-factory/
    function woo_ce_get_wcff_product_fields()
    {
    }
    function woo_ce_format_gpf_availability($availability = \null)
    {
    }
    function woo_ce_format_gpf_condition($condition)
    {
    }
    // Advanced Custom Fields - http://www.advancedcustomfields.com
    function woo_ce_get_acf_product_fields()
    {
    }
    // WooCommerce Wholesale Prices - https://wordpress.org/plugins/woocommerce-wholesale-prices/
    function woo_ce_get_wholesale_prices_roles()
    {
    }
    // FooEvents for WooCommerce - https://www.fooevents.com/
    function woo_ce_format_events_is_event($is_event = '')
    {
    }
    /* Start of: WordPress Administration */
    function woo_ce_extend_subscription_dataset_args($args, $export_type = '')
    {
    }
    // Adds custom Subscription columns to the Subscription fields list
    function woo_ce_extend_subscription_fields($fields = array())
    {
    }
    // Populate Subscription details for export of 3rd party Plugins
    function woo_ce_subscription_extend($subscription, $subscription_id)
    {
    }
    // Order items formatting: Unique
    function woo_ce_unique_order_item_fields($fields = array(), $args = array())
    {
    }
    function woo_ce_unique_order_items_embed_allowed_fields($fields = array(), $args = array())
    {
    }
    function woo_ce_unique_order_item_columns($columns = array(), $fields = array(), $args = array())
    {
    }
    /**
     * @ignore
     */
    \define('PHPEXCEL_ROOT', \dirname(__FILE__) . '/../');
    /**
     *  PHPExcel
     *
     *  Copyright (c) 2006 - 2014 PHPExcel
     *
     *  This library is free software; you can redistribute it and/or
     *  modify it under the terms of the GNU Lesser General Public
     *  License as published by the Free Software Foundation; either
     *  version 2.1 of the License, or (at your option) any later version.
     *
     *  This library is distributed in the hope that it will be useful,
     *  but WITHOUT ANY WARRANTY; without even the implied warranty of
     *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     *  Lesser General Public License for more details.
     *
     *  You should have received a copy of the GNU Lesser General Public
     *  License along with this library; if not, write to the Free Software
     *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     *  @category    PHPExcel
     *  @package     PHPExcel_Writer_PDF
     *  @copyright   Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     *  @license     http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt    LGPL
     *  @version     1.8.0, 2014-03-02
     */
    /**  Require mPDF library */
    $pdfRendererClassFile = \PHPExcel_Settings::getPdfRendererPath() . '/mpdf.php';
    /**
     *  PHPExcel
     *
     *  Copyright (c) 2006 - 2014 PHPExcel
     *
     *  This library is free software; you can redistribute it and/or
     *  modify it under the terms of the GNU Lesser General Public
     *  License as published by the Free Software Foundation; either
     *  version 2.1 of the License, or (at your option) any later version.
     *
     *  This library is distributed in the hope that it will be useful,
     *  but WITHOUT ANY WARRANTY; without even the implied warranty of
     *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     *  Lesser General Public License for more details.
     *
     *  You should have received a copy of the GNU Lesser General Public
     *  License along with this library; if not, write to the Free Software
     *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     *  @category    PHPExcel
     *  @package     PHPExcel_Writer_PDF
     *  @copyright   Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     *  @license     http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt    LGPL
     *  @version     1.8.0, 2014-03-02
     */
    /**  Require DomPDF library */
    $pdfRendererClassFile = \PHPExcel_Settings::getPdfRendererPath() . '/dompdf_config.inc.php';
    /**
     *  PHPExcel
     *
     *  Copyright (c) 2006 - 2014 PHPExcel
     *
     *  This library is free software; you can redistribute it and/or
     *  modify it under the terms of the GNU Lesser General Public
     *  License as published by the Free Software Foundation; either
     *  version 2.1 of the License, or (at your option) any later version.
     *
     *  This library is distributed in the hope that it will be useful,
     *  but WITHOUT ANY WARRANTY; without even the implied warranty of
     *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     *  Lesser General Public License for more details.
     *
     *  You should have received a copy of the GNU Lesser General Public
     *  License along with this library; if not, write to the Free Software
     *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
     *
     *  @category    PHPExcel
     *  @package     PHPExcel_Writer_PDF
     *  @copyright   Copyright (c) 2006 - 2014 PHPExcel (http://www.codeplex.com/PHPExcel)
     *  @license     http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt    LGPL
     *  @version     1.8.0, 2014-03-02
     */
    /**  Require tcPDF library */
    $pdfRendererClassFile = \PHPExcel_Settings::getPdfRendererPath() . '/tcpdf.php';
    /** FINANCIAL_MAX_ITERATIONS */
    \define('FINANCIAL_MAX_ITERATIONS', 128);
    /** FINANCIAL_PRECISION */
    \define('FINANCIAL_PRECISION', 1.0E-8);
    /** LOG_GAMMA_X_MAX_VALUE */
    \define('LOG_GAMMA_X_MAX_VALUE', 2.55E+305);
    /** XMININ */
    \define('XMININ', 2.23E-308);
    /** EPS */
    \define('EPS', 2.22E-16);
    /** SQRT2PI */
    \define('SQRT2PI', 2.5066282746310007);
    /** MAX_VALUE */
    \define('MAX_VALUE', 1.2E+308);
    /** 2 / PI */
    \define('M_2DIVPI', 0.6366197723675814);
    /** MAX_ITERATIONS */
    \define('MAX_ITERATIONS', 256);
    /** PRECISION */
    \define('PRECISION', 8.88E-16);
    function mb_str_replace($search, $replace, $subject)
    {
    }
    /** EULER */
    \define('EULER', 2.718281828459045);
    \define('DEBUGMODE_ENABLED', \false);
    \define('PCLZIP_TEMPORARY_DIR', \PHPExcel_Shared_File::sys_get_temp_dir());
    /**
     *	@package JAMA
     *
     *	Pythagorean Theorem:
     *
     *	a = 3
     *	b = 4
     *	r = sqrt(square(a) + square(b))
     *	r = 5
     *
     *	r = sqrt(a^2 + b^2) without under/overflow.
     */
    function hypo($a, $b)
    {
    }
    /**
     *	@package JAMA
     *
     *	Error handling
     *	@author Michael Bommarito
     *	@version 01292005
     */
    //Language constant
    \define('JAMALANG', 'EN');
    /*
    I've used Babelfish and a little poor knowledge of Romance/Germanic languages for the translations here.
    Feel free to correct anything that looks amiss to you.
    */
    \define('PolymorphicArgumentException', -1);
    \define('ArgumentTypeException', -2);
    \define('ArgumentBoundsException', -3);
    \define('MatrixDimensionException', -4);
    \define('PrecisionLossException', -5);
    \define('MatrixSPDException', -6);
    \define('MatrixSingularException', -7);
    \define('MatrixRankException', -8);
    \define('ArrayLengthException', -9);
    \define('RowLengthException', -10);
    /**
     *	Custom error handler
     *	@param int $num Error number
     */
    function JAMAError($errorNumber = \null)
    {
    }
    /* vim: set expandtab tabstop=4 shiftwidth=4: */
    // +----------------------------------------------------------------------+
    // | PHP Version 4                                                        |
    // +----------------------------------------------------------------------+
    // | Copyright (c) 1997-2002 The PHP Group                                |
    // +----------------------------------------------------------------------+
    // | This source file is subject to version 2.02 of the PHP license,      |
    // | that is bundled with this package in the file LICENSE, and is        |
    // | available at through the world-wide-web at                           |
    // | http://www.php.net/license/2_02.txt.                                 |
    // | If you did not receive a copy of the PHP license and are unable to   |
    // | obtain it through the world-wide-web, please send a note to          |
    // | license@php.net so we can mail you a copy immediately.               |
    // +----------------------------------------------------------------------+
    // | Author: Xavier Noguer <xnoguer@php.net>                              |
    // | Based on OLE::Storage_Lite by Kawai, Takanori                        |
    // +----------------------------------------------------------------------+
    //
    // $Id: OLE.php,v 1.13 2007/03/07 14:38:25 schmidt Exp $
    /**
    * Array for storing OLE instances that are accessed from
    * OLE_ChainedBlockStream::stream_open().
    * @var  array
    */
    $_OLE_INSTANCES = array();
    \define('PCLZIP_READ_BLOCK_SIZE', 2048);
    \define('PCLZIP_SEPARATOR', ',');
    \define('PCLZIP_ERROR_EXTERNAL', 0);
    \define('PCLZIP_TEMPORARY_FILE_RATIO', 0.47);
    // ----- Error codes
    //   -1 : Unable to open file in binary write mode
    //   -2 : Unable to open file in binary read mode
    //   -3 : Invalid parameters
    //   -4 : File does not exist
    //   -5 : Filename is too long (max. 255)
    //   -6 : Not a valid zip file
    //   -7 : Invalid extracted file size
    //   -8 : Unable to create directory
    //   -9 : Invalid archive extension
    //  -10 : Invalid archive format
    //  -11 : Unable to delete file (unlink)
    //  -12 : Unable to rename file (rename)
    //  -13 : Invalid header checksum
    //  -14 : Invalid archive size
    \define('PCLZIP_ERR_USER_ABORTED', 2);
    \define('PCLZIP_ERR_NO_ERROR', 0);
    \define('PCLZIP_ERR_WRITE_OPEN_FAIL', -1);
    \define('PCLZIP_ERR_READ_OPEN_FAIL', -2);
    \define('PCLZIP_ERR_INVALID_PARAMETER', -3);
    \define('PCLZIP_ERR_MISSING_FILE', -4);
    \define('PCLZIP_ERR_FILENAME_TOO_LONG', -5);
    \define('PCLZIP_ERR_INVALID_ZIP', -6);
    \define('PCLZIP_ERR_BAD_EXTRACTED_FILE', -7);
    \define('PCLZIP_ERR_DIR_CREATE_FAIL', -8);
    \define('PCLZIP_ERR_BAD_EXTENSION', -9);
    \define('PCLZIP_ERR_BAD_FORMAT', -10);
    \define('PCLZIP_ERR_DELETE_FILE_FAIL', -11);
    \define('PCLZIP_ERR_RENAME_FILE_FAIL', -12);
    \define('PCLZIP_ERR_BAD_CHECKSUM', -13);
    \define('PCLZIP_ERR_INVALID_ARCHIVE_ZIP', -14);
    \define('PCLZIP_ERR_MISSING_OPTION_VALUE', -15);
    \define('PCLZIP_ERR_INVALID_OPTION_VALUE', -16);
    \define('PCLZIP_ERR_ALREADY_A_DIRECTORY', -17);
    \define('PCLZIP_ERR_UNSUPPORTED_COMPRESSION', -18);
    \define('PCLZIP_ERR_UNSUPPORTED_ENCRYPTION', -19);
    \define('PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE', -20);
    \define('PCLZIP_ERR_DIRECTORY_RESTRICTION', -21);
    // ----- Options values
    \define('PCLZIP_OPT_PATH', 77001);
    \define('PCLZIP_OPT_ADD_PATH', 77002);
    \define('PCLZIP_OPT_REMOVE_PATH', 77003);
    \define('PCLZIP_OPT_REMOVE_ALL_PATH', 77004);
    \define('PCLZIP_OPT_SET_CHMOD', 77005);
    \define('PCLZIP_OPT_EXTRACT_AS_STRING', 77006);
    \define('PCLZIP_OPT_NO_COMPRESSION', 77007);
    \define('PCLZIP_OPT_BY_NAME', 77008);
    \define('PCLZIP_OPT_BY_INDEX', 77009);
    \define('PCLZIP_OPT_BY_EREG', 77010);
    \define('PCLZIP_OPT_BY_PREG', 77011);
    \define('PCLZIP_OPT_COMMENT', 77012);
    \define('PCLZIP_OPT_ADD_COMMENT', 77013);
    \define('PCLZIP_OPT_PREPEND_COMMENT', 77014);
    \define('PCLZIP_OPT_EXTRACT_IN_OUTPUT', 77015);
    \define('PCLZIP_OPT_REPLACE_NEWER', 77016);
    \define('PCLZIP_OPT_STOP_ON_ERROR', 77017);
    // Having big trouble with crypt. Need to multiply 2 long int
    // which is not correctly supported by PHP ...
    //define( 'PCLZIP_OPT_CRYPT', 77018 );
    \define('PCLZIP_OPT_EXTRACT_DIR_RESTRICTION', 77019);
    \define('PCLZIP_OPT_TEMP_FILE_THRESHOLD', 77020);
    \define('PCLZIP_OPT_ADD_TEMP_FILE_THRESHOLD', 77020);
    // alias
    \define('PCLZIP_OPT_TEMP_FILE_ON', 77021);
    \define('PCLZIP_OPT_ADD_TEMP_FILE_ON', 77021);
    // alias
    \define('PCLZIP_OPT_TEMP_FILE_OFF', 77022);
    \define('PCLZIP_OPT_ADD_TEMP_FILE_OFF', 77022);
    // alias
    // ----- File description attributes
    \define('PCLZIP_ATT_FILE_NAME', 79001);
    \define('PCLZIP_ATT_FILE_NEW_SHORT_NAME', 79002);
    \define('PCLZIP_ATT_FILE_NEW_FULL_NAME', 79003);
    \define('PCLZIP_ATT_FILE_MTIME', 79004);
    \define('PCLZIP_ATT_FILE_CONTENT', 79005);
    \define('PCLZIP_ATT_FILE_COMMENT', 79006);
    // ----- Call backs values
    \define('PCLZIP_CB_PRE_EXTRACT', 78001);
    \define('PCLZIP_CB_POST_EXTRACT', 78002);
    \define('PCLZIP_CB_PRE_ADD', 78003);
    \define('PCLZIP_CB_POST_ADD', 78004);
    // End of class
    // --------------------------------------------------------------------------------
    // --------------------------------------------------------------------------------
    // Function : PclZipUtilPathReduction()
    // Description :
    // Parameters :
    // Return Values :
    // --------------------------------------------------------------------------------
    function PclZipUtilPathReduction($p_dir)
    {
    }
    // --------------------------------------------------------------------------------
    // --------------------------------------------------------------------------------
    // Function : PclZipUtilPathInclusion()
    // Description :
    //   This function indicates if the path $p_path is under the $p_dir tree. Or,
    //   said in an other way, if the file or sub-dir $p_path is inside the dir
    //   $p_dir.
    //   The function indicates also if the path is exactly the same as the dir.
    //   This function supports path with duplicated '/' like '//', but does not
    //   support '.' or '..' statements.
    // Parameters :
    // Return Values :
    //   0 if $p_path is not inside directory $p_dir
    //   1 if $p_path is inside directory $p_dir
    //   2 if $p_path is exactly the same as $p_dir
    // --------------------------------------------------------------------------------
    function PclZipUtilPathInclusion($p_dir, $p_path)
    {
    }
    // --------------------------------------------------------------------------------
    // --------------------------------------------------------------------------------
    // Function : PclZipUtilCopyBlock()
    // Description :
    // Parameters :
    //   $p_mode : read/write compression mode
    //             0 : src & dest normal
    //             1 : src gzip, dest normal
    //             2 : src normal, dest gzip
    //             3 : src & dest gzip
    // Return Values :
    // --------------------------------------------------------------------------------
    function PclZipUtilCopyBlock($p_src, $p_dest, $p_size, $p_mode = 0)
    {
    }
    // --------------------------------------------------------------------------------
    // --------------------------------------------------------------------------------
    // Function : PclZipUtilRename()
    // Description :
    //   This function tries to do a simple rename() function. If it fails, it
    //   tries to copy the $p_src file in a new $p_dest file and then unlink the
    //   first one.
    // Parameters :
    //   $p_src : Old filename
    //   $p_dest : New filename
    // Return Values :
    //   1 on success, 0 on failure.
    // --------------------------------------------------------------------------------
    function PclZipUtilRename($p_src, $p_dest)
    {
    }
    // --------------------------------------------------------------------------------
    // --------------------------------------------------------------------------------
    // Function : PclZipUtilOptionText()
    // Description :
    //   Translate option value in text. Mainly for debug purpose.
    // Parameters :
    //   $p_option : the option value.
    // Return Values :
    //   The option text value.
    // --------------------------------------------------------------------------------
    function PclZipUtilOptionText($p_option)
    {
    }
    // --------------------------------------------------------------------------------
    // --------------------------------------------------------------------------------
    // Function : PclZipUtilTranslateWinPath()
    // Description :
    //   Translate windows path by replacing '\' by '/' and optionally removing
    //   drive letter.
    // Parameters :
    //   $p_path : path to translate.
    //   $p_remove_disk_letter : true | false
    // Return Values :
    //   The path translated.
    // --------------------------------------------------------------------------------
    function PclZipUtilTranslateWinPath($p_path, $p_remove_disk_letter = \true)
    {
    }
    function woo_get_action($prefer_get = \false)
    {
    }
    function woo_is_wpsc_activated()
    {
    }
    function woo_is_woo_activated()
    {
    }
    function woo_is_jigo_activated()
    {
    }
    function woo_is_exchange_activated()
    {
    }
    function woo_get_woo_version()
    {
    }
    // Exit if accessed directly
    \define('WOO_CD_DIRNAME', \basename(\dirname(__FILE__)));
    \define('WOO_CD_RELPATH', \basename(\dirname(__FILE__)) . '/' . \basename(__FILE__));
    \define('WOO_CD_PATH', \plugin_dir_path(__FILE__));
    \define('WOO_CD_PREFIX', 'woo_ce');
    \define('WOO_CD_PLUGINPATH', \WP_PLUGIN_URL . '/' . \basename(\dirname(__FILE__)));
    // If above PHP 7.2 evaluates to TRUE, it will require PHPSPREADHSEET, FALSE will require PHPEXCEL
    \define('WOO_CD_PHP_VERSION', \version_compare(\phpversion(), '7.2', '>='));
    function woo_ce_admin_duplicate_plugin()
    {
    }
    function composerRequired0a6b755e903507f6d27cbf0b1de92d3($fileIdentifier, $file)
    {
    }
}